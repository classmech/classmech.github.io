<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://classmech.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://classmech.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-12-10T10:45:51-06:00</updated><id>https://classmech.github.io/feed.xml</id><title type="html">ClassMech</title><subtitle></subtitle><entry><title type="html">Способ захвата транспортным стыковочным модулем космического мусора</title><link href="https://classmech.github.io/blog/2025-12-10-pat-2852561/" rel="alternate" type="text/html" title="Способ захвата транспортным стыковочным модулем космического мусора" /><published>2025-12-10T00:00:00-06:00</published><updated>2025-12-10T00:00:00-06:00</updated><id>https://classmech.github.io/blog/pat-2852561</id><content type="html" xml:base="https://classmech.github.io/blog/2025-12-10-pat-2852561/"><![CDATA[<p>Опубликован патент <a href="https://new.fips.ru/registers-doc-view/fips_servlet?DB=RUPAT&amp;DocNumber=2852561&amp;TypeFile=html">Способ захвата транспортным стыковочным модулем космического мусора</a>. [Текст] : заявка.: 2025110319 от 22.04.2025 / Трушляков В. И., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 19.12.2025 Бюл. № 34.</p>

<h3 id="реферат">Реферат</h3>

<p>Изобретение относится к области ракетно-космической техники, в частности к способам захвата транспортным стыковочным модулем (ТСМ) космического мусора (КМ). Для этого при сближении с КМ на заданную дистанцию ТСМ переходит в режим зависания, после чего его система захвата выстреливается на тросе в окрестность центра масс КМ с нанесением клеевого состава для надежной стыковки. В процессе всего маневра движением ТСМ управляют так, чтобы минимизировать тепловое и механическое воздействие на основной трос, связывающий его с буксиром. Выдачу этого троса осуществляют с минимальным натяжением, а при его чрезмерном провисании — подтормаживают. После захвата КМ трос начинают выдавать с торможением для сохранения прочности всей конструкции. Продольная ось буксира постоянно ориентирована на центр масс ТСМ вплоть до формирования вращающейся тросовой системы и перехода на орбиту утилизации. Достигается захват и увод КМ на вращающейся тросовой связи на основе адгезионного материала, исключающего риск повреждения конструкции КМ и образования нового космического мусора после этого, обеспечивая при этом возможность целостности клеевого состава.</p>]]></content><author><name></name></author><category term="patents" /><summary type="html"><![CDATA[Опубликован патент Способ захвата транспортным стыковочным модулем космического мусора. [Текст] : заявка.: 2025110319 от 22.04.2025 / Трушляков В. И., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 19.12.2025 Бюл. № 34. Реферат Изобретение относится к области ракетно-космической техники, в частности к способам захвата транспортным стыковочным модулем (ТСМ) космического мусора (КМ). Для этого при сближении с КМ на заданную дистанцию ТСМ переходит в режим зависания, после чего его система захвата выстреливается на тросе в окрестность центра масс КМ с нанесением клеевого состава для надежной стыковки. В процессе всего маневра движением ТСМ управляют так, чтобы минимизировать тепловое и механическое воздействие на основной трос, связывающий его с буксиром. Выдачу этого троса осуществляют с минимальным натяжением, а при его чрезмерном провисании — подтормаживают. После захвата КМ трос начинают выдавать с торможением для сохранения прочности всей конструкции. Продольная ось буксира постоянно ориентирована на центр масс ТСМ вплоть до формирования вращающейся тросовой системы и перехода на орбиту утилизации. Достигается захват и увод КМ на вращающейся тросовой связи на основе адгезионного материала, исключающего риск повреждения конструкции КМ и образования нового космического мусора после этого, обеспечивая при этом возможность целостности клеевого состава.]]></summary></entry><entry><title type="html">Построение модели сети для захвата объекта космического мусора</title><link href="https://classmech.github.io/blog/2025-11-28-net-capture-model/" rel="alternate" type="text/html" title="Построение модели сети для захвата объекта космического мусора" /><published>2025-11-28T00:00:00-06:00</published><updated>2025-11-28T00:00:00-06:00</updated><id>https://classmech.github.io/blog/net-capture-model</id><content type="html" xml:base="https://classmech.github.io/blog/2025-11-28-net-capture-model/"><![CDATA[<p>Известны различные способы захвата и увода с орбиты крупных объектов космического мусора. Для захвата могут использоваться манипуляторы, гарпуны, специальные стыковочные устройства, для орбитальной транспортировки – тросовые системы, сила Кулона, потоки частиц.</p>

<p><img src="/assets/img/mechanics-in-space/ion-beam.png" alt="" /></p>

<p>Один  из перспективных способов безопасного захвата крупногабаритных объектов предполагает использование сети. Сеть, связанная  тросом с космическим буксиром, выбрасывается в направлении объекта космического мусора, раскрывается в процессе сближения с ним и выполняет захват. После захвата космический буксир транспортирует захваченный объект космического мусора на орбиту утилизации или захоронения.</p>

<p><img src="/assets/img/mechanics-in-space/debris-net.png" alt="" /></p>

<p>Сетью можно захватывать вращающиеся объекты, захват которых при помощи манипуляторов или других жестких механизмов может привести к значительным ударным нагрузкам при контакте устройства захвата с объектом.</p>

<h2 id="модель-сети">Модель сети</h2>

<p>Для анализа движения сети и её взаимодействия с объектом космического мусора часто используется упрощенная модель, которая представляет сеть в виде системы материальных точек, связанных упругими безмассовыми элементами – пружинами (<a href="https://scholar.google.com/scholar?hl=en&amp;as_sdt=0%2C5&amp;q=mass+spring+model+net+debris&amp;btnG=">mass spring model</a>). Материальные точки располагаются в узлах сети, а также между узлами для более точного моделирования взаимодействия сети с поверхностью объекта космического мусора.</p>

<p><img src="/assets/img/mechanics-in-space/net-model-3.svg" alt="" /></p>

<h3 id="структура-сети">Структура сети</h3>

<p>Для того, чтобы упростить запись уравнений движения сети, представляющей собой систему тел (материальных точек), опишем структуру связей этой системы, используя теорию графов.</p>

<p>Структура соединения узлов сети (материальных точек) может быть описана <strong>ориентированным</strong> графом. Вершины в этом графе представляют собой узлы сети (материальные точки), а соединяющие вершины дуги – это упругие элементы (пружины).</p>

<p class="note" title="Граф">Ориентированный граф G(V,R) есть совокупность двух множеств — непустого множества V вершин и множества 
E упорядоченных пар различных элементов множества V (множество дуг или рёбер).</p>

<p>Структура ориентированного графа описывается матрицей инцидентности S c элементами \(S_{i\alpha}\). Количество строк матрицы S равно количество узлов сети (\(i=1,\ldots,n\)), а количество столбцов – количеству соединений между узлами (\(\alpha=1,\ldots,N\)), т.е. количеству пружин. Элемент матрицы инцидентности \(S_{i\alpha}\) равен +1, если дуга \(\alpha\) выходит из вершины i, минус 1, если дуга входит в вершину i и 0, если дуга не инцидентна вершине i.</p>

<p>Матрица инцидентности описывает не только связь узлов, но и направление этой связи, которое при записи уравнений движения двух смежных узлов позволяет задаться положительным направлением силы упругого взаимодействия между ними. Ниже на рисунке показан пример матрицы инцидентности для сети, состоящей из 6 узлов.</p>

<p>При записи уравнений движения также используются функции \(i^+(\alpha)\) и \(i^-(\alpha)\): функция \(i^+(\alpha)\) равна индексу вершины, из которой дуга α выходит, \(i^-(\alpha)\) равна индексу вершины, в которую дуга α входит.</p>

<p><img src="/assets/img/mechanics-in-space/net-model-1.svg" alt="" /></p>

<p>Для удобства формирования списка координат узлов сети разместим их на равномерной сетке и поместим первый (левый верхний) узел в начало координат. Ось x этой системы координат направим в сторону второго узла (вправо), ось y в сторону четвертого узла (вниз).</p>

<p>Узлы сети пронумеруем “построчно” слева направо, а затем сверху вниз, как показано на рисунке выше. Также слева направо пронумеруем все пружины (дуги), направленные вдоль оси x, а затем пружины, направленные вдоль оси y. Дуги направим от узла с меньшим индексом к узлу с большим индексом.</p>

<h3 id="силы-между-узлами-сети">Силы между узлами сети</h3>

<p>В рассматриваемой модели узлы сети соединяются невесомыми пружинами, которые имитируют упругие свойства нитей, соединяющих узлы сети. Если расстояние между двумя узлами сети увеличивается больше некоторой заданной свободной длины этой пружины \(l_\alpha^0\), то между этими узлами начинает действовать сила упругости, зависящая от деформации пружины и, если учитывается демпфирующие свойства материала сети, скорости этой деформации. Если расстояние между узлами меньше \(l_\alpha^0\), то сила взаимодействия между этими узлами считается равной нулю.</p>

<p><img src="/assets/img/mechanics-in-space/net-model-2.svg" alt="" /></p>

<p>Вектор, соединяющий пару узлов, модуль которого будет определять длину пружины c номером \(\alpha\), будет определяться выражением</p>

\[\Delta \mathbf{r}_\alpha = -\mathbf{r}_{i^+(\alpha)}+\mathbf{r}_{i^-(\alpha)}, \quad \alpha=1,\ldots,N\]

<p>Вектор \(\Delta \mathbf{r}_\alpha\) направлен от узла с индексом \(i^+(\alpha)\) к узлу с индексом \(i^-(\alpha)\). Это выражение можно записать в более общем виде с использованием матрицы инцидентности:</p>

\[\Delta \mathbf{r}_\alpha = - \sum_{k=1}^n S_{k \alpha} \mathbf{r}_k, \quad \alpha=1,\ldots,N\]

<p>Если все координатные столбцы узлов объединить в векторную матрицу столбец</p>

\[\Delta \mathbf r = 
    \begin{bmatrix} 
        \Delta \mathbf{r}_1 \\ 
        \Delta \mathbf{r}_2 \\
        \ldots \\
        \Delta \mathbf{r}_N \\
    \end{bmatrix},\]

<p>то можно записать</p>

\[\Delta \mathbf{r} = - \mathbf{S}^T \mathbf{r}.\]

<p>Зная \(\Delta \mathbf{r}_\alpha\) определим столбец единичных векторов, направленных от узла \(i^{+}(\alpha)\) к узлу \(i^{-}(\alpha)\):</p>

\[\mathbf{e}_\alpha = \frac{\Delta \mathbf{r}_\alpha}{|\Delta \mathbf{r}_\alpha|}, \quad \alpha=1,\ldots,N\]

<p>Эти векторы будут определять направление силы упругости при растяжении пружины от узла \(i^{+}(\alpha)\) к узлу \(i^{-}(\alpha)\).</p>

<p>Cила, действующая на узел сети \(i^{+}(\alpha)\), будет зависеть от удлинения  пружины и проекции скорости движения узла \(i^{-}(\alpha)\) относительно узла \(i^{+}(\alpha)\) на направление \(\mathbf{e}_\alpha\):</p>

\[\mathbf{F}_\alpha = 
\begin{cases}
    \mathbf{e}_\alpha [ (|\Delta \mathbf{r}_\alpha|-l_{\alpha}^0)k_s + V_\alpha^e k_d]&amp; |\Delta \mathbf{r}_\alpha|&gt;l_\alpha^0  \\
    \mathbf{0} &amp; |\Delta \mathbf{r}_\alpha| \leq l_\alpha^0
\end{cases}\]

<p>где \(k_s\) – жесткость нити (пружины) сети, \(k_d\) – коэффициент демпфирования, учитывающий демпфирующие свойства материала сети.</p>

<p>Проекция скорости узла \(i^{-}(\alpha)\) относительно узла \(i^{+}(\alpha)\) на направление \(\mathbf{e}_\alpha\) определяется выражением:</p>

\[V_\alpha^e = \mathbf{e}_\alpha \cdot (\mathbf{v}_{i^-(\alpha)} -\mathbf{v}_{i^+(\alpha)} ), \quad \alpha=1,\ldots,N\]

<p>или</p>

\[V_\alpha^e = - \mathbf{e}_\alpha \cdot \sum_{k=1}^n S_{k \alpha} \mathbf{v}_k, \quad \alpha=1,\ldots,N\]

<h3 id="взаимодействие-сети-с-объектом">Взаимодействие сети с объектом</h3>

<p>Взаимодействие сети с объектом происходит в узлах сети, т.е. если узел касается поверхности объекта в точке этого контакта возникает совместная деформация узла сети и поверхности объекта, что приводит к возникновению нормальной к поверхности объекта силы реакции \(\mathbf{N}_k\) и силы трения \(\mathbf{T}_k\), направленной против скорости скольжения узла по поверхности \(\mathbf{v}_k^\tau\). Приведенные упругие свойства узла и поверхности определяются коэффициентом жесткости \(k_c\) и коэффициентом демпфирования \(k_{dc}\).</p>

<p><img src="/assets/img/mechanics-in-space/net-model-5.svg" alt="" /></p>

<p>Для примера предположим, что объект космического мусора имеет форму сферы радиуса R центр которой расположен в точке, определяемой радиус-вектором \(\mathbf{r}_c\). Предположим также, что масса объекта космического мусора существенно больше массы сети, что позволяет считать, что объект остается неподвижным в процессе взаимодействия с сетью.</p>

<p>Расстояние от узла \(k\) до центра сферы определяется модулем вектора \(\rho_k = \mathbf{r}_k - \mathbf{r}_c\). Предположим, что взаимодействие узла сети со сферой начинается при \(\rho_k &lt; R\) –  в этот момент на узел начинает действовать нормальная сила:</p>

\[\mathbf{N}_{k} = 
    \begin{cases}
        [(R - |\mathbf{\rho}_k|) k_c + v_{kn} k_{dc}] \mathbf{n}_k  &amp; |\mathbf{\rho}_k| &lt; R \\
        0 &amp; |\mathbf{\rho}_k| \geq R \\
    \end{cases}\]

<p>где \(\mathbf{n}_k\) – единичный вектор нормали к поверхности объекта в точке контакта.</p>

<p>Сила сухого трения \(T_k\) при скольжении узла по поверхности тела будет определяться выражением:</p>

\[\mathbf{T}_{k} = - N_{k} f_c \mathbf{e}_v^\tau\]

<p>где \(f_c\) коэффициент трения, \(\mathbf{e}_v^\tau\) - единичный вектор направления касательной скорости \(\mathbf{v}_k^\tau\)</p>

\[\mathbf{v}_k^\tau = \mathbf{v}_k - \mathbf{n}_k (\mathbf{n}_k \cdot \mathbf{v}_k), \quad \mathbf{e}_v^\tau = \mathbf{v}_k^\tau / |\mathbf{v}_k^\tau|.\]

<h3 id="уравнения-движения">Уравнения движения</h3>

<p>Таким образом, каждый узел сети движется под действием суммы упругих сил, действующих со стороны смежных узлов, и сил в точке контакта узла с объектом (нормальная сила и сила трения). В общем случае уравнение движения каждого узла сети имеет вид:</p>

\[m_k \ddot{\mathbf r}_k = \sum_{\alpha=1}^N \mathbf{S}_{k\alpha} \mathbf F_{\alpha}  + \mathbf{N}_k + \mathbf{T}_{k} \quad k=1,\ldots,N\]

<p>где \(m_k\) – масса узла.</p>

<h2 id="модель-сети-в-octavematlab">Модель сети в Octave/MATLAB</h2>

<p>Для примера построим компьютерную модель взаимодействия сети с неподвижной сферой диаметром 1,2 м, которая расположена в начале координат. Сеть падет на сферу в однородном поле силы тяжести с ускорением 9,8 м/с\(^2\). В начальный момент времени сеть квадратной формы шириной 3 м находится на высоте 3 м (вдоль оси z) от начала координат.</p>

<p><img src="/assets/img/mechanics-in-space/net-model-4.svg" alt="" /></p>

<p>Для построения модели создадим в MATLAB два файла: файл-функцию правых частей дифференциальных уравнений и файл-скрипт, в котором будут задаваться параметры системы, запускаться процесс интегрирования и выполняться анализ результатов.</p>

<h3 id="главный-файл-скрипт">Главный файл-скрипт</h3>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clc</span><span class="p">;</span> <span class="nb">clear</span> <span class="nb">all</span><span class="p">;</span>
<span class="c1">% Количество узлов</span>
<span class="n">nc</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1">% в строке</span>
<span class="n">nr</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1">% в столбце</span>
<span class="c1">% Размер сети</span>
<span class="n">Lx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">Ly</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">n</span>  <span class="o">=</span> <span class="n">nc</span><span class="o">*</span><span class="n">nr</span><span class="p">;</span>  <span class="c1">% всего узлов</span>
<span class="c1">% Число дуг (связей, пружин)</span>
<span class="n">na</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nc</span><span class="o">*</span><span class="n">nr</span><span class="o">-</span><span class="n">nc</span><span class="o">-</span><span class="n">nr</span><span class="p">;</span>
<span class="c1">% Матрица инцидентности </span>
<span class="n">S</span>  <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">nc</span><span class="o">*</span><span class="n">nr</span><span class="p">,</span><span class="n">na</span><span class="p">);</span>
</code></pre></div></div>

<p>Координаты узлов определим, используя функцию <strong>meshgrid</strong>, которая формирует матрицу (сеть) координат x,y,z узлов</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Координаты узлов (начальные)</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="nb">meshgrid</span><span class="p">(</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Lx</span><span class="p">,</span><span class="n">nc</span><span class="p">),</span><span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ly</span><span class="p">,</span><span class="n">nr</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Например, для выражения <strong>[x,y,z] = meshgrid(1:2,1:3,1)</strong> x, y и z будут иметь вид:</p>

\[x = \begin{bmatrix} 1 &amp; 2 \\ 1 &amp; 2 \\ 1 &amp; 2 \end{bmatrix}, \quad
    y = \begin{bmatrix} 1 &amp; 1 \\ 2 &amp; 2 \\ 3 &amp; 3 \end{bmatrix}, \quad
    z = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}.\]

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Матрица номеров узлов</span>
<span class="n">nodes</span>   <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">nc</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="c1">% количество горизонтальных пружин</span>
<span class="n">nar</span> <span class="o">=</span> <span class="p">(</span><span class="n">nc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nr</span><span class="p">;</span>
<span class="c1">% количество вертикальных пружин</span>
<span class="n">nac</span> <span class="o">=</span> <span class="p">(</span><span class="n">nr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nc</span><span class="p">;</span>
</code></pre></div></div>

<p>В следующей секции главного скрипта заполняется матрица инцидентности.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% по горизонтальным пружинам элементы i+</span>
<span class="n">S</span><span class="p">(</span><span class="nb">sub2ind</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nodes</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">,</span><span class="mi">1</span><span class="p">,[])</span>  <span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">nar</span><span class="p">))</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">% по горизонтальным пружинам элементы i-</span>
<span class="n">S</span><span class="p">(</span><span class="nb">sub2ind</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nodes</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">'</span><span class="p">,</span><span class="mi">1</span><span class="p">,[])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">nar</span><span class="p">))</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">% по вертикальным пружинам элементы i+</span>
<span class="n">S</span><span class="p">(</span><span class="nb">sub2ind</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nodes</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]),</span> <span class="n">nar</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nar</span><span class="o">+</span><span class="n">nac</span><span class="p">))</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="c1">% по вертикальным пружинам элементы i-</span>
<span class="n">S</span><span class="p">(</span><span class="nb">sub2ind</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">nodes</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[])</span><span class="o">+</span><span class="n">nc</span><span class="p">,</span> <span class="n">nar</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nar</span><span class="o">+</span><span class="n">nac</span><span class="p">))</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Начальные условия</span>
<span class="n">r0</span> <span class="o">=</span> <span class="p">[</span><span class="nb">reshape</span><span class="p">(</span><span class="n">x</span><span class="s1">',1,[]); reshape(y'</span><span class="p">,</span><span class="mi">1</span><span class="p">,[]);</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">z</span><span class="o">'</span><span class="p">,</span><span class="mi">1</span><span class="p">,[])];</span>
<span class="c1">% Совмещаем центр сети с x = y = 0, z = 3;</span>
<span class="n">rm</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">-</span> <span class="n">rm</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">3</span><span class="p">];</span>
<span class="c1">% Начальная скорость </span>
<span class="n">v0</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
<span class="c1">% Вектор начальных условий</span>
<span class="n">q0</span> <span class="o">=</span> <span class="p">[</span><span class="n">r0</span><span class="p">(:);</span><span class="n">v0</span><span class="p">(:)];</span>
</code></pre></div></div>

<p>Заполняем структуру с параметрами системы, которая будет передаваться в функцию правых частей третьим аргументом.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Структура для функции правых частей</span>
<span class="n">p</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">nc</span><span class="o">*</span><span class="n">nr</span><span class="p">;</span>
<span class="n">p</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
<span class="c1">% Масса узлов </span>
<span class="n">p</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">;</span>
<span class="c1">% Ускорение свободного падения</span>
<span class="n">p</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span><span class="p">;</span>
<span class="c1">% Жесткость нитей</span>
<span class="n">p</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">;</span>
<span class="c1">% Коэффициент демпфирования</span>
<span class="n">p</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.3e2</span><span class="p">;</span>
<span class="c1">% Свободная длина</span>
<span class="n">p</span><span class="o">.</span><span class="n">l</span> <span class="o">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">% Радиус сферы, жесткость контакта</span>
<span class="n">p</span><span class="o">.</span><span class="n">r</span>  <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span>
<span class="c1">% Жесткость контакта сферы с узлом сети</span>
<span class="n">p</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">;</span>
<span class="c1">% Коэффициент демпфирования контакта сферы с узлом сети</span>
<span class="n">p</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">;</span>
</code></pre></div></div>

<p>Используем упрощенную модель сухого трения, при этом для исключения вычислительных проблем при скольжении узла по поверхности сферы со скоростью близкой к нулю, примем, что  при скорости скольжения от 0 до 5 мм/с коэффициент трения линейно увеличивается до заданного значения p.fc = 0.2.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Коэффициент трения при контакте сферы с узлом сети</span>
<span class="n">p</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
<span class="c1">% Скорость скольжения, при которой к-т трения достигает</span>
<span class="c1">% максимума</span>
<span class="n">p</span><span class="o">.</span><span class="n">vf</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">;</span>
</code></pre></div></div>

<p>Запускаем процесс интегрирования и строим анимацию.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">% Интегрирование</span>
<span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode113</span><span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">q0</span><span class="p">);</span>

<span class="c1">%% Анимация</span>
<span class="n">h_nodes</span> <span class="o">=</span> <span class="nb">plot3</span><span class="p">(</span><span class="n">r0</span><span class="p">(</span><span class="mi">1</span><span class="p">,:),</span><span class="n">r0</span><span class="p">(</span><span class="mi">2</span><span class="p">,:),</span><span class="n">r0</span><span class="p">(</span><span class="mi">3</span><span class="p">,:),</span><span class="s1">'.'</span><span class="p">);</span> <span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="n">h_lines</span> <span class="o">=</span> <span class="nb">cell</span><span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">na</span>
    <span class="n">XYZ</span> <span class="o">=</span> <span class="n">r0</span><span class="p">(:,</span><span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="p">(:,</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
    <span class="n">h_lines</span><span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="o">=</span> <span class="nb">line</span><span class="p">(</span><span class="n">XYZ</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">XYZ</span><span class="p">(:,</span><span class="mi">2</span><span class="p">),</span><span class="n">XYZ</span><span class="p">(:,</span><span class="mi">3</span><span class="p">),</span><span class="s1">'Color'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">);</span>
<span class="k">end</span>
<span class="p">[</span><span class="n">Xs</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">Zs</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sphere</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span> <span class="nb">colormap</span><span class="p">(</span><span class="nb">copper</span><span class="p">);</span>
<span class="n">hSurf</span> <span class="o">=</span> <span class="nb">surf</span><span class="p">(</span><span class="n">Xs</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">,</span><span class="n">Ys</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">,</span><span class="n">Zs</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">);</span> <span class="nb">shading</span> <span class="n">flat</span><span class="p">;</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">hot</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nb">set</span><span class="p">(</span><span class="n">hSurf</span><span class="p">,</span><span class="s1">'FaceAlpha'</span><span class="p">,</span><span class="mf">0.8</span><span class="p">);</span>
<span class="nb">hold</span> <span class="n">off</span><span class="p">;</span>
<span class="nb">xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="nb">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="nb">zlim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]);</span>
<span class="nb">box</span> <span class="n">on</span><span class="p">;</span>
<span class="nb">daspect</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s1">'Position'</span><span class="p">,[</span><span class="mi">100</span> <span class="mi">100</span> <span class="mi">1920</span> <span class="mi">1080</span><span class="p">]);</span>
<span class="c1">%% </span>
<span class="n">v</span> <span class="o">=</span> <span class="nb">VideoWriter</span><span class="p">(</span><span class="s1">'net.avi'</span><span class="p">);</span> <span class="nb">open</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rk</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">n</span><span class="p">),</span><span class="mi">3</span><span class="p">,[]);</span>
    <span class="n">h_nodes</span><span class="o">.</span><span class="n">XData</span> <span class="o">=</span> <span class="n">rk</span><span class="p">(</span><span class="mi">1</span><span class="p">,:);</span>
    <span class="n">h_nodes</span><span class="o">.</span><span class="n">YData</span> <span class="o">=</span> <span class="n">rk</span><span class="p">(</span><span class="mi">2</span><span class="p">,:);</span>
    <span class="n">h_nodes</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span> <span class="n">rk</span><span class="p">(</span><span class="mi">3</span><span class="p">,:);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">na</span>
        <span class="n">XYZ</span> <span class="o">=</span> <span class="n">rk</span><span class="p">(:,</span><span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="p">(:,</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
        <span class="n">h_lines</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="o">.</span><span class="n">XData</span> <span class="o">=</span> <span class="n">XYZ</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">h_lines</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="o">.</span><span class="n">YData</span> <span class="o">=</span> <span class="n">XYZ</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">h_lines</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="o">.</span><span class="n">ZData</span> <span class="o">=</span> <span class="n">XYZ</span><span class="p">(:,</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">end</span>    
    <span class="n">frame</span> <span class="o">=</span> <span class="nb">getframe</span><span class="p">(</span><span class="nb">gcf</span><span class="p">);</span>    
    <span class="nb">writeVideo</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">frame</span><span class="p">);</span>
<span class="k">end</span>
<span class="nb">close</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="файл-функция-правых-частей">Файл-функция правых частей</h3>

<p>Далее приведена функция правых частей с построчными комментариями.</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
    <span class="c1">% Координатные столбцы узлов 3xn</span>
    <span class="n">r</span>  <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">n</span><span class="p">),</span><span class="mi">3</span><span class="p">,[]);</span>
    <span class="c1">% Координатные столбцы скоростей узлов 3xn</span>
    <span class="n">v</span>  <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">),</span><span class="mi">3</span><span class="p">,[]);</span>    
    <span class="c1">% n x 1 x 3 (координаты в 3 измерение: столбец векторов)</span>
    <span class="n">r3</span> <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="n">r</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="n">v</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">% --------------------------------------------------------------------</span>
    <span class="c1">% Силы между узлами</span>
    <span class="c1">% --------------------------------------------------------------------</span>
    <span class="c1">% вектор от i+(a) к i-(a)</span>
    <span class="n">dr</span> <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="o">-</span><span class="n">pagemtimes</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">S</span><span class="o">'</span><span class="p">,</span><span class="n">r3</span><span class="p">),[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
    <span class="c1">% расстояния между узлами</span>
    <span class="n">dist_nodes</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">dr</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">spring_deformation</span> <span class="o">=</span> <span class="n">dist_nodes</span><span class="o">&gt;</span><span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="p">;</span>
    <span class="c1">% Упругая сила между узлами (если деформация положительная)</span>
    <span class="n">a_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">spring_deformation</span><span class="p">)</span>        
        <span class="c1">% скорость i-(a) относительно i+(a)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="o">-</span><span class="n">pagemtimes</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">S</span><span class="o">'</span><span class="p">,</span><span class="n">v3</span><span class="p">),[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span>
        <span class="c1">% единичные вектора направления от i+(a) к i-(a)</span>
        <span class="n">dr_e</span>    <span class="o">=</span> <span class="n">dr</span><span class="o">.</span><span class="p">/</span><span class="n">dist_nodes</span><span class="p">;</span>
        <span class="c1">% проекция относительной скорости на направление от i+(a) к i-(a)</span>
        <span class="n">dv_dist</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="n">dr_e</span><span class="p">);</span>        
        <span class="n">Fnodes</span>   <span class="o">=</span> <span class="n">spring_deformation</span><span class="o">.*</span><span class="n">dr_e</span><span class="o">.*</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">dist_nodes</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">l</span><span class="p">)</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">d</span><span class="o">*</span><span class="n">dv_dist</span><span class="p">);</span>
        <span class="n">Fnodes3</span>  <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="n">Fnodes</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">a_nodes</span>  <span class="o">=</span> <span class="nb">permute</span><span class="p">(</span><span class="n">pagemtimes</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">S</span><span class="p">,</span><span class="n">Fnodes3</span><span class="p">),[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="p">/</span><span class="n">p</span><span class="o">.</span><span class="n">m</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="c1">% --------------------------------------------------------------------</span>
    <span class="c1">% Контакт со сферой с центром (0,0) и радиусом p.r</span>
    <span class="c1">% --------------------------------------------------------------------</span>
    <span class="n">dist_to_0</span>       <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span>
    <span class="c1">% Расстояние до поверхности сферы.</span>
    <span class="c1">% Отрицательное, если узел оказался внутри сферы</span>
    <span class="n">dist_tp_sphere</span>  <span class="o">=</span> <span class="n">dist_to_0</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">r</span><span class="p">;</span>
    <span class="n">is_contact</span> <span class="o">=</span> <span class="n">dist_tp_sphere</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>    
    <span class="n">a_contact</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_contact</span><span class="p">)</span> 
        <span class="c1">% Вектор нормали в точке контакта</span>
        <span class="n">er</span>    <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="p">/</span><span class="n">dist_to_0</span><span class="p">;</span>
        <span class="c1">% Нормальная скорость</span>
        <span class="n">vr</span>    <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">er</span><span class="p">);</span>
        <span class="c1">% Нормальная сила</span>
        <span class="n">Nc</span>    <span class="o">=</span> <span class="o">-</span><span class="n">is_contact</span><span class="o">.*</span><span class="p">(</span><span class="n">er</span><span class="o">.*</span><span class="p">(</span><span class="n">dist_tp_sphere</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">cb</span><span class="o">+</span><span class="n">vr</span><span class="o">.*</span><span class="n">p</span><span class="o">.</span><span class="n">db</span><span class="p">));</span>
        <span class="c1">% Касательная скорость</span>
        <span class="n">vt</span>    <span class="o">=</span> <span class="n">v</span><span class="o">-</span><span class="n">vr</span><span class="o">.*</span><span class="n">er</span><span class="p">;</span>
        <span class="c1">% Модуль касательной скорости</span>
        <span class="n">vtm</span>   <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">vt</span><span class="o">.^</span><span class="mi">2</span><span class="p">));</span>
        <span class="c1">% Направление касательной скорости</span>
        <span class="n">et</span>    <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="p">/</span><span class="n">vtm</span><span class="p">;</span>
        <span class="c1">% Если касательная скорость нулевая,</span>
        <span class="c1">% то получившийся при делении nan заменяем на 0</span>
        <span class="n">et</span><span class="p">(</span><span class="nb">isnan</span><span class="p">(</span><span class="n">et</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">% К-т трения функция скорости скольжения</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="nb">interp1</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">.</span><span class="n">vf</span><span class="p">],[</span><span class="mi">0</span><span class="p">;</span><span class="n">p</span><span class="o">.</span><span class="n">fc</span><span class="p">],</span><span class="n">vtm</span><span class="p">,</span><span class="s2">"linear"</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">fc</span><span class="p">);</span>
        <span class="c1">% Вектор силы трения</span>
        <span class="n">Fc</span>    <span class="o">=-</span><span class="nb">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nc</span><span class="o">.^</span><span class="mi">2</span><span class="p">))</span><span class="o">.*</span><span class="n">fc</span><span class="o">.*</span><span class="n">et</span><span class="p">;</span>
        <span class="c1">% Ускорение от контактной силы</span>
        <span class="n">a_contact</span>    <span class="o">=</span> <span class="p">(</span><span class="n">Nc</span><span class="o">+</span><span class="n">Fc</span><span class="p">)</span><span class="o">.</span><span class="p">/</span><span class="n">p</span><span class="o">.</span><span class="n">m</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="c1">% Гравитационное ускорение</span>
    <span class="n">ag</span>    <span class="o">=</span> <span class="nb">repmat</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">g</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="o">.</span><span class="n">n</span><span class="p">);</span>
    <span class="c1">% Полное ускорение</span>
    <span class="n">a</span>     <span class="o">=</span> <span class="n">a_nodes</span> <span class="o">+</span> <span class="n">ag</span> <span class="o">+</span> <span class="n">a_contact</span><span class="p">;</span>
    <span class="n">dq</span>    <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">(:);</span> <span class="n">a</span><span class="p">(:)];</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Результат работы программы</p>

<p><img src="/assets/img/mechanics-in-space/net.gif" alt="" /></p>]]></content><author><name></name></author><category term="mechanics" /><category term="CAE" /><category term="matlab" /><summary type="html"><![CDATA[Построение модели сети для захвата объекта космического мусора. Сеть рассматривается как система материальных точек, связанных невесомыми пружинами. Записывается система уравнений движения сети при её взаимодействии с объектом. Приведен пример программы на языке MATLAB/Octave, которая иллюстрирует работу модели.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/mechanics-in-space/net-model-slide.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/mechanics-in-space/net-model-slide.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Игра “Жизнь” на языке Wolfram Mathematica</title><link href="https://classmech.github.io/blog/2025-11-11-wolfram-game-life/" rel="alternate" type="text/html" title="Игра “Жизнь” на языке Wolfram Mathematica" /><published>2025-11-11T00:00:00-06:00</published><updated>2025-11-11T00:00:00-06:00</updated><id>https://classmech.github.io/blog/wolfram-game-life</id><content type="html" xml:base="https://classmech.github.io/blog/2025-11-11-wolfram-game-life/"><![CDATA[<ul>
  <li><a href="/pages/python/game_life/">Правила игры “Жизнь”</a></li>
  <li><a href="/pages/matlab/game_life/">Игра “Жизнь” на языке MATLAB</a></li>
  <li><a href="/pages/python/game_life/">Игра “Жизнь” на языке Python</a></li>
  <li><a href="/pages/databases/gamelife_sql/">Игра “Жизнь” на языке SQL</a></li>
</ul>

<p>Колонию будет задавать списком пар координат “живых” клеток. Например, колония “Глайдер” может быть представлена списком:</p>

<pre><code class="language-Mathematica">colony = {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {1, 2}};
</code></pre>

<p>Построим изображение этой колонии при помощи функции <strong>ListPlot</strong>:</p>

<pre><code class="language-Mathematica">ListPlot[colony, PlotStyle -&gt; PointSize[0.15], 
 PlotRange -&gt; {{-1, 4}, {-1, 4}}, AspectRatio -&gt; 1, Frame -&gt; True, 
 Axes -&gt; False, GridLines -&gt; {Range[-1, 4]}]
</code></pre>

<p><img src="/assets/img/blog/glider.png" alt="" class="lead" width="400" height="400" loading="lazy" /></p>

<h3 id="функция-определения-принадлежности-клетки-колонии-используем-функцию-memberq">Функция определения принадлежности клетки колонии: используем функцию MemberQ</h3>

<p>Для проверки принадлежности клетки <strong>x</strong> колонии <strong>col</strong> будем использовать функцию <strong>MemberQ</strong>, которая возвращает <strong>True</strong> если элемент, указанный вторым аргументом, будет принадлежать списку, указанному первым аргументом и <strong>False</strong> если элемент не найден в списке. Для рассматриваемой колонии:</p>

<pre><code class="language-Mathematica">MemberQ[colony,{1, 0}]
&gt;&gt; True
</code></pre>

<pre><code class="language-Mathematica">MemberQ[colony,{5, 0}]
&gt;&gt; False
</code></pre>

<h3 id="считаем-количество-соседей-используем-функции-tuples-count-и-map">Считаем количество соседей: Используем функции Tuples, Count и Map</h3>

<p>Для определения количества соседей у некоторой клетки или пустой ячейки с координатами <strong>c = (x, y)</strong> необходимо определить список координат смежных ячеек (ячеек-соседей) и подсчитать в этом списке количество ячеек, занятых клетками.</p>

<p>Вокруг каждой клетки 8 смежных ячеек, с которыми она граничит. Координатны смежных ячеек отличаются от координаты клетки не более чем на 1. Например, список координат соседних ячеек для клетки с координатами (2,3):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{{1, 2}, {1, 3}, {1, 4}, {2, 2}, {2, 4}, {3, 2}, {3, 3}, {3, 4}}
</code></pre></div></div>

<p>Для получения списка пар координат смежных ячеек используем функцию <strong>Tuples</strong>, которая позволяет создать список всех возможных кортежей, состоящих из двух 2 элементов, составленных из элементов заданного списка. Первым аргументом в функцию <strong>Tuples</strong> передаём список смещений координат смежных ячеек относительно рассматриваемой клетки (-1, 0, 1), вторым аргументом число 2, определяющее длину кортежей. На выходе получаем все возможные пары смещений координат:</p>

<pre><code class="language-Mathematica">Tuples[{-1, 0, 1}, 2]

&gt;&gt; {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,0}, {0,1}, {1,-1}, {1,0}, {1,1}}
</code></pre>

<p>Для исключения из этого списка пары с нулевым смещением (0,0) используем функцию <strong>DeleteCases</strong>, которая позволяет удалить из списка элемент.</p>

<pre><code class="language-Mathematica">DeleteCases[ Tuples[{-1, 0, 1}, 2], {0,0} ]

&gt;&gt; {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}
</code></pre>

<p>Если каждую полученную пару смещений прибавить к координатам <strong>(x,y)</strong>, получим список координат клеток, смежных клетке (x,y)</p>

<pre><code class="language-Mathematica">{x, y} + # &amp; /@ Tuples[{-1, 0, 1}, 2]

&gt;&gt; {{-1+x,-1+y}, {-1+x,y}, {-1+x,1+y}, {x,-1+y}, {x,y}, {x,1+y}, {1+x,-1+y}, {1+x,y}, {1+x,1+y}}
</code></pre>

<p>Каждую клетку этого списка проверим на принадлежность колонии и подсчитаем количество результатов <strong>True</strong>. Для подсчета элементов в списке, удовлетворяющим заданному условию, используем функцию <strong>Count</strong>:</p>

<pre><code class="language-Mathematica">Count[{True, False, False, False, False, False, False, False}, True]

&gt;&gt; 1
</code></pre>

<p>Создадим функцию подсчёта количества соседей, окружающих ячейку с координатами <strong>c = {x, y}</strong>:</p>

<pre><code class="language-Mathematica">countNeighbours[c_, colony_] := Count[MemberQ[colony, c + #] &amp; /@ Tuples[{-1, 0, 1}, 2], True];
countNeighbours[{1, 1}, colony]

&gt;&gt; 5
</code></pre>

<h3 id="ареал-колонии">Ареал колонии</h3>

<p>Ареал колонии это множество клеток колонии и всех их смежных ячеек. Для каждой ячейки, принадлежащей ареалу колонии, определяется количество соседей и, в зависимости от этого количества и того пустая эта ячейка или занята клеткой принимается решение о появлении новой клетки или переходе существующей в следующее поколение.</p>

<p>Для определения арела колонии сформируем списки смежных ячеек для всех клеток колонии, включив в эти списки и клетки колонии. Для формирования таких списков используем функцию <strong>Outer[f,list1,list2,list3,…]</strong>, которая формирует все возможные комбинации элементов списков самого низкого уровня в каждом из списков и передаёт эти комбинации в качестве аргументов в функцию f.</p>

<pre><code class="language-Mathematica">Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}]

&gt;&gt; {{{{f[1, 10], f[1, 20]}}, {{f[2, 10], f[2, 20]}}}, {{{f[3, 10], f[3, 20]}}, {{f[4, 10], f[4, 20]}}}}
</code></pre>

<p>Чтобы Математика рассматривала списки на уровне 1 как элементы, списков, необходимо указать номер этого уровня последним аргументом:</p>

<pre><code class="language-Mathematica">Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}, 1]

&gt;&gt; {{f[{1, 2}, {10, 20}]}, {f[{3, 4}, {10, 20}]}}
</code></pre>

<p>В качестве функции <strong>f</strong> используем “чистую” функцию сложения элементов двух списков. Второй аргумент функции <strong>Outer</strong> список координат клеток колонии, третий – список смещений.</p>

<pre><code class="language-Mathematica">Outer[#1 + #2 &amp;, colony, Tuples[{-1, 0, 1}, 2], 1]
</code></pre>

<p>Получившийся список многомерный. Сделаем его “плоским” при помощи функции <strong>Flatten</strong>:</p>

<pre><code class="language-Mathematica">Flatten[Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}, 1]]

&gt;&gt; {f[{1, 2}, {10, 20}], f[{3, 4}, {10, 20}]}
</code></pre>

<p>Записанное выше выражение вернет список всех смежных клеток для всех клеток колонии, в котором будут повторения. Эти повторения можно исключить, используя функцию для работы с множествами <strong>Union</strong>, которая при вызове с одним аргументом удаляет повторы элементов.</p>

<pre><code class="language-Mathematica">colonyArea[colony_] := Union[Flatten[Outer[#1 + #2 &amp;, colony, Tuples[{-1, 0, 1}, 2], 1], 1]];
</code></pre>

<h3 id="функция-nextgeneration-используем-функции-union-select-и-map">Функция nextGeneration. Используем функции Union, Select и Map</h3>

<p>На основе списка координат ячеек ареала колонии создадим список, каждый элемент которого будет представлять собой кортеж из трех элементов: координаты ячейки, количество соседей, признак занятости ячейки клеткой.</p>

<pre><code class="language-Mathematica">{#, countNeighbours[#, colony], MemberQ[colony, #]} &amp; /@ colonyArea[colony]

&gt;&gt; {{{-1, -1}, 1, False}, {{-1, 0}, 1, False}, {{-1, 1}, 1, 
  False}, {{0, -1}, 2, False}, {{0, 0}, 2, True}, {{0, 1}, 3, 
  False}, {{0, 2}, 1, False}, {{0, 3}, 1, False}, {{1, -1}, 3, 
  False}, {{1, 0}, 4, True}, {{1, 1}, 5, False}, {{1, 2}, 2, 
  True}, {{1, 3}, 1, False}, {{2, -1}, 2, False}, {{2, 0}, 3, 
  True}, {{2, 1}, 4, True}, {{2, 2}, 2, False}, {{2, 3}, 1, 
  False}, {{3, -1}, 1, False}, {{3, 0}, 2, False}, {{3, 1}, 2, 
  False}, {{3, 2}, 1, False}}
</code></pre>

<p>Из получившегося списка при помощи функции <strong>Select</strong> выберем только те <strong>ячейки</strong>, у который ровно три соседа (это или новые клетки или “выжившие” клетки, у которых три соседа) и <strong>клетки</strong> (занятые ячейки) у которых ровно два соседа.</p>

<pre><code class="language-Mathematica">Select[..., #[[2]] == 3 || (#[[2]] == 2 &amp;&amp; #[[3]]) &amp;]
</code></pre>

<p>Вместо многоточия подставим полученное еще выше выражение для генерации списка 3-кортежей. Результатом работы функции <strong>Select</strong> также будет список 3-кортежей, из которого нам необходимо извлечь только первый элемент:</p>

<pre><code class="language-Mathematica">nextGeneration[colony_] := #[[1]] &amp; /@ 
  Select[{#, countNeighbours[#, colony], MemberQ[colony, #]} &amp; /@ 
    colonyArea[colony], #[[2]] == 3 || (#[[2]] == 2 &amp;&amp; #[[3]]) &amp;]
</code></pre>

<h3 id="функция-nestlist-формирование-списка-поколений">Функция NestList. Формирование списка поколений</h3>

<p>Функция <strong>NestList[f,x,n]</strong> формирует список результатов применения функции <strong>f</strong> к выражению <strong>x</strong> от <strong>0</strong> до <strong>n</strong> раз</p>

<pre><code class="language-Mathematica">NestList[f, x, 4];

&gt;&gt; {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]}
</code></pre>

<p>Используем эту функцию для создания списка поколений колонии</p>

<pre><code class="language-Mathematica">generationList = NestList[nextGeneration, colony, 100];
</code></pre>

<h3 id="результат">Результат</h3>

<p>Создадим более сложную колонию:</p>

<pre><code class="language-Mathematica">colony = {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {1, 2}, {4, -1}, {4, -2}, {4, -3}};

ListPlot[colony, PlotStyle -&gt; PointSize[0.1], 
 PlotRange -&gt; {{-2, 6}, {-4, 5}}, AspectRatio -&gt; 1,
 Frame -&gt; True, Axes -&gt; False, GridLines -&gt; {Range[-3, 4]}, 
 FrameTicks -&gt; None]
</code></pre>

<p><img src="/assets/img/blog/my-colony.png" alt="" class="lead" width="400" height="400" loading="lazy" /></p>

<p>Сгенерируем список поколений и построим анимацию “эволюции” этой колонии:</p>

<pre><code class="language-Mathematica">NestList[nextGeneration, colony, 600];
Animate[ListPlot[%[[i]], PlotStyle -&gt; PointSize[0.01], 
  PlotRange -&gt; {{-50, 50}, {-50, 50}}, AspectRatio -&gt; 1, 
  Axes -&gt; False, Frame -&gt; True, FrameTicks -&gt; None], {i, 1, 600, 1}, 
 DisplayAllSteps -&gt; True]
</code></pre>

<p><img src="/assets/img/blog/GameLife-WolframMathemetica.gif" alt="" class="lead" width="400" height="400" loading="lazy" /></p>

<p><a href="/assets/files/Mathematica/GameLife.nb">Файл Wolfram Mathematica</a></p>]]></content><author><name></name></author><category term="mathematica" /><summary type="html"><![CDATA[Правила игры “Жизнь” Игра “Жизнь” на языке MATLAB Игра “Жизнь” на языке Python Игра “Жизнь” на языке SQL Колонию будет задавать списком пар координат “живых” клеток. Например, колония “Глайдер” может быть представлена списком: colony = {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {1, 2}}; Построим изображение этой колонии при помощи функции ListPlot: ListPlot[colony, PlotStyle -&gt; PointSize[0.15], PlotRange -&gt; {{-1, 4}, {-1, 4}}, AspectRatio -&gt; 1, Frame -&gt; True, Axes -&gt; False, GridLines -&gt; {Range[-1, 4]}] Функция определения принадлежности клетки колонии: используем функцию MemberQ Для проверки принадлежности клетки x колонии col будем использовать функцию MemberQ, которая возвращает True если элемент, указанный вторым аргументом, будет принадлежать списку, указанному первым аргументом и False если элемент не найден в списке. Для рассматриваемой колонии: MemberQ[colony,{1, 0}] &gt;&gt; True MemberQ[colony,{5, 0}] &gt;&gt; False Считаем количество соседей: Используем функции Tuples, Count и Map Для определения количества соседей у некоторой клетки или пустой ячейки с координатами c = (x, y) необходимо определить список координат смежных ячеек (ячеек-соседей) и подсчитать в этом списке количество ячеек, занятых клетками. Вокруг каждой клетки 8 смежных ячеек, с которыми она граничит. Координатны смежных ячеек отличаются от координаты клетки не более чем на 1. Например, список координат соседних ячеек для клетки с координатами (2,3): {{1, 2}, {1, 3}, {1, 4}, {2, 2}, {2, 4}, {3, 2}, {3, 3}, {3, 4}} Для получения списка пар координат смежных ячеек используем функцию Tuples, которая позволяет создать список всех возможных кортежей, состоящих из двух 2 элементов, составленных из элементов заданного списка. Первым аргументом в функцию Tuples передаём список смещений координат смежных ячеек относительно рассматриваемой клетки (-1, 0, 1), вторым аргументом число 2, определяющее длину кортежей. На выходе получаем все возможные пары смещений координат: Tuples[{-1, 0, 1}, 2] &gt;&gt; {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,0}, {0,1}, {1,-1}, {1,0}, {1,1}} Для исключения из этого списка пары с нулевым смещением (0,0) используем функцию DeleteCases, которая позволяет удалить из списка элемент. DeleteCases[ Tuples[{-1, 0, 1}, 2], {0,0} ] &gt;&gt; {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}} Если каждую полученную пару смещений прибавить к координатам (x,y), получим список координат клеток, смежных клетке (x,y) {x, y} + # &amp; /@ Tuples[{-1, 0, 1}, 2] &gt;&gt; {{-1+x,-1+y}, {-1+x,y}, {-1+x,1+y}, {x,-1+y}, {x,y}, {x,1+y}, {1+x,-1+y}, {1+x,y}, {1+x,1+y}} Каждую клетку этого списка проверим на принадлежность колонии и подсчитаем количество результатов True. Для подсчета элементов в списке, удовлетворяющим заданному условию, используем функцию Count: Count[{True, False, False, False, False, False, False, False}, True] &gt;&gt; 1 Создадим функцию подсчёта количества соседей, окружающих ячейку с координатами c = {x, y}: countNeighbours[c_, colony_] := Count[MemberQ[colony, c + #] &amp; /@ Tuples[{-1, 0, 1}, 2], True]; countNeighbours[{1, 1}, colony] &gt;&gt; 5 Ареал колонии Ареал колонии это множество клеток колонии и всех их смежных ячеек. Для каждой ячейки, принадлежащей ареалу колонии, определяется количество соседей и, в зависимости от этого количества и того пустая эта ячейка или занята клеткой принимается решение о появлении новой клетки или переходе существующей в следующее поколение. Для определения арела колонии сформируем списки смежных ячеек для всех клеток колонии, включив в эти списки и клетки колонии. Для формирования таких списков используем функцию Outer[f,list1,list2,list3,…], которая формирует все возможные комбинации элементов списков самого низкого уровня в каждом из списков и передаёт эти комбинации в качестве аргументов в функцию f. Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}] &gt;&gt; {{{{f[1, 10], f[1, 20]}}, {{f[2, 10], f[2, 20]}}}, {{{f[3, 10], f[3, 20]}}, {{f[4, 10], f[4, 20]}}}} Чтобы Математика рассматривала списки на уровне 1 как элементы, списков, необходимо указать номер этого уровня последним аргументом: Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}, 1] &gt;&gt; {{f[{1, 2}, {10, 20}]}, {f[{3, 4}, {10, 20}]}} В качестве функции f используем “чистую” функцию сложения элементов двух списков. Второй аргумент функции Outer список координат клеток колонии, третий – список смещений. Outer[#1 + #2 &amp;, colony, Tuples[{-1, 0, 1}, 2], 1] Получившийся список многомерный. Сделаем его “плоским” при помощи функции Flatten: Flatten[Outer[f, {{1, 2}, {3, 4}}, {{10, 20}}, 1]] &gt;&gt; {f[{1, 2}, {10, 20}], f[{3, 4}, {10, 20}]} Записанное выше выражение вернет список всех смежных клеток для всех клеток колонии, в котором будут повторения. Эти повторения можно исключить, используя функцию для работы с множествами Union, которая при вызове с одним аргументом удаляет повторы элементов. colonyArea[colony_] := Union[Flatten[Outer[#1 + #2 &amp;, colony, Tuples[{-1, 0, 1}, 2], 1], 1]]; Функция nextGeneration. Используем функции Union, Select и Map На основе списка координат ячеек ареала колонии создадим список, каждый элемент которого будет представлять собой кортеж из трех элементов: координаты ячейки, количество соседей, признак занятости ячейки клеткой. {#, countNeighbours[#, colony], MemberQ[colony, #]} &amp; /@ colonyArea[colony] &gt;&gt; {{{-1, -1}, 1, False}, {{-1, 0}, 1, False}, {{-1, 1}, 1, False}, {{0, -1}, 2, False}, {{0, 0}, 2, True}, {{0, 1}, 3, False}, {{0, 2}, 1, False}, {{0, 3}, 1, False}, {{1, -1}, 3, False}, {{1, 0}, 4, True}, {{1, 1}, 5, False}, {{1, 2}, 2, True}, {{1, 3}, 1, False}, {{2, -1}, 2, False}, {{2, 0}, 3, True}, {{2, 1}, 4, True}, {{2, 2}, 2, False}, {{2, 3}, 1, False}, {{3, -1}, 1, False}, {{3, 0}, 2, False}, {{3, 1}, 2, False}, {{3, 2}, 1, False}} Из получившегося списка при помощи функции Select выберем только те ячейки, у который ровно три соседа (это или новые клетки или “выжившие” клетки, у которых три соседа) и клетки (занятые ячейки) у которых ровно два соседа. Select[..., #[[2]] == 3 || (#[[2]] == 2 &amp;&amp; #[[3]]) &amp;] Вместо многоточия подставим полученное еще выше выражение для генерации списка 3-кортежей. Результатом работы функции Select также будет список 3-кортежей, из которого нам необходимо извлечь только первый элемент: nextGeneration[colony_] := #[[1]] &amp; /@ Select[{#, countNeighbours[#, colony], MemberQ[colony, #]} &amp; /@ colonyArea[colony], #[[2]] == 3 || (#[[2]] == 2 &amp;&amp; #[[3]]) &amp;] Функция NestList. Формирование списка поколений Функция NestList[f,x,n] формирует список результатов применения функции f к выражению x от 0 до n раз NestList[f, x, 4]; &gt;&gt; {x, f[x], f[f[x]], f[f[f[x]]], f[f[f[f[x]]]]} Используем эту функцию для создания списка поколений колонии generationList = NestList[nextGeneration, colony, 100]; Результат Создадим более сложную колонию: colony = {{0, 0}, {1, 0}, {2, 0}, {2, 1}, {1, 2}, {4, -1}, {4, -2}, {4, -3}}; ListPlot[colony, PlotStyle -&gt; PointSize[0.1], PlotRange -&gt; {{-2, 6}, {-4, 5}}, AspectRatio -&gt; 1, Frame -&gt; True, Axes -&gt; False, GridLines -&gt; {Range[-3, 4]}, FrameTicks -&gt; None] Сгенерируем список поколений и построим анимацию “эволюции” этой колонии: NestList[nextGeneration, colony, 600]; Animate[ListPlot[%[[i]], PlotStyle -&gt; PointSize[0.01], PlotRange -&gt; {{-50, 50}, {-50, 50}}, AspectRatio -&gt; 1, Axes -&gt; False, Frame -&gt; True, FrameTicks -&gt; None], {i, 1, 600, 1}, DisplayAllSteps -&gt; True] Файл Wolfram Mathematica]]></summary></entry><entry><title type="html">Плоский программный разворот</title><link href="https://classmech.github.io/blog/2025-09-03-turn-around/" rel="alternate" type="text/html" title="Плоский программный разворот" /><published>2025-09-03T00:00:00-05:00</published><updated>2025-09-03T00:00:00-05:00</updated><id>https://classmech.github.io/blog/turn-around</id><content type="html" xml:base="https://classmech.github.io/blog/2025-09-03-turn-around/"><![CDATA[<p>Рассмотрим задачу плоского программного разворота космического аппарата или ступени РН на заданный угол. Предположим, что в начальный момент времени \(t=0\) Угловое положение ступени относительно некоторого фиксированного в пространстве направления определялось углом \(\varphi_0\), при этом угловая скорость ступени была равна нулю \(\omega_0 = 0\).</p>

<p>На борту ступени есть двигатели ориентации, которые могут создавать относительно её центра масс постоянный момент \(M_u\).</p>

<p><img src="/assets/img/mechanics-in-space/stage-turn-around.svg" alt="" /></p>

<p>Необходимо в течение заданного интервала времени \(T\) развернуть ступень из начального углового положения \(\varphi_0\) в конечное положение, определяемое нулевым углом и нулевой угловой скоростью: \(\varphi_e = \omega_e = 0\).</p>

<p>Разворот ступени будет выполнятся в три этапа:</p>
<ol>
  <li>этап разгона с постоянным угловым ускорением, создаваемым двигателем ориентации;</li>
  <li>этап движения с постоянной угловой скоростью (двигатели ориентации выключены);</li>
  <li>этап торможения с постоянным угловым ускорением.</li>
</ol>

<p>Продолжительности этапов разгона и торможения одинаковы и равны \(t_a\).</p>

<p><img src="/assets/img/mechanics-in-space/stage-turn-around-program.svg" alt="" /></p>

<h3 id="этап-разгона">Этап разгона</h3>

<p>На этапе разгона угловая скорость ступени будет увеличиваться по модулю под действием управляющего момента \(M_u\). Закон изменения угловой скорости будет иметь вид:</p>

\[\dot \varphi = \omega = - \frac{M_u}{J} t = - \varepsilon t\]

<p>где \(J\) - момент инерции ступени относительно оси, проходящей через её центр масс и перпендикулярной плоскости разворота, \(\varepsilon\) - постоянное угловое ускорение разворота.</p>

<p>Угол поворота ступени на первом этапе будет изменяться (в условиях рассматриваемой задачи уменьшаться) по известному закону равноускоренного движения:</p>

\[\varphi = \varphi_0 - \frac{\varepsilon t^2}{2}\]

<p>В конце первого этапа угол поворота и угловая скорость будут определяться выражениями:</p>

\[\varphi_1 = \varphi_0 - \frac{\varepsilon t_a^2}{2}, \quad \omega_1 = - \varepsilon t_a\]

<p>При заданной продолжительности разворота $T$ и заданной максимальной угловой скорости разворота \(\omega^{max}\) могут быть определена продолжительность этап разгона (торможения):</p>

\[t_a = \frac{\omega^{max} J}{M_u} = \frac{\omega^{max}}{\varepsilon}\]

<p>и продолжительность второго этапа движения с постоянной угловой скоростью:</p>

\[t_w = T - 2 t_a.\]

<h3 id="движение-с-постоянной-угловой-скоростью">Движение с постоянной угловой скоростью</h3>

<p>На втором этапе движение ступени равномерное. В конце второго этапа угол поворота ступени будет определяться выражением:</p>

\[\varphi_2 = \varphi_1 + \omega_1 t_w =  \varphi_0 - \frac{\varepsilon t_a^2}{2} - \varepsilon t_a t_w\]

<h3 id="этап-торможения">Этап торможения</h3>

<p>На этапе торможения ступень движется равнозамедленно и течение интервала \(t_a\) её угловая скорость уменьшается до нуля. В момент достижения нулевой угловой скорости угол поворота ступени также должен быть равен нулю:</p>

\[0 = \varphi_2 - \omega^{max} t_a + \frac{\varepsilon t_a^2}{2} = \varphi_0 - \frac{\varepsilon t_a^2}{2} - \varepsilon t_a t_w - \omega^{max} t_a + \frac{\varepsilon t_a^2}{2} = \varphi_0  - \varepsilon t_a t_w - \omega^{max} t_a\]

<p>При заданном времени разворота \(T\) и заданном угловом ускорении разворота времена \(t_a\) и \(t_w\) будут определяться решением следующей системы</p>

\[\begin{cases}
    t_a(t_w+t_a)  = \frac{\varphi_0}{\varepsilon} \\
    t_w + 2 t_a = T
\end{cases}\]

<p>Решение этой системы для продолжительности этапа разгона (торможения):</p>

\[t_a = \frac{T}{2} \pm \sqrt{T^2 - 4 \frac{\varphi_0}{\varepsilon}}\]

<p>Разворот за время \(T\) на угол \(\varphi_0\) возможен если</p>

\[T^2 &gt; 4 \frac{\varphi_0}{\varepsilon}\]

<p>В предельном случае, когда \(T^2 = 4 \varphi_0/\varepsilon\) участок движения с постоянной угловой скоростью отсутствует и \(t_a = T/2\), т.е. разворот выполняется в два этапа – этапа разгона и торможения.</p>

<p>В общем случае при выполнения условия \(T^2 &gt; 4 \varphi_0/\varepsilon\) продолжительности разгона (торможения) и равномерного движения определяются по следующим формулам:</p>

\[t_a = \frac{T}{2} - \sqrt{T^2 - 4 \frac{\varphi_0}{\varepsilon}}, \quad t_w = 2 \sqrt{T^2 - 4 \frac{\varphi_0}{\varepsilon}}.\]

<h3 id="источники">Источники</h3>

<p><a href="https://rusneb.ru/catalog/000199_000009_004423718/">Васильев В.Н. Системы ориентации космических аппаратов / В.Н. Васильев. – м.: ФГУП «НПП Внииэм», 2009.</a></p>]]></content><author><name></name></author><category term="mechanics" /><summary type="html"><![CDATA[Рассматривается задача определения параметров плоского программного разворота космического аппарата или ступени РН, выполняемого при помощи реактивных двигателей ориентации, создающих постоянный момент относительно центра масс.]]></summary></entry><entry><title type="html">Модель стандартной атмосферы для среды динамического моделирования SimInTech</title><link href="https://classmech.github.io/blog/cae/2025-08-17-simintec-standard-atmosphere/" rel="alternate" type="text/html" title="Модель стандартной атмосферы для среды динамического моделирования SimInTech" /><published>2025-08-17T00:00:00-05:00</published><updated>2025-08-17T00:00:00-05:00</updated><id>https://classmech.github.io/blog/cae/simintec-standard-atmosphere</id><content type="html" xml:base="https://classmech.github.io/blog/cae/2025-08-17-simintec-standard-atmosphere/"><![CDATA[<p>Модель стандартной атмосферы по ГОСТ 4401-81 для среды динамического моделирования “SimInTech” для диапазона геометрической высоты от -2 до 400 км. В отличие от стандартного блока “Параметры стандартной атмосферы (ГОСТ 4401-81)” библиотеки “Динамика ЛА” представленная здесь модель (блок) может использоваться для определения плотности воздуха, скорости звука, температуры и давления для высоты от -2 до 400 км. Стандартный блок корректно определяет параметры атмосферы до 95 км.</p>

<p><a href="https://gitverse.ru/classmech/gost_4401-81_simintech">Репозитарий проекта на gitverse</a>.</p>]]></content><author><name></name></author><category term="cae" /><category term="simintech" /><summary type="html"><![CDATA[Модель стандартной атмосферы по ГОСТ 4401-81 для среды динамического моделирования "SimInTech" для диапазона геометрической высоты от -2 до 400 км]]></summary></entry><entry><title type="html">Модель эффекта Джанибекова в Wolfram Mathematica</title><link href="https://classmech.github.io/blog/mechanics/2025-04-23-janibekov-effect-in-wolfram-mathematica/" rel="alternate" type="text/html" title="Модель эффекта Джанибекова в Wolfram Mathematica" /><published>2025-04-23T00:00:00-05:00</published><updated>2025-04-23T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/janibekov-effect-in-wolfram-mathematica</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/2025-04-23-janibekov-effect-in-wolfram-mathematica/"><![CDATA[<ul>
  <li><a href="/assets/files/Mathematica/Janibekov-effect.nb">Файл Wolfram Mathematica</a></li>
  <li><a href="/assets/files/3d/screw.stl">3D-модель гайки-барашка (stl)</a></li>
</ul>

<p><img src="/assets/files/Mathematica/Janibekov-effect.gif" alt="" /></p>

<p>Динамические уравнения Эйлера</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">eq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nv">Jx</span><span class="w"> </span><span class="nv">wx</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nv">Jy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">Jz</span><span class="p">)</span><span class="w"> </span><span class="nv">wy</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nv">wz</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w">
   </span><span class="nv">Jy</span><span class="w"> </span><span class="nv">wy</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nv">Jz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">Jx</span><span class="p">)</span><span class="w"> </span><span class="nv">wx</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nv">wz</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="o">,</span><span class="w">
   </span><span class="nv">Jz</span><span class="w"> </span><span class="nv">wz</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nv">Jx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">Jy</span><span class="p">)</span><span class="w"> </span><span class="nv">wy</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nv">wx</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w">
   </span><span class="p">}</span><span class="o">;</span><span class="w">
</span></code></pre></div></div>

<p>Кинематические уравнения для углов последовательности XZ’X’’</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="nv">kinematicEq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="err">ψ</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="nv">wz</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[</span><span class="err">φ</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">wy</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Cos</span><span class="p">[</span><span class="nv">\[CurlyPhi]</span><span class="p">[</span><span class="nv">t</span><span class="p">]])</span><span class="o">/</span><span class="w">
     </span><span class="nb">Sin</span><span class="p">[</span><span class="nv">\[CurlyTheta]</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="o">,</span><span class="w">
   </span><span class="nv">\[CurlyTheta]</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> 
    </span><span class="nv">wz</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Cos</span><span class="p">[</span><span class="nv">\[CurlyPhi]</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">wy</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[</span><span class="nv">\[CurlyPhi]</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="o">,</span><span class="w">
   </span><span class="nv">\[CurlyPhi]</span><span class="o">'</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> 
    </span><span class="nv">wx</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nv">wy</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Cos</span><span class="p">[</span><span class="nv">\[CurlyPhi]</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">wz</span><span class="p">[</span><span class="nv">t</span><span class="p">]</span><span class="w"> </span><span class="nb">Sin</span><span class="p">[</span><span class="nv">\[CurlyPhi]</span><span class="p">[</span><span class="nv">t</span><span class="p">]])</span><span class="o">/</span><span class="w">
      </span><span class="nb">Tan</span><span class="p">[</span><span class="nv">\[CurlyTheta]</span><span class="p">[</span><span class="nv">t</span><span class="p">]]</span><span class="w">
   </span><span class="p">}</span><span class="o">;</span><span class="w">
</span></code></pre></div></div>]]></content><author><name></name></author><category term="mechanics" /><category term="Mathematica" /><summary type="html"><![CDATA[Численное интегрирование уравнений пространственного движения твёрдого тела вокруг неподвижной точки и его визуализация в Wolfram Mathematica]]></summary></entry><entry><title type="html">Моделирования движения механизма с двумя степенями свободы</title><link href="https://classmech.github.io/blog/mechanics/cae/2024-11-09-simintech-course-work/" rel="alternate" type="text/html" title="Моделирования движения механизма с двумя степенями свободы" /><published>2024-11-09T00:00:00-06:00</published><updated>2024-11-09T00:00:00-06:00</updated><id>https://classmech.github.io/blog/mechanics/cae/simintech-course-work</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2024-11-09-simintech-course-work/"><![CDATA[<p><a href="https://gitverse.ru/classmech/simintech/content/master/Курсовая_ТМ">Пример модели механизма с двумя степенями свободы</a> из заданий для курсовой работы кафедры теоретической механики Самарского университета.</p>]]></content><author><name></name></author><category term="mechanics" /><category term="CAE" /><category term="simintech" /><summary type="html"><![CDATA[SimInTech-проект моделирования движения механизма с двумя степенями свободы]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/simintech-course-work.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/simintech-course-work.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Модель движения маятника с точкой подвеса на колесе</title><link href="https://classmech.github.io/blog/mechanics/cae/2024-10-24-wheel-pendulum/" rel="alternate" type="text/html" title="Модель движения маятника с точкой подвеса на колесе" /><published>2024-10-24T00:00:00-05:00</published><updated>2024-10-24T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/wheel-pendulum</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2024-10-24-wheel-pendulum/"><![CDATA[<p>Рассмотрим движение физического маятника с точкой подвеса шарнирно закрепленной в центре колеса (точка С). Колесо может катиться без проскальзывания  по прямой линии на горизонтальной плоскости.</p>

<p>Эта механическая система имеет две степени свободы: её положение определяется углом поворота колеса \(\varphi\) и углом отклонения маятника от вертикали – \(\beta\). Координата центра масс колеса относительно неподвижной системы координат Oxy, расположенной на плоскости, будет определяться произведением радиуса колеса \(r\) на угол его поворота \(\varphi\) с противоположным знаком (рисунок 1).</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/mech.svg" alt="" /></p>

<p class="figcaption">Рисунок 1 - Схема механизма</p>

<p>Движение механизма описывается следующей системой дифференциальных уравнений второго порядка:</p>

\[\left\{
\begin{aligned}
    &amp; \dot \omega a_{11} + \ddot \beta a_{12} \cos \beta  = a_{12} \dot{\beta}^2 \sin \beta - L \\
    &amp; \dot \omega a_{12} \cos \beta + \ddot{\beta} a_{22} = L + m g b \sin \beta \\
\end{aligned}
\right.\]

<p>где \(a_{11} = m_1 r^2+J_1\), \(a_{12} = m_2 r l\), \(a_{22} = J_2\), \(m_1\,J_1\) – масса и момент инерции колеса относительно его центра C, \(r\) – радиус колеса, \(m_2,\,J_2\) – масса и момент инерции маятника относительно точки закрепления С, \(L\) – момент привода, который стремится повернуть маятник против часовой стрелки, а колесо в противоположном направлении.</p>

<p class="note" title="Источник">Уравнения движения маятника приведены в монографии: Формальский А. М. Управление движением неустойчивых объектов.  М.: Физматлит, 2012.</p>

<h2 id="модель-simintech">Модель SimInTech</h2>

<h3 id="параметры-модели-глобальные-переменные">Параметры модели (глобальные переменные)</h3>

<p>Создадим новый проект “Файл”→”Новый проект”→”Схема модели общего вида”.</p>

<p>Параметры (константы) механической системы зададим в <a href="https://help.simintech.ru/#6_interfejs_programmy/skhemnoe_okno/panel_knopok_bystrogo_dostupa/sloi/DAT_knopka_skript.html">скрипте проекта</a>. Для открытия скрипта проекта необходимо нажать на кнопку “Скрипт” на панели инструментов окна проекта (рисунок 2).</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/toolbar.png" alt="" /></p>

<p class="figcaption">Рисунок 2 - Панель инструментов проекта</p>

<p>В редакторе кода (скрипта проекта) создадим секцию инициализации и определим значения параметров механической системы. Секция инициализации выполнятся один раз при запуске проекта:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">initialization</span>
	<span class="c1">// Радиус колеса
</span>	<span class="n">r</span> <span class="p">=</span> <span class="m">0.25</span><span class="p">;</span>
	<span class="c1">// Длина стержня
</span>	<span class="n">l</span> <span class="p">=</span> <span class="m">1.0</span><span class="p">;</span>
	<span class="c1">// Масса колеса
</span>	<span class="n">m1</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
	<span class="c1">// Масса груза		
</span>	<span class="n">m2</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
	<span class="c1">// Момент инерции колеса
</span>	<span class="n">J1</span> <span class="p">=</span> <span class="m">0.5</span><span class="p">*</span><span class="n">m1</span><span class="p">*</span><span class="n">r</span><span class="p">^</span><span class="m">2</span><span class="p">;</span>
	<span class="c1">// Момент инерции груза относительно оси вращения
</span>	<span class="n">J2</span> <span class="p">=</span> <span class="n">m2</span><span class="p">*</span><span class="n">l</span><span class="p">^</span><span class="m">2</span><span class="p">;</span>	
	<span class="c1">// Ускорение силы тяжести
</span>	<span class="n">g</span> <span class="p">=</span> <span class="m">9.81</span><span class="p">;</span>
	<span class="c1">// Начальный угол поворота
</span>	<span class="n">beta0</span> <span class="p">=</span> <span class="m">0.7</span><span class="p">;</span>	            	
<span class="k">end</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="модель-механизма">Модель механизма</h3>

<p>Модель механизма построим при помощи блока <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">“Язык программирования”</a> из библиотеки <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/DIR_dinamicheskie.html">“Динамические”</a>. После помещения блока на схему проекта необходимо дважды начать левую кнопку мыши, чтобы открылся редактор кода блока. В блоке при помощи директивы input объявлены входные переменные: угол поворота маятника от вертикали (beta), угловая скорость вращения маятника (dbeta), угол поворота колеса (phi), угловая скорость колеса (w) и момент привода (Torque). Выходные переменные блока (output) – это угловое ускорением маятника (d2beta) и угловое ускорение колеса (dw):</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input</span> 	<span class="n">beta</span><span class="p">,</span> <span class="n">dbeta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">Torque</span><span class="p">;</span>
<span class="n">output</span>  <span class="n">d2beta</span><span class="p">,</span><span class="n">dw</span><span class="p">;</span>                 
</code></pre></div></div>

<p>В блоке формируется матрица коэффициентов при старших производных системы дифференциальных уравнений движения механизма (матрица масс), матрица правых частей, производится решение системы линейный уравнений относительной старших производных при помощи функции <a href="https://help.simintech.ru/index_frames.html?q=/11_yazyk_programmirovaniya/6_funkcii/1_vektornye_i_matrichnye/lsolve.html">lsolve</a>:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Коэффициенты матрицы масс
</span><span class="n">a11</span> <span class="p">=</span> <span class="n">m1</span><span class="p">*(</span><span class="n">r</span><span class="p">*</span><span class="n">r</span><span class="p">+</span><span class="n">rho</span><span class="p">*</span><span class="n">rho</span><span class="p">)+</span><span class="n">m2</span><span class="p">*</span><span class="n">r</span><span class="p">*</span><span class="n">r</span><span class="p">;</span>
<span class="n">a12</span> <span class="p">=</span> <span class="n">m2</span><span class="p">*</span><span class="n">r</span><span class="p">*</span><span class="n">l</span><span class="p">;</span>
<span class="n">a21</span> <span class="p">=</span> <span class="n">a12</span><span class="p">;</span>
<span class="n">a22</span> <span class="p">=</span> <span class="n">m2</span><span class="p">*</span><span class="n">r</span><span class="p">*</span><span class="n">r</span><span class="p">;</span>                   
<span class="c1">// Коэффициенты столбца правой части
</span><span class="n">b1</span>  <span class="p">=</span> <span class="p">-</span><span class="n">Torque</span><span class="p">+</span><span class="n">a12</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)*</span><span class="n">dbeta</span><span class="p">^</span><span class="m">2</span><span class="p">;</span>
<span class="n">b2</span>  <span class="p">=</span> <span class="p">+</span><span class="n">Torque</span><span class="p">+</span><span class="n">m2</span><span class="p">*</span><span class="n">g</span><span class="p">*</span><span class="n">l</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">);</span>
<span class="c1">// Матрица масс 
</span><span class="n">A</span> <span class="p">=</span> <span class="p">[[</span><span class="n">a12</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span><span class="n">a11</span><span class="p">],[</span><span class="n">a22</span><span class="p">,</span><span class="n">a12</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)]];</span>
<span class="c1">// Матрица правой части
</span><span class="n">B</span> <span class="p">=</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">];</span>
<span class="c1">// Ускорения
</span><span class="n">da</span> <span class="p">=</span> <span class="n">lsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
<span class="c1">// Ускорения записываем в переменные, объявленные в секции output
</span><span class="n">d2beta</span> <span class="p">=</span> <span class="n">da</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
<span class="n">dw</span>     <span class="p">=</span> <span class="n">da</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
</code></pre></div></div>

<p>Таким образом, при помощи блока <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">“Язык программирования”</a> построена функция, описывающая правую часть системы дифференциальных уравнений движения механизма в форме Коши: на вход блока подаются углы и угловые скорости, на выходе формируются угловые ускорения колеса и маятника:</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/mechanism.png" alt="" /></p>

<p class="figcaption">Рисунок 3 - Функция правых частей системы дифференциальных уравнений механизма</p>

<h3 id="интегрирование">Интегрирование</h3>

<p>Сигналы с выходов блока <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">“Язык программирования”</a> подадим на <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0027.html">блоки-интеграторы</a>, на выходах которых в результате интегрирования формируются угловая скорость, угол поворота маятника, угловая скорость и угол поворота колеса.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/integrators.png" alt="" /></p>

<p class="figcaption">Рисунок 4 - Интегрирование сигналов с выходов блока “Язык программирования”</p>

<p>Сигналы с выходов интеграторов записываются в память (блоки <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Substruktury/1008.html">“В память”</a> библиотеки “Субструктуры”) для того чтобы не загромождать схему системы пересекающимися соединительными линиями. Блок <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Substruktury/1008.html">“В память”</a> предназначен для соединения одной части схемы с другой, находящейся в произвольном месте проекта. Установка блока на линию связи соответствует установке именованной метки на блок-схеме. После чего, помеченный сигнал может быть использован в произвольном месте проекта с помощью блока <a href="https://help.simintech.ru/index_frames.html?q=/10_biblioteki_blokov/avtomatika/Substruktury/1009.html">“Из памяти”</a>.</p>

<p>В свойствах второго интегратора на выходе d2beta зададим начальный угол поворота маятника beta0, объявленный в скрипте инициализации проекта (рисунок 5).</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/integrators2.png" alt="" /></p>

<p class="figcaption">Рисунок 5 - Начальные условия интегрирования (свойства блока-интегратора)</p>

<p>В параметрах остальных блоков-интеграторов в качестве начальных условий указаны нули (это значения “по-умолчанию”), т.е. в начальный момент времени маятник отклонён на угол beta0, при этом угол  поворота колеса, его угловая скорость и угловая скорость самого мятника равны нулю .</p>

<p>Схема модели свободного движения маятника при нулевом внешнем моменте имеет показана на рисунке 6. На вход “torque” модели дифференциальных уравнений подан постоянный нулевой сигнал.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/mechanism2.png" alt="" /></p>

<p class="figcaption">Рисунок 6 - Модель механизма</p>

<h3 id="сигналы-проекта">Сигналы проекта</h3>

<h4 id="создание-сигналов">Создание сигналов</h4>

<p>При помощи <a href="https://help.simintech.ru/index_frames.html?q=/13_priemy_raboty/1_modelirovanie/signaly_proekta_baza_signalov_vektorizovannyi_blok.html">редактора сигналов проекта</a> (Главное меню → Сервис → Сигналы) создадим четыре глобальные переменные, в которые будем записывать кинематические параметры маятника: углы поворота и угловые скорости колеса и маятника. Эти сигналы нам понадобятся для построения графиков кинематических параметров механизма и для визуализации его движения.</p>

<p class="note" title="Сигналы">Под <a href="https://help.simintech.ru/#13_priemy_raboty/1_modelirovanie/signaly_proekta_baza_signalov_vektorizovannyi_blok.html">сигналами в SimInTech понимаются</a> глобальные параметры проекта или группы проектов, которые создаются тремя способами: при помощи таблицы сигналов проекта, путем объявления и задания сигналов в скрипте проекта с помощью внутреннего языка программирования или с помощью базы данных проекта, если необходим обмен данными между несколькими проектами в рамках пакета проектов.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/signals.png" alt="" /></p>

<p class="figcaption">Рисунок 7 - Сигналы проекта</p>

<h4 id="связь-сигналов-с-динамическими-переменными-блоков-модели">Связь сигналов с динамическими переменными блоков модели</h4>

<p>После создания списка сигналов откроем <a href="https://help.simintech.ru/index_frames.html?q=/13_priemy_raboty/1_modelirovanie/signaly_proekta_baza_signalov_vektorizovannyi_blok.html">редактор связей</a> (Главное меню → Сервис → Связи…), при помощи которого установим связь между кинематическими параметрами и созданными ранее глобальными переменными – сигналами проекта.</p>

<p>После открытия редактора связей, не закрывая его, в окне модели выделим второй блок интегратор (рисунок 8), на вход которого поступает производная угла поворота маятника \(\dot beta\), а на выходе формируется угол \(\beta\). В левой нижней области списка сигналов блока “Интегратор” появятся переменная  fdif, обозначающая то, то поступает на вход блока (первая производная угла \(\dot \beta\)), и xdiff – то, что формируется на выходе блока – результат интегрирования (\(\beta\)). Левой кнопкой мыши схватим строчку xdiff и перетащим её в свободную строчку столбца “Источник”.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/connection1.png" alt="" /></p>

<p class="figcaption">Рисунок 8 - Связь сигналов с параметрами блока (выбор блока)</p>

<p>Далее откроем вкладку “Сигнал” редактора связей. Здесь будет показан список ранее созданных сигналов проекта. Левой кнопкой мыши схватим строку beta и перетащим её в столбец “Приёмник”, как показано на рисунке 9. Таким образом мы указали, что результат интегрирования блока “Integrator_2” будет в процессе моделирования автоматически записываться в глобальную переменную (“сигнал проекта”) beta. Подобным образом необходимо связать все оставшиеся сигналы проекта.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/connection2.png" alt="" /></p>

<p class="figcaption">Рисунок 9 - Связь сигналов с параметрами блока (выбор сигнала)</p>

<h3 id="графики-сигналов">Графики сигналов</h3>

<p>Для построения графиков изменения угла поворота маятника \(\beta\) откроем <a href="https://help.simintech.ru/index_frames.html?q=/21_postroenie_grafikov_i_vyvod_raschetnyx_dannyx/grafiki/DAT_kak_sozdat_grafik.html">менеджер данных</a> (рисунок 10) и, нажав правую кнопку мыши, добавим в раздел “Графики” новый “Временной график”.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/manager.png" alt="" /></p>

<p class="figcaption">Рисунок 10 - Менеджер данных</p>

<p>В контекстном меню созданного временного графика, выберем “Добавить” и “Параметр”, указав в качестве имени параметра сигнал проекта  beta.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/graph-parameter.png" alt="" /></p>

<p class="figcaption">Рисунок 11 - Добавить параметр</p>

<p>Аналогичным образом создадим временные графики для всех определенных ранее сигналов проекта, связанных с параметрами модели.</p>

<h3 id="результаты-моделирования">Результаты моделирования</h3>

<p>На рисунке 12 показано изменение угла поворота маятника при его свободном движении после запуска процесса моделирования движения механизма. Как следует из рисунка 12, в своём свободном движении при заданных начальных условиях маятник совершает колебаний вокруг устойчивого положения равновесия \(\beta = \pi\).</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/fig-beta.png" alt="" /></p>

<p class="figcaption">Рисунок 12 - Угол поворота маятника</p>

<h3 id="система-управления">Система управления</h3>

<h4 id="управление-углом-beta">Управление углом \(\beta\)</h4>

<p>Добавим в модель системы управления, которая будет удерживать маятник в неустойчивом положении равновесия \(\beta = 0\). Сигнал момента, формируемого системой управления, определим как линейную комбинацию угла \(\beta\) и его производной:</p>

\[M_\beta = - k_1 [(\beta-\beta_p) + k_2 (\dot{\beta}-\dot{\beta}_p)]\]

<p>Т.е. управляющий момент \(M_\beta\)  будет тем больше по модулю, чем больше отклонение (ошибка) угла и угловой скорости от требуемого (программного) значения \(\beta_p = 0\), \(\dot{\beta}_p = 0\). Знак минус в выражении момента означает, что знак момента будет противоположен знаку отклонения угла \(\beta\) от вертикального положения и знаку отклонения угловой скорости от нуля. Коэффициенты \(k_1\) и \(k_2\) – коэффициенты усиления отклонений. Выбор этих параметров – это отдельная задача теории автоматического управления, которая здесь не рассматривается.</p>

<p>На рисунке 13 приведен график изменения угла поворота маятника при действии определенного выше момента \(M_\beta\) c \(k_1 = 60\) Нм/рад и \(k_2 = 9\) Нм*с/рад: при этих коэффициентах в течение 2 секунд мятник возвращается и удерживается системой управления в нулевом положении.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/fig-beta2.png" alt="" /></p>

<p class="figcaption">Рисунок 13 - Угол поворота маятника при управлении</p>

<h4 id="управление-углом-varphi">Управление углом \(\varphi\)</h4>

<p>При действии управляющего момента \(M_\beta\) движение самого колеса не контролируется, поэтому после стабилизации углового положения маятника колесо продолжит движение с некоторой скоростью. Это иллюстрирует рисунок 14, где показан график изменения угловой скорости колеса.</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/fig-w.png" alt="" /></p>

<p class="figcaption">Рисунок 14 - Угловая скорость вращения колеса</p>

<p>Добавим управление, которое будет возвращать колесо в начало координат. Для этого к управляющему моменту \(M_\beta\) добавим еще один момент, значение которого будет пропорционально отклонению угла поворота колеса \(\varphi\)  и его угловой скорости \(\omega = \dot{\varphi}\) от нулевого значения. Поскольку колесо катится без проскальзывания, нулевое значение угла \(\varphi\) будет соответствовать его положению  \(x = - r \varphi\) в начале координат (рисунок 1):</p>

\[M_\varphi = - [k_3 (\varphi-\varphi_p) + k_4 (\dot{\varphi}-\dot{\varphi}_p)]\]

<p>где \(\varphi_p = \dot{\varphi}_p = 0\) – программные значения угла поворота и угловой скорости колеса.</p>

<p>Схема модели будет иметь вид:</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/wheel-model.png" alt="" /></p>

<p class="figcaption">Рисунок 15 - Схема модели</p>

<p>На рисунках 16 и 17 показаны графики изменения угла поворота маятника и угловой скорости колеса при действии управляющего момента</p>

\[M_u = M_\beta + M_\varphi.\]

<p><img src="/assets/img/blog/simintech-pendulum-wheel/fig-beta3.png" alt="" /></p>

<p class="figcaption">Рисунок 16 - Изменение угла поворота маятника</p>

<p><img src="/assets/img/blog/simintech-pendulum-wheel/fig-w3.png" alt="" /></p>

<p class="figcaption">Рисунок 17 - Изменение угловой скорости колеса</p>

<p>Работа управляющего момента показана на следующем видео:</p>

<iframe width="720" height="405" src="https://rutube.ru/play/embed/372d6fbe0938d1a08b05ff77c2aa9085/?p=GIjg2NRaHxzazvODRIn6Yw" frameborder="0" allow="clipboard-write; autoplay" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>

<p><a href="https://gitverse.ru/classmech/simintech/content/master/pendulum_wheel">Проект на GitVerse.</a></p>]]></content><author><name></name></author><category term="mechanics" /><category term="CAE" /><category term="simintech" /><summary type="html"><![CDATA[Построение в среде динамического моделирования SimInTech модели движения маятника с подвижной точкой подвеса, закрепленной на колесе.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/simintech-pendulum-wheel/slide.jpg" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/simintech-pendulum-wheel/slide.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Пример вывода уравнений движения системы тел методом Кейна</title><link href="https://classmech.github.io/blog/mechanics/cae/matlab/2024-08-15-kane-3d/" rel="alternate" type="text/html" title="Пример вывода уравнений движения системы тел методом Кейна" /><published>2024-08-15T00:00:00-05:00</published><updated>2024-08-15T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/matlab/kane-3d</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/matlab/2024-08-15-kane-3d/"><![CDATA[<h1 id="метод-кейна">Метод Кейна</h1>

<p>Метод разработан в 1961 проф. Т. Кейном (Стэндфорский университет) (Kane, T.R., Dynamics of nonholonomic systems, J. App. Mech., 28, 574, 1961). Метод основан на принципе Даламбера-Лагранжа и ориентирован на машинное формирование уравнений движения. При выводе уравнений движения используются вспомогательные векторные величины, которые здесь будут называться частными линейными \(\mathbf v_{ik}\) и угловыми скоростями \(\boldsymbol \omega_{ik}\). Эти величины являются векторными множителями, стоящими перед обобщенными скоростями в выражениях для линейных и угловых скоростей тел механической системы. Например, скорость материальной точки на плоскости, положение которой определяется двумя координатами x и y, в декартовой системе координат можно представить как:</p>

\[\mathbf v = \mathbf{e}_x \dot{x} + \mathbf{e}_y \dot{y}\]

<p>В этом выражении частными линейными скоростями будут единичные векторы \(\mathbf{e}_x\) и \(\mathbf{e}_x\).</p>

<p>При вращении твердого тела вокруг неподвижной точки частными угловыми скоростями будет орты связанной с телом системы координат \(\mathbf{e}_x^c, \mathbf{e}_y^c, \mathbf{e}_z^c\), поскольку угловая скорость тела будет определяться выражением</p>

\[\boldsymbol{\omega} = \mathbf{e}_x^c \omega_x + \mathbf{e}_y^c \omega_y + \mathbf{e}_z^c \omega_z\]

<p>Рассмотрим движение несвободной системы материальных точек. Движение каждой точки определяется внешней силой и силой реакции:</p>

\[m_k \mathbf a_k = \mathbf F_k + \mathbf R_k, \quad k=1,\ldots,n.\]

<p>После умножения каждого уравнения на соответствующее виртуальное перемещение \(\delta \mathbf r_k\) и сложения всех уравнений, для идеальных связей получим общее уравнение динамики:</p>

\[\sum_{k=1}^N \left(\mathbf F_k - m_k \mathbf a_k \right)\cdot \delta \mathbf r_k + \sum_{k=1}^N \underbrace{\mathbf R_k \cdot \delta \mathbf r_k}_{0} = 0.\]

<p>Подставляя вариации радиус-вектора \(\mathbf r_k(q_1,\ldots,q_n)\) в обобщённых координатах:</p>

\[\delta \mathbf r_k =  \sum_{i=1}^n \frac{\partial \mathbf r_k}{\partial q_i} \delta q_i.\]

<p>получим</p>

\[\sum_{k=1}^N \left(\mathbf F_k - m_k \mathbf a_k \right)\cdot \sum_{i=1}^n \frac{\partial \mathbf r_k}{\partial q_i} \delta q_i  = 0.\]

<p>После изменения порядка суммирования:</p>

\[\sum_{i=1}^n \sum_{k=1}^N \left(\mathbf F_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} - m_k \mathbf a_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} \right) \delta q_i = 0.\]

<p>и с учётом независимости вариаций обобщённых координат:</p>

\[\sum_{k=1}^N \left(\mathbf F_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} - m_k \mathbf a_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} \right)= 0, \quad i=1,\ldots,n.\]

<p>Частная производная вектора скорости точки по обобщенной скорости имеет вид:</p>

\[\frac{\partial \mathbf v_k}{\partial \dot q_i} = \frac{\partial {\mathbf r_k}}{\partial {q}_i} = \mathbf u_{ki}.\]

<p>и называется частной скоростью:</p>

\[\mathbf u_{ki} = \frac{\partial \mathbf v_k}{\partial \dot q_i}\]

<p>Подставляя</p>

\[\frac{\partial {\mathbf r_k}}{\partial {q}_j} = \frac{\partial \mathbf v_k}{\partial \dot q_j}\]

<p>в уравнения движения</p>

\[\sum_{k=1}^N \left(\mathbf F_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} - m_k \mathbf a_k \cdot \frac{\partial \mathbf r_k}{\partial q_i} \right)= 0, \quad i=1,\ldots,n.\]

<p>получим</p>

\[\sum_{k=1}^N \left(\mathbf F_k \cdot \frac{\partial \mathbf v_k}{\partial \dot q_i} - m_k \mathbf a_k \cdot \frac{\partial \mathbf v_k}{\partial \dot q_i} \right)= 0, \quad i=1,\ldots,n.\]

<p>или</p>

\[\sum_{k=1}^N \left(\mathbf F_k \cdot \mathbf u_{ki} - m_k \mathbf a_k \cdot \mathbf u_{ki} \right)= 0, \quad i=1,\ldots,n.\]

<p>Обозначив обобщенные активные силы \(Q_i\) и силы инерции \(Q_i^*\):</p>

\[Q_i = \sum_{k=1}^{N} \mathbf F_k \cdot \mathbf u_{ki}, \quad
  Q_i^* = - \sum_{k=1}^{N} m_k \mathbf a_k \cdot \mathbf u_{ki}\]

<p>уравнения</p>

\[\sum_{k=1}^N \left(\mathbf F_k \cdot \mathbf u_{ki} - m_k \mathbf a_k \cdot \mathbf u_{ki} \right)= 0, \quad i=1,\ldots,n.\]

<p>принимают вид:</p>

\[Q_i + Q_i^* = 0.\]

<h3 id="алгоритм">Алгоритм</h3>

<ol>
  <li>Выбираются обобщенные координаты \(q_1,q_2\ldots,q_n\).</li>
  <li>Определяются скорости тел, которые  могут быть как производные обобщенных координат, так и их линейными комбинациями (например, угловые скорости для твердого тела).</li>
  <li>Определяются выражения для векторов скоростей точек приложения сил.</li>
  <li>Определяются выражения для векторов скоростей центров масс тел.</li>
  <li>Определяются выражения для векторов угловых скоростей тел.</li>
  <li>Определяются векторы линейных ускорений тел системы и их угловые ускорения.</li>
  <li>Определяются частные линейные и угловые скорости для точек приложения сил, центров масс тел.</li>
  <li>Определяются силы и моменты (активные и инерционные).</li>
  <li>Вычисляются скалярные произведения сил, моментов и частных скоростей.</li>
</ol>

<h1 id="пример">Пример</h1>

<h2 id="схема-системы">Схема системы</h2>

<p>Используя метод Кейна, построим модель движения механической системы с четырьмя степенями свободы, представленной на рисунке 1. Система состоит из двух стержней связанных шарнирами. Первый стержень при помощи сферического шарнира связан с неподвижным основанием, второй стержень соединяется с первым при помощи цилиндрического шарнира.</p>

<p>Движение механизма происходит под действием силы тяжести, действующей отрицательном направлении оси \(Oz_0\).</p>

<p><img src="/assets/img/blog/kane-two-bodies-model.png" alt="" /></p>

<p class="figcaption">Рисунок 1 - Схема механизма</p>

<p>Положение шарниров задано координатными столбцами векторов \(\mathbf{c}_{11}^{(1)}\), \(\mathbf{c}_{12}^{(1)}\), \(\mathbf{c}_{22}^{(2)}\):</p>

<ul>
  <li>вектор \(\mathbf{c}_{11}\) соединяет центр масс тела 1 и шарнирную точку (О) первого шарнира;</li>
  <li>вектор \(\mathbf{c}_{12}\) соединяет центр масс тела 1 и шарнирную точку (А) второго шарнира;</li>
  <li>вектор \(\mathbf{c}_{22}\) соединяет центр масс тела 2 и шарнирную точку (А) второго шарнира.</li>
</ul>

<h2 id="кинематические-соотношения">Кинематические соотношения</h2>

<p>Положение системы определим столбцом обобщенных координат:</p>

\[\mathbf q = [\alpha_1,\alpha_2,\alpha_3,\alpha_4]^T\]

<p>Первые три угла определяют ориентацию базиса \(C_1 x_1 y_1 z_1\), связанного с телом 1 относительно неподвижного базиса \(O x_0 y_0 z_0\). Для определения ориентации используется последовательность XY’Z’’ (углы Брайнта). Матрица преобразования координат из базиса \(C_1 x_1 y_1 z_1\) в базис \(O x_0 y_0 z_0\) определяется выражением:</p>

\[\mathbf{A}^{01} = \mathbf{A}_{x}(\alpha_1) \mathbf{A}_{y}(\alpha_2) \mathbf{A}_{z}(\alpha_3)\]

<p>Угол \(\alpha_4\) определяет ориентацию тела 2 относительно тела 1. Вращение тела 2 относительно тела 1 происходит вокруг общей оси \(y\), поэтому матрица преобразования координат из базиса \(C_2 x_2 y_2 z_2\), связанного со вторым телом в базис \(C_1 x_1 y_1 z_1\), будет иметь вид:</p>

\[\mathbf{A}^{12} = \mathbf{A}_{y}(\alpha_4)\]

<p>Сформируем столбец скоростей системы, но не из обобщенных скоростей, а из проекций угловых скоростей тела 1 на его связанные оси и производной угла поворота второго тела относительно первого.</p>

\[\mathbf{u}=\left[\omega_x^{\left(1\right)},\omega_y^{\left(1\right)},\omega_z^{\left(1\right)},{\dot{\alpha}}_4\right]^T\]

<p>Эта особенность метода Кейна позволяет упростить вывод уравнений движения системы.</p>

<h3 id="скорость-и-ускорение-центра-масс-тела-1">Скорость и ускорение центра масс тела 1</h3>

<p>Вектор скорости центра масс первого тела определяется выражением:</p>

\[\vec{V}_1  = \vec{\omega}_1 \times (-\vec{c}_{11}).\]

<p>Координатная форма этого выражения в неподвижной СК \(A_1 x_0 y_0 z_0\) будет иметь вид:</p>

\[\mathbf{V}_1^{(0)}=\mathbf{A}^{01}{\widetilde{\mathbf{\omega}}}_1^{(1)}\ \left(-\mathbf{c}_{11}^{\left(1\right)}\right)=\mathbf{A}^{01}{\widetilde{\mathbf{c}}}_{11}^{\left(1\right)}\mathbf{\omega}_1^{(1)}=\left[\begin{matrix}\mathbf{A}^{01}{\widetilde{\mathbf{c}}}_{11}^{\left(1\right)}&amp;\mathbf{0}_3\\\end{matrix}\right]\mathbf{u}=\mathbf{Q}_{V1}^{(0)}\mathbf{u}\]

<p>Оператор тильда используется для матричной записи векторного произведения и преобразует координатный столбец вектора в кососимметрическую матрицу:</p>

\[\tilde{\mathbf a} = 
  \begin{bmatrix}
  0 &amp; -a_z &amp; a_y \\
  a_z &amp; 0 &amp; -a_x \\
 -a_y &amp; a_x &amp; 0
  \end{bmatrix}, \quad \mathbf a \times \mathbf b = \tilde{\mathbf a} \mathbf b\]

<p>Матрица \(\mathbf{Q}_{V1}^{(0)}\) имеет размерность \(3\times n\), где \(n\) – число степеней свободы системы. Каждый столбец этой матрицы представляет собой частную скорость центра масс тела 1, например, первый вектор \(\mathbf{u}_{11}\) можно получить следующим образом:</p>

\[\mathbf{u}_{11} = \mathbf{Q}_{V1}^{(0)} \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}.\]

<p>Координатный столбец ускорения центра масс получим, продифференцировав выражение для скорости:</p>

\[\mathbf{a}_1^{(0)} = \mathbf{Q}_{V1}^{(0)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{V1}^{(0)} \dot{\mathbf{u}}\]

<p>Производная матрицы частных векторов:</p>

\[\dot{\mathbf{Q}}_{V1}^{(0)} = \begin{bmatrix} \mathbf{A}^{01} \tilde{\boldsymbol \omega}_1^((1) ) \tilde{\mathbf c}_{11}^{(1)} &amp;  \mathbf{0}_3 \end{bmatrix}\]

<p>где \({0}_3\) – столбец нулей \(3 \times 1\).</p>

<h3 id="угловая-и-скорость-ускорение-тела-1">Угловая и скорость ускорение тела 1</h3>

<p>Координатный столбец вектора угловой скорости первого тела в проекциях на собственные оси будет определяться выражением</p>

\[\boldsymbol{\omega}_1^{(1)} = \begin{pmatrix} \mathbf{E}_{3} &amp; \mathbf{0}_3 \end{pmatrix} \mathbf{u} = \mathbf{Q}_{w1}^{(1)} \mathbf{u}\]

<p>Матрица \(\mathbf{Q}_{w1}^{(1)}\) как и матрица \(\mathbf{Q}_{V1}^{(0)}\) имеет размерность \(3\times n\), где \(n\). Каждый столбец матрицы представляет собой частную угловую скорость тела 1.</p>

<p>Угловое ускорение тела 1</p>

\[\boldsymbol{\varepsilon}_1^{(1)} = \mathbf{Q}_{w1}^{(1)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{w1}^{(1)} \mathbf{u}\]

<p>Матрица  \(\mathbf{Q}_{w1}^{(1)}\) не зависит от времени, поэтому \(\dot{\mathbf{Q}}_{V1}^{(0)} = 0\).</p>

<h3 id="скорость-и-ускорение-центра-масс-тела-2">Скорость и ускорение центра масс тела 2</h3>

<p>Вектор скорости центра масс второго тела представляет собой сумму скорости движения второго тела вместе с первым и скорости второго тела относительно первого:</p>

\[\vec{V}_2  = \vec{V}_{2}^e + \vec{V}_{2}^r = \vec{\omega}_1 \times (-\vec{c}_{11}+\vec{c}_{12}-\vec{c}_{22})\]

<p>В координатной матричной форме это выражение имеет вид:</p>

\[\mathbf{V}_2^{\left(0\right)}=\mathbf{A}^{01}{\widetilde{\mathbf{\omega}}}_1^{\left(1\right)}\ \left(-\mathbf{c}_{11}^{\left(1\right)}+\mathbf{c}_{12}^{\left(1\right)}-\mathbf{A}^{12}\mathbf{c}_{22}^{\left(2\right)}\right)+\mathbf{A}^{01}\mathbf{A}^{12}\left(-{\widetilde{\mathbf{e}}}_y\mathbf{c}_{22}^{\left(2\right)}\right){\dot{\alpha}}_4\]

<p>где \(\mathbf{e}_y  = [0,1,0]\) – единичный вектор оси y – оси вращения второго тела относительно первого.</p>

<p>Изменим порядок векторного произведения для того, чтобы вынести координатный столбец угловой скорости первого тела в правую часть выражения:</p>

\[\mathbf{V}_2^{\left(0\right)} = -\mathbf{A}^{01}\left(-{\widetilde{\mathbf{c}}}_{11}^{\left(1\right)}+{\widetilde{\mathbf{c}}}_{12}^{\left(1\right)}-\widetilde{\mathbf{A}^{12}\mathbf{c}_{22}^{\left(2\right)}}\right)\mathbf{\omega}_1^{\left(1\right)}+\mathbf{A}^{01}\mathbf{A}^{12}{\widetilde{\mathbf{c}}}_{22}^{\left(2\right)}\mathbf{e}_y{\dot{\alpha}}_4\]

<p>и введем матрицу частных скоростей тела 2 \(\mathbf{Q}_{V2}^{(0)}\):</p>

\[\mathbf{V}_2^{\left(0\right)} = \left[-\begin{matrix}\mathbf{A}^{01}\left(-{\widetilde{\mathbf{c}}}_{11}^{\left(1\right)}+{\widetilde{\mathbf{c}}}_{12}^{\left(1\right)}-\widetilde{\mathbf{A}^{12}\mathbf{c}_{22}^{\left(2\right)}}\right)&amp;\mathbf{A}^{01}\mathbf{A}^{12}{\widetilde{\mathbf{c}}}_{22}^{\left(2\right)}\mathbf{e}_y\\\end{matrix}\right]\mathbf{u}=\mathbf{Q}_{V2}^{(0)}\mathbf{u}\]

<p>Продифференцируем выражение для \(\mathbf{V}_2^{\left(0\right)}\) для определения ускорения центра масс тела 2:</p>

\[\mathbf{a}_1^{(0)}=\mathbf{Q}_{V1}^{(0)}\dot{\mathbf{u}}+{\dot{\mathbf{Q}}}_{V1}^{(0)}\mathbf{u}\]

<p>где \({\dot{\mathbf{Q}}}_{V1}^{(0)}\) – производная матрицы \(\mathbf{Q}_{V2}^{(0)}\):</p>

\[{\dot{\mathbf{Q}}}_{V2}^{(0)}=
\begin{bmatrix}
-\mathbf{A}^{01}{\widetilde{\mathbf{\omega}}}_1^{\left(1\right)}\left(-{\widetilde{\mathbf{c}}}_{11}^{\left(1\right)}+{\widetilde{\mathbf{c}}}_{12}^{\left(1\right)}-\widetilde{\mathbf{A}^{12}\mathbf{c}_{22}^{\left(2\right)}}\right)+\mathbf{A}^{01}\widetilde{\left(\mathbf{A}^{12}{\widetilde{\mathbf{\Omega}}}_2^{\left(2\right)}\mathbf{c}_{22}^{\left(2\right)}\right)} &amp;
\mathbf{A}^{01}{\widetilde{\mathbf{\omega}}}_1^{\left(1\right)}\mathbf{A}^{12}{\widetilde{\mathbf{c}}}_{22}^{\left(2\right)}\mathbf{e}_y+\mathbf{A}^{01}\mathbf{A}^{12}{\widetilde{\mathbf{\Omega}}}_2^{\left(2\right)}{\widetilde{\mathbf{c}}}_{22}^{\left(2\right)}\mathbf{e}_y
\end{bmatrix}\]

<h3 id="угловая-скорость-и-ускорение-второго-тела">Угловая скорость и ускорение второго тела</h3>

<p>Угловая скорость тела 2 определяется угловой скоростью тела 1 (\(\vec{\omega}_1\)) и угловой скоростью тела 2 относительно тела 1 (\(\vec{\Omega}_2\)):</p>

\[\vec{\omega}_2 = \vec{\omega}_1 + \vec{\Omega}_2.\]

<p>В матричной координатной форме это выражение имеет вид (в системе координат тела 2):</p>

\[\boldsymbol{\omega}_2^{(2)}=\left[\left(\mathbf{A}^{12}\right)^T\mathbf{E}_\mathbf{3}\ \ \ \mathbf{e}_y\right]\dot{\mathbf{u}}=\mathbf{Q}_{w2}^{(2)}\mathbf{u}\]

<p>Координатный столбец углового ускорения тела 2 определим дифференцированием выражения для \(\boldsymbol{\omega}_2^{(2)}\):</p>

\[\boldsymbol{\varepsilon}_2^{(2)}=\mathbf{Q}_{w2}^{(2)}\dot{\mathbf{u}}+{\dot{\mathbf{Q}}}_{w2}^{(2)}\mathbf{u}\]

<p>где</p>

\[{\dot{\mathbf{Q}}}_{w2}^{(2)}=\left[\left(\mathbf{A}^{12}{\widetilde{\mathbf{\Omega}}}_2^{\left(2\right)}\right)^T\mathbf{E}_\mathbf{3}\ \ \ \mathbf{0}_3\right]\]

<h2 id="силы">Силы</h2>

<p>Движение механической системы  происходит под действием силы тяжести, действующей отрицательном направлении оси \(Oz_0\). Координатные столбцы сил, действующих на тела 1 и 2 в неподвижном базисе:</p>

\[\mathbf{F}_1^{(0)} = [0,0,-m_1 g]^T, \quad \mathbf{F}_2^{(0)} = [0,0,-m_2 g]^T\]

<h2 id="уравнения-движения">Уравнения движения</h2>

<p>Сила инерции первого тела определяется выражением:</p>

\[\boldsymbol{\Phi}_1 = - m_1 \mathbf{a}_1 = - m_1 [ \mathbf{Q}_{V1}^{(0)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{V1}^{(0)} \mathbf{u} ]\]

<p>Это выражение необходимо умножить скалярно на соответствующие частные скорости центра масс первого тела. Учитывая, что необходимые частные скорости это столбцы матрицы \(\mathbf{Q}_{V1}^{(0)}\), скалярное произведение можно записать в матричном виде следующим образом</p>

\[\mathbf{Q}_{v1} = \begin{bmatrix}
  \mathbf{u}_{11} \cdot \boldsymbol{\Phi}_1  \\
  \mathbf{u}_{12} \cdot \boldsymbol{\Phi}_1  \\
  \mathbf{u}_{13} \cdot \boldsymbol{\Phi}_1  \\
  \mathbf{u}_{14} \cdot \boldsymbol{\Phi}_1  \\
  \end{bmatrix} =   
  (\mathbf{Q}_{V1}^{(0)})^T \left\{- m_1 \left( \mathbf{Q}_{V1}^{(0)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{V1}^{(0)} \mathbf{u} \right) \right\}\]

<p>Главный момент сил инерции тела 1</p>

\[\mathbf M_{c1}^{\Phi} = - \mathbf{J}_1 \boldsymbol{\varepsilon}_1^{(1)} - \boldsymbol{\omega_1}^{(1)} \times \mathbf{J}_1 \boldsymbol{\omega}_1^{(1)}\]

<p>скалярно умножается на частные угловые скорости тела 1:</p>

\[\mathbf{Q}_{w1} = 
  \begin{bmatrix}
  \mathbf{w}_{11} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{12} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{13} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{14} \cdot \mathbf M_{c1}^{\Phi}  \\
  \end{bmatrix} = 
  (\mathbf{Q}_{w1}^{(1)})^T \left[- \mathbf{J}_1 (\mathbf{Q}_{w1}^{(1)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{w1}^{(1)} \mathbf{u}) - \boldsymbol{\omega_1}^{(1)} \times \mathbf{J}_1 \boldsymbol{\omega}_1^{(1)} \right]\]

<p>Аналогичные выражения определяются для тела 2</p>

\[\mathbf{Q}_{v2} = \begin{bmatrix}
  \mathbf{u}_{21} \cdot \boldsymbol{\Phi}_2  \\
  \mathbf{u}_{22} \cdot \boldsymbol{\Phi}_2  \\
  \mathbf{u}_{23} \cdot \boldsymbol{\Phi}_2  \\
  \mathbf{u}_{24} \cdot \boldsymbol{\Phi}_2  \\
  \end{bmatrix} =   
  (\mathbf{Q}_{V2}^{(0)})^T \left\{- m_2 \left( \mathbf{Q}_{V2}^{(0)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{V2}^{(0)} \mathbf{u} \right) \right\}\]

\[\mathbf{Q}_{w2} = 
  \begin{bmatrix}
  \mathbf{w}_{21} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{22} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{23} \cdot \mathbf M_{c1}^{\Phi}  \\
  \mathbf{w}_{24} \cdot \mathbf M_{c1}^{\Phi}  \\
  \end{bmatrix} = 
  (\mathbf{Q}_{w2}^{(2)})^T \left[- \mathbf{J}_2 (\mathbf{Q}_{w2}^{(2)} \dot{\mathbf{u}} + \dot{\mathbf{Q}}_{w2}^{(2)} \mathbf{u}) - \boldsymbol{\omega}_2^{(2)} \times \mathbf{J}_2 \boldsymbol{\omega}_2^{(2)} \right]\]

<p>Далее определяются обобщенные силы. Поскольку силы приложены в центрах масс тел, векторы этих сил скалярно умножаются на соответствующие частные линейные скорости центров масс:</p>

\[\mathbf{F}_{v1} = (\mathbf{Q}_{V1}^{(0)})^T \mathbf{F}_1\]

\[\mathbf{F}_{v2} = (\mathbf{Q}_{V2}^{(0)})^T \mathbf{F}_2\]

<p>Сложив полученные обобщённые силы</p>

\[\mathbf Q_{v1} + \mathbf Q_{v2} + \mathbf Q_{w1} + \mathbf Q_{w2} +\mathbf Q_{v1} + \mathbf{F}_{v1} + \mathbf{F}_{v2} = 0,\]

<p>и выделив слагаемые с производной координатного столбца скорости, получим систему дифференциальных уравнений в матричной форме относительно \(\dot{\mathbf{u}}\):</p>

\[\mathbf{Q}_{v1} + \mathbf{Q}_{v2} + \mathbf{Q}_{w1} + \mathbf{Q}_{w1} + \mathbf{F}_{v1} + \mathbf{F}_{v2} = 0\]

\[\begin{aligned}
&amp; \sum_{i=1}^{2}{\left\{-m_i\left[\mathbf{Q}_{Vi}^{\left(0\right)}\right]^T\mathbf{Q}_{Vi}^{\left(0\right)}-\left[\mathbf{Q}_{wi}^{\left(i\right)}\right]^T\mathbf{J}_i^{\left(i\right)}\mathbf{Q}_{wi}^{\left(i\right)}\right\}\dot{\mathbf{u}}} = \\ 
&amp; = \sum_{i=1}^{2}{m_i\left[\mathbf{Q}_{Vi}^{\left(0\right)}\right]^T{\dot{\mathbf{Q}}}_{Vi}^{\left(0\right)}\mathbf{u}} + \sum_{i=1}^{2}{\left[\mathbf{Q}_{wi}^{\left(i\right)}\right]^T\left[\mathbf{J}_i^{\left(i\right)}{\dot{\mathbf{Q}}}_{wi}^{\left(i\right)}\mathbf{u}+{\widetilde{\mathbf{\omega}}}_i^{\left(i\right)}\mathbf{J}_i^{\left(i\right)}\mathbf{\omega}_i^{\left(i\right)}\right]\ } - \sum_{i=1}^{2}{\left(\mathbf{Q}_{Vi}^{\left(0\right)}\right)^T\mathbf{F}_i} 
\end{aligned}\]

<p>Эти уравнения интегрируются совместно кинематическими уравнениями, связывающими производные углов с угловыми скоростями:</p>

\[\dot{\alpha}_1 = \sec \alpha_2 (\omega_{1x}^{(1)} \cos \alpha_3 - \omega_{1y}^{(1)} \sin \alpha_3),\]

\[\dot{\alpha}_2 = \omega_{1x}^{(1)} \sin \alpha_3 + \omega_{1y}^{(1)} \cos \alpha_3,\]

\[\dot{\alpha}_3 = \tan \alpha_2 (\omega_{1y}^{(1)} \sin \alpha_3 - \omega_{1x}^{(1)} \cos \alpha_3) + \omega_{1z}^{(1)}.\]

<h2 id="matlab-код">MATLAB-код</h2>

<h3 id="главный-файл-скрипт">Главный файл-скрипт</h3>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span> <span class="nb">all</span><span class="p">;</span> <span class="nb">clc</span><span class="p">;</span>

<span class="c1">% Матрицы тензоров инерции тел в главных центральных осях</span>
<span class="n">p</span><span class="o">.</span><span class="n">J1</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
<span class="n">p</span><span class="o">.</span><span class="n">J2</span> <span class="o">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">;</span>
<span class="c1">% Шарнирные векторы</span>
<span class="n">p</span><span class="o">.</span><span class="n">c11</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">p</span><span class="o">.</span><span class="n">c12</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="n">p</span><span class="o">.</span><span class="n">c22</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="c1">% Массы тел</span>
<span class="n">p</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">p</span><span class="o">.</span><span class="n">m2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">% Ускорение свободного падения</span>
<span class="n">p</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.807</span><span class="p">;</span>

<span class="c1">% Начальные условия</span>
<span class="n">q0</span> <span class="o">=</span> <span class="p">[</span><span class="nb">pi</span><span class="p">/</span><span class="mi">4</span><span class="p">;</span><span class="nb">pi</span><span class="p">/</span><span class="mi">4</span><span class="p">;</span><span class="nb">pi</span><span class="p">/</span><span class="mi">4</span><span class="p">;</span><span class="nb">pi</span><span class="p">/</span><span class="mi">4</span><span class="p">;</span>  <span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">% Относительная погрешность</span>
<span class="n">opt</span> <span class="o">=</span> <span class="nb">odeset</span><span class="p">(</span><span class="s1">'RelTol'</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">);</span>
<span class="c1">% Запуск процесса интегрирования</span>
<span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="nb">ode113</span><span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="n">dqdt_kane</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">q0</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

<span class="c1">% Графики</span>
<span class="nb">close</span> <span class="nb">all</span><span class="p">;</span>
<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="p">/</span><span class="nb">pi</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'\alpha_1'</span><span class="p">,</span><span class="s1">'\alpha_2'</span><span class="p">,</span><span class="s1">'\alpha_3'</span><span class="p">,</span><span class="s1">'\alpha_4'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'t, c'</span><span class="p">);</span> 
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'\alpha_i, градус'</span><span class="p">);</span>

<span class="nb">figure</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">(:,</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="p">/</span><span class="nb">pi</span><span class="p">);</span>
<span class="nb">legend</span><span class="p">(</span><span class="s1">'\omega_{1x}'</span><span class="p">,</span><span class="s1">'\omega_{1y}'</span><span class="p">,</span><span class="s1">'\omega_{1z}'</span><span class="p">,</span><span class="s1">'d\alpha_4/dt'</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s1">'t, c'</span><span class="p">);</span> 
<span class="nb">ylabel</span><span class="p">(</span><span class="s1">'Угловые скорости, ...^o/c'</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="функция-правых-частей">Функция правых частей</h3>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">dqdt_kane</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>

<span class="n">dq</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c1">% Матрицы элементарных поворотов</span>
<span class="n">Ax</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="mi">0</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)];</span>
<span class="n">Ay</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="o">-</span><span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)];</span>
<span class="n">Az</span> <span class="o">=</span> <span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span><span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">];</span>
<span class="c1">% Единичные векторы осей</span>
<span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>
<span class="n">ey</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>
<span class="n">ez</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">];</span>
<span class="n">e0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">];</span>

<span class="c1">% Матрица-столбец скоростей</span>
<span class="n">u</span>  <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">);</span>

<span class="c1">% Матрица преобразования координат из 1 в 0</span>
<span class="n">A01</span> <span class="o">=</span> <span class="n">Ax</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">Ay</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">Az</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">% Матрица преобразования координат из 2 в 1</span>
<span class="n">A12</span> <span class="o">=</span> <span class="n">Ay</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="c1">% Матрица преобразования координат из 2 в 0</span>
<span class="n">A02</span> <span class="o">=</span> <span class="n">A01</span><span class="o">*</span><span class="n">A12</span><span class="p">;</span>

<span class="c1">% Угловая скорость тела 1</span>
<span class="n">w1_1</span>  <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">);</span>
<span class="c1">% Относительная угловая скорость тела 2 относительно тела 1 в СК 2</span>
<span class="n">Ow1_2</span> <span class="o">=</span> <span class="n">ey</span><span class="o">*</span><span class="n">q</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">% Абсолютная угловая скорость тела 2 в СК 2</span>
<span class="n">w2_2</span>  <span class="o">=</span> <span class="n">A12</span><span class="o">'*</span><span class="n">w1_1</span><span class="o">+</span><span class="n">Ow1_2</span><span class="p">;</span>

<span class="c1">% Частные линейные скорости центра масс С1 в 0</span>
<span class="n">Q1V_0</span>  <span class="o">=</span> <span class="p">[</span><span class="n">A01</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c11</span><span class="p">)</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
<span class="c1">% Производная Q1V_0</span>
<span class="n">dQ1V_0</span> <span class="o">=</span> <span class="p">[</span><span class="n">A01</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">w1_1</span><span class="p">)</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c11</span><span class="p">)</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>

<span class="c1">% Частные линейные скорости центра масс С2 в 0</span>
<span class="n">Q2V_0</span>  <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">A01</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c11</span><span class="p">)</span><span class="o">+</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c12</span><span class="p">)</span><span class="o">-</span><span class="n">tilde</span><span class="p">(</span><span class="n">A12</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">))</span> <span class="n">A01</span><span class="o">*</span><span class="n">A12</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">)</span><span class="o">*</span><span class="n">ey</span><span class="p">];</span>
<span class="n">dQ2V_0</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">A01</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">w1_1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">tilde</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">c11</span><span class="p">)</span><span class="o">+</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c12</span><span class="p">)</span><span class="o">-</span><span class="n">tilde</span><span class="p">(</span><span class="n">A12</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">))</span><span class="o">+</span><span class="n">A01</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">A12</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">Ow1_2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">),</span><span class="k">...</span>
          <span class="n">A01</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">w1_1</span><span class="p">)</span><span class="o">*</span><span class="n">A12</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">)</span><span class="o">*</span><span class="n">ey</span><span class="o">+</span><span class="n">A01</span><span class="o">*</span><span class="n">A12</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">Ow1_2</span><span class="p">)</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c22</span><span class="p">)</span><span class="o">*</span><span class="n">ey</span><span class="p">];</span>

<span class="c1">% Частные угловые скорости 1 в 0 не нужны </span>
<span class="n">Q1w_1</span>  <span class="o">=</span> <span class="p">[</span><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>
<span class="n">dQ1w_1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>

<span class="c1">% Частные угловые скорости 2 в 0 не нужны </span>
<span class="n">Q2w_2</span>  <span class="o">=</span> <span class="p">[</span><span class="n">A12</span><span class="o">'*</span><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">ey</span><span class="p">];</span>
<span class="n">dQ2w_2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">A12</span><span class="o">*</span><span class="n">tilde</span><span class="p">(</span><span class="n">Ow1_2</span><span class="p">))</span><span class="o">'*</span><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)];</span>

<span class="c1">% Силы тяжести</span>
<span class="n">F1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">m1</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">g</span><span class="p">];</span>
<span class="n">F2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">m2</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">g</span><span class="p">];</span>

<span class="c1">% Матрица масс</span>
<span class="n">M</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">m1</span><span class="o">*</span><span class="p">(</span><span class="n">Q1V_0</span><span class="s1">')*Q1V_0-p.m2*(Q2V_0'</span><span class="p">)</span><span class="o">*</span><span class="n">Q2V_0</span><span class="o">-</span><span class="p">(</span><span class="n">Q1w_1</span><span class="s1">')*(p.J1*Q1w_1)-(Q2w_2'</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">J2</span><span class="o">*</span><span class="n">Q2w_2</span><span class="p">;</span>

<span class="c1">% Матрица правых частей</span>
<span class="n">B</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">m1</span><span class="o">*</span><span class="p">(</span><span class="n">Q1V_0</span><span class="s1">')*dQ1V_0*u-(Q1w_1'</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">J1</span><span class="o">*</span><span class="n">dQ1w_1</span><span class="o">*</span><span class="n">u</span><span class="o">+</span><span class="n">tilde</span><span class="p">(</span><span class="n">w1_1</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">J1</span><span class="o">*</span><span class="n">w1_1</span><span class="p">)</span><span class="o">-</span><span class="k">...</span>
       <span class="n">p</span><span class="o">.</span><span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="n">Q2V_0</span><span class="s1">')*dQ2V_0*u-(Q2w_2'</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">J2</span><span class="o">*</span><span class="n">dQ2w_2</span><span class="o">*</span><span class="n">u</span><span class="o">+</span><span class="n">tilde</span><span class="p">(</span><span class="n">w2_2</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">J2</span><span class="o">*</span><span class="n">w2_2</span><span class="p">)</span><span class="o">+</span><span class="k">...</span>
       <span class="p">(</span><span class="n">Q1V_0</span><span class="s1">')*F1+(Q2V_0'</span><span class="p">)</span><span class="o">*</span><span class="n">F2</span>  <span class="p">);</span>

<span class="c1">% Решаем СЛУ относительно старших производных (угловых ускорений)</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">M</span><span class="p">\</span><span class="n">B</span><span class="p">;</span>

<span class="c1">% Кинематические уравнения</span>
<span class="c1">% Производные углов</span>
<span class="n">dq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sec</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">q</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">)));</span>
<span class="n">dq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">+</span><span class="n">q</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">dq</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="nb">tan</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">-</span><span class="n">q</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span><span class="o">+</span><span class="n">q</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="n">dq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">% Угловые ускорения</span>
<span class="n">dq</span><span class="p">(</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="n">du</span><span class="p">;</span>

<span class="k">end</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="mechanics" /><category term="CAE" /><category term="matlab" /><summary type="html"><![CDATA[Derivation of the equations of spatial motion for a system of two bodies using the Kane method.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/kane-two-bodies-model_cover.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/kane-two-bodies-model_cover.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Уравнения относительного орбитального движения</title><link href="https://classmech.github.io/blog/mechanics/2024-07-21-relative_orbital_motion/" rel="alternate" type="text/html" title="Уравнения относительного орбитального движения" /><published>2024-07-21T00:00:00-05:00</published><updated>2024-07-21T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/relative_orbital_motion</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/2024-07-21-relative_orbital_motion/"><![CDATA[<h2 id="система-координат">Система координат</h2>

<p>Рассматривается движение космического аппарата (КА) относительно орбитальной станции, движущейся по круговой или эллиптической орбите. Положение КА относительно станции определяется в орбитальной подвижной системе координат \(Ox_oy_oz_o\), связанной с центром масс станции. Ось \(Ox_o\) направлена по направлению  радиус вектора станции относительно центра Земли (\(\vec r\)), ось \(Oy_o\)  лежит в плоскости орбиты станции и направлена в направлении орбитального движения, ось \(Oz_o\) дополняет систему координат \(Ox_oy_oz_o\) до правой.</p>

<p><img src="/assets/img/mechanics-in-space/relative-orbital.svg" alt="" /></p>

<h2 id="нелинейные-уравнения-для-эллиптической-орбиты-станции">Нелинейные уравнения для эллиптической орбиты станции</h2>

<p>Нелинейные уравнения движения КА относительно станции при движении станции по эллиптической орбите имеют следующий вид:</p>

\[\left\{
\begin{aligned}
&amp; \ddot x - 2 \dot{\vartheta} \dot y - \ddot{\vartheta} y - \dot{\vartheta}^2 x = - \frac{\mu(r+x)}{[(r+x)^2+y^2+z^2]^{3/2}} + \frac{\mu}{r^2} \\
&amp; \ddot y + \dot{\vartheta} \dot x + \ddot{\vartheta} x - \dot{\vartheta}^2 y = - \frac{\mu y}{[(r+x)^2+y^2+z^2]^{3/2}}\\
&amp; \ddot z = - \frac{\mu z}{[(r+x)^2+y^2+z^2]^{3/2}}
\end{aligned}
\right.\]

<p>где \(x, y, z\) – координаты КА относительно станции (проекции вектора \(\rho\) на оси орбитальной подвижной системы координат станции), \(\mu\) – гравитационный параметр Земли. Угол истинной аномалии станции \(\dot \vartheta\) и расстояние от станции до центра Земли \(r\), определяются дифференциальными уравнениями движения станции по эллиптической орбите:</p>

\[\ddot \vartheta = -\frac{2 \dot r \dot \vartheta}{r}, \quad \ddot{r} = r \dot{\vartheta}^2 - \frac{\mu}{r^2}.\]

<p>Функция правых частей на языке MATLAB</p>

<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">nonlinear_relative_orbital</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
    <span class="n">r</span>       <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>     <span class="c1">% расстояние до притягивающего центра</span>
    <span class="n">theta</span>   <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>     <span class="c1">% угол истинной аномалии станции</span>
    <span class="n">rho</span>     <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">);</span>   <span class="c1">% относительные координаты</span>
    <span class="n">dr</span>      <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>     <span class="c1">% dr/dt</span>
    <span class="n">dtheta</span>  <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>     <span class="c1">% угловая скорость орбитального движения</span>
    <span class="n">v</span>       <span class="o">=</span> <span class="n">q</span><span class="p">(</span><span class="mi">8</span><span class="p">:</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">% относительная скорость</span>
    
    <span class="c1">% Уравнения движения станции</span>
    <span class="n">d2r</span>     <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">dtheta</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="p">/(</span><span class="n">r</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">d2theta</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">dr</span><span class="o">*</span><span class="n">dtheta</span><span class="p">/</span><span class="n">r</span><span class="p">;</span>
    
    <span class="n">rm</span>      <span class="o">=</span> <span class="nb">sqrt</span><span class="p">((</span><span class="n">r</span><span class="o">+</span><span class="n">rho</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">);</span>
    
    <span class="n">d2x</span>     <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="n">rho</span><span class="p">(</span><span class="mi">1</span><span class="p">))/</span><span class="n">rm</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="p">/</span><span class="n">r</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dtheta</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">d2theta</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">dtheta</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">d2y</span>     <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">2</span><span class="p">)/</span><span class="n">rm</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">dtheta</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">d2theta</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">dtheta</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">d2z</span>     <span class="o">=</span> <span class="o">-</span><span class="n">p</span><span class="o">.</span><span class="n">mu</span><span class="o">*</span><span class="n">rho</span><span class="p">(</span><span class="mi">3</span><span class="p">)/</span><span class="n">rm</span><span class="o">^</span><span class="mi">3</span><span class="p">;</span>
    
    <span class="n">dq</span> <span class="o">=</span> <span class="p">[</span><span class="n">dr</span><span class="p">;</span><span class="n">dtheta</span><span class="p">;</span><span class="n">v</span><span class="p">;</span><span class="n">d2r</span><span class="p">;</span><span class="n">d2theta</span><span class="p">;</span><span class="n">d2x</span><span class="p">;</span><span class="n">d2y</span><span class="p">;</span><span class="n">d2z</span><span class="p">];</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="нелинейные-уравнения-относительного-движения-для-круговой-орбиты-станции">Нелинейные уравнения относительного движения для круговой орбиты станции</h2>

<p>При движении станции по круговой орбите \(\dot{\vartheta} = n_0 = \text{const}, \, \ddot{\vartheta}  = 0, \, r = a_0 = \text{const}\) уравнения упрощаются:</p>

\[\left\{
\begin{aligned}
&amp; \ddot x - 2 n_0 \dot y - n^2_0 x = - \frac{\mu(a_0+x)}{[(a_0+x)^2+y^2+z^2]^{3/2}} + \frac{\mu}{a_0^2} \\
&amp; \ddot y + n_0 \dot x - n^2_0 y = - \frac{\mu y}{[(a_0+x)^2+y^2+z^2]^{3/2}}\\
&amp; \ddot z = - \frac{\mu z}{[(a_0+x)^2+y^2+z^2]^{3/2}}
\end{aligned}
\right.\]

<h2 id="линеаризованные-уравнения-для-круговой-орбиты">Линеаризованные уравнения для круговой орбиты</h2>

<p>Для малого в сравнении с радиусом орбиты расстояния между станцией и КА (\(\rho &lt;&lt; a_0\)) приведенные выше можно линеаризовать и привести к системе линейных дифференциальных уравнений:</p>

\[\left\{
\begin{aligned}
&amp; \ddot x - 2 n_0 \dot y - 3 n^2_0 x = 0, \\
&amp; \ddot y + 2 n_0 \dot x =  0, \\
&amp; \ddot z + n_0^2 z  = 0,
\end{aligned}
\right.\]

<p>которые могут быть проинтегрированный аналитически:</p>

\[\begin{aligned}
&amp; x = x_0 (4 - 3\cos n_0t) + \frac{1}{n_0} \left[ \dot x_0 \sin n_0 t + 2 \dot y_0 (1-\cos n_0t) \right],\\
&amp; y  =  y_0 + \left[ 6x_0+\frac{4\dot y_0}{n_0}\right] \sin n_0 t + \frac{2 \dot x_0}{n}(\cos n_0 t-1) -\left[ 6n_0 x_0+3 \dot y_0\right]t,\\
&amp; z  = \frac{z_0}{n_0} \sin n_0 t + z_0 \cos n_0 t.
\end{aligned}\]

<h3 id="источники-и-ссылки">Источники и ссылки</h3>

<ol>
  <li>Alfriend K.T. et al. Spacecraft formation flying: Dynamics, control and navigation // Spacecraft Formation Flying: Dynamics, control and navigation. 2009.</li>
  <li><a href="/pages/mechanics-in-space/relative-orbital-motion/">Относительное орбитальное движение 1</a>.</li>
  <li><a href="https://classmech.ru/pages/matlab/lab_hill_frame/">Относительное орбитальное движение 2</a></li>
</ol>]]></content><author><name></name></author><category term="mechanics" /><category term="matlab" /><summary type="html"><![CDATA[Система координат Рассматривается движение космического аппарата (КА) относительно орбитальной станции, движущейся по круговой или эллиптической орбите. Положение КА относительно станции определяется в орбитальной подвижной системе координат \(Ox_oy_oz_o\), связанной с центром масс станции. Ось \(Ox_o\) направлена по направлению радиус вектора станции относительно центра Земли (\(\vec r\)), ось \(Oy_o\) лежит в плоскости орбиты станции и направлена в направлении орбитального движения, ось \(Oz_o\) дополняет систему координат \(Ox_oy_oz_o\) до правой. Нелинейные уравнения для эллиптической орбиты станции Нелинейные уравнения движения КА относительно станции при движении станции по эллиптической орбите имеют следующий вид: \[\left\{ \begin{aligned} &amp; \ddot x - 2 \dot{\vartheta} \dot y - \ddot{\vartheta} y - \dot{\vartheta}^2 x = - \frac{\mu(r+x)}{[(r+x)^2+y^2+z^2]^{3/2}} + \frac{\mu}{r^2} \\ &amp; \ddot y + \dot{\vartheta} \dot x + \ddot{\vartheta} x - \dot{\vartheta}^2 y = - \frac{\mu y}{[(r+x)^2+y^2+z^2]^{3/2}}\\ &amp; \ddot z = - \frac{\mu z}{[(r+x)^2+y^2+z^2]^{3/2}} \end{aligned} \right.\] где \(x, y, z\) – координаты КА относительно станции (проекции вектора \(\rho\) на оси орбитальной подвижной системы координат станции), \(\mu\) – гравитационный параметр Земли. Угол истинной аномалии станции \(\dot \vartheta\) и расстояние от станции до центра Земли \(r\), определяются дифференциальными уравнениями движения станции по эллиптической орбите: \[\ddot \vartheta = -\frac{2 \dot r \dot \vartheta}{r}, \quad \ddot{r} = r \dot{\vartheta}^2 - \frac{\mu}{r^2}.\] Функция правых частей на языке MATLAB function dq = nonlinear_relative_orbital(t,q,p) r = q(1); % расстояние до притягивающего центра theta = q(2); % угол истинной аномалии станции rho = q(3:5); % относительные координаты dr = q(6); % dr/dt dtheta = q(7); % угловая скорость орбитального движения v = q(8:10); % относительная скорость % Уравнения движения станции d2r = r*dtheta^2-p.mu/(r^2); d2theta = -2*dr*dtheta/r; rm = sqrt((r+rho(1))^2+rho(2)^2+rho(3)^2); d2x = -p.mu*(r+rho(1))/rm^3 + p.mu/r^2 + 2*dtheta*v(2) + d2theta*rho(2) + dtheta^2*rho(1); d2y = -p.mu*rho(2)/rm^3 - 2*dtheta*v(1) - d2theta*rho(1) + dtheta^2*rho(2); d2z = -p.mu*rho(3)/rm^3; dq = [dr;dtheta;v;d2r;d2theta;d2x;d2y;d2z]; end Нелинейные уравнения относительного движения для круговой орбиты станции При движении станции по круговой орбите \(\dot{\vartheta} = n_0 = \text{const}, \, \ddot{\vartheta} = 0, \, r = a_0 = \text{const}\) уравнения упрощаются: \[\left\{ \begin{aligned} &amp; \ddot x - 2 n_0 \dot y - n^2_0 x = - \frac{\mu(a_0+x)}{[(a_0+x)^2+y^2+z^2]^{3/2}} + \frac{\mu}{a_0^2} \\ &amp; \ddot y + n_0 \dot x - n^2_0 y = - \frac{\mu y}{[(a_0+x)^2+y^2+z^2]^{3/2}}\\ &amp; \ddot z = - \frac{\mu z}{[(a_0+x)^2+y^2+z^2]^{3/2}} \end{aligned} \right.\] Линеаризованные уравнения для круговой орбиты Для малого в сравнении с радиусом орбиты расстояния между станцией и КА (\(\rho &lt;&lt; a_0\)) приведенные выше можно линеаризовать и привести к системе линейных дифференциальных уравнений: \[\left\{ \begin{aligned} &amp; \ddot x - 2 n_0 \dot y - 3 n^2_0 x = 0, \\ &amp; \ddot y + 2 n_0 \dot x = 0, \\ &amp; \ddot z + n_0^2 z = 0, \end{aligned} \right.\] которые могут быть проинтегрированный аналитически: \[\begin{aligned} &amp; x = x_0 (4 - 3\cos n_0t) + \frac{1}{n_0} \left[ \dot x_0 \sin n_0 t + 2 \dot y_0 (1-\cos n_0t) \right],\\ &amp; y = y_0 + \left[ 6x_0+\frac{4\dot y_0}{n_0}\right] \sin n_0 t + \frac{2 \dot x_0}{n}(\cos n_0 t-1) -\left[ 6n_0 x_0+3 \dot y_0\right]t,\\ &amp; z = \frac{z_0}{n_0} \sin n_0 t + z_0 \cos n_0 t. \end{aligned}\] Источники и ссылки Alfriend K.T. et al. Spacecraft formation flying: Dynamics, control and navigation // Spacecraft Formation Flying: Dynamics, control and navigation. 2009. Относительное орбитальное движение 1. Относительное орбитальное движение 2]]></summary></entry></feed>
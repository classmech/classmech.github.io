<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://classmech.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://classmech.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-04-14T04:14:02-05:00</updated><id>https://classmech.github.io/feed.xml</id><title type="html">ClassMech</title><subtitle></subtitle><entry><title type="html">Интегрирование уравнений движения системы с двумя степенями свободы в среде Python</title><link href="https://classmech.github.io/blog/mechanics/cae/2024-04-01-two-dof-python/" rel="alternate" type="text/html" title="Интегрирование уравнений движения системы с двумя степенями свободы в среде Python" /><published>2024-04-01T00:00:00-05:00</published><updated>2024-04-01T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/two-dof-python</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2024-04-01-two-dof-python/"><![CDATA[<p>Круглая пластина может вращаться вокруг оси, проходящей через точку \(О_1\) и перпендикулярной плоскости рисунка. В канале пластины движется шарик М, закреплённый на пружине со свободной длиной \(l_0\). Канал, в котором движется шарик, находится на расстоянии 2h = R от оси вращения.</p>

<p>Рассмотрим два режима движения системы:</p>
<ul>
  <li>движение системы при известном законе движения пластины;</li>
  <li>движение системы как системы с двумя степенями свободы.</li>
</ul>

<h2 id="система-с-одной-степенью-свободы">Система с одной степенью свободы</h2>

<p>В первом случае круглая пластина вращается по известному закону \(\varphi(t)\) и механическая система имеет только одну степень свободы – движение шарика относительно пластины.</p>

<p><img src="/assets/img/blog/two-dof-mech-python-1.png" alt="model.png" /></p>

<h3 id="уравнения-движения">Уравнения движения</h3>

<p>При движении пластины с известной угловой скоростью \(\dot{\varphi}(t) = \omega\) и ускорением \(\varepsilon\) уравнения относительного движения шарика относительно подвижной системы координат \(Oxy\), связанной с пластиной, имеют следующий вид:</p>

\[\left\{
\begin{aligned}
&amp; m \ddot x = G \sin \varphi - P - F_{f} + \Phi_e^n \sin \psi + \Phi_e^\tau \cos \psi \\
&amp; m \ddot y = G \cos \varphi + N_y + \Phi_e^n \cos \psi - \Phi_e^\tau \sin \psi - \Phi_c \\
&amp; m \ddot z = N_z
\end{aligned}
\right.\]

<p>где \(m\) - масса шарика, \(P = c \dot x\) - сила упругости пружины, \(F_f = \text{sign} (V_r) f \sqrt{N_y^2 + N_z^2}\) - сила трения скольжения, \(G  = m g\) - сила веса, \(\Phi_e^n\) - переносная центробежная сила  инерции:</p>

\[\Phi_e^n = m \omega^2 (O_1M) = m \omega^2 \frac{O_1K}{\cos \psi}\]

<p>переносная вращательная сила инерции:</p>

\[\Phi_e^\tau = m \varepsilon (O_1M) = m \varepsilon \frac{O_1K}{\cos \psi}\]

\[AK = \sqrt{R^2 - h^2}, \quad KM = (x + l_0) - AK, \quad \psi = \arctan \frac{KM}{O_1 K}\]

<p>Движение шарика происходит вдоль оси \(x\), поэтому \(y=0\). Из второго уравнения системы выразим реакцию \(N_y\):</p>

\[N_y = \Phi_e^\tau \sin \psi - G \cos \varphi - \Phi_e^n \cos \psi + \Phi_c\]

<p>Дифференциальное уравнение второго порядка, описывающее движения шарика вдоль оси \(Ox\), будет иметь вид:</p>

\[\ddot x = g \sin \varphi - \frac{c}{m} x - \text{sign}(V_r) f (\Phi_e^\tau \sin \psi - G \cos \varphi - \Phi_e^n \cos \psi)\frac{1}{m} + \frac{\Phi_e^n}{m} \sin \psi + \frac{\Phi_e^\tau}{m} \cos \psi = f(x,\dot x, t)\]

<p>Приведём это уравнение к системе дифференциальных уравнений первого порядка:</p>

\[\left\{
\begin{aligned}
&amp; \dot x = V_x \\
&amp; \dot V_x = f(x, V_x, t)
\end{aligned}
\right.\]

<p>Вектор состояния системы в момент времени t определяется координатным столбцом</p>

\[q(t) = \begin{bmatrix} x \\ V_x \end{bmatrix}\]

<p>Дифференциальные уравнения движения в матричной форме:</p>

\[\frac{dq}{dt} = f(q, t)\]

<p>Численно проинтегрируем полученные уравнения.</p>

<h3 id="функция-правых-частей">Функция правых частей</h3>

<p>Для численного интегрирования уравнений движения системы в среде Python необходимо создать функцию правых частей f(q,t). В начале разрабатываемой программы подключаем модуль для работы с массивами (array):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div>

<p>и функцию интегрирования дифференциальных уравнений <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html">solve_ivp</a> из модуля <a href="https://docs.scipy.org/doc/scipy/reference/integrate.html">scipy.integrate</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
</code></pre></div></div>

<p>Для \(\varphi = \omega t\), \(\omega = \text{const}\) функция правых частей дифференциальных уравнений движения имеет вид:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>    
    <span class="n">x</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vx</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Параметры системы
</span>    <span class="n">g</span>   <span class="o">=</span> <span class="mf">9.807</span>   <span class="c1"># ускорение свободного падения
</span>    <span class="n">m</span>   <span class="o">=</span> <span class="mf">0.5</span>     <span class="c1"># масса шарика
</span>    <span class="n">w</span>   <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="c1"># угловая скорость пластины
</span>    <span class="n">c</span>   <span class="o">=</span> <span class="mi">150</span>     <span class="c1"># жёсткость пружины
</span>    <span class="n">L0</span>  <span class="o">=</span> <span class="mf">0.025</span>   <span class="c1"># свободная длина пружины
</span>    <span class="n">R</span>   <span class="o">=</span> <span class="mf">0.1</span>     <span class="c1"># радиус пластины
</span>    <span class="n">phi</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">t</span>     <span class="c1"># Угол поворота пластины    
</span>    <span class="n">f</span>   <span class="o">=</span> <span class="mf">0.0</span>     <span class="c1"># Коэффициент трения
</span>        
    <span class="c1"># Силы реакции 
</span>    <span class="n">Ny</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">vx</span><span class="o">-</span><span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Модуль силы реакции (для вычисления силы трения)
</span>    <span class="n">N</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ny</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Nz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
    
    <span class="c1"># Ускорение шарика
</span>    <span class="n">ax</span>  <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">m</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vx</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="n">m</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
        
    <span class="c1"># аргумент функции - вектор q содержит координату и скорость,
</span>    <span class="c1"># возвращаем производную от q, т.е. скорость и ускорение    
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
</code></pre></div></div>

<p>Аргументы функции: t - время, q - вектор состояния системы для момента времени t. Для системы с одной степенью свободы это координата шарика x и его скорость vx.</p>

<h3 id="интегрирование">Интегрирование</h3>

<p>Численное интегрирование выполняется при помощи функции <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html">solve_ivp</a></p>

<p>Порядковые аргументы функции:</p>
<ol>
  <li>имя функции правой части системы ДУ</li>
  <li>интервал интегрирования от t0 до tN</li>
  <li>массив начальных условий</li>
</ol>

<p>Именованные аргументы:</p>
<ul>
  <li><strong>rtol</strong> - относительная погрешность</li>
  <li><strong>atol</strong> - абсолютная погрешность</li>
</ul>

<p>Ошибка на шаге интегрирования не превышает: atol + rtol * abs(y)</p>

<p>По умолчанию используется метод <a href="https://ru.wikipedia.org/wiki/Метод_Рунге_—_Кутты">Рунге-Кутты</a> с контролем точности и автоматическим выбором шага.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">dqdt</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span>
</code></pre></div></div>

<p>Результат работы функции <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html">solve_ivp</a> - структура <strong>sol</strong> с результатами интегрирования:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    message: The solver successfully reached the end of the integration interval.
    success: True
    status: 0
        t: [ 0.000e+00  1.000e-04 ...  4.992e+00  5.000e+00]
        y: [[ 0.000e+00 -1.215e-08 ...  8.183e-03  1.020e-02]
            [ 0.000e+00 -2.429e-04 ...  2.862e-01  2.480e-01]]
      sol: None
 t_events: None
 y_events: None
     nfev: 1586
     njev: 0
      nlu: 0
</code></pre></div></div>

<p><strong>sol.t</strong> – Массив времени 1xN: первый элемент массива - начальное значение времени t0 последний элемент массива - конечное значение времени интегрирования tN.</p>

<p><strong>sol.y</strong> – таблица значений перемещения sol.y[0] и скорости шарика sol.y[1].</p>

<h3 id="построение-графиков">Построение графиков</h3>

<p>Для построения графиков необходимо подключить библиотеку <a href="https://matplotlib.org/">matplotlib</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<p>Зададим параметры графиков по умолчанию: ширину и высоту графиков в дюймах, размер и тип шрифта</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">"figure.figsize"</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">17</span><span class="o">/</span><span class="mf">2.5</span><span class="p">,</span><span class="mi">10</span><span class="o">/</span><span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">"font.size"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">14</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s">"font.family"</span><span class="p">]</span> <span class="o">=</span> <span class="s">'Arial'</span>
</code></pre></div></div>

<p>Построим график изменения координаты шарика:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'x, м'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>

<p>Графики изменения координаты и скорости шарика можно показать на одном рисунке.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">'k-'</span><span class="p">,</span> <span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">'k--'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'м, м/с'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>

<p>В этом случае необходимо добавить <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html">“легенду”</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'Координата'</span><span class="p">,</span><span class="s">'Скорость'</span><span class="p">));</span>
</code></pre></div></div>
<p>​  <br />
По умолчанию “легенда” располагается на поле графика автоматически. Положение можно указать при помощи строкового параметра <strong>loc</strong>. Возможные значения:</p>
<ul>
  <li>‘best’</li>
  <li>‘upper right’</li>
  <li>‘upper left’</li>
  <li>‘lower left’</li>
  <li>‘lower right’</li>
  <li>‘right’</li>
  <li>‘center left’</li>
  <li>‘center right’</li>
  <li>‘lower center’</li>
  <li>‘upper center’</li>
  <li>‘center’</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'Координата'</span><span class="p">,</span><span class="s">'Скорость'</span><span class="p">),</span> <span class="n">loc</span> <span class="o">=</span> <span class="s">'upper left'</span><span class="p">);</span>
</code></pre></div></div>

<p>В подписях осей и легенде можно использовать LaTeX-разметку для математических символов</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'x, м, $V_x$, м/c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'x'</span><span class="p">,</span><span class="s">'$V_x$'</span><span class="p">));</span>
</code></pre></div></div>

<p>Для сохранения рисунка в графический файл используется функция <strong>savefig</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">"x_Vx.png"</span><span class="p">,</span><span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</code></pre></div></div>

<p>Еще один вариант построения графиков двух функций на одном рисунке, используя две оси y с разным масштабом</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">line1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">'k-'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'x'</span><span class="p">);</span>
<span class="n">ax1</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">ax1</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'x, м'</span><span class="p">);</span>

<span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">.</span><span class="n">twinx</span><span class="p">()</span>
<span class="n">line2</span> <span class="o">=</span> <span class="n">ax2</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">'k--'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'$V_x$'</span><span class="p">)</span>
<span class="n">ax2</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">'$V_x$, м/с'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-x-v-1.png" alt="model.png" /></p>

<h3 id="передача-параметров-в-функцию-правых-частей">Передача параметров в функцию правых частей</h3>

<p>В приведенном выше примере параметры системы были определены в функции правых частей, что не является хорошей практикой программирования. При таком подходе при изменении параметров системы будет необходимо вносить изменения в эту функцию. Для исследования влияния параметров на движение системы удобнее параметры системы задавать вне тела функции правых частей. Для передачи  параметров в функцию правых частей можно использовать объект типа <a href="https://habrahabr.ru/post/330034/">namedtuple</a> из модуля <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple">collections</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c1"># Создаем структуру данных 
</span><span class="n">Parameters</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Parameters'</span><span class="p">,</span> <span class="s">'g, m, w, c, L0, R, f'</span><span class="p">)</span>

<span class="c1"># Создаем набор параметров
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="mf">9.81</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mf">0.025</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
<span class="c1"># или так
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">L0</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># Ещё один набор параметров (с другой жёсткостью пружины)
</span><span class="n">p2</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span> <span class="n">L0</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Следует отметить, что как и классический tuple (кортеж), именованный кортеж не изменяем, т.е. после создания нельзя изменить значение атрибута, это приведет к ошибке.</p>

<p>Перепишем функцию правых частей дифференциальных уравнений, добавив третий аргумент функции – структуру с параметрами системы</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1"># Функция правых частей
</span>    <span class="c1"># t - текущее время
</span>    <span class="c1"># q - вектор состояния системы
</span>    <span class="c1"># p - параметры системы
</span>    <span class="c1"># для системы с одной степенью свободы это координата шарика и его скорость
</span>    <span class="n">x</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные
</span>    <span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">t</span>    <span class="c1"># Угол поворота     
</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">vx</span><span class="o">-</span><span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ny</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Nz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>     
    <span class="c1"># Вычисляем ускорение шарика
</span>    <span class="n">ax</span>  <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">m</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vx</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="n">m</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
   
    <span class="c1"># q содержит координату и скорость,
</span>    <span class="c1"># возвращаем производную от q - скорость и ускорение    
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
</code></pre></div></div>

<p>Поскольку функция численного интегрирования solve_ivp первым аргументом ожидает функцию с двумя параметрами, используем лямбда-функцию двух аргументов, которая будет вызывать новую функцию правых частей с тремя аргументами, передавая в неё структуру с параметрами системы:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sol1</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p1</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span>
</code></pre></div></div>

<p>Решение для второго набора параметров</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sol2</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p2</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">)</span>
</code></pre></div></div>

<p>Сравним два решения:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol1</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol1</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'k-'</span><span class="p">,</span> <span class="n">sol2</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol2</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">'k--'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'c=100 Н/м'</span><span class="p">,</span><span class="s">'c=200 Н/м'</span><span class="p">]);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'x, м'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Влияние жёсткости пружины'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="определение-силы-реакции-при-движении-шарика-в-канале">Определение силы реакции при движении шарика в канале</h3>

<h4 id="вариант-1">Вариант 1.</h4>

<p>Создадим функцию, которая будет вычислять реакцию заданного вектора состояния q и параметров p:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Ny</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1"># t - время
</span>    <span class="c1"># q - массив из двух элементов (x, Vx)
</span>    <span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">R</span>
</code></pre></div></div>

<p>Склеиваем таблицу времени (строку 1xN) с таблицей решения (матрица 2xN), транспонируем результат. В результате этих действий получим матрицу Nx3, каждая строка которой содержит решение для заданного момента времени:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># t0 x(t0) vx(t0)
# t1 x(t1) vx(t1)
# t2 x(t2) vx(t2)
# ...
# tN x(tN) vx(tN)
</span><span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sol1</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol1</span><span class="p">.</span><span class="n">y</span><span class="p">)).</span><span class="n">T</span>
</code></pre></div></div>

<p>Вызываем функцию  Ny(t, q, p) для каждой строки полученной матрицы:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sol1_Ny</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">Ny</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">p1</span><span class="p">),</span> <span class="n">data1</span> <span class="p">))</span>
</code></pre></div></div>

<p>Для второго набора параметров</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sol2</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol2</span><span class="p">.</span><span class="n">y</span><span class="p">)).</span><span class="n">T</span><span class="p">;</span>
<span class="n">sol2_Ny</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">Ny</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">p2</span><span class="p">),</span> <span class="n">data2</span> <span class="p">))</span>
</code></pre></div></div>

<p>Построим графики сил реакции \(N_y\) для двух наборов параметров</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol1</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol1_Ny</span><span class="p">,</span><span class="s">'r-'</span><span class="p">,</span><span class="n">sol2</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol2_Ny</span><span class="p">,</span><span class="s">'b-.'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'$N_y$, Н'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'c=100 Н/м'</span><span class="p">,</span><span class="s">'c=200 Н/м'</span><span class="p">]);</span>
</code></pre></div></div>

<h4 id="вариант-2">Вариант 2.</h4>

<p>Функция, которую можно вызвать сразу для всех значений таблицы решения.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Ny</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1"># t - массив t0, t1, t2, ... tN
</span>    <span class="c1"># q - массив [ [ x(t0), x(t1), x(t2), ..., x(tN) ], [ vx(t0), vx(t1), ..., vx(tN) ] ]    
</span>    <span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol1</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">Ny</span><span class="p">(</span><span class="n">sol1</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol1</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p1</span><span class="p">),</span> <span class="n">sol2</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">Ny</span><span class="p">(</span><span class="n">sol2</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol2</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p2</span><span class="p">));</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'$N_y$, Н'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'c=100 Н/м'</span><span class="p">,</span><span class="s">'c=200 Н/м'</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-c-effect.png" alt="model.png" />
​</p>
<h3 id="аппроксимация-функции-sign-гладкой-функцией">Аппроксимация функции sign гладкой функцией</h3>

<p>Численные методы интегрирования дифференциальных уравнений обычно предполагают гладкость функции правых частей \(f(t,q)\) по своим аргументам. Аппроксимируем функцию sign, которая использовалась для определения направления действия силы трения, гладкой функцией на основе <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BC%D0%BE%D0%B8%D0%B4%D0%B0">сигмоиды</a></p>

\[S(x) = \frac{1}{1+e^{-x}}\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s">'r-'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">'k--'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'S(x)'</span><span class="p">,</span><span class="s">'sign(x)'</span><span class="p">]);</span>
</code></pre></div></div>

<p>“Крутизной” сигмоиды можно управлять при помощи параметра-множителя k перед аргументом x</p>

\[S(x) = 2 \left( \frac{1}{1+e^{-k x}} - \frac{1}{2} \right)\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span> <span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.005</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">10000</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1000</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="s">'k--'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'k=10 000'</span><span class="p">,</span><span class="s">'k=2 000'</span><span class="p">,</span><span class="s">'k=1 000'</span><span class="p">,</span><span class="s">'sign(x)'</span><span class="p">]);</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-sigmoid.png" alt="" /></p>

<p>Перепишем функцию правых частей:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1"># Функция правых частей
</span>    <span class="c1"># t - текущее время
</span>    <span class="c1"># q - вектор состояния системы
</span>    <span class="c1"># p - параметры системы
</span>    <span class="c1"># для системы с одной степенью свободы это координата шарика и его скорость
</span>    <span class="n">x</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные
</span>    <span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">t</span>    <span class="c1"># Угол поворота     
</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">vx</span><span class="o">-</span><span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
    <span class="n">Nz</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ny</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Nz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>     
    <span class="c1"># Вычисляем ускорение шарика
</span>    <span class="n">ax</span>  <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">m</span> <span class="o">-</span> <span class="n">f</span><span class="o">*</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="n">m</span> <span class="o">+</span> <span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">R</span><span class="p">)</span>
   
    <span class="c1"># q содержит координату и скорость,
</span>    <span class="c1"># возвращаем производную от q - скорость и ускорение    
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">vx</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
</code></pre></div></div>

<p>Решение и графики</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p1</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">L0</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p1</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">'BDF'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">'k-'</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">'k--'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'x, м, $V_x$, м/c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'x'</span><span class="p">,</span><span class="s">'$V_x$'</span><span class="p">));</span>
</code></pre></div></div>
<p>​</p>
<h2 id="система-с-двумя-степенями-свободы">Система с двумя степенями свободы</h2>

<p>Во втором рассматриваемом случае механическая системы имеет две степени свободы, при этом движение происходит под действием только потенциальных сил – силы упругости пружины и силы тяжести. Трение при движении шарика внутри канала и при вращении пластины вокруг оси \(O_1\) не учитывается.</p>

<p><img src="/assets/img/blog/two-dof-mech-python-2.png" alt="model.png" /></p>

<p>Уравнения движения запишем в форме уравнений Лагранжа второго рода для угла поворота пластины и координаты шарика относительно пластины:</p>

\[\begin{aligned}
    &amp; \frac{d}{dt} \frac{\partial T}{\partial \dot \varphi} - \frac{\partial T}{\partial \varphi} = - \frac{\partial \Pi}{\partial \varphi} \\
    &amp; \frac{d}{dt} \frac{\partial T}{\partial \dot x} - \frac{\partial T}{\partial x} = - \frac{\partial \Pi}{\partial x}
\end{aligned}\]

<p>Кинетическая энергия системы имеет вид:</p>

\[T = \frac{1}{2} m_2\left(\dot{\varphi}^2 \left(l_0-\frac{\sqrt{3} R}{2}+x\right)^2+\left(\dot x - R \dot{\varphi}\right)^2\right)+\frac{3}{8} m_1 R^2 \dot{\varphi}^2\]

<p>Потенциальная энергия системы:</p>

\[\Pi = \frac{1}{2} \left(c x^2+g m_2 \sin \varphi \left(-2 l_0 + \sqrt{3} R - 2 x\right) - g R (m_1+2 m_2) \cos \varphi\right)\]

<p>Уравнения движения:</p>

\[\left\{
\begin{align}
&amp; \left[ m_2 \left(l_0-\frac{\sqrt{3} R}{2}+x\right)^2+\frac{3 m_1 R^2}{4}+m_2 R^2 \right] \cdot \ddot{\varphi} - m_2 R \cdot \ddot x =  \frac{1}{2} \left(g m_2 \cos \varphi \left(2 l_0-\sqrt{3} R+2 x\right)-g R (m_1+2 m_2) \sin \varphi \right) - 2 m_2 \dot{\varphi} \dot{x} \left(l_0-\frac{\sqrt{3} R}{2}+x\right) \\
&amp; -m_2 R \cdot \ddot \varphi + m_2 \cdot \ddot x = - c x + m_2 g \sin \varphi + m_2 \left( l_0 - \frac{\sqrt{3}}{2}R + x \right) \dot{\varphi}^2
\end{align}
\right.\]

<p>Полученную систему дифференциальных уравнений можно записать в матричной форме</p>

\[\left\{
\begin{aligned}
&amp; a_{11} \cdot \ddot \varphi + a_{12} \cdot \ddot x = b_1 \\
&amp; a_{21} \cdot \ddot \varphi + a_{22} \cdot \ddot x = b_2
\end{aligned}
\right.\]

<p>или</p>

\[\begin{bmatrix} a_{11} &amp; a_{12}  \\ a_{21} &amp; a_{22} \end{bmatrix} \cdot \begin{bmatrix} \ddot \varphi \\ \ddot x \end{bmatrix} = \begin{bmatrix} b_{1} \\ b_{2} \end{bmatrix}\]

<p>где</p>

\[\begin{aligned}
&amp; a_{11} = \left[ m_2 \left(l_0-\frac{\sqrt{3} R}{2}+x\right)^2+\frac{3 m_1 R^2}{4}+m_2 R^2 \right], \quad a_{12} = - m_2 R \\
&amp; a_{21} = -m_2 R, \quad a_{22} = m_2 \\
&amp; b_1 = \frac{1}{2} \left(g m_2 \cos \varphi \left(2 l_0-\sqrt{3} R+2 x\right)-g R (m_1+2 m_2) \sin \varphi \right) - 2 m_2 \dot{\varphi} \dot{x} \left(l_0-\frac{\sqrt{3} R}{2}+x\right) \\
&amp; b_2 = - c x + m_2 g \sin \varphi + m_2 \left( l_0 - \frac{\sqrt{3}}{2}R + x \right) \dot{\varphi}^2
\end{aligned}\]

<p>Дифференциальные уравнения движения системы записаны в форме системы линейных уравнений относительно ускорений. Это систему можно решить аналитически и привести систему уравнений к форме Коши. Однако, для системы с большим числом степеней свободы, аналитическое решение и приведение системы к форме Коши будет громоздким, поэтому удобнее решение системы линейных уравнений проводить численно в функции правых частей.</p>

<h3 id="параметры-системы">Параметры системы</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Создаем структуру данных 
</span><span class="n">Parameters</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Parameters'</span><span class="p">,</span> <span class="s">'g, m1, m2, c, L0, R'</span><span class="p">)</span>

<span class="c1"># Создаем набор параметров
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="mf">9.81</span><span class="p">,</span> <span class="n">m1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">m2</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">L0</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="функция-правых-частей-1">Функция правых частей</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="c1"># Функция правых частей
</span>    <span class="c1"># t - текущее время
</span>    <span class="c1"># q - вектор состояния системы
</span>    <span class="c1"># p - параметры системы
</span>    <span class="c1"># для системы с одной степенью свободы это координата шарика и его скорость    
</span>    <span class="n">phi</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">vx</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="c1"># Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные
</span>    <span class="n">g</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="c1"># Коэффициенты при ускорения в системе линейных уравнений
</span>    <span class="c1"># относительно производных
</span>    <span class="n">a11</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">m1</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">R</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">R</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">a12</span> <span class="o">=</span> <span class="o">-</span><span class="n">m2</span><span class="o">*</span><span class="n">R</span>
    
    <span class="n">a21</span> <span class="o">=</span> <span class="o">-</span><span class="n">m2</span><span class="o">*</span><span class="n">R</span>
    <span class="n">a22</span> <span class="o">=</span>  <span class="n">m2</span>
    
    <span class="c1"># Элементы матрицы правых частей
</span>    <span class="n">b1</span>  <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="p">(</span> <span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">L0</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">vx</span><span class="o">*</span><span class="n">w</span>
    <span class="n">b2</span>  <span class="o">=</span> <span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="n">g</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    
    <span class="c1"># Составляем матрицы системы линейный уравнений относительно вторых производных
</span>    <span class="n">A</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span><span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">],</span> <span class="p">[</span><span class="n">a21</span><span class="p">,</span> <span class="n">a22</span><span class="p">]]</span> <span class="p">)</span>
    <span class="n">B</span>   <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">])</span>

    <span class="c1"># Решаем систему линейных уравнений
</span>    <span class="n">d2q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>   
    
    <span class="c1"># Получаем угловое ускорение 
</span>    <span class="n">d2phi</span> <span class="o">=</span> <span class="n">d2q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># и линейное относительное ускорение шарика
</span>    <span class="n">d2x</span>   <span class="o">=</span> <span class="n">d2q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># q содержит координату и скорость,
</span>    <span class="c1"># возвращаем производную от q - скорость и ускорение    
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">d2phi</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">d2x</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="начальные-условия">Начальные условия</h3>

\[\varphi(0) = 0.2, \quad x(0) = 0, \quad \dot{\varphi}(0) = 0.02, \quad \dot{x}(0) = 0.\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q0</span>  <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="интегрирование-1">Интегрирование</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">q0</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-7</span><span class="p">)</span>
</code></pre></div></div>

<p>График изменения угла поворота пластины</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'k-'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'$</span><span class="se">\\</span><span class="s">varphi$, рад'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-phi.png" alt="" /></p>

<p>График перемещения шарика</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">'k-'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'$x$, м'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-x.png" alt="" /></p>

<p>Проверим корректность построенной модели. Рассматриваемая механическая система с двумя степенями свободы является консервативной: при движении этой системы сумма её потенциальной П и кинетической Т энергий не изменяется.</p>

<h3 id="функция-вычисления-кинетической-энергии-системы">Функция вычисления кинетической энергии системы</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">kinetic_energy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">vx</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>    
    
    <span class="n">g</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    
    <span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">/</span><span class="mf">8.0</span><span class="p">)</span><span class="o">*</span><span class="n">m1</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m2</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">L0</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">vx</span><span class="o">-</span><span class="n">R</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">T</span>
</code></pre></div></div>

<p>График изменения кинетической энергии</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">kinetic_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="s">'k-'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'T, Дж'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>
<p>​</p>
<h3 id="функция-вычисления-потенциальной-энергии-системы">Функция вычисления потенциальной энергии системы</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">potential_energy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span>   <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">vx</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>    
    
    <span class="n">g</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L0</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">L0</span><span class="o">+</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="p">(</span><span class="n">m1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">m2</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">P</span>
</code></pre></div></div>

<p>График изменения потенциальной энергии</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">potential_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="s">'k-'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'П, Дж'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="полная-энергия">Полная энергия</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E</span> <span class="o">=</span> <span class="n">kinetic_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">potential_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">kinetic_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">potential_energy</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span> <span class="n">E</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s">'dotted'</span><span class="p">);</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Энергия, Дж'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">([</span><span class="s">'T'</span><span class="p">,</span><span class="s">'П'</span><span class="p">,</span><span class="s">'T+П'</span><span class="p">]);</span>
</code></pre></div></div>

<p><img src="/assets/img/blog/two-dof-mech-python-TPE.png" alt="" /></p>

<p>График иллюстрирует сохранение полной энергии системы, что свидетельствует о корректности построенной модели механической системы с двумя степенями свободны.</p>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Пример интегрирования в среде Python уравнений движения механической системы с двумя степенями свободы на примере курсовой работы "Исследование движения точки и механической системы" курса теоретической механики Самарского университета]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/two-dof-mech-python.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/two-dof-mech-python.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Модель системы обезвешивания в SimInTech</title><link href="https://classmech.github.io/blog/mechanics/cae/2024-03-09-simintech-ground-test-model/" rel="alternate" type="text/html" title="Модель системы обезвешивания в SimInTech" /><published>2024-03-09T00:00:00-06:00</published><updated>2024-03-09T00:00:00-06:00</updated><id>https://classmech.github.io/blog/mechanics/cae/simintech-ground-test-model</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2024-03-09-simintech-ground-test-model/"><![CDATA[<p>Для подтверждения работоспособности механизмов подвижных элементов конструкций космических аппаратов (раскрываемых солнечных батарей, антенн), средств разделения элементов конструкций ракет-носителей (отработавших ускорителей, створок головных обтекателей, хвостовых отсеков) обычно не ограничиваются только математическим и компьютерным моделированием, а используют и экспериментальные методы. Например, для экспериментальной отработки системы раскрытия солнечных батарей КА строят сложные многозвеньевые механические системы для компенсации действия на створки солнечной батареи сил веса, имитируя, конечно с погрешностями, в земных условия условия невесомости.  Ниже на фото показана подобная система обезвешивания панели солнечной батареи, состоящей из 5 створок. На фото видны тросы, на которых подвешены створки, прикрепленные к подвижным поперечным балкам, которые могут двигаться с небольшим сопротивлением по направляющим.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/solar-array.png" alt="" /></p>

<p class="figcaption">Рисунок 1 - Система обезвешивания створок солнечных батарей КА</p>

<p>Перед разработчиком экспериментальной установки стоит задача выбора параметров системы обезвешивания, например длин и жесткостей тросов, и оценки влияния системы обезвешивания на движение отрабатываемой механической системы, чтобы можно было сопоставить результаты испытаний с ожидаемым (расчётным) движением в условиях полета и сделать вывод об успешности прохождения этапа наземной отработки отрабатываемой системы. Очевидно, что модель движения отрабатываемой системы в условиях наземной отработки является более сложной, чем модель исходной системы.</p>

<h2 id="отделение-переходного-отсека">Отделение переходного отсека</h2>

<p>Рассмотрим для примера модель отделения переходного неразрезного отсека орбитального блока. Схема отделения отсека описана в патенте <a href="https://patents.s3.yandex.net/RU2200117C1_20030310.pdf">“УСТРОЙСТВО ДЛЯ ОТДЕЛЕНИЯ ПЕРЕХОДНОГО ОТСЕКА ОТ КОСМИЧЕСКОГО ОБЪЕКТА (RU 2 200 117 C1)”</a>. Отсек отделяется от орбитального блока без разделения на створки, подобно створкам головного обтекателя ракеты-носителя (поэтому его и “прозвали” неразрезной отсек), а съезжает по роликам, установленным на орбитальном блоке. На самом отсеке установлены направляющие, по которым катятся ролики. Такая схема позволяет снизить массу отсека в сравнении с отсеком разделяемым на створки за счёт исключения из конструкции продольных стыков.</p>

<p>Начальную скорость движения отсека относительно орбитального блока после разделения поперечного стыка отсека с орбитальным блоком обеспечивают пружинные толкатели (рисунок 2).</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/op-otsek.png" alt="" /></p>

<p class="figcaption">Рисунок 2 - Отделяемый переходный отсек орбитального блока</p>

<p>При проведении экспериментальной отработки может быть необходимо подтвердить скорость движения отсека относительно орбитального блока, отсутствие “зацепов” отсека за конструкцию орбитального блока (его макета). Если рассматривать только относительное поступательное движение переходного отсека и орбитального блока, то относительную скорость можно определить из закона об изменении кинетической энергии:</p>

\[\Delta V = V_2 - V_1 = \sqrt{\frac{2A}{m^*}}\]

<p>где \(A\) - суммарная работа толкателей отделения, \(m^*\) - приведенная масса определяемая выражением:</p>

\[m^* = \frac{m_{OB} m_{A}}{m_{OB}+m_A}\]

<p>где \(m_{OB}\) – масса орбитального блока, \(m_A\) – масса отделяемого отсека.</p>

<p>Для наземной отработки процесса отделения неразрезного переходного отсека в книге <a href="https://search.rsl.ru/ru/record/01005108584">“Расчёт и проектирование систем разделения ступеней ракет”</a> рекомендуется использовать вертикальную схему обезвешивания, показанную на рисунке 3.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/eu.jpg" alt="" /></p>

<p class="figcaption">Рисунок 3 - Схема экспериментальной установки (рисунок из книги <a href="https://search.rsl.ru/ru/record/01005108584">“К. С. Колесников, В. В. Кокушкин, С. В. Борзых, Н. В. Панкова Расчёт и проектирование систем разделения ступеней ракет. М.: МГТУ им. Н.Э. Баумана. 2006.”</a>)</p>

<p>Отсек 7 подвешивается в кардановом подвесе при помощи блочно-тросовой системы 2. Вес отсека компенсируется при помощи противовеса 13, масса которого равна массе отсека, массе траверсы 4 и других элементов подвески.</p>

<p>Очевидно, что в этой схеме под действием толкателей отделения 8 после разделения поперечного стыка 9 будет двигаться и отсек и траверса и противовес, т.е. масса минимум в два раза превышающая массу самого отсека, поэтому скорость движения отсека относительно макета орбитального блока 6 (\(\Delta V^{исп}\)) после окончания работы толкателей 8 будет меньше скорости отсека в условиях полета \(\Delta V\):</p>

\[\Delta V^{исп} &lt; \sqrt{\frac{2A}{2 m^*}} = \frac{\Delta V}{\sqrt{2}}\]

<p>Для того чтобы в условиях наземной отработки добиться той же скоростей движения переходного отсека необходимо компенсировать увеличение массы. Для этого используется  дополнительный комплект толкателей противовеса 12 (рисунок 3). Удвоив работу толкателей в системе, можно компенсировать удвоение подвижной массы экспериментальной установки:</p>

\[\Delta V^{исп} = \sqrt{\frac{2\cdot (2 A)}{2 m^*}} = \Delta V\]

<p>Добавление в систему дополнительных толкателей приводит к большему начальному растяжению троса системы обезвешивания. До начала движения отсека трос будет растягиваться весом противовеса 13 и усилием дополнительных толкателей 12. Необходимо проанализировать влияние троса на движение отсека и сравнить это движение с движением в условиях полета.</p>

<p>Для решения это задачи можно использовать среду SimInTech, которая имеет уже готовые блоки библиотеки “Механика” для описания исследуемой системы.</p>

<h2 id="модель-в-simintech">Модель в SimInTech</h2>

<p>Построим упрощенную модель экспериментальной установки, позволяющую проанализировать поступательное движение отсека. Будем учитывать только упругие свойства троса, пренебрегая влиянием на движение отсека его массы. При построении модели также не будет учитываться сопротивление троса при взаимодействии с блоками подвески и влияние самих блоков на движение системы (сопротивление при вращении блоков, их инерционно-массовые характеристики).</p>

<p>В условиях наземной отработки скорость отсека относительно неподвижного макета орбитального блока после окончания работы толкателей отделения будет определяться массой отсека (\(m_A\)) и работой толкателей (обозначим скорость отсека как \(V_A\)):</p>

\[V_A = \sqrt{\frac{2A}{m_A}}\]

<p>Расчётная схема модели приведена на рисунке 4. Справа на рисунке 4 показана эквивалентная схема экспериментальной с учётом принятых допущений. Трос растягивается силами веса отсека (\(G_A\)) и балансировочного груза (\(G_B\)), на отсек действует сила толкателей \(P_A\), на противовес – сила дополнительных толкателей (\(P_B\)).</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/eu-model.png" alt="" /></p>

<p class="figcaption">Рисунок 4 - Схема модели</p>

<p>Схема SimInTech модели показана на рисунке 5 (следует отметить, что по структуре модель подобна модели <a href="/blog/mechanics/cae/2022-11-16-simintech-rsts/">вращающейся тросовой системы</a>). Для сравнения движения отсека в условиях полета и в условиях наземной отработки построены две модели: слева показана модель движения отсека в условиях полета, справа – в условиях наземной отработки. По количеству блоков модель движения отсека в условиях наземной экспериментальной установки в три раза больше.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/model.png" alt="" /></p>

<p class="figcaption">Рисунок 5 - Схема модели в среде SimInTech</p>

<p>Отсек и противовес представлены в виде материальных точек одинаковой массы. В SimInTech эти тела моделируются при помощи блоков “Масса” библиотеки “Механика”. Силы веса, действующие на отсек и противовес, представлены в виде блоков “Источник силы” подраздела “Механические источники”. Силы веса действуют в противоположные стороны (имеют разные знаки), растягивая трос, соединяющий отсек с противовесом.</p>

<p>Толкатель моделируется при помощи блока <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/mekhanika/elementy_postupat_dvizh/4223.html">Нелинейная пружина”</a>. В блоке в табличном виде задается закон изменения суммарной силы толкателей отсека от деформации пружины. При отрицательной деформации (пружина сжата), равной ходу толкателя, сила пружины равна суммарному  начальному усилию толкателей $P_0$, при нулевой деформации сила равна конечному усилию толкателей \(P_K\), при дальнейшем увеличении деформации сила пружины равна нулю (рисунок 6). Работа толкателей для примера подобрана так, чтобы после окончания их работы переходный отсек двигался со скоростью 1 м/с.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/nonlinear-spring.png" alt="" /></p>

<p class="figcaption">Рисунок 6 - Свойства блока “Нелинейная пружина” (модель толкателей отделения переходного отсека)</p>

<p>В новой версии библиотеки “Механика” начальная деформация нелинейной пружины определяется начальным положением тела (“Масса”), поэтому, в параметрах массы, моделирующей отсек, необходимо указать начальное положение (рисунок 7).</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/mass.png" alt="" /></p>

<p class="figcaption">Рисунок 7 - Параметры блока “Масса”, моделирующего переходный отсек</p>

<p>Трос моделируется при помощи блока “Поступательная пружина”. В отличие от Нелинейной пружины, начальная деформация (“Начальное растяжение”) линейной пружины определяется в самом блоке (не вполне понятен различный подход разработчиков к способу определения начальной деформации пружин).</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/tether.png" alt="" /></p>

<p class="figcaption">Рисунок 8 - Свойства блока “Поступательная пружина” (модель троса)</p>

<p>До начала движения трос растянут силой веса переходного отсека и начальным усилием дополнительных толкателей. В этот момент стык переходного отсека с орбитальным блоком еще не раскрылся и удерживается замками, поэтому толкатели отделения отсека не растягивают троса. Предполагается, что в системе обезвешивания используется многожильный трос, эквивалентный по жесткости сплошному стальному тросу диаметром 10 мм и длиной 10 метров – 261.8 кН/м.</p>

<p>Дополнительные толкатели также моделируется при помощи блока “Нелинейная пружина”. Все параметры модели определяются в скрипте инициализации модели:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">initialization</span>
	<span class="c1">// Модуль упругости троса
</span>	<span class="n">YM</span> <span class="p">=</span> <span class="m">200e9</span><span class="p">;</span>
	<span class="c1">// Диаметр троса
</span>	<span class="n">tether_d</span>  <span class="p">=</span> <span class="m">0.010</span><span class="p">;</span>
	<span class="c1">// Длина троса
</span>	<span class="n">tether_l</span>  <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
	<span class="c1">// Площадь поперечного сечения троса
</span>	<span class="n">tether_A</span>  <span class="p">=</span> <span class="n">tether_d</span><span class="p">*</span><span class="n">tether_d</span><span class="p">*</span><span class="n">pi</span><span class="p">/</span><span class="m">4</span><span class="p">;</span>
	<span class="c1">// Жесткость троса
</span>	<span class="n">tether_c</span>  <span class="p">=</span> <span class="n">YM</span><span class="p">*</span><span class="n">tether_A</span><span class="p">/</span><span class="n">tether_l</span><span class="p">;</span>	
	<span class="c1">// Масса переходного отсека
</span>	<span class="n">O_mass</span> <span class="p">=</span> <span class="m">500</span><span class="p">;</span>
	<span class="c1">// Масса противовеса
</span>	<span class="n">B_mass</span> <span class="p">=</span> <span class="m">500</span><span class="p">;</span>
	<span class="c1">// Ускорение силы тяжести
</span>	<span class="n">g</span> <span class="p">=</span> <span class="m">9.807</span><span class="p">;</span>  
	<span class="c1">// Начальное усилие толкателей (суммарное)
</span>	<span class="n">P0</span> <span class="p">=</span> <span class="m">1800</span><span class="p">;</span>
	<span class="c1">// Конечное  усилие толкателей (суммарное)
</span>	<span class="n">PK</span> <span class="p">=</span> <span class="m">700</span><span class="p">;</span>
	<span class="c1">// Ход толкателей
</span>	<span class="n">P_stroke</span> <span class="p">=</span> <span class="m">0.2</span><span class="p">;</span>  			
<span class="k">end</span>
</code></pre></div></div>

<h2 id="результаты-моделирования">Результаты моделирования</h2>

<p>На рисунке 9 показаны графики изменения скорости отсека в условиях полета и в условиях наземной экспериментальной установки без задействования дополнительных толкателей противовеса. В этом случае скорость отсека в условиях наземной отработки в $\sqrt{2}$ меньше скорости отсека в условиях полёта.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/velocity1.png" alt="" /></p>

<p class="figcaption">Рисунок 9 - Скорость отделяемого отсека в условиях полета и в условиях наземной отработки (без учёта действия толкателей противовеса)</p>

<p>На рисунке 10 показаны графики изменения скорости отсека в условиях полета и в условиях наземной экспериментальной установки при задействовании дополнительных толкателей. Рисунок иллюстрирует заметное влияние упругих свойств троса на скорость отсека: амплитуда колебаний скорости отсека после окончания работы толкателей составляет около 0,05 м/с (5 % от конечной скорости отсека). Результаты моделирования также показывают, что в течение 0,04 с после разделения стыка переходный отсек в условиях испытаний движется быстрее чем в реальных условиях за счёт начального растяжения троса, вызванного действием дополнительных толкателей противовеса.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/velocity2.png" alt="" /></p>

<p class="figcaption">Рисунок 10 - Скорость отделяемого отсека в условиях полета и в условиях наземной отработки (с учётом действия толкателей противовеса)</p>

<p>На рисунке 11 показан график изменения силы толкателей, действующей на переходный отсек. Продолжительность работы толкателей переходного отсека составляет около 0.35 с.</p>

<p><img src="/assets/img/blog/simintech-ground-test-model/pusher-force.png" alt="" /></p>

<p class="figcaption">Рисунок 11 - Суммарная сила толкателей, действующая на переходный отсек</p>

<p>Построенная простейшая модель движения отделяемого переходного отсека в условиях наземной экспериментальной отработки позволяет оценить влияние упругих свойств троса на движение отсека.</p>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Модель в среде SimInTech наземной экспериментальной установки для отработки процесса отделения переходного отсека от орбитального блока.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/simintech-ground-test-model/slide.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/simintech-ground-test-model/slide.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Раскрытие посадочной опоры многоразовой ступени РН Falcon-9</title><link href="https://classmech.github.io/blog/mechanics/cae/2023-12-07-leg-open/" rel="alternate" type="text/html" title="Раскрытие посадочной опоры многоразовой ступени РН Falcon-9" /><published>2023-12-07T00:00:00-06:00</published><updated>2023-12-07T00:00:00-06:00</updated><id>https://classmech.github.io/blog/mechanics/cae/leg-open</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2023-12-07-leg-open/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#уравнения-движения" id="markdown-toc-уравнения-движения">Уравнения движения</a>    <ul>
      <li><a href="#кинетическая-энергия-системы" id="markdown-toc-кинетическая-энергия-системы">Кинетическая энергия системы</a></li>
      <li><a href="#обобщенная-сила" id="markdown-toc-обобщенная-сила">Обобщенная сила</a></li>
      <li><a href="#уравнение-движения" id="markdown-toc-уравнение-движения">Уравнение движения</a></li>
    </ul>
  </li>
  <li><a href="#задание" id="markdown-toc-задание">Задание</a></li>
</ul>

<p>Рассмотрим процесс свободного раскрытия посадочной опоры многоразовой первой ступени РН Falcon-9. Возвращаемая ступень имеет четыре одинаковые посадочные опоры. Опоры раскрываются до касания поверхности земли в процессе работы двигателя торможения. Движение посадочной опоры при раскрытии рассматривается по отношению к корпусу возвращаемой ступени, т.е. по отношению к неинерциальной системе координат движущейся с известным ускорением под действием силы тяги двигателя и силы тяжести. Действие других сил на движение опоры не рассматривается.</p>

<p><img src="/assets/img/blog/landing-gear.jpg" alt="" /></p>

<p class="figcaption">Рисунок 1 - Посадочная опора возвращаемой ступени РН Falcon-9 в раскрытом положении</p>

<p>Посадочную опору представим в виде двух однородных стержней, которые назовем опорный подкос и демпфирующий подкос. Опорный подкос имеет постоянную длину \(OB = l\).  Демпфирующий подкос представляет собой телескопическую конструкцию и его длина \(AB = s\) при раскрытии опоры увеличивается. В первом приближении будем считать, что масса подкоса равномерно распределена по длине. Для анализа процесса раскрытия посадочной опоры используется упрощенная модель, схема которой показана на рисунке 2. Подкос OB представлен однородным стержнем с массой \(m_{OB}=m\), демпфирующий подкос \(AB = s\) представлен однородным стержнем переменной длины AB и массой \(m_{AB}\).</p>

<p><img src="/assets/img/blog/f9-gear-open-1.png" alt="" /></p>

<p class="figcaption">Рисунок 2 - Схема посадочной опоры</p>

<p>В процессе раскрытия опоры возвращаемая ступень движется поступательно с известной вертикальной перегрузкой, определяемой работой двигателя торможения.</p>

<h2 id="уравнения-движения">Уравнения движения</h2>

<p>Для записи уравнений движения посадочной опоры используем формализм Лагранжа. Рассматриваемый механизм имеет одну степень свободы и его положение однозначно определяется углом поворота опорного подкоса относительно корпуса возвращаемой ступени \(\varphi\). Уравнение Лагранжа второго рода имеет вид</p>

\[\frac{d}{dt} \frac{\partial T}{\partial \dot \varphi} - \frac{\partial T}{\partial \varphi} = Q_\varphi\]

<p>где T – кинетическая энергия системы, \(Q_\varphi\) – обобщенная сила.</p>

<h3 id="кинетическая-энергия-системы">Кинетическая энергия системы</h3>

<p>Кинетическая энергия системы \(T\) представляет собой кинетическую энергию движения посадочной опоры относительно корпуса. Эта кинетическая энергия будет складываться из кинетических энергий двух звеньев АВ и ОВ:</p>

\[T = T_{AB} + T_{OB}\]

<p>Как было отмечено выше, подкос OB представлен однородным стержнем с массой \(m_{OB}=m\), а демпфирующий подкос AB представлен однородным стержнем <strong>переменной длины</strong> \(AB=s(t)\) и массой \(m_{AB}\). Кинетическая энергия демпфирующего подкоса определяется с учётом изменения его длины при развороте. Масса демпфирующего подкоса постоянна и равна</p>

\[m_{AB}=k m,\]

<p>где коэффициент k представляет собой отношение массы подкоса АВ к массе подкоса ОВ. Длина s демпфирующего подкоса АВ есть функция угла поворота \(\varphi\), который зависит от времени. Для определения кинетической энергии рассмотрим бесконечно-малый элемент этого стержня, который имеет массу \(dm\). Эту элементарную массу можно представить как произведение погонной массы стержня \(\mu\) на бесконечно-малый участок длины \(dm = \mu ds\) . Погонную массу стержня \(\mu\) определим как отношению его полной массы \(m_{AB}\) к текущей длине, которую обозначим как s:</p>

\[dm = \mu ds=k m/s ds.\]

<p>Элементарная масса \(dm\) совершает сложное движение. Во-первых, она поворачивается, вместе со стержнем вокруг оси А. Назовём эту скорость трансверсальной скоростью \(v_\tau\). Во-вторых, масса \(dm\) движется вдоль стержня вследствие изменения его длины. Это будет радиальная скорость \(v_r\)  (рисунок 3).</p>

<p>Сделаем еще одно допущение о том, что радиальные скорости точек стержня увеличиваются от точки А к точке В линейно от нуля (скорость точки А), до \(V_B= \dot s\). Скорость точки, находящейся на расстоянии \(\xi\) от точки А, будет равна</p>

\[v_r=  \frac{\xi}{s} \dot s\]

<p><img src="/assets/img/blog/f9-gear-open-3.png" alt="" /></p>

<p class="figcaption">Рисунок 3 - К определению кинетической энергии демпфирующего подкоса</p>

<p>Касательная скорость точки также зависит от расстояния до оси вращения А и от угловой скорости вращения стержня АВ:</p>

\[v_\tau = \xi \dot \beta\]

<p>где 	\(\beta\) – угол поворота стержня АВ относительно корпуса. Полная скорость массы \(dm\) определяется выражением:</p>

\[v_{dm}=\sqrt{v_\tau^2+v_r^2}=\sqrt{\frac{ξ^2}{s^2}\dot{s}^2+ξ^2 \dot{\beta}^2}\]

<p>Кинетическую энергию демпфирующего подкоса определим как:</p>

\[T_{AB} = \int_0^s \frac{v_{dm}^2}{2}\frac{km}{s} = \frac{1}{2} \int_0^s (\xi^2 \dot \beta^2 +\frac{\xi^2}{s^2} \dot s^2) \frac{km}{s} d \xi = \frac{1}{6} (s^2 \dot \beta ^2 + \dot s^2 ) m_{AB}.\]

<p>Угол поворота стержня АВ \(\beta\) будет определяться выражением:</p>

\[\cos \beta = \frac{h^2 + s^2 - l^2}{2sh}\]

<p>а длина \(s\) выражением</p>

\[s^2 = l^2 + h^2 - 2 l h \cos \varphi\]

<p>Представим расстояние между шарнирами \(h\) как \(h= \zeta l\), где \(\zeta\) некоторая безразмерная величина \(0 &lt; \zeta &lt; 1\). С учетом этой замены, выражение для угла \(\beta\)  и длины \(s\) примут вид:</p>

\[\cos \beta = \frac{\zeta - \cos \varphi}{\eta}, \quad s = \eta l\]

<p>где \(\eta^2 = 1 + \zeta^2 - 2 \zeta \cos \varphi\)</p>

<p>Продифференцировав последние выражения, получим угловую скорость демпфирующего подкоса и скорость его удлинения</p>

\[\dot \beta = \frac{\eta \cos \varphi-1}{\eta^2} \dot \varphi, \quad \dot s = l \frac{\zeta}{\eta} \dot \varphi \sin \varphi\]

<p>Кинетическая энергия посадочной опоры примет вид:</p>

\[T = \frac{1}{6} (s^2 \dot \beta ^2 + \dot s^2 ) m + \frac{J_{OB} \dot \varphi^2}{2}\]

<p>Подставим в это выражение полученные выше выражения для \(\dot beta\)  ̇и \(\dot s\), получим:</p>

\[T = \frac{1}{6} m_{AB} l^2 \dot \varphi^2 + \frac{J_{OB} \dot \varphi^2}{2}\]

<p>С учетом соотношения масс \(m_{AB}=km\):</p>

\[T = \frac{1}{6} (1+k) m l^2 \dot \varphi^2\]

<h3 id="обобщенная-сила">Обобщенная сила</h3>

<p>Поскольку движение посадочной опоры рассматривается относительно системы координат, связанной с корпусом возвращаемой ступени, которая движется в поле силы тяжести под действием силы тяги двигателя, на посадочные опоры будут действовать переносные силы инерции \(G_{OB}\)  и \(G_{AB}\). При постоянной силе тяги обобщенные силы можно определить, используя выражение для потенциальной энергии посадочной опоры:</p>

\[\Pi = \Pi_{OB}+\Pi_{AB} = m_{OB} g n_x \frac{l_{OB}}{2} \cos \varphi + m_{AB} g n_x \left[ h+\frac{s}{2} \cos (\pi - \beta) \right]\]

<p>где \(n_x\) – перегрузка возвращаемой ступени, вызванная работой двигателя торможения. За нулевой уровень потенциальной энергии принята поперечная плоскость возвращаемой ступени, проходящая через точку О. Для известного выражения потенциальной энергии, обобщенная сила будет определяться выражением:</p>

\[Q_\varphi = - \frac{\partial \Pi}{\partial \varphi} = - \frac{1}{2} g (k+1) l m n_x \sin \varphi\]

<h3 id="уравнение-движения">Уравнение движения</h3>

<p>При принятых допущениях, если движение системы происходит только под действием переносной силы инерции, уравнение движения посадочной работы имеет вид уравнения нелинейного математического маятника и не зависит от масс элементов, а определяется только длиной опорного подкоса и перегрузкой возвращаемой ступени:</p>

\[\ddot \varphi = \frac{3}{2l} g n_x \sin \varphi\]

<p>Это уравнение интегрируется с начальными условиями \(\varphi(0) = 0\), \(\dot{\varphi}(0) = \omega_0\).</p>

<h2 id="задание">Задание</h2>

<ol>
  <li>Определите угловую скорость опорного подкоса при раскрытии посадочной опоры при следующий параметрах посадочной опоры и начальных условиях:
    <ul>
      <li>масса опорного подкоса \(m_{AB} = 250\) кг;</li>
      <li>масса телескопического подкоса \(m_{ОB} = 150\) кг;</li>
      <li>длина опорного подкоса \(l =\) м;</li>
      <li>начальная длина телескопического подкоса \(s_0 =\) м;</li>
      <li>конечный угол поворота опорного подкоса \(\varphi_k = 120^o\);</li>
      <li>начальная угловая скорость подкоса \(\dot \varphi(0) = 10^o/c\) (при \(\varphi_0 = 0\));</li>
      <li>перегрузка \(n_x = 1\).</li>
    </ul>
  </li>
  <li>Определите максимальную силу растяжения телескопического подкоса после раскрытия опоры: считая, что в момент полного раскрытия опоры он имеет жесткость на растяжение \(c = 10^5\) Н/м.</li>
</ol>

<p><img src="/assets/img/blog/f9-gear-open-4.png" alt="" /></p>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Model of the free opening of the landing gear of the Falcon-9 reusable launch vehicle.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/gear-open-image.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/gear-open-image.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Модель контактного взаимодействиях в MSC.ADAMS</title><link href="https://classmech.github.io/blog/mechanics/cae/2023-12-01-adams-friction-model/" rel="alternate" type="text/html" title="Модель контактного взаимодействиях в MSC.ADAMS" /><published>2023-12-01T00:00:00-06:00</published><updated>2023-12-01T00:00:00-06:00</updated><id>https://classmech.github.io/blog/mechanics/cae/adams-friction-model</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2023-12-01-adams-friction-model/"><![CDATA[<p>При контакте двух тел деформация \(\delta\) определяется как длина отрезка \(ab\), соединяющего точки двух поверхностей взаимодействующих тел, которые находятся на минимальном расстоянии от центра масс объема пересечения (общего объема) двух поверхностей \(c\).</p>

<p><img src="/assets/img/mechanics-in-space/pusher-contact.svg" alt="" /></p>

<p class="figcaption">Рисунок 1 - Взаимодействие двух твердых тел</p>

<h3 id="сила-реакции">Сила реакции</h3>

<p>Контактная сила (сила реакции) направлена вдоль отрезка \(ab\). Ее модуль (при \(\delta &gt; 0\)) определяется выражением:</p>

\[R = c \cdot \delta^k + S(\delta, 0, 0, \delta_{max}, d) \cdot \dot \delta\]

<p>где \(c\) – коэффициент жесткости контакта, \(k\) – степень, определяющая характер роста силы реакции в зависимости от \(\delta\), \(d\) – коэффициент демпфирования, \(\delta_{max}\) – деформация, при которой демпфирование достигает максимального значения, \(S(\delta, 0, 0, \delta_{max}, d)\) – функция \(\delta\) равная нулю если \(\delta \leq 0\), равная \(d\), если \(\delta \geq \delta_{max}\), и вычисляемая при помощи полинома \(P_3(x)\) третьего порядка на интервале от 0 до \(\delta_{max}\), коэффициенты которого определяются из условий</p>

\[P_3(0) = 0, \quad P'_3(0) = 0, \quad P_3(\delta_{max}) = d, \quad P'_3(\delta_{max}) = 0\]

<p>где \(P'_3\) – первая производная полинома по своему аргументу. В общем виде функция \(S(x,x_{min},y_{min},x_{max},y_{max})\) равна \(y_{min}\), если \(x&lt;x_{min}\), равна \(y_{max}\), если \(x&gt;x_{max}\), и “плавно” переходит (при помощи полинома третьего порядка) от \(y_{min}\) к \(y_{max}\) при изменении \(x\) от \(x_{min}\) к \(x_{max}\) (рисунок 2).</p>

<p><img src="/assets/img/mechanics-in-space/step-function.svg" alt="" /></p>

<p class="figcaption">Рисунок 2 - Функция \(S(x,x_{min},y_{min},x_{max},y_{max})\)</p>

<h3 id="сила-трения">Сила трения</h3>

<p>При контактном взаимодействии используется упрощенная модель трения. Сила трения зависит от относительной скорости скольжения двух тел \(V_{12}\) и величины реакции \(R\):</p>

\[F = \mu(V_{12}) R\]

<p>где функция \(\mu(V_{12})\) (рисунок 2) имеет вид</p>

\[\mu(V_{12}) = 
\begin{cases}
\mu_d &amp; V_{12} \leq -v_d \\
S(V_{12},-v_d,\mu_d,-v_s,\mu_s) &amp; -v_d &lt; V_{12} &lt; -v_s \\
S(V_{12},-v_s,\mu_s,v_s,-\mu_s) &amp; -v_s \leq V_{12} \leq v_s \\
S(V_{12},v_s,-\mu_s,v_d,-\mu_d) &amp; v_s &lt; V_{12} &lt; -v_d \\
-\mu_d &amp; V_{12} \geq v_d \\
\end{cases}\]

<p>где \(\mu_s\) – коэффициент трения покоя, \(\mu_d\) – коэффициент трения скольжения.</p>

<p><img src="/assets/img/mechanics-in-space/adams-mu-friction.svg" alt="" /></p>

<p class="figcaption">Рисунок 3 - Зависимость коэффициента трения от скорости относительного скольжения взаимодействующих тел \(\mu(V_{12})\)</p>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Алгоритм вычисления силы реакции и силы трения в MSC.ADAMS при контактном взаимодействии двух тел]]></summary></entry><entry><title type="html">Модель посадки КА на Луну</title><link href="https://classmech.github.io/blog/mechanics/cae/python/2023-11-03-moon-lander/" rel="alternate" type="text/html" title="Модель посадки КА на Луну" /><published>2023-11-03T00:00:00-05:00</published><updated>2023-11-03T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/python/moon-lander</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/python/2023-11-03-moon-lander/"><![CDATA[<p><a href="/pages/mechanics-in-space/moon-lander/">Посадка на Луну</a></p>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><category term="python" /><summary type="html"><![CDATA[Пример моделирования посадки КА на поверхность Луны в среде Python.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/mechanics-in-space/moon-lander.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/mechanics-in-space/moon-lander.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Модель отделения головного обтекателя ракеты-носителя в SimInTech</title><link href="https://classmech.github.io/blog/mechanics/cae/2023-09-08-fairing-pneumatic/" rel="alternate" type="text/html" title="Модель отделения головного обтекателя ракеты-носителя в SimInTech" /><published>2023-09-08T00:00:00-05:00</published><updated>2023-09-08T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/fairing-pneumatic</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2023-09-08-fairing-pneumatic/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#математическая-модель" id="markdown-toc-математическая-модель">Математическая модель</a>    <ul>
      <li><a href="#уравнения-движения" id="markdown-toc-уравнения-движения">Уравнения движения</a>        <ul>
          <li><a href="#принятые-допущения" id="markdown-toc-принятые-допущения">Принятые допущения</a></li>
          <li><a href="#кинематические-соотношения" id="markdown-toc-кинематические-соотношения">Кинематические соотношения</a></li>
          <li><a href="#силы-и-моменты" id="markdown-toc-силы-и-моменты">Силы и моменты</a></li>
          <li><a href="#уравнение-движения" id="markdown-toc-уравнение-движения">Уравнение движения</a>            <ul>
              <li><a href="#первый-этап-движения" id="markdown-toc-первый-этап-движения">Первый этап движения</a></li>
              <li><a href="#второй-этап-движения" id="markdown-toc-второй-этап-движения">Второй этап движения</a></li>
            </ul>
          </li>
          <li><a href="#изменение-давления-в-полости-толкателя" id="markdown-toc-изменение-давления-в-полости-толкателя">Изменение давления в полости толкателя</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#модель-simintech" id="markdown-toc-модель-simintech">Модель SimInTech</a>    <ul>
      <li><a href="#база-данных-сигналов" id="markdown-toc-база-данных-сигналов">База данных сигналов</a></li>
      <li><a href="#проект-пневмосистема" id="markdown-toc-проект-пневмосистема">Проект “Пневмосистема”</a></li>
      <li><a href="#проект-створка-го" id="markdown-toc-проект-створка-го">Проект “Створка ГО”</a></li>
    </ul>
  </li>
  <li><a href="#результаты-моделирования" id="markdown-toc-результаты-моделирования">Результаты моделирования</a></li>
  <li><a href="#список-источников" id="markdown-toc-список-источников">Список источников</a></li>
</ul>

<p>Головной обтекатель (ГО) – это элемент конструкции ракеты-носителя (РН), предназначенный для защиты полезного груза от внешних тепловых и аэродинамических нагрузок при транспортировке полностью собранной ракеты-носителя или космической головной части к стартовому столу и во время полёта ракеты-носителя в плотных слоях атмосферы. После прохождения плотных слоев производится сброс ГО, поскольку он становится бесполезной массой.</p>

<p>ГО, как правило, собирается из двух половинок - створок, на которые и он разделяется перед отделением. Для отделения створок используется два способа, отличающиеся характером движения створок: отделение с разворотом створок и отделение без разворота створок. В первом случае каждая створка шарнирно связывается с переходным отсеком РН и после разделения ГО на створки выполняется разворот створок при помощи пружинных или пневматических толкателей. После разворота на некоторый заданный угол створки отделяются от РН. Пример схемы узла вращения, освобождающем створку после разворота на заданный угол приведен в патенте [<a href="https://www.elibrary.ru/item.asp?id=37474498">1</a>]).</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/A96rLYqPfik" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p class="figcaption">Рисунок 1 - Отделение створок ГО с разворотом</p>

<p>Во втором случае створки отделяются в поперечном направлении также под действием толкателей, но уже без разворота и движутся почти поступательно относительно РН после разделения. Такая схема используется для отделения створок ГО РН “Falcon-9” [<a href="https://www.youtube.com/watch?v=LtI1V624vWM">2</a>].</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/LtI1V624vWM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<p class="figcaption">Рисунок 2 - Отделение створок ГО без разворота</p>

<p>Здесь рассматривается первый способ отделения ГО с разворотом створок при помощи пневматических толкателей. Модель построена с использованием материалов патента [<a href="https://www.elibrary.ru/item.asp?id=37474498">1</a>] и учебного пособия [<a href="http://repo.ssau.ru/handle/Uchebnye-posobiya/Analiticheskoe-proektirovanie-mehanicheskih-sistem-Elektronnyi-resurs-ucheb-posobie-54489">5</a>].</p>

<p>На рисунке 3 показана схема рассматриваемого ГО, разделяемого на две створки. Створки соединяются друг с другом по продольным стыкам при помощи замков. Это могут быть, например, рычажные замки, соединенные тягами, как показано в патенте [<a href="https://www.elibrary.ru/item.asp?id=37474498">1</a>] или <a href="https://yandex.ru/patents/doc/RU2369534C1_20091010">линейный удлиненный заряд</a>. К переходному отсеку каждая створка также крепится замками поперечного стыка. После прохождения плотных слоев атмосферы система управления подает команду на раскрытие замков и створки под действием толкателей начинают разворачиваться вокруг узлов вращения. Каждая створка разворачивается при помощи двух пневмотолкателей. Один конец каждого толкателя  шарнирно прикрепляется к створке, а штоки упираются в переходный отсек РН, отталкиваясь от него в процессе разворота створки.</p>

<p><img src="/assets/img/fairing/GO-scheme-2.png" alt="" /></p>

<p class="figcaption">Рисунок 3 - Головной обтекатель</p>

<p>На рисунке 4 показана схема пневмосистемы разворота створки, которая состоит из баллона с рабочим телом, например, сжатым воздухом, пневмоклапана (ПК) и двух пневмотолкателей. Перед отделением створки срабатывает пневмоклапан для подготовки пневмосистемы к работе – заполнения рабочих полостей толкателей, чтобы сразу после срабатывания замков крепления створки начали разворот.</p>

<p><img src="/assets/img/fairing/Pneumatic_system.png" alt="" /></p>

<p class="figcaption">Рисунок 4 - Схема пневмосистемы</p>

<p>Предположим, что в нашей модели в момент \(t = 0 + \Delta t_1\) срабатывает пневмоклапан ПК, показанный на рисунке 3. С этого момента начинается наполнение рабочих полостей толкателей, при этом створка остается неподвижной –  замки крепления, соединяющие её с другой створкой и с переходным отсеком, не позволяют створке вращаться.</p>

<p>В момент времени \(t = 0 + \Delta t_2\) производится срабатывание замков крепления и створка под действием пневмотолкателей начинает разворот. Интервал времени \(t_2 - t_1\) необходим для заполнения пневмосистемы. Фактическое время готовности  пневмосистемы для работы после срабатывания пневмоклапана будет определяться объёмом той части пневмосистемы, что находится после пневмоклапана и проходным сечением пневмоклапана.</p>

<h1 id="математическая-модель">Математическая модель</h1>

<p>Для начала запишем математическую модель движения створок. Важно понять, как будет двигаться створка относительно РН, чтобы убедиться, что это движение будет безударным и створка не столкнется с РН. С этой точки зрения удобней  рассматривать движение створок относительно неинерциальной системы координат, связанной с РН, которая движется с некоторым известным ускорением.</p>

<h2 id="уравнения-движения">Уравнения движения</h2>

<h3 id="принятые-допущения">Принятые допущения</h3>

<p>Модель движения створки ГО будет строится с учетом следующих допущений:</p>

<ol>
  <li>Створка – абсолютно-твердое тело постоянного состава.</li>
  <li>Движение створок не оказывает влияния на движение РН.</li>
  <li>РН движется поступательно с постоянной продольной перегрузкой.</li>
  <li>Масса толкателя мала по сравнению с массой створки.</li>
  <li>Процесс в пневмосистеме толкателя разворота створки адиабатный (без обмена энергией с внешней средой).</li>
  <li>Моменты сопротивления в точках (шарнирах) крепления толкателя к створке пренебрежимо малы.</li>
  <li>Трение в узлах вращения створки, соединяющих её с РН, также отсутствует.</li>
  <li>Отделение створок происходит в разреженных слоях атмосферы, поэтому действие аэродинамических сил на движение створки считается малым и не учитывается.</li>
  <li>Рассматривается плоское движение створки.</li>
</ol>

<p>С учетом принятых допущений о плоском движении и абсолютной твердости створки можно упростить модель пневмосистемы, заменив действие двух пневмотолкателей одним с удвоенной площадью штока. Эти допущения позволяют рассматривать движение двух створок независимо друг от друга, т.е. достаточно рассмотреть движение одной створки.</p>

<p>На рисунке 5 показана схема рассматриваемой механической системы. В неинерциальной системе координат движение створки происходит под действием силы толкателей \(\mathbf P\) и переносной силы инерции \(\mathbf G\), определяемой движением РН с некоторой перегрузкой.</p>

<h3 id="кинематические-соотношения">Кинематические соотношения</h3>

<p>Сила, создаваемая толкателем, будет зависеть от перемещения его штока. Перемещение штока определяет объём рабочей полости толкателя. С увеличением этого объёма давление в рабочей полости будет падать, приводя к уменьшению силы. Длину толкателя определим из теоремы косинусов, записанной для треугольника osp (рисунок 5):</p>

\[l_{sp}^2 = l^2 = y_p^2 + \rho_p^2 - 2 y_p \rho_p \cos (\varphi + \psi_p)\]

<p>где \(\rho_p = op\) – расстояние от оси вращения створки до оси вращения шарнира точки крепления толкателя на створке; \(\rho_c = oc\) – расстояние от оси вращения створки до её центра масс. Полученное выражение позволяет найти связь между изменением длины толкателя и изменением угла поворота створки, а также между угловой скоростью створки и скоростью выдвижения штока толкателя. Продифференцировав последнее выражение, получим</p>

\[\dot{l} = y_p \rho_p \frac{\sin(\varphi + \psi_p)}{l} \dot{\varphi}\]

<p><img src="/assets/img/fairing/GO-scheme.png" alt="" /></p>

<p class="figcaption">Рисунок 5 - Схема системы</p>

<p>Запишем уравнение в вариациях:</p>

\[\delta l = y_p \rho_p \frac{\sin(\varphi + \gamma_p)}{l} \delta \varphi\]

<h3 id="силы-и-моменты">Силы и моменты</h3>

<p>Уравнение в вариациях можно использовать для определения момента, создаваемого силой толкателя относительно оси вращения не проводя дополнительных геометрических построений. В соответствии с <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D1%8B%D1%85_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B9">принципом виртуальных перемещений</a></p>

\[\delta A_p = P \delta l = M_p \delta \varphi,\]

<p>следовательно момент, создаваемый толкателем относительно оси вращения створки будет определяться следующим образом:</p>

\[M_p = \frac{\delta l}{\delta \varphi} P = y_p \rho_p \frac{\sin(\varphi + \gamma_p)}{l} P\]

<p>Момент переносной силы инерции относительно оси вращения определяется как:</p>

\[M_\Phi = (x_c \sin \varphi - y_c \cos \varphi) m g n_x\]

<p>где \(n_x\) – продольная перегрузка РН, \(m\) - масса створки, \(g\) – ускорение свободного падения.</p>

<h3 id="уравнение-движения">Уравнение движения</h3>

<p>Движение створки при отделении можно разделить на два этапа: этап разворота створки и этап свободного движения относительно РН после потери механической связи створки с переходным отсеком.</p>

<h4 id="первый-этап-движения">Первый этап движения</h4>

<p>Движение створки относительно РН на этапе вращения описывается одним дифференциальным уравнением:</p>

\[J_o \ddot{\varphi} = M_p + M_\Phi\]

<p>где \(J_o\) – момент инерции створки относительно оси вращения. При известном поперечном моменте инерции створки относительно оси, проходящей через центр масс, момент инерции относительно оси, проходящей через ось вращения створки может быть определен по <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%93%D1%8E%D0%B9%D0%B3%D0%B5%D0%BD%D1%81%D0%B0_%E2%80%94_%D0%A8%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0">теореме Штейнера</a></p>

\[J_o = J_c + m (x_c+y_c)^2 = J_c + m \rho_c^2\]

<p>Подставляя выражения для моментов сил, получим:</p>

\[J_o \ddot{\varphi} = y_p \rho_p \frac{\sin(\varphi + \gamma_p)}{l} P + (x_c \sin \varphi - y_c \cos \varphi) m g n_x\]

<h4 id="второй-этап-движения">Второй этап движения</h4>

<p>После того, как створка достигнет угла отделения (угол потери связи) её <strong>относительное движение</strong>, т.е. движение по отношению к РН, будет равноускоренным вдоль продольной оси РН (x), равномерным вдоль поперечной оси (y) и также равномерным будет вращение створки вокруг центра масс:</p>

\[x = x_k + V_{xk} t + \frac{n_x g t^2}{2}, \quad y = y_k + V_{yk} t, \quad \varphi = \varphi_{k} + \omega_k t\]

<p>где \(x_k\), \(y_k\) – координаты центра масс створки на момент потери механической связи в шарнире, \(V_{xk}\), \(V_{yk}\) – скорости центра масс на момент потери механической связи, \(\varphi_{k}\), \(\omega_k\) – угол и угловая скорость створки на момент потери механической связи.</p>

<h3 id="изменение-давления-в-полости-толкателя">Изменение давления в полости толкателя</h3>

<p>Для записи дифференциального уравнения изменения давления в рабочей полости толкателя можно воспользоваться готовыми “рецептами”, например, из справочника <a href="https://lib-bkm.ru/load/23-1-0-432">Герц Е.В., Крейнин Г.В. “Расчет пневмоприводов” (1975)</a>.</p>

<p>Мы же воспользуемся возможностями системы <a href="https://simintech.ru/">SimInTech</a> и построим модель пневмосистемы, используя блоки из разделов “Пневмомашины и пневмоавтоматика” и “Механика” для построения модели пневмосистемы.</p>

<h1 id="модель-simintech">Модель SimInTech</h1>

<p>Модель в <a href="https://simintech.ru/">SimInTech</a> построим с использованием пакета проектов: построим отдельную модель пневмосистемы и модель движения створки, которые объединим в рамках одного <a href="https://help.simintech.ru/?q=/4_nachalo_raboty/sozdanie_kompleksnoj_modeli/teplogidravlicheskaya_model/vvedenie_v_sredy_part_1/kompleksnaya_model/DAT_sozdanie_paketa.html">пакета проектов</a>. Обмениваться данными модели будут при помощи общей <a href="https://help.simintech.ru/?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">базы данных сигналов</a>. Структура комплексной модели или пакета показана на рисунке 6.</p>

<p><img src="/assets/img/fairing/simintech-packet-structure.png" alt="" /></p>

<p class="figcaption">Рисунок 6 - Схема проекта “Пневмосистема”</p>

<p>Модель пневмосистемы, “зная” положение штока пневмотолкателя и его скорость будет определять силу, которую создает толкатель. Модель створки, получив значение силы, будет определять кинематические параметры створки и вычислять перемещение и скорость штока, которые определяются положением и угловой скоростью створки.</p>

<p>На рисунке 7 показан пакет проектов “Отделение_ГО.pak”, который включает в свой состав проекты “Пневмосистема.prt” и “Створка_ГО.prt”.</p>

<p><img src="/assets/img/fairing/simintech-packet.png" alt="" /></p>

<p class="figcaption">Рисунок 7 - Схема проекта “Пневмосистема”</p>

<h2 id="база-данных-сигналов">База данных сигналов</h2>

<p>На рисунке 8 показана <a href="https://help.simintech.ru/index.html?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">база сигналов</a>.</p>

<p><img src="/assets/img/fairing/simintech-signals.png" alt="" /></p>

<p class="figcaption">Рисунок 8 - Схема проекта “Пневмосистема”</p>

<p><a href="https://help.simintech.ru/index.html?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">Сигналы</a> разделены на три категории:</p>
<ul>
  <li>Пневмосистема</li>
  <li>Тела</li>
  <li>Команды</li>
</ul>

<p class="note">Описываемая структура сигналов не является единственно возможной. Структура была создана в процесса изучения SimInTech и вряд ли лишена недостатков.</p>

<p>В первой категории собраны <a href="https://help.simintech.ru/index.html?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">сигналы</a>, связанные с работой пневмосистемы. В этой категории три группы сигналов</p>
<ul>
  <li>FAIRING_VALVE</li>
  <li>FAIRING_PN</li>
  <li>FAIRING_PUSHER</li>
</ul>

<p>В группе FAIRING_VALVE только один сигнал, управляющий состоянием пневмоклапана 1-открыт, 0-закрыт.</p>

<p>В группе FAIRING_PN собраны сигналы, характеризующие состояние пневмосистемы:</p>
<ul>
  <li>FAIRING_PN_PRESSURE_PUSHER - давление в рабочей полости пневмотолкателя,</li>
  <li>FAIRING_PN_PRESSURE_TANK - давление в баллоне пневмосистемы.</li>
</ul>

<p>В группе FAIRING_PUSHER собраны сигналы, характеризующие работу толкателя:</p>
<ul>
  <li>FAIRING_PUSHER_P - сила, создаваемая толкателем,</li>
  <li>FAIRING_PUSHER_STROKE - максимальное перемещение штока толкателя или его “ход” (константа).</li>
  <li>FAIRING_PUSHER_S - фактическое перемещение штока толкателя.</li>
  <li>FAIRING_PUSHER_V - скорость штока толкателя.</li>
</ul>

<p>В категории Тела одна группа сигналов FAIRING c сигналами</p>
<ul>
  <li>FAIRING_PHI - угол поворота створки;</li>
  <li>FAIRING_W - угловая скорость створки.</li>
</ul>

<p>В категории Команды также только одна группа FAIRING_COM c сигналом FAIRING_COM_SEP определяющим начало движения створки – раскрытие замков.</p>

<p>Сигналы связываются с параметрами состояния элементов модели при помощи <a href="https://help.simintech.ru/?q=/9_grafika_i_animaciya/5_animacionnaya_sistema/redaktor_sviazey.html">редактора связей</a>.</p>

<p><img src="/assets/img/fairing/simintech-links.png" alt="" /></p>

<p class="figcaption">Рисунок 9 - Редактор связей</p>

<h2 id="проект-пневмосистема">Проект “Пневмосистема”</h2>

<p>Схема проекта “Пневмосистема” приведена на рисунке 10. Проект состоит из субмодели, которая будет описана далее, на вход которой подаются значения сигналов из общей базы данных проекта: перемещение штока и скорость штока. Также в этом проекте формируется сигнал открытия пневмоклапана, который также подается на вход субмодели. Выходы субмодели (усилие толкателя и состояние пневмоклапана) записываются в <a href="https://help.simintech.ru/index.html?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">базу сигналов проекта</a>.</p>

<p><img src="/assets/img/fairing/Pneumo-1.png" alt="" /></p>

<p class="figcaption">Рисунок 10 - Схема проекта “Пневмосистема”</p>

<p>Субмодель “Пневмосистема” состоит из двух <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/gidro_i_pnevmosistemy/spravka_po_blokam/Polosti/3908.html">полостей постоянного объема</a>, которые имитируют объемы пневмосистемы до и после пневмоклапана, самого пнемоклапана (Пневмоклапан 1), разделяющего две части пневмосистемы, пневмотолкателя и дросселя моделирующего вход в пневмотолкатель (штуцер).</p>

<p>При открытии пневмоклапана ПК1, показанного на рисунке 11, газ из баллона заполняет часть пневмосистемы от ПК1 до рабочей полости пневмотолкателей. Клапан ПК1 открывается при подаче управляющего сигнала с уровнем “1” на вход субмодели “Пневмоклапан (1-открыт, 0-закрыт)”.</p>

<p><img src="/assets/img/fairing/Pneumo-2.png" alt="" /></p>

<p class="figcaption">Рисунок 11 - Схема пневмосистемы</p>

<p>Сила создаваемая толкателем будет определяться давлением в рабочей полости толкателя и положением штока, от которого это давление будет зависеть. Для моделирования толкателя используется блок “ПневмотолкательГПС - Пневмоцилиндр одностороннего действия (базовый)”. Этот блок имеет имеет один двунаправленный порт, по которому передается “скорость” и “сила”. Входом для пневмотолкателя является скорость штока.</p>

<p>В субмодели пневмосистемы реализована логика прекращения работы толкателя. Когда шток толкателя достигнет своего максимального выдвинутого положения действие на створку силы толкателя прекращается. В блоке <a href="https://simintech.ru/">SimInTech</a> в модели пневмотолкателя реализовано ограничение перемещение штока при помощи контактной силы, зависящей от перемещения и скорости штока (модель “упора”): в параметрах толкателя можно задать коэффициент жесткости упора штока и их коэффициент демпфирования.</p>

<p><img src="/assets/img/fairing/pusher-prop.png" alt="" /></p>

<p class="figcaption">Рисунок 12 - Параметры пневмотолкателя</p>

<p>Когда шток достигает своего крайнего  положения и останавливается под действием контактной силы упора на выходной порт толкателя передается и сила, создаваемая давлением в рабочей полости, и контактная сила от взаимодействия с упором. Для того, чтобы эта сила противодействия упора не действовала на створку при помощи блока <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/avtomatika/Substruktury/3014.html">“Двунаправленная шина (выход)”</a> двунаправленный сигнал разделяется на два математических сигнала “F” (сила - выход) и “V” (скорость - вход). Выходной сигнал “Сила” в рассматриваемом случае будет вектором, содержащим значение силы пневмотолкателя, создаваемой давлением и силой воздействия упора на шток толкателя. Из массива этих двух величин при помощи блоков <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/avtomatika/Vektornye/0020.html">Демультиплексор</a> и <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/avtomatika/Vektornye/0019.html">Мультиплексор</a> извлекается сила, создаваемая давлением в рабочей полости. Далее в соответствии со схемой значение силы умножается на значение признака достижения штоком выдвинутого положения. Результат подается на выходной порт “Усилие толкателя”.</p>

<p class="note">Приведенный здесь способ “извлечения” нужного элемента из двунаправленной шины при помощи пары Демультиплексор/Мультиплексора не выглядит  изящным, однако на момент подготовки этой статьи другого менее громоздкого решения автор не нашел.</p>

<p>Когда шток полностью выдвинется, на выходе “Сила толкателя” будет нулевой сигнал (толкатель не совершает работу). Сигнал со входа “Скорость штока” также будет обнуляться (в модели движения створки). В результате после полного выдвижения штока на створку ГО прекратит действие сила толкателя, а сам шток толкателя будет оставаться неподвижным.</p>

<h2 id="проект-створка-го">Проект “Створка ГО”</h2>

<p>Модель движения створки в проекте “Створка ГО” (рисунок 13) считывает из базы сигналов силу, создаваемую толкателем и перемещение его штока. Перемещение штока пневмотолкателя используется для того, чтобы контролировать момент окончания его работы.</p>

<p>Уравнения движения створки интегрируются в блоке типа <a href="https://help.simintech.ru/index.html?q=/13_priemy_raboty/3_razrabotka_blokov/1_sredstvami_simintech/sozdanie_svoego_bloka.html">“Субмодель”</a>. На вход блока подаются значение силы толкателя, перемещение штока толкателя и признак открытия замков крепления створки (1 - замки открыты, 0 - замки закрыты, створка неподвижна). На выходе субмодели формируются скорость штока, угловая скорость створки, угол поворота створки, которые записываются в <a href="https://help.simintech.ru/index.html?q=/8_baza_dannyh_signalov/baza_dannyh_signalov_SDB.html">базу данных сигналов</a>.</p>

<p>В модели также формируется сигнал на открытие замков, удерживающих створку (изменяется состояние сигнала FAIRING_COM_SEP с 0 на 1), после чего начинается ее разворот. Сигнал формируется при помощи блока <a href="https://help.simintech.ru/index.html?q=/10_biblioteki_blokov/avtomatika/Istochniki/0001.html">“Ступенька”</a>.</p>

<p><img src="/assets/img/fairing/Leaf-model-1.png" alt="" /></p>

<p class="figcaption">Рисунок 13 - Схема проекта “Створка_ГО”</p>

<p>Субмодель “Движение створки ГО” состоит из двух основных блоков “Дифференциальное уравнение движения створки” и “Кинематическое уравнения” (рисунок 14).</p>

<p><img src="/assets/img/fairing/Leaf-model-2.png" alt="" /></p>

<p class="figcaption">Рисунок 14 - Модель разворота створки</p>

<p>Блок “Дифференциальное уравнения движения створки” (блока типа “Язык программирования”) содержит следующий код:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Вход:  Угол поворота створки и сила толкателей
</span><span class="n">input</span>  <span class="n">phi</span><span class="p">,</span> <span class="n">pusher_force</span><span class="p">;</span>
<span class="c1">// Выход: Угловое ускорение створки
</span><span class="n">output</span> <span class="n">d2phi</span><span class="p">;</span>

<span class="c1">// Длина толкателя
</span><span class="n">pusher_length</span> <span class="p">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">yp</span><span class="p">^</span><span class="m">2</span><span class="p">+</span><span class="n">rp</span><span class="p">^</span><span class="m">2</span><span class="p">-</span><span class="m">2</span><span class="p">*</span><span class="n">yp</span><span class="p">*</span><span class="n">rp</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">));</span>
<span class="c1">// Момент, создаваемый толкателями относительно оси вращения створки
</span><span class="n">Mp</span> <span class="p">=</span> <span class="n">yp</span><span class="p">*</span><span class="n">rp</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">)*</span><span class="n">pusher_force</span><span class="p">/</span><span class="n">pusher_length</span><span class="p">;</span>
<span class="c1">// Момент от переносной силы инерции
</span><span class="n">Mg</span> <span class="p">=</span> <span class="p">(</span><span class="n">xc</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)-</span><span class="n">yc</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))*</span><span class="n">m</span><span class="p">*</span><span class="m">9.807</span><span class="p">*</span><span class="n">nx</span><span class="p">;</span> 
<span class="c1">// Угловое ускорение створки
</span><span class="n">d2phi</span> <span class="p">=</span> <span class="p">(</span><span class="n">Mp</span><span class="p">+</span><span class="n">Mg</span><span class="p">)/</span><span class="n">Jo</span><span class="p">;</span>		
</code></pre></div></div>

<p>В блоке определяется угловое ускорение створки по углу поворота створки и силы, действующей на створку.</p>

<p>В блоке “Кинематическое уравнение” определяется скорость выдвижения штока. С выхода этого блока сигнал скорости штока перемножается с признаком достижения штоком предельного (выдвинутого) положения. Если шток достиг предельного положения, то на выходной порт “Скорость штока” подается ноль, означающий неподвижность штока (рисунок 14).</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input</span>  <span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span><span class="p">;</span>
<span class="n">output</span> <span class="n">dl</span><span class="p">;</span>

<span class="c1">// Длина
</span><span class="n">pusher_length</span> <span class="p">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">yp</span><span class="p">^</span><span class="m">2</span><span class="p">+</span><span class="n">rp</span><span class="p">^</span><span class="m">2</span><span class="p">-</span><span class="m">2</span><span class="p">*</span><span class="n">yp</span><span class="p">*</span><span class="n">rp</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">));</span>
<span class="c1">// Скорость выдвижения штока
</span><span class="n">dl</span> <span class="p">=</span> <span class="n">yp</span><span class="p">*</span><span class="n">rp</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">)*</span><span class="n">dphi</span><span class="p">/</span><span class="n">pusher_length</span><span class="p">;</span>
</code></pre></div></div>

<p>Интегрирование уравнений движения производится при помощи метода Гира (Gear51).</p>

<p><img src="/assets/img/fairing/simintech-proj-settings.png" alt="" /></p>

<p class="figcaption">Рисунок 15 - Настройки проектов</p>

<h1 id="результаты-моделирования">Результаты моделирования</h1>

<p>Результаты моделирования были экспортированы в текстовый файл при помощи блоков <a href="https://help.simintech.ru/?q=/4_nachalo_raboty/sozdanie_kompleksnoj_modeli/teplogidravlicheskaya_model/vvedenie_v_sredy_part_2/sozdanie_indnvid_algoritma/DAT_sozdanie_individ_algoritma3.html">“Выход алгоритма”</a> и <a href="https://help.simintech.ru/?q=/10_biblioteki_blokov/avtomatika/Vyvod_dannyh/0016.html">“В файл”</a>. Графики построены при помощи библиотеки matplotlib в среде Python.</p>

<p><img src="/assets/img/fairing/simintech-export.png" alt="" /></p>

<p class="figcaption">Рисунок 16 - Экспорт результатов моделирования в текстовый файл</p>

<p>На рисунке 17 показан график изменения давления в рабочей полости толкателя и в баллоне пневмосистемы. После срабатывания пневмоклапана давление в полостях баллона и пневмотолкателя выравниваются (пневмосистема заполняется). После начала движения створки давление в рабочей полости толкателя падет  вследствие увеличения её объема при развороте створки и выдвижения штока.</p>

<p><img src="/assets/img/fairing/simintech-fairing-pressure.png" alt="" /></p>

<p class="figcaption">Рисунок 17 - Модель разворота створки</p>

<p>На рисунках 18 и 19 приведены графики изменения угла поворота створки и ее угловой скорости. На графике изменения угловой скорости створки виден этап движения створки под действием момента, создаваемого пневмотолкателем, и этап движения “по инерции”, когда створка по отношению к РН движется только под действием переносной силы инерции. На втором этапе угловая скорость створки уменьшается до тех пор пока её центр масс не достигнет максимальной высоты над поперечным стыком створки с переходным отсеком. После этого переносная сила инерции будет создавать момент, “помогающий” створке разворачиваться и угловая скорость будет увеличиваться.</p>

<p><img src="/assets/img/fairing/simintech-fairing-angle.png" alt="" /></p>

<p class="figcaption">Рисунок 18 - Угол поворота створки</p>

<p><img src="/assets/img/fairing/simintech-fairing-w.png" alt="" /></p>

<p class="figcaption">Рисунок 19 - Угловая скорость створки</p>

<p>На рисунке 20 показан график перемещения штока пневмотолкателя. График иллюстрирует ограничение перемещения штока толкателя.</p>

<p><img src="/assets/img/fairing/simintech-fairing-s.png" alt="" /></p>

<p class="figcaption">Рисунок 20 - Перемещение штока толкателя</p>

<p>На рисунке 21 приведен график изменения силы толкателя, действующей на створку. После открытия пневмоклапана по мере заполнения полости толкателя рабочим телом сила увеличивается и достигает максимального значения. После начала движения створки сила уменьшается вследствие увеличения объема рабочей полости толкателя и становится равной нулю после того, как шток толкателя выдвинется на максимальное расстояние.</p>

<p><img src="/assets/img/fairing/simintech-fairing-force.png" alt="" /></p>

<p class="figcaption">Рисунок 21 - Сила толкателя, действующая на створку</p>

<h1 id="список-источников">Список источников</h1>

<ol>
  <li><a href="https://www.elibrary.ru/item.asp?id=37474498">Патент № 2424953 C1 Российская Федерация, МПК B64G 1/00, F42B 15/36. Отделяемый крупногабаритный головной обтекатель ракеты-носителя : № 2010125721/11 : заявл. 24.06.2010 : опубл. 27.07.2011 / Н. Е. Гребнев, Г. Е. Круглов, В. Н. Новиков [и др.] ; заявитель Федеральное государственное унитарное предприятие “Государственный научно-производственный ракетно-космический центр “ЦСКБ-Прогресс” (ФГУП “ГНПРКЦ “ЦСКБ-Прогресс”), Российская Федерация, от имени которой выступает Министерство обороны Российской Федерации.</a></li>
  <li><a href="https://www.youtube.com/watch?v=LtI1V624vWM">SpaceX Fairing Separation Test</a></li>
  <li><a href="https://www.youtube.com/watch?time_continue=15&amp;v=A96rLYqPfik&amp;embeds_referring_euri=https%3A%2F%2Fwww.google.com%2F&amp;source_ve_path=MjM4NTE&amp;feature=emb_title">Fairing Separation</a></li>
  <li><a href="https://youtu.be/kxmAW6aGc58?t=51">Technology Insights: Fairing Separation Test</a></li>
  <li><a href="http://repo.ssau.ru/handle/Uchebnye-posobiya/Analiticheskoe-proektirovanie-mehanicheskih-sistem-Elektronnyi-resurs-ucheb-posobie-54489">Круглов, Г. Е. Аналитическое проектирование механических систем [Электронный ресурс] : учеб. пособие / Г. Е. Круглов ; Самар. гос. аэрокосм. ун-т им. С. П. Королева (СГАУ). - Самара, 2000. - on-line</a></li>
</ol>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[SimInTech complex model of the separation process of the fairing leaves of the launch vehicle.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/fairing/fairing-frontpage.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/fairing/fairing-frontpage.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Определение момента сопротивления в шарнире физического маятника</title><link href="https://classmech.github.io/blog/mechanics/python/2023-04-21-friction-torque/" rel="alternate" type="text/html" title="Определение момента сопротивления в шарнире физического маятника" /><published>2023-04-21T00:00:00-05:00</published><updated>2023-04-21T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/python/friction-torque</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/python/2023-04-21-friction-torque/"><![CDATA[<p>Оценка постоянного момента сопротивления в оси вращения физического маятника по продолжительности его колебаний из некоторого начального положения до полной остановки. Численное интегрирование движения физического маятника в среде Python.</p>

<h2 id="постановка-задачи">Постановка задачи</h2>

<p>Рассмотрим движение физического маятника с известной массой \(m\), моментом инерции относительно оси вращения \(J\) и расстоянием от оси вращения до центра масс \(l\). Маятник совершает плоские колебания в вертикальной плоскости. В оси вращения маятника «О» действует малый <strong>постоянный</strong> момент сопротивления \(M\).</p>

<p><img src="/assets/img/blog/pendulum-friction.svg" alt="" /></p>

<p>Предположим, что нам неизвестен момент сопротивления \(M\) и этот момент необходимо определить из эксперимента, оценив продолжительность затухания колебаний маятника при движении и заданного начального положения, определяемого углом \(\varphi_0\).</p>

<h2 id="уравнения-движения">Уравнения движения</h2>

<p>Запишем уравнение малых колебаний маятника:</p>

\[J \ddot{\varphi} = - m g l \varphi - M \text{sgn} (\varphi)\]

<p>Рассмотрим движение маятника в течение половины периода из начального положения \(\varphi = \varphi_0 &lt; 0\) при \(\dot \varphi &gt; 0\). На этом интервале направление действия момента сопротивления не изменяется, поэтому уравнение движения можно записать в следующем виде:</p>

\[\ddot \varphi = -k^2  \varphi - f,\]

<p>где</p>

\[k^2 = \frac{mgl}{J}, \quad f = \frac{M}{J}\]

<p>Решение этого линейного неоднородного уравнения определяется как:</p>

\[\varphi =  \left(\frac{f}{k^2} + \varphi_0\right) \cos ⁡kt - \frac{f}{k^2}\]

<p>Зная период колебаний маятника:</p>

\[T = \frac{2 \pi}{k} = 2 \pi \sqrt{\frac{J}{mgl}},\]

<p>определим угол поворота маятника через половину периода:</p>

\[\varphi(T/2) = \varphi(\pi/k) = - \varphi_0 - 2 \frac{f}{k^2}\]

<p>Учитывая, что в начальный момент \(\varphi_0 &lt; 0\), амплитуда колебаний маятника за половину периода уменьшится на \(\Delta A(T/2)= 2f/k^2\), а за весь период – на \(\Delta A(T) = 4f/k^2\). Средняя скорость уменьшения амплитуды колебаний равна:</p>

\[\frac{\Delta A(T)}{T} = \frac{4f}{k^2 T}\]

<p>Теперь можно оценить продолжительность затухания колебаний маятника:</p>

\[t_d = \frac{\varphi_0}{\Delta A(T)} T = \frac{\varphi_0 k^2}{4f} T = \frac{\sqrt{mglJ}}{2M} \pi \varphi_0\]

<p>Постоянный момент сопротивления \(M\) в шарнире при известной продолжительности затухания колебаний:</p>

\[M = \frac{\sqrt{mglJ}}{2t_d} \pi \varphi_0.\]

<h2 id="численное-интегрирование-и-проверка-формулы">Численное интегрирование и “проверка” формулы</h2>

<p>Численно проинтегрируем в среде <a href="https://scipy.org/">Python</a> уравнение движения нелинейного маятника (без допущения о малости его колебаний) для проверки полученной формулы.</p>

<p>Подключаемые библиотеки:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>

<p>Объявляем гладкую функцию для аппроксимации функции модуля, которая в малой окрестности нуля (“малость” этого интервала зависит от параметра n) плавно изменяется от минус 1 до 1:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'__iter__'</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">xi</span><span class="p">)))</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
</code></pre></div></div>

<p>Функция правых частей дифференциальных уравнений</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>  
    <span class="n">phi</span>  <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dphi</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d2phi</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">g</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">l</span><span class="o">/</span><span class="n">p</span><span class="p">.</span><span class="n">J</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">.</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dphi</span><span class="p">)</span><span class="o">/</span><span class="n">p</span><span class="p">.</span><span class="n">J</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">dphi</span><span class="p">,</span><span class="n">d2phi</span><span class="p">])</span>
</code></pre></div></div>

<p>Объявляем тип на основе <a href="https://docs.python.org/3/library/dataclasses.html">dataclass</a> для хранения параметров системы:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Data</span><span class="p">:</span>
    <span class="c1"># Масса маятника
</span>    <span class="n">m</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="c1"># Расстояние от точки подвески до центра масс (от оси вращения)
</span>    <span class="n">l</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="c1"># Момент инерции маятника относительно оси вращения
</span>    <span class="n">J</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span>  <span class="mi">100</span><span class="o">*</span><span class="mf">0.5</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span>    
    <span class="c1"># Момент сопротивления
</span>    <span class="n">M</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="c1"># Ускорение свободного падения
</span>    <span class="n">g</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">9.807</span>

<span class="c1"># Создаем экземпляр класса Data (объект)
</span><span class="n">p</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
</code></pre></div></div>

<p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html">Численно интегрируем</a> уравнение движения маятника методом <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html#r179348322575-1">Рунге-Кутты</a> с начальным углом отклонения маятника 20 градусов:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q0</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="mi">0</span><span class="p">]</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">:</span> <span class="n">dqdt</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="n">q0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'RK45'</span><span class="p">,</span> <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span>
</code></pre></div></div>

<p>Построим график изменения угла поворота маятника:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">t</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">sol</span><span class="p">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="n">ls</span><span class="o">=</span><span class="s">':'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'t, c'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Угол поворота, градус'</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/files/python/pendulum-phi.svg" alt="" class="lead" width="600" /></p>

<p>Из графика следует, что колебания затухают приблизительно через 11,5 секунд. Оценим момент трения по выведенной ранее формуле:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">g</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">l</span><span class="o">*</span><span class="n">p</span><span class="p">.</span><span class="n">J</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">q0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mf">11.5</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="mf">3.047837910536908</span>
</code></pre></div></div>

<p>Получилось 3.05 Нм. Эта оценка отличается от значения, заданного при интегрировании (3 Нм) менее чем на 2 %.</p>

<h2 id="литература">Литература</h2>

<ol>
  <li>Гладков Сергей Октябринович, Богданова Софья Борисовна <a href="https://cyberleninka.ru/article/n/k-voprosu-ucheta-sily-soprotivleniya-v-sharnirnoy-tochke-krepleniya-fizicheskogo-mayatnika-i-ee-vliyanie-na-dinamiku-dvizheniya">К вопросу учета силы сопротивления в шарнирной точке крепления физического маятника и ее влияние на динамику движения</a> // Известия вузов. ПНД. 2019. №1.</li>
  <li>Mungan C. E., Lipscombe T. C. <a href="https://www.usna.edu/Users/physics/mungan/_files/documents/Publications/EJP34.pdf">Simple pendulum with speed-independent bearing friction</a> //European Journal of Physics. – 2022. – Т. 43. – №. 4. – С. 045001. DOI 10.1088/1361-6404/ac646a.</li>
</ol>]]></content><author><name></name></author><category term="mechanics" /><category term="python" /><summary type="html"><![CDATA[Determining the friction torque in the pivot point of a physical pendulum through measuring the time it takes to swing from an initial angle until it comes to a halt. Implementing numerical methods to simulate the dynamics of a physical pendulum in Python.]]></summary></entry><entry><title type="html">Анализ предметной области и создание таблиц на примере базы данных с информацией о выпускных работах</title><link href="https://classmech.github.io/blog/database/2023-04-15-ddl-sql-example/" rel="alternate" type="text/html" title="Анализ предметной области и создание таблиц на примере базы данных с информацией о выпускных работах" /><published>2023-04-15T00:00:00-05:00</published><updated>2023-04-15T00:00:00-05:00</updated><id>https://classmech.github.io/blog/database/ddl-sql-example</id><content type="html" xml:base="https://classmech.github.io/blog/database/2023-04-15-ddl-sql-example/"><![CDATA[<p><a href="/pages/databases/ddl-example/">Пример создания таблиц базы данных с информацией о выпускных квалификационных работах</a>.</p>]]></content><author><name></name></author><category term="database" /><summary type="html"><![CDATA[Пример создания таблиц базы данных с информацией о выпускных квалификационных работах.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/db/student-vkr-er-1.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/db/student-vkr-er-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Модель движения летающего стенда возвращаемой ступени РН в SimInTech</title><link href="https://classmech.github.io/blog/mechanics/cae/2023-03-17-jump/" rel="alternate" type="text/html" title="Модель движения летающего стенда возвращаемой ступени РН в SimInTech" /><published>2023-03-17T00:00:00-05:00</published><updated>2023-03-17T00:00:00-05:00</updated><id>https://classmech.github.io/blog/mechanics/cae/jump</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2023-03-17-jump/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#схема-системы" id="markdown-toc-схема-системы">Схема системы</a></li>
  <li><a href="#уравнения-движения" id="markdown-toc-уравнения-движения">Уравнения движения</a></li>
  <li><a href="#модель-simintech" id="markdown-toc-модель-simintech">Модель SimInTech</a>    <ul>
      <li><a href="#структура-модели" id="markdown-toc-структура-модели">Структура модели</a></li>
      <li><a href="#субмодель-динамической-модели-ступени" id="markdown-toc-субмодель-динамической-модели-ступени">Субмодель динамической модели ступени</a></li>
      <li><a href="#блок-управления-тягой" id="markdown-toc-блок-управления-тягой">Блок управления тягой</a></li>
      <li><a href="#блок-управления-углом-поворота-сопла" id="markdown-toc-блок-управления-углом-поворота-сопла">Блок управления углом поворота сопла</a></li>
      <li><a href="#блок-задающий-программное-изменение-высоты" id="markdown-toc-блок-задающий-программное-изменение-высоты">Блок, задающий программное изменение высоты</a></li>
      <li><a href="#блок-задающий-программное-изменение-бокового-смещения" id="markdown-toc-блок-задающий-программное-изменение-бокового-смещения">Блок, задающий программное изменение бокового смещения</a></li>
      <li><a href="#скрипт-модели" id="markdown-toc-скрипт-модели">Скрипт модели</a></li>
      <li><a href="#графики" id="markdown-toc-графики">Графики</a></li>
      <li><a href="#зd-визуализация" id="markdown-toc-зd-визуализация">ЗD Визуализация</a></li>
      <li><a href="#результаты" id="markdown-toc-результаты">Результаты</a></li>
    </ul>
  </li>
</ul>

<h1 id="схема-системы">Схема системы</h1>

<p>Схема системы показана на рисунке 1. Движение стенда (далее ступень) рассматривается относительно инерциальной системы координат \(O X_o Y_o\), связанной с землей. Положение ступени определяется координатами центра масс \(x\) (высота), \(y\) и углом наклона ступени \(\theta\) к вертикали.</p>

<p><img src="/assets/img/blog/simintech-jump/simintech-model.png" alt="" /></p>

<p class="figcaption">Рисунок 1 - Схема системы</p>

<p>Движение ступени происходит под действием силы тяжести \(G\), приложенной в центре масс, силы тяги двигателя \(P\), приложенной в точке \(p\), и аэродинамической силы \(F_a\), которая приложена в точке \(a\) (центр давления). Аэродинамическая сила представлена в виде суммы продольной \(X_a\) и поперечной \(Y_a\) составляющих. Направление силы тяги относительно продольной оси ступени определяется углом поворота сопла двигателя \(\gamma_p\).</p>

<h1 id="уравнения-движения">Уравнения движения</h1>

<p>Уравнения движения ступени построены при следующих допущениях:</p>
<ol>
  <li>Рассматривается действие на ступень только поперечной аэродинамической силы \(Y_a\), которая будет определяться горизонтальной скоростью ступени и скоростью ветра.</li>
  <li>Положение точки приложения аэродинамической силы не изменяется относительно корпуса ступени при развороте ступени: \(ba = x_a\) const. Также не изменяется в процессе движения момент инерции ступени и положение её центра масс относительно корпуса (\(bC = = x_c\) const).</li>
  <li>Полет происходит на небольшой высоте, гравитационное ускорение остается постоянным.</li>
  <li>Не учитывается действие на ступень газодинамических сил от струй двигателя, отражающихся от поверхности земли, при движении на небольшой высоте.</li>
  <li>Динамические свойства системы управления тягой двигателя и вектором тяги не учитываются.</li>
</ol>

<p>Вертикальное движение ступени определяется тягой двигателя и силой притяжения Земли. Уравнение вертикального движения имеет вид:</p>

\[m \ddot{x} = P \cos(\theta + \gamma_p) - G + Y_a \sin \theta\]

<p>где \(G = m g\) – вес ступени, \(g\) – ускорение свободного падения, \(m\) – масса ступени, \(P\) – тяга двигателя, \(Y_a\) – аэродинамическая сила:</p>

\[Y_a = S_m C_y \frac{\rho (\dot y - w)^2}{2} \text{sgn}(\dot y - w)\]

<p>где \(S_m\) – характерная площадь ступени (площадь Миделя), к которой отнесен аэродинамический коэффициент поперечной силы  \(C_y\), \(w\) – скорость ветра, \(\dot y\) – горизонтальная скорость ступени, \(\rho\) – плотность воздуха.</p>

<p>Горизонтальное движение ступени описывается уравнением:</p>

\[m \ddot{y} = P \sin(\theta + \gamma_p) - Y_a \cos \theta\]

<p>Уравнение движения ступени вокруг центра масс:</p>

\[J_z \ddot{\theta} = P (x_c-x_p) \sin \gamma_p  - Y_a (x_a-x_c)\]

<p>где \(x_a\) – координата x точки приложения аэродинамической силы в базовой системе координат \(b x_b y_b\) ступени, \(x_p\) – координата x точки приложения силы тяги ступени в базовой системе координат, \(x_c\)  – координата x центра масс ступени в базовой системе координат, \(J_z\) – поперечный момент инерции ступени.</p>

<p>Уравнения движения ступени интегрируются совместно с дифференциальным уравнением изменения массы при расходе топлива:</p>

\[\frac{dm}{dt} = - \frac{P}{I_s}\]

<p>где \(I_s\) – удельный импульс двигателя ступени [м/c].</p>

<h1 id="модель-simintech">Модель SimInTech</h1>

<h2 id="структура-модели">Структура модели</h2>

<p>Модель <a href="https://simintech.ru/">SimInTech</a> состоит из четырех блоков (субмоделей):</p>
<ul>
  <li>блок динамической модели ступени – “Попрыгунчик”;</li>
  <li>блок управления тягой двигателя;</li>
  <li>блок управления углом поворота сопла;</li>
  <li>блок, задающий программное изменение высоты;</li>
  <li>блок, задающий программное изменение бокового смещения ступени.</li>
</ul>

<p><img src="/assets/img/blog/simintech-jump/simintech-jump-1.png" alt="" /></p>

<p class="figcaption">Рисунок 2 - Общий вид модели</p>

<h2 id="субмодель-динамической-модели-ступени">Субмодель динамической модели ступени</h2>

<p>Динамическая модель ступени создана на основе стандартного блока <a href="https://help.simintech.ru/#13_priemy_raboty/3_razrabotka_blokov/1_sredstvami_simintech/sozdanie_svoego_bloka.html">“Субмодель”</a> с дополнительными свойствами (момент инерции, аэродинамический коэффициент, …). В созданной субмодели используется блок <a href="https://help.simintech.ru/#10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">“Язык программирования”</a>, в котором записаны дифференциальные уравнения движения ступени, используя встроенный <a href="https://help.simintech.ru/#11_yazyk_programmirovaniya/KEY_yazik_programmirovania.html">язык программирования SimInTech</a>. Интегрирование уравнений производится при помощи стандартных блоков типа <a href="https://help.simintech.ru/#10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0027.html">“Интегратор”</a>. На вход субмодели подаются сила тяги двигателя \(P\), угол поворота сопла \(\gamma_p\) и скорость горизонтального ветра \(W\). Выходы субмодели: кинематические параметры ступени (положение и скорость центра масс, угол поворота ступени, её угловя скорость).</p>

<p><img src="/assets/img/blog/simintech-jump/simintech-jump-4.png" alt="" /></p>

<p class="figcaption">Рисунок 3 - Структура субмодели “Попрыгунчик”</p>

<p>Для построения графиков и упрощения экспорта результатов моделирования в текстовый файл (таблица значений кинематических параметров) в проекте используются <a href="https://help.simintech.ru/#13_priemy_raboty/1_modelirovanie/signaly_proekta_baza_signalov_vektorizovannyi_blok.html">сигналы</a>.</p>

<p><img src="/assets/img/blog/simintech-jump/signals.png" alt="" /></p>

<p class="figcaption">Рисунок 4 - Сигналы проекта</p>

<p>Значения в базу сигналов записываются с линий связи субмодели “Попрыгунчик”. Сигналы связываются со значениями с линий связи субмодели при помощи <a href="https://help.simintech.ru/#9_grafika_i_animaciya/5_animacionnaya_sistema/redaktor_sviazey.html">редактора связей</a></p>

<p><img src="/assets/img/blog/simintech-jump/link-editor.png" alt="" /></p>

<p class="figcaption">Рисунок 5 - <a href="https://help.simintech.ru/#9_grafika_i_animaciya/5_animacionnaya_sistema/redaktor_sviazey.html">Редактор связей</a></p>

<p>Код блока <a href="https://help.simintech.ru/#10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">“Язык программирования”</a> – дифференциальные уравнения:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Плоская модель движения возвращаемой ступени
// для отработки посадки
// "Попрыгунчик"
// m       - масса
// P       - тяга
// w 	   - горизонтальная скорость ветра
// gamma_p - угол поворота сопла
// dx, dy  - вертикальная и горизонтальная скорость
// theta   - угол наклона ступени
// dtheta  - угловая скорость ступени
// rho     - плотность воздуха
</span>
<span class="n">input</span>  <span class="n">m</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">gamma_P</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">dtheta</span><span class="p">,</span> <span class="n">rho</span><span class="p">;</span>
<span class="n">output</span> <span class="n">d2x</span><span class="p">,</span> <span class="n">d2y</span><span class="p">,</span> <span class="n">d2theta</span><span class="p">,</span> <span class="n">Fa</span><span class="p">;</span>

<span class="c1">// Аэродинамическая сила
</span><span class="n">Fa</span>  <span class="p">=</span> <span class="m">0.5</span><span class="p">*</span><span class="n">rho</span><span class="p">*(</span><span class="n">w</span><span class="p">-</span><span class="n">dy</span><span class="p">)^</span><span class="m">2</span><span class="p">*</span><span class="n">Cy</span><span class="p">*</span><span class="n">Sm</span><span class="p">*</span><span class="n">sign</span><span class="p">(</span><span class="n">w</span><span class="p">-</span><span class="n">dy</span><span class="p">);</span> 
<span class="c1">// Плечо аэродинамической силы
</span><span class="n">ha</span>  <span class="p">=</span> <span class="n">xa</span><span class="p">-</span><span class="n">xc</span><span class="p">;</span> 
<span class="c1">// Плечо силы тяги
</span><span class="n">hp</span>  <span class="p">=</span> <span class="n">xc</span><span class="p">-</span><span class="n">xp</span><span class="p">;</span> 
<span class="c1">// Уравнения
</span><span class="n">d2x</span>     <span class="p">=</span> <span class="p">(</span> <span class="n">p</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">)-</span><span class="n">m</span><span class="p">*</span><span class="n">g</span> <span class="p">+</span> <span class="n">Fa</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="p">)/</span><span class="n">m</span><span class="p">;</span>
<span class="n">d2y</span>     <span class="p">=</span> <span class="p">(</span> <span class="n">p</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">+</span><span class="n">gamma_p</span><span class="p">)-</span><span class="n">Fa</span><span class="p">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="p">)/</span><span class="n">m</span><span class="p">;</span>
<span class="n">d2theta</span> <span class="p">=</span> <span class="p">(-</span><span class="n">p</span><span class="p">*</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma_p</span><span class="p">)*</span><span class="n">hp</span><span class="p">-</span><span class="n">Fa</span><span class="p">*</span><span class="n">ha</span> <span class="p">)/</span><span class="n">Jz</span><span class="p">;</span> 
</code></pre></div></div>

<p>Параметр \(g\) – ускорение свободного падения, объявлена в блоке инициализации модели. Другие параметры,  используемые в скрипте блока (Sm, Cy, xc, xp, xa) определены в свойствах субмодели “Попрыгунчик”:</p>

<p><img src="/assets/img/blog/simintech-jump/model-params.png" alt="" /></p>

<p class="figcaption">Рисунок 6 - Параметры субмодели “Попрыгунчик”</p>

<p>Для того, чтобы добавить эти свойства к субмодели необходимо перевести SimInTech в режим разработчика (Меню “Вид” - “Режим разработчика”), в общих свойствах субмодели указать новое наименование типа блока, теперь это не “стандартная” субмодель, а блок типа “TJumpStage”. Процедура создания блоков на основе субмоделей <a href="https://help.simintech.ru/#13_priemy_raboty/3_razrabotka_blokov/1_sredstvami_simintech/sozdanie_svoego_bloka.html">описана в справочной системе SimInTech</a>.</p>

<h2 id="блок-управления-тягой">Блок управления тягой</h2>

<p>Учитывая, что ступень движется с небольшой вертикальной скоростью, тяга двигателя будет близка к весу ступени \(G\). Используемый в блоке управления тяги <a href="https://ru.wikipedia.org/wiki/ПИД-регулятор">ПД-регулятор</a> вычисляет “добавку” к этому весу. В блоке управления тягой сравнивается фактическая высота ступени \(x\) с программным значением высоты \(x_p\) и на основе этой разницы (ошибки) формируется значение тяги:</p>

\[P = G + k_1 e_x + k_2 \dot e_x\]

<p>где \(e_x = x_p - x\).</p>

<p><img src="/assets/img/blog/simintech-jump/simintech-jump-2.png" alt="" /></p>

<p class="figcaption">Рисунок 7 - Структура блока управления тягой двигателя</p>

<h2 id="блок-управления-углом-поворота-сопла">Блок управления углом поворота сопла</h2>

<p>Горизонтальное движение ступени производится за счет наклона её корпуса. Для наклона корпуса используется момент относительно центра масс, создаваемый тягой двигателя при ненулевом угле поворота сопла \(\gamma_p\). В блоке управления углом поворота сопла при возникновении разницы между программным значением горизонтальной координаты ступени \(y_p\) и фактическим значением \(y\) определяется угол наклона ступени при помощи <a href="https://ru.wikipedia.org/wiki/ПИД-регулятор">ПД-регулятора</a>:</p>

\[\theta_{PD} = k_3 e_y - k_4 \dot e_y, \quad e_y = y_p-y\]

<p>При этом максимальный угол поворота ступени ограничивается некоторым предельным значением \(\theta_{max}\):</p>

\[\theta_p = 
\begin{cases}
\theta_{PD} &amp; |\theta_{PD}| \leq \theta_{max} \\
\theta_{max} &amp; |\theta_{PD}| &gt; \theta_{max}
\end{cases}\]

<p>Полученное значение угла поворота ступени используется как программное значение \(\theta_p\), которое на следующем этапе сравнивается с текущим значением угла \(\theta\). Разница между программным и фактическим значением поступает на вход <a href="https://ru.wikipedia.org/wiki/ПИД-регулятор">ПИД-регулятора</a>, который формирует сигнал угла поворота сопла двигателя. Этот угол также ограничен некоторым предельным значением:</p>

\[\gamma_{PID} = k_5 e_{\theta} + k_6 \dot e_{\theta} + k_7 \int_0^t \dot e_{\theta} d \tau, \quad e_{\theta} = \theta_p-\theta\]

\[\gamma_p = 
\begin{cases}
\gamma_{PID} &amp; |\gamma_{PID}| \leq \gamma_{max} \\
\gamma_{max} &amp; |\gamma_{PID}| &gt; \gamma_{max}
\end{cases}\]

<p>На вход блока управления углом поворота сопла также поступает горизонтальная скорость блока. При превышении горизонтальной скорости некоторого предельного значения программное значение угла наклона ступени становится равным нулю.</p>

<p><img src="/assets/img/blog/simintech-jump/simintech-jump-3.png" alt="" /></p>

<p class="figcaption">Рисунок 8 - Структура блока управления углом поворота сопла</p>

<h2 id="блок-задающий-программное-изменение-высоты">Блок, задающий программное изменение высоты</h2>

<p>Программа управления высотой имеет вид:</p>

\[x_p = \frac{h_{max}}{2} \left[ 1 + \sin \left( \frac{2\pi}{t_k}t+\frac{3 \pi}{2} \right) \right]\]

<p>где \(t_k\) – конечное время, \(h_{max}\) – максимальная высота.</p>

<p><img src="/assets/img/blog/simintech-jump/simintech-jump-5.png" alt="" /></p>

<p class="figcaption">Рисунок 9 - Структура блока, задающего программное значение высоты</p>

<h2 id="блок-задающий-программное-изменение-бокового-смещения">Блок, задающий программное изменение бокового смещения</h2>

<p>Программа управления боковым перемещение ступени определяется выражением:</p>

\[y_p = 
\begin{cases}
0, &amp; t&lt;t_1 \\
\frac{y_k}{2} \left[ \sin( \frac{t-t_1}{t_2-t_1}\pi-\frac{\pi}{2})+1 \right], &amp; t_1 \leq t \leq t_2 \\
0, &amp; t&gt;t_2
\end{cases}\]

<p>где \(t_1 = \Delta t_v\) – продолжительность вертикального участка при взлете ступени, \(t_2\) - t_{k} - \Delta t_v \(начало вертикального участка спуска ступени,\) t_k \(-- конечное время (продолжительность полета),\) y_k $$ – расстояние от точки взлета до точки посадки.</p>

<p>Это программа управления задается в блоке “Язык программирования”:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Горизонтальное перемещение
</span><span class="n">output</span> <span class="n">y_p</span><span class="p">;</span>
<span class="c1">// Начало участка вертикального спуска
</span><span class="n">t2</span> <span class="p">=</span> <span class="n">endtime</span><span class="p">-</span><span class="n">t_vert</span><span class="p">;</span>
<span class="c1">// Горизонтальное перемещение
</span><span class="n">yend</span> <span class="p">=</span> <span class="n">y_end</span><span class="p">;</span>
                          
<span class="c1">// Вертикальный участок
</span><span class="k">if</span> <span class="n">time</span><span class="p">&lt;=</span><span class="n">t_vert</span> <span class="k">then</span> <span class="n">y_p</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="c1">// Участок горизонтального перемещения
</span><span class="k">if</span> <span class="n">time</span><span class="p">&gt;</span><span class="n">t_vert</span> <span class="k">and</span> <span class="n">time</span><span class="p">&lt;=</span><span class="n">t2</span> <span class="k">then</span> <span class="n">y_p</span> <span class="p">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">((</span><span class="n">time</span><span class="p">-</span><span class="n">t_vert</span><span class="p">)*</span><span class="n">pi</span><span class="p">/(</span><span class="n">t2</span><span class="p">-</span><span class="n">t_vert</span><span class="p">)-</span><span class="n">pi</span><span class="p">/</span><span class="m">2</span><span class="p">)*</span><span class="m">0.5</span><span class="p">+</span><span class="m">0.5</span><span class="p">)*</span><span class="n">yend</span><span class="p">;</span>
<span class="k">if</span> <span class="n">time</span><span class="p">&gt;</span><span class="n">t2</span> <span class="k">then</span> <span class="n">y_p</span> <span class="p">=</span> <span class="n">yend</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="скрипт-модели">Скрипт модели</h2>

<p>В скрипте модели объявляются переменные, используемые в коде и свойствах блоков.</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">initialization</span>
	<span class="c1">// Максимальный угол поворота сопла
</span>	<span class="k">var</span> <span class="n">gamma_max</span> <span class="p">=</span> <span class="m">4</span><span class="p">*</span><span class="n">pi</span><span class="p">/</span><span class="m">180</span><span class="p">;</span>
	<span class="c1">// Максимальный угол наклона ступени
</span>	<span class="k">var</span> <span class="n">theta_max</span> <span class="p">=</span> <span class="m">4</span><span class="p">*</span><span class="n">pi</span><span class="p">/</span><span class="m">180</span><span class="p">;</span>
	<span class="c1">// Продолжительность вертикального участка
</span>	<span class="k">var</span> <span class="n">t_vert</span>    <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
	<span class="c1">// Максимальная горизонтальная скорость ступени
</span>	<span class="k">var</span> <span class="n">v_hor_max</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
	<span class="c1">// Горизонтальное перемещение ступени 
</span>	<span class="k">var</span> <span class="n">y_end</span>     <span class="p">=</span> <span class="m">150</span><span class="p">;</span>
	<span class="c1">// Максимальная высота подъема ступени
</span>	<span class="k">var</span> <span class="n">h_max</span>     <span class="p">=</span> <span class="m">50</span><span class="p">;</span> 
<span class="k">end</span>
</code></pre></div></div>

<h2 id="графики">Графики</h2>

<p>Для того, чтобы не загромождать модель блоками типа <a href="https://help.simintech.ru/#10_biblioteki_blokov/avtomatika/Vyvod_dannyh/1001.html">“Временной график”</a> для построения графиков используется <a href="https://help.simintech.ru/#6_interfejs_programmy/skhemnoe_okno/panel_knopok_bystrogo_dostupa/raschet/DAT_knopka_menedzher_dannyh.html">менеджер данных</a>:</p>

<p><img src="/assets/img/blog/simintech-jump/manager.png" alt="" /></p>

<p class="figcaption">Рисунок 10 - Менеджер данных</p>

<h2 id="зd-визуализация">ЗD Визуализация</h2>

<p>Для визуализации движения блока средствами SimInTech используются блоки из раздела <a href="https://help.simintech.ru/index.html#11_yazyk_programmirovaniya/6_funkcii/3_graficheskie_i_sistemnye/DIR_modul_3d_vizualizacii.html">Визуализация 3D</a> – блоки типа “Просмотрщик” и “Объект”. Один из блоков “Объект” отображает ступень, второй – поверхность неподвижной земли.</p>

<p><img src="/assets/img/blog/simintech-jump/res3D.gif" alt="" /></p>

<p class="figcaption">Рисунок 11 - Визуализация 3D - Просмотрщик</p>

<p>Свойства блока “Объект”, используемого для отображения ступени показаны на рисунке 12. Положение объекта задается выражениями, записанными при помощи сигналов x, y и theta.</p>

<p><img src="/assets/img/blog/simintech-jump/object-3D.png" alt="" /></p>

<p class="figcaption">Рисунок 12 - Свойства блока “Объект” для отображения ступени</p>

<h2 id="результаты">Результаты</h2>

<p>Далее приведены результаты моделирования движения ступени. В соответствии с программой полета ступень поднимается на максимальную высоту 50 метров. Посадка ступени производится на расстоянии 150 метров от места взлета. На рисунке 12 показаны графики изменения высоты и горизонтального перемещения ступени.</p>

<p><img src="/assets/img/blog/simintech-jump/xy.png" alt="" /></p>

<p class="figcaption">Рисунок 13 -  Изменение высоты и горизонтального перемещения ступени</p>

<p>На рисунке 13 показаны графики изменения вертикальной и горизонтальной скорости ступени.</p>

<p><img src="/assets/img/blog/simintech-jump/VxVy.png" alt="" /></p>

<p class="figcaption">Рисунок 14 -  Изменение вертикальной и горизонтальной скорости ступени</p>

<p>На рисунке 15 показаны графики изменения угла поворота ступени и угла поворота сопла двигателя. На рисунке можно увидеть реакцию ступени на воздействие горизонтального ветра.</p>

<p><img src="/assets/img/blog/simintech-jump/theta-gamma.png" alt="" /></p>

<p class="figcaption">Рисунок 15 -  Угол наклона ступени и угол поворота сопла</p>

<p>Видеоиллюстрация результата моделирования движения ступени (Blender 3D):</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/tZ2NOIJS1G0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Модель иллюстрирует движение летающего стенда для отработки мягкой посадки первой ступени многоразовой ракеты-носителя. При помощи подобного летающего стенда компания SpaceX начиная с 2012 года отрабатывала технологию посадки возвращаемой ступени РН Falcon-9.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/simintech-jump/title.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/simintech-jump/title.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Эффект Джанибекова в SimInTech</title><link href="https://classmech.github.io/blog/mechanics/cae/2022-12-04-simintech-janibekov/" rel="alternate" type="text/html" title="Эффект Джанибекова в SimInTech" /><published>2022-12-04T00:00:00-06:00</published><updated>2022-12-04T00:00:00-06:00</updated><id>https://classmech.github.io/blog/mechanics/cae/simintech-janibekov</id><content type="html" xml:base="https://classmech.github.io/blog/mechanics/cae/2022-12-04-simintech-janibekov/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#эффект-джанибекова" id="markdown-toc-эффект-джанибекова">Эффект Джанибекова</a></li>
  <li><a href="#анализ-устойчивости" id="markdown-toc-анализ-устойчивости">Анализ устойчивости</a>    <ul>
      <li><a href="#вращение-вокруг-оси-с-максимальным-значением-момента-инерции" id="markdown-toc-вращение-вокруг-оси-с-максимальным-значением-момента-инерции">Вращение вокруг оси с максимальным значением момента инерции</a></li>
      <li><a href="#вращение-вокруг-оси-с-промежуточным-значением-момента-инерции" id="markdown-toc-вращение-вокруг-оси-с-промежуточным-значением-момента-инерции">Вращение вокруг оси с промежуточным значением момента инерции</a></li>
    </ul>
  </li>
  <li><a href="#модель" id="markdown-toc-модель">Модель</a>    <ul>
      <li><a href="#блок-динамических-уравнений" id="markdown-toc-блок-динамических-уравнений">Блок динамических уравнений</a></li>
      <li><a href="#блок-кинематических-уравнений" id="markdown-toc-блок-кинематических-уравнений">Блок кинематических уравнений</a></li>
      <li><a href="#переход-от-углов-последовательности-131-к-углам-последовательности-232" id="markdown-toc-переход-от-углов-последовательности-131-к-углам-последовательности-232">Переход от углов последовательности 131 к углам последовательности 232</a></li>
      <li><a href="#скрипт-модели" id="markdown-toc-скрипт-модели">Скрипт модели</a></li>
    </ul>
  </li>
  <li><a href="#ссылки" id="markdown-toc-ссылки">Ссылки</a></li>
</ul>

<p>Среда динамического моделирования <a href="https://simintech.ru">SimInTech</a> предлагает простой набор функций для визуализации движения моделируемых объектов. В этой статье рассматривается построение модели и визуализации движения гайки-барашка при ее свободном вращении вокруг собственной оси с “промежуточным” моментом инерции. Это движение известно как <a href="https://ru.wikipedia.org/wiki/Эффект_Джанибекова">“Эффект Джанибекова”</a>.</p>

<h2 id="эффект-джанибекова">Эффект Джанибекова</h2>

<p><a href="https://ru.wikipedia.org/wiki/Эффект_Джанибекова">Эффектом Джанибекова</a> называют необычное движение вращающейся вокруг одной из своих осей гайки-барашка, выражающееся в её периодическом быстром перевороте на 180 градусов. Этой яркое явление наблюдал космонавт <a href="https://ru.wikipedia.org/wiki/Джанибеков,_Владимир_Александрович">Владимир Александрович Джанибеков</a> на борту орбитальной стации <a href="https://ru.wikipedia.org/wiki/Салют-7">Салют-7</a> в 1985 году. На рисунке 1 показано движение гайки-барашка, построенное при помощи описываемой далее модели в среде динамического моделирования <a href="https://simintech.ru">SimInTech</a>.</p>

<iframe width="800" height="450" src="https://www.youtube.com/embed/Ha8oHDutwQQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p class="figcaption">Рисунок 1 - Неустойчивое движение гайки-барашка</p>

<p>Вокруг этого явления возникло множество различных безумных теорий, например, встречалось объяснение этого эффекта “на основании философии Дуализма Диалектики Абсолютного Парадокса” (все буквы, конечно, заглавные), однако этот эффект описывается в рамках классической механики. Вращение гайки-барашка вокруг оси с промежуточным или средним моментом инерции, например вокруг собственной оси Y, если значения главных моментов инерции удовлетворяют условиям \(J_z &lt; J_y &lt; J_x\),  является неустойчивым, что и приводит к наблюдаемому перевороту гайки. Некоторой аналогией движения гайки является поведение физического маятника,  выведенного небольшим возмущением из неустойчивого (верхнего) положения равновесия.</p>

<p><img src="/assets/img/blog/jan-simintech-pendulum.gif" alt="" /></p>

<p class="figcaption">Рисунок 2 - Движение физического маятника</p>

<p>Мятник будет совершать размашистые колебания с амплитудой чуть меньше 180 градусов, подходя к точке неустойчивого равновесия то слева то справа, надолго “зависая” в этом положении. Нижнее устойчивое положение маятник будет проходить с большой скоростью. Подобным же образом ведет себя гайка, но гайка, в отличие от маятника, имеет устойчивые и неустойчивые движения, а не положения, поэтому у гайки длительные движения в окрестности неустойчивоой оси Y сменяются быстрыми переворотами на 180 градусов.</p>

<h2 id="анализ-устойчивости">Анализ устойчивости</h2>

<p>Рассмотрим движение твердого тела, которое имеет три различных главных момента инерции, при этом обозначения <a href="https://prosopromat.ru/faq/voprosy-faq/vopros-o-glavnyx-centralnyx-osyax-inercii-secheniya.html">главных центральных осей</a> тела выбраны так, чтобы выполнялись условия \(J_z \leq  J_y \leq  J_x\).</p>

<p><img src="/assets/img/blog/jan-simintech-object.png" alt="" /></p>

<p class="figcaption">Рисунок 3 - Система координат, связанная с гайкой</p>

<h3 id="вращение-вокруг-оси-с-максимальным-значением-момента-инерции">Вращение вокруг оси с максимальным значением момента инерции</h3>

<p>Предположим, что тело вращающется вокруг главной оси с максимальным моментом инерции – $Cx$, с угловой скоростью \(\omega_0 = \text{const}\). Пусть проекции угловой скорости на все собственные оси получили малые возмущения, которые обозначим как \(\delta_x\), \(\delta_y\) и \(\delta_z\) соответственно:</p>

\[\omega_x = \omega_0 + \delta_x, \; \ \omega_y = 0+\delta_y, \; \omega_z = 0 + \delta_z.\]

<p>Уравнения движения тела в возмущениях имеют вид:</p>

\[\left\{
\begin{aligned}
	&amp; J_x \dot \delta_x - (J_y-J_z) \delta_y \delta_z = 0, \\
	&amp; J_y \dot \delta_y - (J_z-J_x) \delta_z (\omega_0 + \delta_x) = 0, \\
	&amp; J_z \dot \delta_z - (J_x-J_y) \delta_y (\omega_0 + \delta_x) = 0. \\
\end{aligned}
\right.\]

<p>Раскрывая скобки и пренебрегая произведениями малых отклонений (малыми второго порядка), получим:</p>

\[\left\{
\begin{aligned}
	&amp; J_x \dot \delta_x = 0, \\
	&amp; J_y \dot \delta_y - (J_z-J_x) \delta_z \omega_0 = 0, \\
	&amp; J_z \dot \delta_z - (J_x-J_y) \delta_y \omega_0 = 0. \\
\end{aligned}
\right.\]

<p>Из 1-го уравнения следует, что</p>

\[\delta_x = \text{const}.\]

<p>Из 2-го и 3-го уравнений можно получить два независимых линейных дифференциальных уравнения второго порядка:</p>

\[J_y \ddot \delta_y - \omega_0^2 \frac{(J_z-J_x) (J_x-J_y)}{J_z}\delta_y = 0.\]

\[J_z \ddot \delta_z - \omega_0^2 \frac{(J_z-J_x) (J_x-J_y)}{J_y}\delta_z = 0.\]

<p>Вид решений последних двух линейных дифференциальных уравнений зависит от знака множителя при \(\delta_y\) и \(\delta_z\). При \(J_z&lt;J_y&lt;J_x\):</p>

\[\omega_0^2 \frac{(J_x-J_z) (J_x-J_y)}{J_y J_z} &gt; 0,\]

<p>следовательно решения будут иметь вид:</p>

\[\delta_y = a_y \sin (\lambda t + \varepsilon_y), \quad \delta_z = a_z \sin (\lambda t + \varepsilon_z)\]

<p>Т.е. отклонения \(\delta_y\) и \(\delta_z\) не будут возрастать и вращение вокруг оси \(Cx\) будет устойчивым. Подобным образом показывается устойчивость вращения тела вокруг главной оси с минимальным моментом инерции \(Cz\).</p>

<h3 id="вращение-вокруг-оси-с-промежуточным-значением-момента-инерции">Вращение вокруг оси с промежуточным значением момента инерции</h3>

<p>Теперь предположим, что тело вращается вокруг оси \(Cy\) с промежуточным значением момента инерции. Рассмотрим устойчивость такого движения при небольших возмущениях проекций угловой скорости:</p>

\[\omega_x = \delta_x, \; \ \omega_y = \omega_0+\delta_y, \; \omega_z = \delta_z.\]

<p>Уравнения движения тела имеют вид:</p>

\[\left\{
\begin{aligned}
	&amp; J_x \dot \delta_x - (J_y-J_z) (\omega_0 + \delta_y) \delta_z = 0, \\
	&amp; J_y \dot \delta_y - (J_z-J_x) \delta_z \delta_x = 0, \\
	&amp; J_z \dot \delta_z - (J_x-J_y) \delta_x (\omega_0 + \delta_y) = 0. \\
\end{aligned}
\right.\]

<p>Пренебрегая малыми второго порядка, получим:</p>

\[\left\{
\begin{aligned}
	&amp; J_x \dot \delta_x - (J_z-J_x) \delta_z \omega_0 = 0, \\
	&amp; J_y \dot \delta_y = 0, \\
	&amp; J_z \dot \delta_z - (J_x-J_y) \delta_x \omega_0 = 0. \\
\end{aligned}
\right.\]

<p>Из 2-го уравнения следует: \(\delta_y = \text{const}\). Из 1-го и 3-го уравнений:</p>

\[\ddot \delta_x + \omega_0^2 \frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} \delta_x = 0.\]

\[\ddot \delta_z + \omega_0^2 \frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} \delta_z = 0.\]

<p>При \(J_z&lt;J_y&lt;J_x\):</p>

\[\omega_0^2 \frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} &lt; 0,\]

<p>следовательно решения для возмущений будут иметь вид:</p>

\[\delta_x = C_1 e^{\lambda t} + C_2 e^{- \lambda t}, \quad \delta_y = C_3 e^{\lambda t} + C_4 e^{- \lambda t}\]

<p>Мы видим, что возмущения неограниченно возрастают, поэтому вращение вокруг оси \(y_2\) будет неустойчиво.</p>

<p>Полученные уравнения показывают только устойчивость или неустойчивость движения твердого тела при вращении вокруг одной из собcтвенных осей и не описывают само движение при перевороте гайки. Среда моделирования <a href="https://simintech.ru">SimInTech</a> позволит нам не только убедиться в неустойчивости движения вокруг оси с промежуточным моментом инерции, построив графики изменения угловой скорости гайки, но и “увидеть” это движение при помощи модуля 3D-визуализации.</p>

<h2 id="модель">Модель</h2>

<p>Общий вид модели в <a href="https://simintech.ru">SimInTech</a> показан на рисунке 3.</p>

<p><img src="/assets/img/blog/jan-simintech-model.png" alt="" /></p>

<p class="figcaption">Рисунок 5 - Модель</p>

<p>Главным блоком модели вляется новый блок “Гайка (XZ’X’’)”, созданный на основе субмодели. Этот блок может использоваться для моделирования движения твердого тела вокруг центра масс в углах Эйлера. На вход блока подаётся вектор внешнего момента, который в этой задаче равен нулю, и массив значений главных моментов инерции объекта-гайки. Выходными сигналами блока являются вектор проекций угловой скорости гайки на собственные оси [wx, wy, wz] и вектор углов поворота связанной с гайкой системы координат по отношению к неподвижной системе. Угловое положение системы координат, связанной с гайкой, определяется углами Эйлера последовательности поворотов XZ’X’’. Структура блока показа на следующем рисунке:</p>

<p><img src="/assets/img/blog/jan-simintech-screw.png" alt="" /></p>

<p class="figcaption">Рисунок 6 - Модель блока “Гайка (XZ’X’’)”</p>

<p>В блоке “Гайка (XZ’X’’)” используются блоки-интеграторы, начальные условия которых (начальная угловая скорость и начальные значения углов Эйлера) заданы в свойствах блока “Гайка (XZ’X’’)”:</p>

<p><img src="/assets/img/blog/jan-simintech-body-prop.png" alt="" /></p>

<p class="figcaption">Рисунок 7 - Свойства блока “Гайка (XZ’X’’)”</p>

<p>Для того, чтобы добавить эти свойства к субмодели необходимо перевести SimInTech в режим разработчика (Меню “Вид” - “Режим разработчика”), в общих свойствах субмодели “Гайка” указать новое наименование типа блока, теперь это не “стандартная” субмодель, а блок типа “ТвердоеТело131”. Таким образом на основе субмодели создается новый блок со своими уникальными свойствами.</p>

<p><img src="/assets/img/blog/jan-simintech-submodel-type.png" alt="" /></p>

<p class="figcaption">Рисунок 8 - Задание типа блока</p>

<h3 id="блок-динамических-уравнений">Блок динамических уравнений</h3>

<p>В блоке “Динамические уравнения” в явном виде на встроенном языке программирования записываются динамические уравнения Эйлера в проекциях на главные центральные оси тела:</p>

\[\left\{
\begin{aligned}
	&amp; J_x \dot \omega_x - (J_z-J_x) \omega_y \omega_z = M_x, \\
	&amp; J_y \dot \omega_y - (J_z-J_x) \omega_z \omega_x = M_y, \\
	&amp; J_z \dot \omega_z - (J_x-J_y) \omega_x \omega_y = M_z. \\
\end{aligned}
\right.\]

<p>В рассматриваемом случае движение тела происходит “по-инерции”, поэтому все проекции внешнего момента на собственные оси равны нулю \(M_x = M_y = M_z = 0\). Ниже приведен код блока “динамические уравнения” (блок “<a href="https://help.simintech.ru/index.html#10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">Язык программирования</a>” из раздела “<a href="https://help.simintech.ru/index.html#10_biblioteki_blokov/avtomatika/DIR_dinamicheskie.html">Динамические</a>”):</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Динамические уравнения Эйлера 
// в главных центральных осях
// Входы :
// Torque - Вектор момента в главных центральных осях [Нм]
// J      - Главные моменты инерции [кгм2]
// w      - угловые скорости в проекциях на главные оси [1/с]
</span><span class="n">input</span> <span class="n">Torque</span><span class="p">[</span><span class="m">3</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="m">3</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
<span class="c1">// Выходы :
// dw     - Вектор угловых ускорений [1/с2]
</span><span class="n">output</span> <span class="n">dw</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>

<span class="n">dw</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Torque</span><span class="p">[</span><span class="m">1</span><span class="p">]+(</span><span class="n">J</span><span class="p">[</span><span class="m">2</span><span class="p">]-</span><span class="n">J</span><span class="p">[</span><span class="m">3</span><span class="p">])*</span><span class="n">w</span><span class="p">[</span><span class="m">2</span><span class="p">]*</span><span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">])/</span><span class="n">J</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
<span class="n">dw</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Torque</span><span class="p">[</span><span class="m">2</span><span class="p">]+(</span><span class="n">J</span><span class="p">[</span><span class="m">3</span><span class="p">]-</span><span class="n">J</span><span class="p">[</span><span class="m">1</span><span class="p">])*</span><span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">]*</span><span class="n">w</span><span class="p">[</span><span class="m">1</span><span class="p">])/</span><span class="n">J</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
<span class="n">dw</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">Torque</span><span class="p">[</span><span class="m">3</span><span class="p">]+(</span><span class="n">J</span><span class="p">[</span><span class="m">1</span><span class="p">]-</span><span class="n">J</span><span class="p">[</span><span class="m">2</span><span class="p">])*</span><span class="n">w</span><span class="p">[</span><span class="m">1</span><span class="p">]*</span><span class="n">w</span><span class="p">[</span><span class="m">2</span><span class="p">])/</span><span class="n">J</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
</code></pre></div></div>

<p>На вход блока подаётся вектор проекций угловой скорости тела, на выходе получается вектор проекций угловых ускорений тела (правая часть дифференциальных уранвений).</p>

<h3 id="блок-кинематических-уравнений">Блок кинематических уравнений</h3>

<p>Кинематические уравнения связывают производные параметров, определяющих ориентацию базиса, связанного с твердым телом по отношению к неподвижному базису, с проекциями угловых скоростей. В рассматриваемой задаче используется система углов Эйлера последовательности XZ’X’’, т.е. из исходного положения, когда связанный с телом базис совпадает с неподвижным базисом, угловое положение первого определяется тремя последовательными поворотами:</p>

<ol>
  <li>вокруг оси \(Cx_2\) на угол прецессии \(\psi\);</li>
  <li>вокруг оси \(Cz_2\) на угол нутации \(\vartheta\);</li>
  <li>вокруг оси \(Cx_2\) на угол собственного вращения \(\varphi\).</li>
</ol>

<p><img src="/assets/img/blog/jan-simintech-CS.png" alt="" /></p>

<p class="figcaption">Рисунок 9 - Углы XZ’X’’</p>

<p>Кинематические уравнения для рассматриваемой последовательности поворотов:</p>

\[\left\{
\begin{aligned}
\dot \psi &amp; = \frac{\omega_z \sin \varphi - \omega_y \cos \varphi}{\sin \vartheta}, \\
\dot \vartheta &amp; = \omega_z cos \varphi + \omega_y \sin \varphi, \\
\dot \varphi &amp; = \omega_x + \frac{\omega_y \cos \varphi - \omega_z \sin \varphi}{\tan \vartheta} 
\end{aligned}
\right.\]

<p>Блок кинематических уравнений написан также на встроенном языке программирования (блок “<a href="https://help.simintech.ru/index.html#10_biblioteki_blokov/avtomatika/Dinamicheskie/DAT_0985.html">Язык программирования</a>” из раздела “<a href="https://help.simintech.ru/index.html#10_biblioteki_blokov/avtomatika/DIR_dinamicheskie.html">Динамические</a>”):</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Кинематические уравнения для последовательности поворотов 131
</span><span class="n">input</span>  <span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
<span class="n">output</span> <span class="n">da</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>

<span class="n">da</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">]*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">])-</span><span class="n">w</span><span class="p">[</span><span class="m">2</span><span class="p">]*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">]))/</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span>
<span class="n">da</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">]*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">])+</span><span class="n">w</span><span class="p">[</span><span class="m">2</span><span class="p">]*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">]);</span>
<span class="n">da</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="n">w</span><span class="p">[</span><span class="m">1</span><span class="p">]+</span><span class="n">w</span><span class="p">[</span><span class="m">2</span><span class="p">]*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">])/</span><span class="n">tg</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">])-</span><span class="n">w</span><span class="p">[</span><span class="m">3</span><span class="p">]*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">])/</span><span class="n">tg</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]);</span>
</code></pre></div></div>

<h3 id="переход-от-углов-последовательности-131-к-углам-последовательности-232">Переход от углов последовательности 131 к углам последовательности 232</h3>

<p>В модуле 3D-визуализации SimInTech <a href="https://help.simintech.ru/index.html#11_yazyk_programmirovaniya/6_funkcii/3_graficheskie_i_sistemnye/modul_3d_vizualizacii/viewer3dsetlcsangles.html">ориентация объекта в пространстве также задается тремя углами Эйлера</a>, определяющими ориентацию связанного с телом базиса по отношению к неподвижному базису, но используется последовательность <strong>YZ’Y’‘</strong>, т.е. первый поворот выполняется вокруг оси Y на угол прецессии, второй поворот вокруг новой оси Z (поэтому она обозначается как Z’) на угол нутации и третий поворот  на угол собственного вращения вокруг оси Y’’.</p>

<p class="note">К сожалению, <a href="https://help.simintech.ru/index.html#11_yazyk_programmirovaniya/6_funkcii/3_graficheskie_i_sistemnye/DIR_modul_3d_vizualizacii.html">в справке</a> описан только этот способ определения ориентации тела в модуле 3D-визуализации, поэтому если в разрабатываемой модели используется другой набор углов, как в рассматриваемом случае, или вместо углов используются катернионы или направляющие косинусы, то для визуализации движения необходимо выполнять пересчет используемых параметров в углы последовательности YZ’Y’’.</p>

<p>Для преобразования одного набора углов Эйлера в другой используется субмодель “Углы 131 в 232”, структура которой показана на следующем рисунке.</p>

<p><img src="/assets/img/blog/jan-simintech-131-232.png" alt="" /></p>

<p class="figcaption">Рисунок 10 - Блок преобразования углов последовательности XZ’X’’ в последовательность YZ’Y’’</p>

<p>На вход субмодели поступает массив (вектор) углов последовательности XZ’X’’ (или 131). Внутри субмодели по значениям углов формируются матрицы поворота вокруг оси X на угол прецессии:</p>

\[A_x(\psi) = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; \cos \psi &amp; -\sin \psi \\ 0 &amp; \sin \psi &amp; \cos \psi \end{bmatrix}\]

<p>вокруг оси Z на угол прецессии:</p>

\[A_z(\vartheta) = \begin{bmatrix} \cos \vartheta &amp; -\sin \vartheta &amp; 0 \\ \sin \vartheta &amp; \cos \vartheta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\]

<p>и вокруг оси X на угол собственного вращения</p>

\[A_x(\varphi) = \begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; \cos \varphi &amp; -\sin \varphi \\ 0 &amp; \sin \varphi &amp; \cos \varphi \end{bmatrix}\]

<p>Матрицы перемножаются в прямом порядке:</p>

\[A = A_x(\psi) \cdot A_z(\vartheta) \cdot A_x(\varphi)\]

<p>В результате перемножения трех матриц элементарных поворотов получается матрица направляющих косинусов базиса связанного с телом по отношению к неподвижному базису.</p>

<p>Матрица направляющих косинусов поступает на вход субмодели DCM-A232, которая написана на встроенном языке программирования. В субмодели <a href="http://www.eecs.qmul.ac.uk/~gslabaugh/publications/euler.pdf">определяются углы последовательности 232 по элементам полученной матрицы направляющих косинусов</a>. Ниже приведён код субмодели DCM-A232:</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Вычисление углов последовательности 232
// по элементам матрицы направляющих косинусов
</span><span class="n">input</span>  <span class="n">u</span><span class="p">[</span><span class="m">3</span><span class="p">,</span><span class="m">3</span><span class="p">];</span>
<span class="n">output</span> <span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>

<span class="c1">// Для каждого угла есть два решения
</span><span class="n">a21</span> <span class="p">=</span>  <span class="n">arccos</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">]);</span>
<span class="n">a22</span> <span class="p">=</span>  <span class="m">2</span><span class="p">*</span><span class="n">pi</span><span class="p">-</span><span class="n">a21</span><span class="p">;</span>

<span class="n">a31</span> <span class="p">=</span>  <span class="n">atan2</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="m">2</span><span class="p">][</span><span class="m">3</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a21</span><span class="p">),</span><span class="n">u</span><span class="p">[</span><span class="m">2</span><span class="p">][</span><span class="m">1</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a21</span><span class="p">));</span>
<span class="n">a32</span> <span class="p">=</span>  <span class="n">atan2</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="m">2</span><span class="p">][</span><span class="m">3</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a22</span><span class="p">),</span><span class="n">u</span><span class="p">[</span><span class="m">2</span><span class="p">][</span><span class="m">1</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a22</span><span class="p">));</span>

<span class="n">a11</span> <span class="p">=</span>  <span class="n">atan2</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="m">3</span><span class="p">][</span><span class="m">2</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a21</span><span class="p">),-</span><span class="n">u</span><span class="p">[</span><span class="m">1</span><span class="p">][</span><span class="m">2</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a21</span><span class="p">));</span>
<span class="n">a12</span> <span class="p">=</span>  <span class="n">atan2</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="m">3</span><span class="p">][</span><span class="m">2</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a22</span><span class="p">),-</span><span class="n">u</span><span class="p">[</span><span class="m">1</span><span class="p">][</span><span class="m">2</span><span class="p">]/</span><span class="n">sin</span><span class="p">(</span><span class="n">a22</span><span class="p">));</span>

<span class="c1">// Выбираем первое... 
</span><span class="n">a</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">a11</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">a21</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="n">a31</span><span class="p">;</span>
</code></pre></div></div>

<p>Найденные углы передаются на выход субмодели “Углы 131 в 232”. С выхода  значения углов записываются в базу сигналов: переменные A1, A2, A3 соответсенно, которые были предварительно объявленны в редакторе сигналов (меню “Сервис” → “Сигналы”):</p>

<p><img src="/assets/img/blog/jan-simintech-signals.png" alt="" /></p>

<p class="figcaption">Рисунок 11 - Сигналы A1, A2, A3</p>

<p>Для записи сигналов используется блок <a href="https://help.simintech.ru/#10_biblioteki_blokov/avtomatika/Signaly/1021.html">“Запись в список сигналов”</a>:</p>

<p><img src="/assets/img/blog/jan-simintech-signals-write.png" alt="" /></p>

<p class="figcaption">Рисунок 12 - Свойства блока “Запись в список сигналов”</p>

<h3 id="скрипт-модели">Скрипт модели</h3>

<p>В скрипте модели в блоке инициализации задаются значения главных моментов инерции гайки, создается окно 3D-визуализации, загружается объект - гайка из файла <a href="/assets/files/3d/screw.stl">screw.stl</a>.</p>

<p><img src="/assets/img/blog/jan-simintech-script-button.png" alt="" /></p>

<p class="figcaption">Рисунок 13 - Редактор скрипта модели</p>

<p>Вне блока инициализации записаны две строчки кода, которые будут вызываться на каждом шаге интегрирования. Функция <a href="https://help.simintech.ru/index.html#11_yazyk_programmirovaniya/6_funkcii/3_graficheskie_i_sistemnye/modul_3d_vizualizacii/viewer3dsetlcsangles.html">Viewer3DSetLCSAngles</a> поворачивает гайку на углы Эйлера, полученные на шаге интегрирования, функция <a href="https://help.simintech.ru/index.html#11_yazyk_programmirovaniya/6_funkcii/3_graficheskie_i_sistemnye/modul_3d_vizualizacii/viewer3dsetlcsposition.html">Viewer3DSetLCSPosition</a> перемещает центр масс гайки вдоль оси x имитируя её движение после схода с винта.</p>

<div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">initialization</span>
     <span class="k">var</span> <span class="n">Jx</span> <span class="p">=</span> <span class="m">2000</span><span class="p">;</span>
     <span class="k">var</span> <span class="n">Jy</span> <span class="p">=</span> <span class="m">4000</span><span class="p">;</span>
     <span class="k">var</span> <span class="n">Jz</span> <span class="p">=</span> <span class="m">6000</span><span class="p">;</span>

     <span class="n">Id</span>  <span class="p">=</span> <span class="n">Viewer3DCreate</span><span class="p">;</span>
     <span class="n">OId</span> <span class="p">=</span> <span class="n">Viewer3DPlotObject</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">],</span> <span class="p">[</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">],</span> <span class="err">"</span><span class="n">screw</span><span class="p">.</span><span class="n">stl</span><span class="err">"</span><span class="p">);</span>
     <span class="n">Viewer3DShowObjectAxes</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="n">OId</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>    
<span class="k">end</span>

<span class="n">Viewer3DSetLCSAngles</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="n">OId</span><span class="p">,</span> <span class="n">A1</span><span class="p">*</span><span class="m">180</span><span class="p">/</span><span class="n">pi</span><span class="p">,</span> <span class="n">A2</span><span class="p">*</span><span class="m">180</span><span class="p">/</span><span class="n">pi</span><span class="p">,</span> <span class="n">A3</span><span class="p">*</span><span class="m">180</span><span class="p">/</span><span class="n">pi</span><span class="p">);</span>
<span class="n">Viewer3DSetLCSPosition</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">oID</span><span class="p">,</span> <span class="p">-</span><span class="m">0.2</span><span class="p">+</span><span class="m">0.05</span><span class="p">*</span><span class="n">time</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Перед запуском модели необходимо в настройках “Параметры расчета” на закладке “Синхронизация” поставить галочку “Синхронизировать с реальным временем”.</p>

<p><img src="/assets/img/blog/jan-simintech-params-sim.png" alt="" /></p>

<p><img src="/assets/img/blog/jan-simintech-sync.png" alt="" /></p>

<p class="figcaption">Рисунок 14 - Синхронизация скорости расчёта с реальным временем</p>

<p>После запуска модели появится окно “Модуль 3D Визуализации SimInTech”, в котором будет показано движение гайки. Графики изменения проекций вектора угловой скорости гайки на собственные оси показаны на рисунке 15.</p>

<p><img src="/assets/img/blog/jan-simintech-wxwywz.png" alt="" /></p>

<p class="figcaption">Рисунок 15 - Угловые скорости гайки</p>

<h2 id="ссылки">Ссылки</h2>

<ol>
  <li><a href="http://www.eecs.qmul.ac.uk/~gslabaugh/publications/euler.pdf">Й. Виттенбург, Динамика систем тел</a>, М.: Наука, 1980.</li>
  <li><a href="http://www.eecs.qmul.ac.uk/~gslabaugh/publications/euler.pdf">Gregory G. Slabaugh. Computing Euler angles from a rotation matrix</a></li>
</ol>]]></content><author><name></name></author><category term="mechanics" /><category term="cae" /><summary type="html"><![CDATA[Модель и визуализация движения в SimInTech гайки-барашка при её вращении вокруг оси с промежуточным моментом инерции, известного как "Эффект Джанибекова".]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://classmech.github.io/assets/img/blog/jan-simintech-object.png" /><media:content medium="image" url="https://classmech.github.io/assets/img/blog/jan-simintech-object.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>
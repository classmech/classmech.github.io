


{
  "pages": [
    {
      
      
      
      "content": "\n\n\n  404\n\n  Page not found :(\n  The requested page could not be found.\n\n",
      "url": "/404.html"
    },{
      
      "title": "Вывод уравнения движения механизма",
      
      "content": "Рассмотрим движение плоского механизма, представленного на рисунке 1. Механизм состоит из тела 1, представляющего собой два жестко соединенных в точке В стержня. В точке О тело 1 шарнирно закреплено на неподвижной опоре. Вдоль стержня АВ может двигаться шарик M (тело 2), который представлен материальной точкой с известной массой \\(m\\). К шарику прикреплена пружина, другой конец которой закреплен в точке А тела 1. Механизм движется в вертикальной плоскости: тело 1 вращается вокруг шарнира О по закону:\n\n[\\varphi = \\varphi_0 + \\omega t]\n\n\nРисунок 1 - Схема механической системы и силы, действующие на шарик\n\nВывод уравнения движения шарика вдоль стержня с использованием уравнений относительного движения\n\nУравнение относительного движения шарика (по отношению к неинерциальной системе координат \\(Axy\\)) в векторной форме имеет вид\n\n[m \\vec{a}_r = \\vec{F}_y + m \\vec g + \\vec N_y + \\vec{\\Phi}^e + \\vec{\\Phi}^k]\n\nВ правой части уравнения к активным силам (сила действия пружины и сила притяжения), силе реакции опоры (сила действия стержня АВ на шарик) добавлены переносная сила инерции \\(\\Phi^e\\), учитывающая вращение подвижной системы координат вокруг шарнира О и сила инерции Кориолиса \\(\\Phi^k\\).\n\nАктивные силы и сила реакции\n\nНа шарик действуют сила пружины, которая определяется ее деформацией относительно свободной длины \\(l_0\\) и жесткостью \\(k\\):\n\n[F_y = k (x-l_0)]\n\nсила притяжения \\(G = m g\\) и сила реакции стержня АВ – \\(N_y\\), которая направлена перпендикулярно стержню.\n\nСилы инерции\n\nПереносная сила инерции \\(\\Phi^e\\) при вращении тела 1 с постоянной угловой скоростью \\(\\omega\\) определяется выражением\n\n[\\Phi^e = \\omega^2 \\, OM \\, m]\n\nСила инерции Кориолиса направлена перпендикулярно стержню АВ и определяется выражением\n\n[\\Phi^k = 2 m \\dot x \\omega]\n\nНаправления сил инерции показано на рисунке 2.\n\n\nРисунок 2 - Силы инерции\n\nУравнения движения\n\nПроецируя векторное уравнение относительного движения шарика на ось \\(Ax\\), получим\n\n[m \\ddot x = m \\omega^2 OM \\cos \\gamma  - mg \\sin \\varphi - k (x - l_0)]\n\nУчитывая, что \\(\\cos \\gamma = x / OM\\):\n\n[m \\ddot x = m \\omega^2 x - mg \\sin \\varphi - k (x - l_0)]\n\nПроекция уравнения на ось \\(Ay\\)\n\n[0 = - m \\omega^2 ОА - mg \\cos \\varphi  +  N_y - 2 m \\dot x \\omega]\n\nпозволит найти силу реакции стержня АВ\n\n[N_y = m \\omega^2 ОА + mg \\cos \\varphi + 2 m \\dot x \\omega]\n\nВывод уравнения движения шарика вдоль стержня с использованием уравнений абсолютного движения\n\nКоординатный столбец радиус вектора шарика в неподвижной системе координат\n\nЗапишем положение шарика в неподвижной системе координат \\(Ox_0y_0\\), начало которой находится в шарнире О. Координатный столбец радиус-вектора шарика в неподвижной системе координат выражен через его положение по отношению к подвижной системе координат \\(Axy\\) (координата \\(x\\)) и угловое положение  подвижной системы координат по отношению к неподвижной (угол \\(\\varphi\\)):\n\n[r = { OA \\, \\text{Sin}[\\varphi[t]]\\ + x[t] \\, \\text{Cos}[\\varphi[t]], -OA \\, \\text{Cos}[\\varphi[t]]\\ + x[t] \\, \\text{Sin}[\\varphi[t]] }]\n\nКоординатный столбец абсолютного ускорения шарика\n\nДля определения абсолютного ускорения шарика используем функцию дифференцирования\n\n[a = \\text{D}[r,{t,2}]]\n\nСилы действующие на шарик\n\nШарик движется под действием силы веса \\(mg\\), силы пружины \\(F_y\\) силы реакции стержня АВ \\(N_y\\). Запишем проекции этих сил на оси неподвижной системы координат\n\n[F = {0,-m\\,g} - k\\,(x[t]-l_0){\\text{Cos}[\\varphi[t]],\\,\\text{Sin}[\\varphi[t]]} + Ny\\,{-\\text{Sin}[\\varphi[t]],\\text{Cos}[\\varphi[t]]}]\n\nУравнение движения\n\nСпроецируем векторное уравнение \\(m \\vec a = \\vec F\\) на подвижную ось $Ax$, единичный вектор которой в неподвижной системе координат определяется выражением\n\n[e_x = { \\text{Cos}[\\varphi[t]],\\, \\text{Sin}[\\varphi[t]]}]\n\nДля вычисления скалярного произведения вектора абсолютного ускорения шарика и единичного вектора \\(e_x\\) используется оператор “точка”:\n\n[\\text{eqx} = m\\,a.e_x = F.e_x //\\text{FullSimplify}]\n\nТакже можно спроецировать уравнение движения на ось \\(Ay\\)\n\n[\\text{eqy} = m\\,a.e_y = F.e_y //\\text{FullSimplify}]\n\nВ уравнениях движения необходимо заменить функцию \\(\\varphi(t)\\) и её производные заданными выражениями, исходя из заданного закона изменения угла поворота \\(\\varphi = \\varphi_0 + \\omega t\\)\n\n[\\text{conditions} = { \\varphi’[t] -&gt; \\omega, \\varphi[t] -&gt; \\varphi0 + \\omega\\,t, \\varphi’‘[t] -&gt; 0 };]\n\nПерепишем первое уравнение\n\n[\\text{eqx} = m\\,a.e_x = F.e_x /. \\text{conditions} //\\text{FullSimplify}]\n\n",
      "url": "/pages/wolfram/CourseWork_1/"
    },{
      
      "title": "Лабораторная работа 1",
      "description": "Пояснения к первой лабораторной работе по курсу Информатика\n",
      "content": "Задание\n\nСоставить блок-схему алгоритма и программу на языке Паскаль для вычисления значений функции\n\n[y = \\frac{a^2 + \\ln bx}{e^x + \\cos (cx)}]\n\nпри заданном значении x, которое вводится с клавиатуры. Параметры функции и значение аргумента  приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      1.5\n    \n    \n      b\n      2.1\n    \n    \n      c\n      3.22\n    \n    \n      x\n      1.83\n    \n  \n\n\nТекст программы\n\nprogram Lab1;\n\n  var a, b, c, x, y: real;\n\nbegin\n  a:=1.5;\n  b:=2.1;\n  c:=3.22;\n\n  write('введите x=');\n  readln(x);\n\n  y:=(sqr(a)+ln(b*x))/(exp(x)+cos(c*x));\n\n  writeln('при x=',x:5:2,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nПояснения\n\nПрограмма на языке Паскаль состоит из трёх основных разделов:\n\n\n  заголовок\n  раздел описаний\n  тело программы или блок опрераторов\n\n\nВ рассматриваемой программе заголовок это первая строчка\nprogram Lab1;\n\nкоторая говорит о том, что эта программа называется Lab1.\n\nСледующий раздел это раздел описаний, где перечисляются используемые в программе переменные с указанием их типов (целые, вещественные, …).\nВ примере это\nvar a, b, c, x, y : real;\n\nВ программе используется 5 переменных, которым можно присвоить вещественные значения (тип real).\n\nВ разделе операторов, который начинается с ключевого слова begin и заканчивается словом end. (с точкой) записываются действия, которые выполняет программа.\nВ первых строчках раздела операторов, объявленным ранее переменным, присваиваются значения:\na:=1.5;\nb:=2.1;\nc:=3.22;\n\nОбратите внимание, что операция присвоения значения переменной записывается при помощи сиволов двоеточие и равно (a:=1.5), чтобы отличать это действие от операции сравнения значений переменных a=1.5, результатом которой будет истина или ложь.\n\nВо второй строке вызывается функция write, которая выводит на экран значение переменной или текст, который передается этой функции в качестве аргумента:\nwrite('введите x=');\n\nПосле этого вызывается функция readln(x), которая приводит к приостановке программы, пока пользователь не введет какое-то значение и не нажмет ENTER.\nreadln(x);\n\nВведённое пользователем значение запиcывается в переменную x.\n\nПосле получения от пользователя программы значения x, можно вычислить значение функции и записать её в переменную y:\ny:=(sqr(a)+ln(b*x))/(exp(x)+cos(c*x));\n\nВ этой строке используются математические функции вычисления корня sqrt, натурального логарифма ln, косинуса cos и экспоненты exp. Аргументы этим функциям передаются в круглых скобках. Для тригонометрических функций предполагается, что аргумент задан в радианах.\n\nРезультат выводится на экран при помощи функции writeln, которая отличается от использованной ранее функции write тем, что после вывода на экран всех значениий, функция переводит крусор на новую строчку.\nwriteln('при x=', x:5:2, ' значение y=', y:5:2);\n\nФункции writeln передано четыре аргумента, которые она выведет на экран друг за другом. В начале выведется текст ‘при x=’ (он записан в кавычках, чтобы транслятор языка Паскаль не рассматривал содержимое этой строки как часть кода порграммы. Далее выводится значение (содержимое) переменной x. Слева от переменной x через двоеточия указаны два числа – 5 и 2, при помощи которых производится форматирование числового значения:\n\n\n  для вывода используется пять позиций на экране;\n  значение переменной x округляется до второго знака после запятой.\n\n\nНапример, если пользователь ввел значение x равное 1.15345687, то на экран будет выведено\n\n\n  \n    \n       \n      1\n      .\n      1\n      5\n    \n  \n\n\nЕсли рассматриваемую строку заменить на\nwriteln('при x=', x, ' значение y=', y);\n\nто на экран тоже будет выведен результат, но с большим количеством “лишних” цифр.\nпри x= 1.1200000000000001E+000 значение y= 1.4303744323446415E+000\n\n\nПосле значения x в той же строке выводится текст ‘ значение y=’ и значение переменной y, с тем же форматом вывода и округления, который использовался для вывода переменной x.\n\nПоследняя функция приостанавливает выполнения программы, ожидая от пользователя нажатия кнопки ENTER, чтобы можно было прочитать результаты работы программы:\nreadln;\n\n\nКод этой же программы на языке Python\nimport math\n\na = 1.5\nb = 2.1\nc = 3.22\n\nx = float(input('Введите значение x = '))\n\ny=(a*a+math.log(b*x))/(math.exp(x)+math.cos(c*x))\n\nprint('при x= {} значение y = {}'.format(x,y))\n\n",
      "url": "/pages/informatics/Lab1/"
    },{
      
      "title": "Лабораторная работа 2",
      "description": "Составление алгоритмов и программирование разветвляющихся алгоритмов с двумя альтернативами, ветвление ветвления, оператор выбора\n",
      "content": "Задание 2.1\n\nСоставить блок-схему алгоритмаи программу на языке Паскаль для вычисления значений функции \\(y = f(x)\\) при произвольных значениях \\(x\\). Получить результат работы программы для двух заданных значениий \\(x\\).\n\n[y = \\left{\n  \\begin{array}{ll}\n  b + 3 \\cos ^3 x &amp; x \\le 2\n  \\sqrt {a x^2 + 7x + 10} &amp; x &gt; 2\n  \\end{array} \\right.]\n\nпри заданном значении x, которое вводится с клавиатуры. Параметры функции приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      3.7\n    \n    \n      b\n      6.1\n    \n  \n\n\nprogram Lab21;\n\nvar a, b, x, y : real;\n\nbegin\n  a:=3.7;b:=6.1;\n  write('Введите x = ');\n  readln(x);\n  if x&lt;=2 then y := b + 3*cos(x)*sqr(cos(x))\n    else y := sqrt(a*sqr(x)+7*x+10);\n  writeln('При x = ', x:5:2, ' значение y = ', y:5:2);\n  readln;\nend.\n\n\nВ программе используется простой условный (разветвляющийся) алгоритм, имеющий два варианта выполнения в зависимости от того истинно ли УСЛОВИЕ или ложно. Этот алгоритм в языке паскаль записывается следующим образом:\n\nif УСЛОВИЕ then\n  begin\n    код, выполняемый, если УСЛОВИЕ истинно;\n    ...;\n    ...;\n  end\nelse\n  begin\n    код, выполнямый если УСЛОВИЕ ложно;\n    ...;\n    ...;    \n  end\n\n\nЕсли фрагмент кода, который выполняется при выполнении условия занимет одну строчку, то запись алгоритма ветвления можно упростить, записав соответствующий код сразу после ключего слова then и else:\n\nif УСЛОВИЕ then код, выполняемый, если УСЛОВИЕ истинно\nelse код, выполнямый если УСЛОВИЕ ложно;\n\n\nАльтернативный вариант формитирования программы, который читается лучше:\n\nif УСЛОВИЕ then\n  код, выполняемый при УСЛОВИИ\nelse\n  код, выполнямый если УСЛОВИЕ не выпоняется;\n\n\nОбратите внимание, что код, записанный после ключевого слова then не заканчивается точкой с запятой, поскольку алгоритм ветвления еще не закончен. Точка с запятой ставится только в конце строки с ключевым словом else.\n\nВозможная также следующая конструкция алгоритма ветвления без альтернативного варианта:\n\nif УСЛОВИЕ then\n  код, выполняемый при УСЛОВИИ ;\n\n\nили, для многострочного кода:\n\nif УСЛОВИЕ then\n  begin\n    код, выполняемый при УСЛОВИИ ;\n    ... ;\n    ... ;\n    ... ;\n  end\n\n\nЗадание 2.2\n\nСоставить схему алгоритма и два варианта программы на языке Паскаль для вычисления значений функции \\(y=f(x)\\) при произвольных значениях \\(x\\).\n\n[y =\\left{\n    \\begin{array}{ll}\n    x + 2b, &amp; x &lt; -1 \n    e^{-x} &amp; -1 \\leq x \\leq 2\n    \\cos ax &amp; x&gt;2\n    \\end{array}\n  \\right.]\n\nПараметры функции приведены в таблице:\n\n\n  \n    \n      Параметр\n      Значение\n    \n    \n      a\n      3.7\n    \n    \n      b\n      6.1\n    \n  \n\n\nprogram Lab22;\n  var a,b,x,y:real;\nbegin\n  a:=3.7;\n  b:=6.1;\n\n  write('введите x=');\n  readln(x);\n\n  if x&lt;-1 then\n    y:=x+2*b\n  else if x&lt;=2 then\n    y:=exp(-x)\n  else\n    y:=cos(a*x);\n\n  writeln('При x=', x:5:2, ' значение y=', y:5:2);\n  readln;\nend.\n\n\nЗадание 2.3\n\nЗадание. Составить схему алгоритма и программу на языке Турбо Паскаль для вычисления значений функции \\(y=f(x)\\) при произвольных значениях \\(x\\).\n\n[y = \\left{\n  \\begin{array}{ll}\n    x + 2b &amp; x = -2 \n    e^{-x} &amp; x = 1 \n    \\cos ax &amp;  x =3\n  \\end{array}\n  \\right.]\n\nprogram Lab21;\nvar\n    a, b, y : real;\n    x : integer;\nbegin\n\n  a:=3.7;\n  b:=6.1;\n\n  write('Введите x=');\n  readln(x);\n\n  case x of\n    -2 : y:=x+2*b;\n     1 : y:=exp(-x);\n     3 : y:=cos(a*x);\n  else\n    begin\n      writeln ('значение x задано неверно' );\n      writeln('нажми Enter');\n      readln;\n      exit;  \n    end;\n  end;\n\n  writeln('при x=',x,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nВ этой программе используется оператор выбора case. Оператор case целеообразно использовать если необходимо выполнять различный код в зависимости от значения какой-либо переменной.\n\nВ примере вид вычисляемой функции меняется в зависимости от значения целочисленной переменной \\(x\\). Программу для вычисления функции можно написать, используя конструкцию if/else, но код получается громоздким:\n\nprogram Lab21;\nvar\n    a, b, y : real;\n    x : integer;\nbegin\n\n  a:=3.7;\n  b:=6.1;\n\n  write('Введите x=');\n  readln(x);\n\n  if x = -2 then\n    y:=x+2*b\n  else if x = 1\n    y:=exp(-x)\n  else if x = 3\n    y:=cos(a*x)\n  else\n    begin\n      writeln ('значение x задано неверно' );\n      writeln('нажми Enter');\n      readln;\n      exit;  \n    end;\n\n  writeln('при x=',x,' значение y=',y:5:2);\n  readln;\n\nend.\n\n\nПеременная, значение которой определяет выполняемый фрагмент кода, может иметь тип integer, char, string.\n\nОператор case может использоваться для выполнения кода при попадании проверяемой переменной в заданный интервал, нижняя и верхняя граница которого записываются через две точки:\n\nprogram Lab21;\nvar\n    x : integer;\nbegin\n\n  write('Введите число от 1 до 9 :');\n  readln(x);\n\n  writeln('Вы ввели ');\n\n  case x of      \n      1..5   : write('число меньше 6'); {Если x в диапазоне от 1 до 5}\n      6..9   : write('число больше 5'); {Если x в диапазоне от 6 до 9}\n  else\n    begin\n      writeln('Значение x вне диапазона от 1 до 9' );\n      writeln('Нажмите Enter');      \n      readln;    \n    end\n  end;\n\nend.\n\n\nили если значение переменной есть в списке значений, перечесляемых через запятую:\n\nprogram Lab21;\nvar\n    x : integer;\nbegin\n\n  write('Введите число от 1 до 9 :');\n  readln(x);\n\n  writeln('Вы ввели ');\n\n  case x of\n      2,4,6,8   : write('нечетное число'); {Если x в списке 2,4,6,8}\n      1,3,5,7,9 : write('четное число');\n\n  else\n    begin\n      writeln('Значение x вне диапазона от 1 до 9' );\n      writeln('Нажмите Enter');      \n    end\n  end;\n\nend.\n\n",
      "url": "/pages/informatics/Lab2/"
    },{
      
      "title": "Лабораторная работа 3",
      "description": "Построение таблицы функции\n",
      "content": "Задание 3.1\n\nЗадание 3.2\n\n",
      "url": "/pages/informatics/Lab3/"
    },{
      
      "title": "Лабораторная работа 4",
      "description": "Одномерные и двумерные массивы\n",
      "content": "Задание 4.1\n\nЗадание 4.2\n\n",
      "url": "/pages/informatics/Lab4/"
    },{
      
      "title": "Лабораторная работа 5",
      "description": "Программирование задач, решаемых с помощью цикла итерационного цикла\n",
      "content": "Итерационный цикл - оператор цикла, в котором количество повторений заранее неизвестно. В итерационном цикле на кажом шаге (итерации) производится проверка достижения желаемого результата.\n\nРассмотрим для примера разложение в ряд функции \\(\\sin x\\):\n\n[y = \\sin x = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + \\ldots = S_0 + S_1 + S_2 + \\ldots S_k + \\ldots = \\sum_{k=0}^{\\infty} (-1)^n \\frac{x^{2n+1}}{(2n+1)!}]\n\nЧем больше членов этого ряда будет вычислено, тем точнее получится результат, например при \\(x = 1.0\\) радиан :\n\n\n  \n    \n      Количество учитываемых слагаемых\n      Значение последнего члена, \\(S_k\\)\n      Значение ряда, y\n    \n  \n  \n    \n      1\n      1.00000\n      1.00000\n    \n    \n      2\n      0.16667\n      0.83333\n    \n    \n      3\n      0.00833\n      0.84167\n    \n    \n      4\n      0.00020\n      0.84147\n    \n  \n\n\nНапишем программу вычисления этого ряда для заданного значения \\(x\\) с заданной точностью, т.е. будем вычислять \\(S_k\\) и добавлять их к общей сумме до тех пор, пока приращение по модулю не станет меньше заданного значения \\(\\epsilon\\).\n\nПри составлении программы вместо использования общей формулы для вычисления k-го члена ряда (пока без учета знака)\n\n[S_k = \\frac{x^{2k+1}}{(2k+1)!}]\n\nбудем вычислять значение \\(S_k\\) на основе предыдущего значения.\n\nЗаметим, что\n\n[S_2 = \\frac{x^3}{3!} = S_1 \\frac{x^2}{2 \\cdot 3}]\n\n[S_3 = \\frac{x^5}{5!} = S_2 \\frac{x^2}{4 \\cdot 5}]\n\n[S_4 = \\frac{x^7}{7!} = S_3 \\frac{x^2}{6 \\cdot 7} =  S_3 \\frac{x^2}{(4 \\cdot 2-2) \\cdot (4 \\cdot 2-1)}]\n\nили в общем виде\n\n[S_k = S_{k-1} \\frac{x^2}{(2 \\cdot k - 2) \\cdot (2 \\cdot k - 1)}]\n\nДля того чтобы учеть знак перед \\(S_k\\) используем оператор определения остатка от деления\n\n  mod\n\n\nдля четных \\(k\\) (k mod 2 = 0) слагаемое \\(S_k\\) вычитается из общей суммы ряда, для нечетных – добавляется к сумме.\n\nprogram Lab4;\n\nvar\n  i          :integer; { номер итерации }\n  S          :real;    { член ряда }\n  x, y, eps  :real;    { аргумент, функция, точность }\n\nbegin\n  write('Введите значение аргумента x=');\n  readln(x);\n\n  write('Введите точность eps=');\n  readln(eps);\n\n  { Первая итерация }\n  i:= 1;  \n  { Первый член (слагаемое) ряда }\n  S:= x;  \n  { Значение функции для первой итерации }\n  y:= S;\n\n  { Пока |S| больше eps ...}\n  while (abs(S)&gt;eps) do\n    begin\n      i:= i + 1;\n\n      { Вычисляем следующее слагаемое ряда}\n      S:= S*x*x/((2*i-2)*(2*i-1));\n\n      { Уточняем значение ряда на величину Si (с учетом знака) }\n      if i mod 2 = 0 then\n        y:= y - S\n      else\n        y:= y + S;        \n\n      { продолжаем, пока уточнение значения ряда по модулю |S| не станет меньше заданной погрешности eps }      \n    end;\n\n  writeln('Значение функции при x=', x:8:5, ' с точностью до eps=', eps:8:5, ': y=', y:8:5);\n\nend.\n\n\nВерсия этой программы на языке Python:\n\nfrom math import sin\n\nx   = float( input('Введите значение аргумента x=') )\neps = float( input('Введите точность eps=') )\n\ni = 1\nS = x\ny = S\n\nwhile abs(S) &gt; eps:\n  i = i + 1\n\n  S = S*x*x/((2*i-2)*(2*i-1))  \n\n  if i % 2 == 0:\n    y = y - S\n  else:\n    y = y + S   \n\nprint( 'При x={:8.5f} и eps={:8.5f} y={:8.5f}, точное значение {:8.5f}'.format(x, eps, y, sin(x)) )\n\n",
      "url": "/pages/informatics/Lab5/"
    },{
      
      "title": "Лабораторная работа 6",
      "description": "Процедуры и функции\n",
      "content": "Подпрограмма самостоятельный именованный фрагмент программы, реализующий определенный алгоритм и допускающий многократное обращение к нему из различных частей основной программы. В турбо-паскале подпрограмма может быть оформлена в виде процедуры или функции.\n\nПроцедуры\n\nОбъявление процедуры начинается с ключевого слова ~procedure~, за которым следуют имя процедуры и список формальных параметров. Список параметров с указанием их типов заключается в круглые скобки. Перед параметрами, с помощью которых в вызывающую программу возвращается результат работы процедуры, ставится слово VAR. После строки с именем процедуры следует тело процедуры, содержащее раздел описаний процедцры и раздел исполняемых операторов процедуры.\n\nprogram Lab6;\n\n{ Объявление процедуры с именем pifagor }\nprocedure pifagor(a, b: real; var c: real);\nbegin\n  c:=sqrt(a*a+b*b);  \nend;\n\n{ Объявление переменных главной программы }\nvar\n  a, b, c : real;\n\n{ Основная программа }\nbegin\n  write('Введите длину катета a = '); readln(a);\n  write('Введите длину катета b = '); readln(b);\n\n  { Вызов процедуры. В третий параметр (с) записывается значение переменной c, вычисляемый внутри процедуры }\n  pifagor(a,b,c);\n\n  writeln('c = ', c:5:2);\n\nend.\n\n\nФункции\n\nФункции - это подпрограмма, результатом работы которой является некоторое значение, подобное переменной. Функция, как и процедура, может иметь список параметров, следующих за именем функции в круглых скобках. Но если имя процедуры используется только для ее вызова, то с именем функции связывается ее значение. Для этого в теле любой функци нужно осуществить присваивание ей (её имени) вычисленного значения.\n\nprogram Lab6;\n\n{ Объявление функции, вычисляющей сумму квадратов катетов прямоугольного треугольника }\nfunction pifagor(a, b: real): real;\nbegin\n  { присваиваем результат работы функции её имени }\n  pifagor:=sqrt(a*a+b*b);  \nend;\n\n{ Объявление переменных главной программы }\nvar\n  a, b, c : real;\n\nbegin\n  write('Введите длину катета a = '); readln(a);\n  write('Введите длину катета b = '); readln(b);\n\n  { Вызов функции }\n  c:= pifagor(a, b);\n\n  { Функция может использоваться в выражениях, как и любая встроенная функция (sin, cos, ...) }\n  c:= 2*pifagor(a, b);   \n\nend.\n\n\nПример задания\n\nСоставить программу на языке Паскаль для вычисления значения функции\n\n[y = \\frac{\\sin ax}{x^2 + a^2}]\n\nв точках \\(x = {0.2, 0.7, 1.0, 1.2, 1.8, 2.0, 2.2}\\) при заданных значениях \\(a = {2, 2.5, 3, 7, 4.1, 4.9}\\). Нахождение значения функции \\(f(x)\\) при заданных значениях а оформить в виде подпрограммы. Результат вывести в виде двумерной таблицы.\n\nprogram lab6;\n\n{ Определяем тип данных -- вектор и двумерный массив }\ntype vector= array [1..20] of real;\n     massiv= array [1..20,1..20] of real;\n\n{ Объявление переменных }\nvar x,a:vector;\n    i,j,k,n,m:integer;\n    y:massiv;\n\n{ Объявление процедуры, которая записывает двумерный массив в параметр y (тип массив) }\n{ Входные параметры процедуры -- размеры массива и массивы x и a }\nprocedure p(n, m : integer; x, a : vector; var y : massiv);\nbegin\n  for i:=1 to n do\n    for j:= 1 to m do\n      y[i,j]:=sin(a[j]*x[i])/(sqr(x[i])+sqr(a[j]));\nend;\n\n{ Тело основной программы }\nbegin\n\n  Write ('Введите количество значений  x и a= ');\n  Readln(n,m);\n\n  { Ввод значений x }\n  for i:=1 to n do\n    begin\n      Write ('Введите x[',i,']=');\n      Readln(x[i]);\n    end;\n  { Ввод значений a }\n  for j:= 1 to m do\n    begin\n      Write ('Введите a[',j,']=');\n      Readln(a[j]);\n    end;\n\n  { Вызов процедуры p и заполнение массива y }\n  p(n, m, x, a, y);\n\n  { После того как массив заполнен, выводим его в виде таблицы}\n\n  { Вывод шапки таблицы }\n  writeln ('         Таблица');\n  writeln('┌───────┬───────┬───────┬───────┬───────┬───────┬───────┐');\n  write('│ x \\ a │');\n\n  { Вывод a в первой строке }\n  for i:=1 to m do           \n    write(a[i]:4:1,'   │');\n  { Перевод строки }\n  writeln;\n\n  { Для каждой строки таблицы от 1 до n }\n  for i:=1 to n do\n    begin\n      writeln('├───────┼───────┼───────┼───────┼───────┼───────┼───────┤');\n\n      { вывод x в  первую колонку i-ой строки }\n      write('|', x[i]:3:1,'    ','│');\n\n      { вывод y в i-ой строке }\n      for j:=1 to m do\n        write(y[i, j]:7:3,'│');\n\n      { Перевод строки }\n      writeln;\n\n    end;\n\n  { Вывод подвала таблицы }  \n  Writeln('└───────┴───────┴───────┴───────┴───────┴───────┴───────┘');\n\n  { Ожидание, пока пользователь не нажмет Enter }\n  readln;\n\nend.\n\n\n",
      "url": "/pages/informatics/Lab6/"
    },{
      
      "title": "Об авторе",
      
      "content": "\n  Юдинцев Вадим Вячеславович. Доцент кафедры теоретической механики Самарского университета.\n\n\nОбласть интересов\n\n\n  Динамика систем тел, динамика систем тел переменной структуры\n  Задачи активной уборки космического мусора\n  Средства отделения и раскрытия подвижных элементов конструкции космических аппаратов\n  Компьютерная графика\n  Информационные технологии\n\n\nНаучная работа\n\n\n  Статьи\n  Профиль в Scopus\n  Профиль в РИНЦ\n  Профиль в WoS\n\n\nОбразовательная деятельность\n\n\n  Динамика твёрдого тела и систем твёрдых тел\n  Технологии и языки программирования\n  Компьютерная графика\n  Информатика\n  Управление ИТ-сервисом и контентом\n  Основы Wolfram Mathematica\n  Основы MATLAB\n  Базы данных\n  Прикладные задачи динамики твердого тела и систем тел\n  Методы вычислений\n  Основы SimInTech\n\n\nСсылки\n\n\n  Youtube\n  RuTube\n\n",
      "url": "/about/"
    },{
      
      "title": "Матричная алгебра",
      
      "content": "Матрицы перемножаются по правилам матричной алгебры\n\n&gt;&gt; a = [1 2; 3 4];\n\n\n&gt;&gt; b = a*a\n\nb =\n     7    10\n    15    22\n\n\nЕсли необходимо перемножить матрицы поэлементно, то необходимо использовать оператор .* Конечно, матрицы должны быть одной размерности\n\n&gt;&gt; b = a.*a\n\nb =\n     1     4\n     9    16\n\n\nЭто же относится к операции возведения в степень. Возведение в степень 2 матрицы  a эквивалентно умножению этой матрицы на саму себя\n\n&gt;&gt; b = a^2\n\nb =\n     7    10\n    15    22\n\n\nЕсли нужно возвести в квадрат каждый элемент матрицы, то необходимо использовать оператор .^\n\n&gt;&gt; a.^2\n\nans =\n     1     4\n     9    16\n\n\nДеление матрицы a на матрицу b означает умножение матрицы a на обратную к b матрицу\n\n&gt;&gt; a = [1 2; \n        3 4];\n \n&gt;&gt; b = [4 3; \n        1 8];\n\n&gt;&gt; c = a/b\n\nc =\n    0.2069    0.1724\n    0.6897    0.2414\n\n&gt;&gt; c = a*inv(b)\n\nc =\n    0.2069    0.1724\n    0.6897    0.2414\n\n\nЕсли нужно поделить поэлементно одну матрицу на другую, то необходимо использовать оператор деления с точкой ./\n\n&gt;&gt; c = a./b \n\nc =\n    0.2500    0.6667\n    3.0000    0.5000\n\n",
      "url": "/pages/matlab/algebra/"
    },{
      
      "title": "Анимация в Wolfram Mathematica",
      
      "content": "\n  Пример\n  Модель самолета из примера\n\n",
      "url": "/pages/wolfram/animation/"
    },{
      
      "title": "Дополнительное задание по курсу Базы данных",
      
      "content": "Разработка информационной системы склада.\n\nЧасть 1\n\nНапишите SQL-код для создания в базе данных трех таблиц:\n\n  Клиенты (Customers),\n  Заказы (Orders),\n  Продукты (Products).\n\n\nВ таблице Customers должны быть следующие поля:\n\n  CustomerID (целое число, первичный ключ)\n  CustomerName (текст)\n  ContactName (текст)\n  Address (текст)\n  OrderDate (текст)\n  ShipDate (текст)\n\n\nВ таблице Orders должны быть следующие поля:\n\n  OrderID (целое число, первичный ключ)\n  CustomerID (целое число, внешний ключ к таблице Customers)\n  OrderDate (дата)\n  ShipDate (дата)\n\n\nВ таблице «Товары» должны быть следующие поля:\n\n  ProductID (целое число, первичный ключ)\n  ProductName (текст)\n  SupplierID (целое число)\n  CategoryID (целое число)\n  Price (decimal)\n\n\nНапишите SQL код для создания этих таблиц и установления необходимых отношений (внешние ключи, таблицы связей) между ними (таблиц может быть больше 3).\n\nЧасть 2\n\nДобавьте в созданные ранее таблицы данные: по 5 клиентов из 3 стран (Россия, Китай, Бразилия), не менее 10 заказов, размещенных в 2021 и 2022 годах (часть заказов не отправлена) и не менее 5 товаров. Напишите код SQL, выполняющий следующие запросы к базе данных:\n\n  Получите всю информацию о клиенте, включая имя клиента, имя контактного лица и страну.\n  Получите всю информацию о заказе, включая идентификатор заказа, имя клиента и дату заказа для всех заказов, размещенных в 2021 году.\n  Получите все заказы, которые еще не были отправлены, включая идентификатор заказа, имя клиента и дату заказа.\n  Найдите всех клиентов из России, разместивших заказ в 2021 году, включая их имя, контактное имя и адрес.\n\n\nНапишите код SQL для извлечения этих данных из таблиц. Код должен включать соответствующие предложения SQL, такие как SELECT, FROM, WHERE и JOIN.\n",
      "url": "/pages/databases/aux-task-1/"
    },{
      
      "title": "Интегрирование уравнения материальной движения точки и верификация решения",
      "description": "Численное решение задачи баллистики с учётом сопротивления воздуха и верификация полученного решения в среде Python, используя теорему об изменении кинетической энергии.\n",
      "content": "import numpy as np\nfrom scipy.integrate import solve_ivp\nfrom collections import namedtuple\nimport matplotlib.pyplot as plt\nimport scipy.integrate as integrate\n\n\nПараметры модели\n\nПараметры модели задаются при помощи именованного кортежа\n\np = namedtuple(\"params\", \"m Cx rho Sm g\")\n# Масса\np.m = 5;\n# Ускорение свободного падения\np.g = 9.807\n# Аэродинамический коэффициент лобового сопротивления\np.Cx = 1.0;\n# Характерная площадь\np.Sm = np.pi*0.2**2/4\n# Плотность воздуха\np.rho = 1.2  \n\n\nФункция правых частей\n\nФункция правых частей описывает дифференциальное уравнение второго порядка (как систему двух уравнений первого порядка) движения материальной точки под действием силы тяжести в однородном поле и аэродинамической силы сопротивления, направленной в противоположную сторону скорости:\n\n\n  \n    \n      [m \\frac{d \\vec{v}}{dt} = - m \\vec{g} - \\frac{\\vec{v}}{\n      \\vec v\n      } C_x S_m q.]\n    \n  \n\n\ndef dydt(t, q, p):     \n    r = q[0:2];    \n    v = q[2:4];\n    # Скоростной напор    \n    dynamic_pressure = p.rho*np.dot(v,v)*0.5;   \n    # Аэродинамическая сила\n    Fa = -v/np.sqrt(np.dot(v,v))*p.Cx*p.Sm*dynamic_pressure;\n    # Сила тяжести\n    G = np.array([0,-p.m*p.g]);\n    # Координатный столбец главного вектора сил, действующего на тело\n    F = G + Fa;\n    # Ускорение\n    a = F/p.m;\n    return np.hstack([v,a]) \n\n\nФункция для остановки процесса интегрирования при h = 0\n\nФункция-“детектор”, передаваемая в интегратор (параметр events), для определения времени достижения нулевой высоты и остановки процесса интегрирования.\n\ndef event_h_eq_0(t, q):  \n  # Возвращаем высоту (контролируемая функция)\n  return q[1]  \n\n# функция-детектор срабатывает при условии h = 0 при движении \"вниз\" (при убывании контролируемой функции) \nevent_h_eq_0.direction = -1\n# функция-детектор останавливает процесс\nevent_h_eq_0.terminal  = True  \n\n\nНачальные условия и запуск численного интегрирования\n\nv0     = 30\nphi0   = np.deg2rad(45)\nr0_vec = [0,0]\nv0_vec = [v0*np.cos(phi0),v0*np.sin(phi0)]\nq0     = np.hstack([r0_vec,v0_vec])\n\n\nsol = solve_ivp(lambda t,q: dydt(t,q,p), [0, 5], q0, method='RK45', rtol = 1e-8, max_step = 0.5, events = [event_h_eq_0])\n\n\nВид решения\n\n  message: A termination event occurred.\n  success: True\n   status: 1\n        t: [ 0.000e+00  1.445e-02  1.590e-01  5.280e-01  9.195e-01\n             1.343e+00  1.790e+00  2.244e+00  2.703e+00  3.187e+00\n             3.687e+00  4.053e+00]\n        y: [[ 0.000e+00  3.064e-01 ...  6.725e+01  7.295e+01]\n            [ 0.000e+00  3.053e-01 ...  6.322e+00 -8.882e-15]\n            [ 2.121e+01  2.118e+01 ...  1.585e+01  1.535e+01]\n            [ 2.121e+01  2.104e+01 ... -1.577e+01 -1.880e+01]]\n      sol: None\n t_events: [array([ 4.053e+00])]\n y_events: [array([[ 7.295e+01, -8.882e-15,  1.535e+01, -1.880e+01]])]\n     nfev: 68\n     njev: 0\n      nlu: 0\n\n\nРешение\n\nТраектория\n\nplt.plot(sol.y[0],sol.y[1],'.-'); plt.grid(ls=':'); plt.xlabel('x, м'); plt.ylabel('y, м');\n\n\nВерификация\n\nТеорема об изменении кинетической энергии\n\n[T_k - T_0 = A_a + A_g,]\n\n\\(A_a\\) - работа аэродинамической силы сопротивления, \\(A_g = 0\\) т.к. изменение высоты равно нулю. Работа силы сопротивления:\n\n[dA_a = \\vec{F} \\cdot \\vec{V} dt, \\quad A_a = \\int_0^{t_k} \\vec{F} \\cdot \\vec{V} dt]\n\nv = sol.y[2:4].T\nv\n\narray([[ 21.21320344,  21.21320344],\n       [ 21.17864132,  21.03701046],\n       [ 20.84522028,  19.29945152],\n       [ 20.0850104 ,  15.04180359],\n       [ 19.39798133,  10.75264161],\n       [ 18.76020505,   6.30836944],\n       [ 18.17157011,   1.79943502],\n       [ 17.62244665,  -2.6357364 ],\n       [ 17.07976753,  -6.99151935],\n       [ 16.49182395, -11.41599742],\n       [ 15.84673062, -15.77466726],\n       [ 15.34602733, -18.80247627]])\n\n\nОпределим модуль скорости:\n\nv_norm = np.sqrt(np.sum(v*v,axis=1))\nv_norm\n\narray([30.        , 29.85114164, 28.40760528, 25.09309662, 22.17884085,\n       19.79244347, 18.26044705, 17.81846605, 18.45534615, 20.05754856,\n       22.35976294, 24.27001584])\n\n\nСкоростной напор:\n\ndynamic_pressure = p.rho*(v_norm**2)*0.5\n\n\nЕдиничный вектор направления скорости точки:\n\nev = v/np.reshape(v_norm,[-1,1])\nev\n\narray([[ 0.70710678,  0.70710678],\n       [ 0.70947509,  0.70473052],\n       [ 0.73379013,  0.67937622],\n       [ 0.80041976,  0.59943991],\n       [ 0.87461655,  0.48481531],\n       [ 0.94784684,  0.31872616],\n       [ 0.99513282,  0.09854277],\n       [ 0.98899909, -0.14792162],\n       [ 0.92546449, -0.37883437],\n       [ 0.8222253 , -0.56916215],\n       [ 0.7087164 , -0.70549349],\n       [ 0.63230397, -0.7747204 ]])\n\n\nАэродинамическая сила\n\nFa = -ev*p.Cx*p.Sm*np.reshape(dynamic_pressure,[-1,1])\n\n\nМощность аэродинамической силы\n\ndW = np.sum(Fa*v,axis=1)\n\nplt.figure(figsize=[8,4])\nplt.plot(sol.t,dW,'.-')\nplt.ylim([-550,0])\nplt.fill_between(sol.t,dW, alpha=0.3)\nplt.xlabel('t, c')\nplt.ylabel('Мощность, Вт')\n\n\nРабота аэродинамической силы\n\nWork_aero = integrate.simps(dW,x=sol.t)\nWork_aero\n\n-777.4154150947423\n\n\nНачальная кинетическая энергия\n\nT0 = v_norm[ 0]**2*p.m*0.5\n\n\nКонечная кинетическая энергия\n\nTK = v_norm[-1]**2*p.m*0.5\n\n\nИзменение кинетической энергии\n\ndelta_T = TK - T0\ndelta_T\n\n-777.4158275842642\n\n\nПогрешность\n\nОтносительная погрешность\n\n[\\varepsilon = \\frac{\\Delta T - A_a}{\\Delta T} 100 \\%]\n\n100*(delta_T-Work_aero)/delta_T\n\n5.305905890102044e-05\n\n\nАбсолютная погрешность\n\n[a = \\Delta T - A_a]\n\ndelta_T-Work_aero\n\n-0.0004124895218637903\n\n\n",
      "url": "/pages/python/ballistic-verification/"
    },{
      
      "title": "Pascal",
      "description": "Структура программы, ключевые слова, типы данных\n",
      "content": "Ключевые cлова\n\n\n  \n    \n      and\n      end\n      nil\n      set\n    \n    \n      array\n      file\n      not\n      then\n    \n    \n      begin\n      for\n      of\n      to\n    \n    \n      const\n      goto\n      packed\n      until\n    \n    \n      case\n      function\n      or\n      type\n    \n    \n      div\n      if\n      procedure\n      var\n    \n    \n      do\n      in\n      program\n      while\n    \n    \n      downto\n      label\n      record\n      with\n    \n    \n      else\n      mod\n      repeat\n       \n    \n  \n\n\nСтруктура программы\n\nProgram MyFirstProgram;\n\n  &lt;раздел описаний&gt;\n\nbegin\n\n  &lt;оператор 1&gt;;\n  &lt;оператор 2&gt;;\n  . . . . . . .\n  &lt;оператор N&gt;;\n\nend.\n\n\nПрограмма, которая выводит на экран сообщение “Здравствуй Мир!”\n\nProgram HelloWorld;\nBegin\n   writeln('Здравствуй Мир!');\nEnd.\n\n\nРаздел описаний\n\nРаздел подключаемых модулей\n\nЭтот раздел должен быть первым в разделе описаний. Раздел подключаемых модулей описывает модули, написанные на языке Паскаль в которых объявлены процедуры\n",
      "url": "/pages/informatics/base_syntax/"
    },{
      
      "title": "Манипуляции с матрицами",
      
      "content": "Ввод матрицы\n\nОсновным типом данных в MATLAB является матрица. Элементы матрицы записываются в квадратных скобках. Элементы в строке разделяются запятыми или пробелами:\n\na = [1  2  3]\na = [1, 2, 3]\n\n\nДля ввода матрицы-столбца элементы необходимо разделять точками с запятой\n\na = [1; 2; 3]\n\n\nПрямоугольная или квадратная матрица вводится построчно\n\na = [1 2 3; 4 5 6]\n\n\nКаждую строку матрицы для наглядности можно начинать в коде скрипта или функции с новой строки:\n\na = [1 2 3; \n     4 5 6]\n\n\nСоздание последовательностей\n\nОператор : формирует матрицу-строку от начального значения до конечного значения с заданным шагом:\n\n&gt;&gt; a = 1:0.5:3.9\n\na =\n\n    1.0000    1.5000    2.0000    2.5000    3.0000    3.5000\n\n\nФункция linspace разбивает интервал, заданный своими границами на заданное количество точек\n\n&gt;&gt; a = linspace(1,3.9,4)\n\na =\n    1.0000    1.9667    2.9333    3.9000\n\n\nСпециальные матрицы\n\nМатрица единиц:\n\n&gt;&gt; ones(3,2)\n\nans =\n\n     1     1\n     1     1\n     1     1\n\n\nПри вызове функции с одним аргументом, результатом является квадратная матрица\n\n&gt;&gt; ones(3)\n\nans =\n\n     1     1    1\n     1     1    1\n     1     1    1\n\n\nМатрица нулей\n\n&gt;&gt; zeros(3,2)\n\nans =\n\n     0     0\n     0     0\n     0     0\n\n&gt;&gt; zeros(3)\n\nans =\n\n     0     0    0\n     0     0    0\n     0     0    0\n\n\n\nЕдиничная матрица\n\n&gt;&gt; eye(3)\n\nans =\n\n     1     0    0\n     0     1    0\n     0     0    1\n\n\nОбъединение матриц\n\nСклейка строк (слева направо)\n\n&gt;&gt; a = [1 2 3];\n&gt;&gt; b = [3 5 5];\n&gt;&gt; c = [a b]\n\nc =\n     1     2     3     3     5     5\n~~\n\nТо же самое делает функция **cat**. Склеиваем матрицы по второму измерению (склеиваем столбцы - \"клей наносим справа/слева\") \n\n~~~matlab\n&gt;&gt; cat(2, a, b)\n\nans =\n     1     2     3     3     5     5\n\n\nСклеиваем матрицы по второму измерению (склеиваем столбцы - “клей наносим снизу/сверху”)\n\n&gt;&gt; cat(1, a, b)\n\nans =\n     1     2     3\n     3     5     5\n\n\nИзменение формы матрицы\n\n&gt;&gt; a = [1 2 3;\n        4 5 6;\n        7 8 9;\n        10 1 12]\n\na =\n     1     2     3\n     4     5     6\n     7     8     9\n    10     1    12\n\n\nПревратить матрицу a в матрицу 2 x 6. Указываем только первую размерность, второй размер вычисляется на основе количества элементов в исходной матрице:\n\n&gt;&gt; a = reshape(a, 2, [])\n\na =\n     1     7     2     8     3     9\n     4    10     5     1     6    12\n\n\nМожно указать только второй размер новой матрицы. В этом случае первый размер определится автоматически:\n\n&gt;&gt; a = reshape(a, [], 2)\n\na =\n     1     8\n     4     1\n     7     3\n    10     6\n     2     9\n     5    12\n\n\nМожно явно указать обе размерности\n\n&gt;&gt; a = reshape(a, 3, 4)\n\na =\n     1    10     8     6\n     4     2     1     9\n     7     5     3    12\n\n\nОперация транспонирования матрицы выполняется при помощи оператора ‘ (одинарная кавычка)\n\n&gt;&gt; a'\n\nans =\n     1     4     7\n    10     2     5\n     8     1     3\n     6     9    12\n\n\nили при помощи функции transpose\n\n&gt;&gt; transpose(a)\n\nans =\n     1     4     7\n    10     2     5\n     8     1     3\n     6     9    12\n\n\nКопирование матриц\n\nДана матрица-столбец\n\n&gt;&gt; a = [1; 2];\n\n\nИспользуем функцию repmat: повторяем столбец 5 раз вдоль второго измерения и 1 раз (т.е. ничего не меняем) по первой размерности:\n\n&gt;&gt; repmat(a, 1, 5)\n\nans =\n     1     1     1     1     1\n     2     2     2     2     2\n\n\nМожно сделать копии по двум размерностям\n\n&gt;&gt; b = repmat(a, 2, 5)\n\nb =\n     1     1     1     1     1\n     2     2     2     2     2\n     1     1     1     1     1\n     2     2     2     2     2\n\n\n",
      "url": "/pages/matlab/basic/"
    },{
      
      "title": "Ячейки",
      
      "content": "Для хранения в матричном виде элементов различных типов используются ячейки.\n\nСоздание матрицы ячеек\n\nДля создания матриц ячеек используется функция cell.   Создадим пустую матрицу ячеек 3x3:\n\n&gt;&gt; data = cell(3)\n\ndata =\n  3×3 cell array\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\nПрямоугольная матрица ячеек\n\n&gt;&gt; data = cell(2,3)\n\ndata =\n  2×3 cell array\n    {0×0 double}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\n\nВ отличие от числовых матриц, обращение к элементам матрицы ячеек выполняется при помощи индексов элементов в фигурных скобках, а не в круглых. Запишем в ячейку {1, 1} число\n\n&gt;&gt; data{1,1} = 123\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {0×0 double}\n\n\nв ячейку {2, 3} строку\n\n&gt;&gt; data{2,3} = 'Текст '\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {0×0 double}    {'Текст '  }\n\n\nа в ячейку {2, 2} матрицу\n\n&gt;&gt; data{2,2} = [1 2; 3 4]\n\ndata =\n  2×3 cell array\n    {[     123]}    {0×0 double}    {0×0 double}\n    {0×0 double}    {2×2 double}    {'Текст '  }\n\n\nСодержимое матрицы\n\n&gt;&gt; data{2,3}\n\nans =\n    'Текст '\n\n&gt;&gt; data{2,2}\n\nans =\n     1     2\n     3     4    \n\n\nПреобразование\n\nЕсли матрица ячеек содержит только числовые значения, то её можно преобразовать в числовую матрицу при помощи функции cell2mat.\n\nСоздадим матрицу-столбец из двух ячеек. Каждая ячейка содержит числовую матрицу строку:\n\n&gt;&gt; a = {[1,2,3];[4,5,6]}\n\na =\n  2×1 cell array\n    {1×3 double}\n    {1×3 double}\n\n\nПреобразование матрицы ячеек в числовую матрицу\n\n&gt;&gt; cell2mat(a)\n\nans =\n     1     2     3\n     4     5     6\n\n\nЕсли первая ячейка будет содержать матрицу-строку, а вторая – матрицу-столбец, то такое преобразование будет невозможно\n\n&gt;&gt; a = {[1,2,3];[4;5;6]}\n\na =\n  2×1 cell array\n    {1×3 double}\n    {3×1 double}\n\n&gt;&gt; cell2mat(a)\n\nError using cat\nDimensions of arrays being concatenated are not consistent.\n\nError in cell2mat (line 83)\n            m{n} = cat(1,c{:,n});\n\n\nОбратное преобразование числовой матрицы в матрицу ячеек выполняется при помощи функции mat2cell.\nПредположим, что есть квадратная матрица 5x5:\n\n&gt;&gt; a = magic(5)\n\na =\n    17    24     1     8    15\n    23     5     7    14    16\n     4     6    13    20    22\n    10    12    19    21     3\n    11    18    25     2     9\n\n\nРассечём эту матрицу одной горизонтальной линией и двумя вертикальными так, чтобы получилась матрица ячеек 2 на 3, в которой элемент {1,1} содержит первые две строки и два столбца исходной матрицы, элемент {1,2} – две первые строки и столбцы 3 и 4 исходной матрицы:\n\n&gt;&gt; c = mat2cell(a,[2 3],[2 2 1])\n\nc =\n  2×3 cell array\n    {2×2 double}    {2×2 double}    {2×1 double}\n    {3×2 double}    {3×2 double}    {3×1 double}\n\n\nВторым аргументом указывается массив с количествами строк каждой подматрицы, вторым аргументом – количество столбцов у каждой подматрицы. Проверяем результат:\n\n&gt;&gt; c{1,1}\n\nans =\n    17    24\n    23     5\n\n&gt;&gt; c{1,2}\n\nans =\n     1     8\n     7    14\n\n&gt;&gt; c{2,1}\n\nans =\n     4     6\n    10    12\n    11    18\n\n\n",
      "url": "/pages/matlab/cells/"
    },{
      
      "title": "Модель относительного движения ступеней ракеты-носителя при \"холодном\" разделении",
      "description": "Задание для выпускной квалификационной работы (бакалавриат, 2024).\n",
      "content": "Исходные данные\n\nПервая и вторая ступень ракеты-носителя (РН) разделяются по “холодной” схеме: в начале производится выключение двигателя первой ступени, затем разделяется поперечный стык первой и второй ступени и при помощи пневматических толкателей ступени расталкиваются в противоположных направлениях. После расхождения ступеней на некоторое расстояние запускается двигатель второй ступени.\n\n\n\n1 - Блок первой ступени, 2 - блок второй ступени, 3 - сопло двигателя второй ступени, 4 - критическое сечение сопла блока второй ступени, 5 - пневматический толкатель отделения (цилиндр), 6 - шток толкателя отделения, 7 - клапан открытия пневмосистемы для заполнения рабочей полости толкателя, 8 - баллон с рабочим телом (сжатый воздух).\n\nРисунок 1 - Схема разделения\n\n\n  Масса первой ступени 50 тонн, длина \\(L_{1}\\) = 40 метров. Центр масс находится на расстоянии \\(x_{c1}\\) = 12 метров от нижнего срез ступени. Центр масс может быть смещен от продольной оси первой ступени на расстояние до 40 мм. Момент инерции ступени относительно поперечной оси, проходящей через центр масс 3000000 кг\\(\\cdot\\)м\\(^2\\).\n  Масса второй ступени 100 тонн, центр масс находится на расстоянии \\(x_{c2}\\) = 10 метров от разделяемого стыка с первой ступенью. Центр масс может быть смещен от продольной оси второй ступени на расстояние до 40 мм. Момент инерции ступени относительно поперечной оси, проходящей через центр масс 5000000 кг\\(\\cdot\\)м\\(^2\\).\n  На первой ступени установлен пневматический толкатель, упирающийся в области критического сечения сопла двигателя второй ступени.\n\n\nЗадание\n\n\n  Разработать модель холодного разделения ступеней многоразовой РН при помощи пневматического толкателя.\n  Определить параметры пневмосистемы разделения ступеней (давление, ход штока, диаметр штока, механическая работа).\n  Определить продолжительность заполнения рабочей полости толкателя рабочим телом (после открытия клапана).\n  Определить кинематические параметры разделяемых ступеней после окончания работы толкателей\n  Оценить безударность относительного движения ступеней и сформулировать требования к минимальному зазору между соплом блока второй ступени и конструкцией верхнего отсека блока первой ступени.\n  Продолжительность работы толкателя должны быть не более 2 с, относительная скорость между блоками первой и второй ступени должна быть не менее 4 м/с.\n\n\nЛитература и ссылки\n\n\n  Холодное разделение ступеней РН Falcon-9\n  К. С. Колесников, В. В. Кокушкин, С. В. Борзых, Н. В. Панкова Расчёт и проектирование систем разделения ступеней ракет. М.: Издательство МГТУ им. Н.Э. Баумана, 2006. (стр. 101, п. 2.3 Сила Пневматического толкателя).\n  Е. В. Герц, Г. В. Крейнин Расчёт пневмоприводов Справочное пособие М.: Машиностроение, 1975.\n\n",
      "url": "/pages/thesis/2024/cold-separation/"
    },{
      
      "title": "Колонизация",
      "description": "Определение оптимального пути облёта ближайших звёздных систем\n",
      "content": "В текстовом файле заданы координаты ближайших семи к Солнцу звёздных систем:\n\nИмя,                x (пк),    y (пк),    z (пк)\nАльфа Центавра,  -0.472264, -0.361451, -1.151219\nЗвезда Барнарда, -0.017373, -1.816613,  0.149123\nВольф 359,       -0.017373, -1.816613,  0.149123\nЛаланд 21185,    -2.282811,  0.649334,  0.292057\nСириус,          -0.494323,  2.476731, -0.758485\nЭпсилон Эридана,  1.898970,  2.541426, -0.528523\nПроцион,         -1.469312,  3.176170,  0.320024\n\n\nКоординаты выражены в парсеках\n\nДля заданного количества \\(n \\leq 7\\) ближайших звёздных систем определить наиболее оптимальный маршрут их облёта.\n\nОт системы к системе корабль первую половину пути движется с постоянным ускорением, вторую - с замедлением. Ускорение и замедление равно ускорению свободного падения для того, чтобы экипаж корабля в течение всего полёта жил в условиях земной гравитации.\n\nПостроить (вывести на экран) таблицу облёта всех  \\(n\\) звёздных систем в следующем виде:\n\n\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n| № | Отправление    | Прибытие       | Расст., св. лет. | Tкор, лет | Tз, лет | Макс. скорость |\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n| 1 | Солнце         | Альфа Центавра | ...              | ...       | 0.5с    |                |\n| 2 | Альфа Центавра | Вольф 359      | ...              | ...       | ...     |                |\n| 3 | ...            | ...            | ...              | ...       | ...     |                |\n|---+----------------+----------------+------------------+-----------+---------+----------------|\n\nСуммарная длина маршрута ... св. лет.\n\nСуммарная продолжительность маршрута:\n- по часам корабля ... лет\n- по часам Зкмли   ... лет\n\nМаксимальная скорость ...c\n\n\n\nВ каждой строке таблицы должны быть указаны\n\n  точка отправления;\n  точка прибытия;\n  расстояние в световых годах;\n  время перелёта по часам корабля (в годах);\n  время перелёта по часам Земли;\n  максимальная скорость корабля в долях скорости света\n\n\nИтоговый результат (под таблицей):\n\n  пройденный кораблём путь\n  итоговая продолжительность полёта по часам корабля\n  итоговая продолжительность полёта по часам Земли\n\n\nПрограмма должна вывести на экран и сохранить в файл png две проекции маршрута на плоскость xz и xy, на которых дисками обозначены звездные системы.\n\nhttp://www.zitterbug.net/future/future815.html\nhttp://math.ucr.edu/home/baez/physics/Relativity/SR/Rocket/rocket.html\n\nСписок заданий\n",
      "url": "/pages/python/course_works/colonization/"
    },{
      
      "title": "Комментарии к представленным решения контрольной работы",
      
      "content": "К решению задания 2\n\nНайти максимальное значение табличной функции и значение аргумента, которое соответствует этому значению. Пусть задана табличная функция:\n\nx = [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0];\ny = [0.06,1.24,1.94,1.69,1.24,0.4,-0.23,-0.41,-0.06,0.34,0.35];\n\n\nЕсли вызвать функцию max с одной переменной под результат (слева от знака равно):\n\nymax = max(y)\n\n\nто она вернет только максимальное значение из массива y. Нас же интересует не только максимальное значение, но и его номер в массиве y, при помощи которого мы найдем соответствующее значение x. Для этого есть второй вариант вызова функции max (min), о чем написано в справочной системе:\n\n[ymax, iymax] = max(y)\n\n\nВ ymax запишется 1,94, а в iymax - 3. Т.е. максимальное значение y находится под индексом 3 в массиве y. Используем этот индекс извлечения значения x:\n\n x_ymax = x(imax)\n\n\nК решению задания 5\n\nДля определения среднего значения функции нужно вспомнить интегральное исчисление, а не создавать для построения графика среднего значения таблицу:\n\ny1 = [k1 k1 k1 k1 k1 k1]\n\n\nгде k1 это среднее значение в массиве y табличной функции. Во-первых, при таком решении результат будет неправильным (кроме некоторых частных случаев). Во-вторых, чтобы провести горизонтальную линию на графике достаточно двух точек.\n\nСреднее значение функции определяется следующим образом:\n\n[\\hat f = \\frac{1}{b-a} \\int_a^b f(x) dx]\n\nПравильное решение задания 5:\n\n% Табличная функция \nx = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0];\ny = [8.49, 7.72, 5.47, 1.8, -1.28, -5.07, -6.34];\n\n% Интеграл (метод трапеций)\nsy = trapz(x,y);\n\n% Крайние точки интервала (первая и последняя из массива x)\na = x(1); b = x(end);\n\n% Среднее значение функции\nmean_y = sy/(b-a);\n\n% График функции\nfigure;\nplot(x,y);\nhold on;\n\n% Пунктирный отрезок от (a,mean_y) до (b,mean_y)\nplot ([a, b], [mean_y, mean_y],'--');\nhold off;\n\nxlabel('x'); ylabel('y');\nlegend('Функция', 'Среднее значение');\n\n\nК решению задания 9\n\nДля дифференцирования табличной функции используются известные формулы численного дифференцирования, например, самая простая двухточечная формула:\n\n[y’(x) = \\frac{y(x+h)-y(x)}{h}]\n\nДля табличной функции\n\nx = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];\ny = [0.0, 0.16, 0.31, 0.45, 0.59, 0.71, 0.81, 0.89, 0.95, 0.99, 1.0];\n\n\nРешение может быть таким\n\n% Шаг таблицы\nh = 0.1;\n% Значение x при котром необходимо оценить значение производной функции\nxi = 0.7; \n% Создаем интерполирующую функцию (линейная интерполяция), \n% чтобы не искать вручную положение xi в массиве и значения функции при xi+h  \nyx = @(xi) interp1(x, y, xi);\n% Оценка производной\ndfdx = (yx(xi+h)-yx(xi))/h;\n\n\nК решению задания 10\n\nИзвестны координаты семи точек на плоскости, заданных массивами координат \\(x\\) и \\(y\\), например:\n\nx = [5, 9, 9, 2, 9, 6, 7];\ny = [2, 2, 6, 7, 1, 5, 5];\n\n\nЧтобы найти пары координаты двух ближайших точек и расстояние между ними нужно перебрать все возможные варианты пар точек. Из \\(m=7\\) точек можно составить \\(n\\) сочетаний по \\(k=2\\) элементов:\n\n[n = \\frac{m!}{k!(m-k)!}]\n\nЭто выражение можно вычислить при помощи функции factorial:\n\nm = numel(x);\nk = 2;\nn = factorial(m)/(factorial(k)*factorial(m-k));\n\n\nили при помощи встроенной функции nchoosek:\n\nn = nchoosek(numel(x),2);\n\n\nЗная n, при помощи двух вложенных циклов можно создать массив сочетаний, в который будем записывать номера пар точек и расстояние между ними:\n\n% Резервируем место под матрицу \n% В первом столбце будет номер первой точки пары,\n% во втором столбце - номер второй точки пары,\n% в третьем - расстояние между точками.\ndist = zeros(n,3);\n% номер первой строки dist\nk = 1;\nfor i1 = 1:numel(x)-1 % i1 изменяется от первого до предпоследнего\n    for i2 = i1+1:numel(x) % i2 изменяется от i1+1 до последнего       \n        % Расстояние между точками\n        d = sqrt( (x(i1)-x(i2))^2 + (y(i1)-y(i2))^2 );\n        % Записываем в строку k номера точек и расстояние между ними\n        dist(k,:) = [i1, i2, d];\n        % Переходим к следующей строке \n        k = k + 1;\n    end\nend\n\n% Определяем минимальное значение в третьем столбце (расстояние) и номер строки, \n% min_pair_index, которая соответствует этому минимальному расстоянию\n[mind, min_pair_index] = min(dist(:,3));\n\n% Первая точка\nx1 = x(dist(min_pair_index,1));\ny1 = y(dist(min_pair_index,1));\n% Вторая точка\nx2 = x(dist(min_pair_index,2));\ny2 = y(dist(min_pair_index,2));\n\n% Выводим на экран значения координат точек, расстояние между между которыми \n% минимально\nfprintf('x1 = %i, y1 = %i\\n',x1, y1);\nfprintf('x2 = %i, y2 = %i\\n',x2, y2);\n\n% Определяем максимальное расстояние\nmaxd = max(dist(:,3));\n% Определяем среднее расстояние\nmeand = mean(dist(:,3));\n\n\nЕсли первым аргументов в функцию nchoosek передать массив, то функция вернет все сочетания элементов массива по k (второй аргумент). Например, результатом работы функции\n\nnchoosek([1,2,3,4],2)\n\n\nбудет\n\n1,2\n1,3\n1,4\n2,3\n2,4\n3,4\n\n\nт.е. все возможные сочетания пар элементов из массива 1, 2, 3, 4.\n\nЭту функцию вместе с функцией arrayfun можно использовать для перебора всех пар точек без использования циклов:\n\n% Все пары номеров точек\ni1i2 = nchoosek(1:length(x),2);\n\n% Для каждого элемента из первого и второго столбца номеров вызываем функцию \n% двух переменных, которая определяет расстояние между точками i1 и i2\ndist = arrayfun(@(i1,i2) sqrt((x(i1)-x(i2))^2+(y(i1)-y(i2))^2), i1i2(:,1), i1i2(:,2));\n\n% Определяем минимальное расстояние между точками \n[mind, k] = min(dist);\n% По номеру строки с минимальным значением расстояния из массива d \n% извлекаем координаты точек из массивов x и y\nfprintf('x1 = %i, y1 = %i\\n',x(i1i2(k,1)), y(i1i2(k,1)));\nfprintf('x2 = %i, y2 = %i\\n',x(i1i2(k,2)), y(i1i2(k,2)));\n\n% Определяем максимальное расстояние\nmaxd = max(dist(:,3));\n% Определяем среднее расстояние\nmeand = mean(dist(:,3));\n\n\n",
      "url": "/pages/matlab/comments_test_2022_matlab/"
    },{
      
      "title": "Компьютерный практикум по механике",
      
      "content": "\n  Относительное орбитальное движение\n\n",
      "url": "/pages/comp_mechanics/"
    },{
      
      "title": "Использование функций scipy.stats. Доверительные интервалы.",
      
      "content": "В математической статистике интервальной оценкой называется результат использования выборки для вычисления интервала возможных значений неизвестного параметра, оценку которого нужно построить. Следует отличать от точечной оценки, которая даёт лишь одно значение. Самым распространенным видом интервальных оценок являются доверительные интервалы.\n\nДоверительная вероятность - вероятность того, что доверительный интервал накроет неизвестное истинное значение параметра, оцениваемого по выборочным данным.\n\nОценка математического ожидания нормального распределения при известном \\(\\sigma\\)\n\nКоличественный признак генеральной совокупности X распределен нормально и известно среднеквадратическое отклонение этого распределения. Из генеральной совокупности формируется выборка, по которой определяется математическое ожидание выборки \\(\\hat{x}\\).\n\nНеобходимо найти доверительный интервал \\([\\hat{x}-d, \\hat{x}+d]\\), который покрывает неизвестное математическое ожидание \\(a\\) генеральной совокупности с надежностью или доверительной вероятностью \\(\\gamma\\):\n\\(P(|\\hat{x}-a|&lt;d) = \\gamma\\)\n\nМатематическое ожидание выборки \\(\\hat{x}\\) рассматривается как нормально-распределенная случайная величина с математическим ожиданием \\(\\hat{x}\\) и стандартным отклонением \\(\\sigma/\\sqrt{n}\\).\n\n# Стандартное отклонение генеральной совокупности\nsigma = 0.8\n# Математическое ожидание генеральной совокупности\nmean  = 4.1\n# Формируем выборку из генеральной совокупности\n# Объем выборки\nn = 30\n# Выборка\ndata = np.random.normal(loc=mean, scale=sigma, size=n)\n# Надежность оценки (доверительная вероятность)\ngamma = 0.95\n# Оценка математического ожидания выборки\nmean_of_sample = np.mean(data)\n# Стандартное отклонение выборочной средней \nsigma_of_mean = scipy.stats.sem(data)\n\n\nВызываем функцию scipy.stats.norm.interval:\n\n  первый аргумент: надежность оценки (доверительная вероятность)\n  второй аргумент (loc): оценка математического ожидания\n  третий аргумент (scale): оценка стандартного отклонения математического ожидания выборки, вычисляемой при помощи функции scipy.stats.sem\n\n\ninterval = scipy.stats.norm.interval(gamma, loc = mean_of_sample, scale = sigma_of_mean)\nprint('Математическое ожидание принадлежит интервалу [{:4.2f}; {:4.2f}]'.format(interval[0],interval[1]))\n\n\nРезультат:\nМатематическое ожидание принадлежит интервалу [3.89; 4.47]\n\n\nОценка математического ожидания нормального распределения при неизвестном \\(\\sigma\\)\n\nЕсли стандартное отклонение генеральной совокупности неизвестно, то для определения доверительного интервала используется распределение Стьюдента:\n\n[P(\\hat{x}-t_\\gamma s/\\sqrt{n} &lt; a &lt; \\hat{x}+t_\\gamma s/\\sqrt{n}) = 2 \\int_{0}^{t_\\gamma} S(t,n) dt = \\gamma]\n\nгде \\(s\\) - “исправленное” среднеквадратичное отклонение выборки, \\(S(t,n)\\) - плотность распределения Стьюдента.\n\n# Надежность оценки\ngamma = 0.95\n# Оценка математического ожидания \nmean_of_sample = np.mean(data)\n# Стандартное отклонение выборочной средней совокупности\nsigma_of_mean = scipy.stats.sem(data)\n\n\nВызываем функцию scipy.stats.t.interval:\n\n  первый аргумент: надежность оценки (доверительная вероятность)\n  второй аргумент df: число степеней свободы, равное количеству элементов в выборке, уменьшенному на 1\n  третий аргумент (loc): оценка математического ожидания\n  четвертый аргумент (scale): оценка стандартного отклонения математического ожидания выборки, вычисляемой при помощи функции scipy.stats.sem\n\n\n# Доверительный интервал математического ожидания\ninterval = scipy.stats.t.interval(gamma, df = n-1, loc = mean_of_sample, scale = sigma_of_mean)\nprint(interval)\n\n\nРезультат:\n\n(3.8810695725888413, 4.482390285924866)\n\n\nПри больших выборках (n&gt;30) распределение Стьюдента стремится к нормальному и для оценки доверительного интервала может использоваться нормальное распределение. При малых выборках нормальное распределение будет давать более узкий (т.е. слишком оптимистичный) интервал, в отличие от распределения Стьюдента.\n\n# Очень маленькая выборка\nn = 5\ndata = np.random.normal(loc=mean, scale=sigma, size=n)\n# Оценка математического ожидания \nmean_of_sample = np.mean(data)\n# Стандартное отклонение выборочной средней совокупности\nsigma_of_mean = scipy.stats.sem(data)\n# Доверительный интервал математического ожидания с использованием распределения Стьюдента\ninterval = scipy.stats.t.interval(gamma, df = n-1, loc = mean_of_sample, scale = sigma_of_mean)\nprint('Интервал по распределению Стьюдента  [{:5.3f}; {:5.3f}]'.format(interval[0],interval[1]))\n# Доверительный интервал математического ожидания с использованием нормального распределения\ninterval = scipy.stats.norm.interval(gamma, loc = mean_of_sample, scale = sigma_of_mean)\nprint('Интервал по нормальному распределению [{:5.3f}; {:5.3f}]'.format(interval[0],interval[1]))\n\n\nРезультат:\n\nИнтервал по распределению Стьюдента  [3.000; 4.419]\nИнтервал по нормальному распределению [3.209; 4.210]\n\n\nСписок использованных источников\n\n\n  Гмуртан В. Е. Теория вероятностей и математическая статистика: Учеб. пособие для вузов. - 8-е изд. стер. - М.: Высш. шк. 2002.\n\n",
      "url": "/pages/bigdata/confidence-intervals/"
    },{
      
      "title": "Выпуклая оболочка",
      
      "content": "\n  Разработать программу, которая загружает из текстового файла координаты точек на плоскости и строит проходящую через эти точки выпуклую оболочку (многоугольник), содержащую эти точки.\n  Программа должна вывести на экран все точки и построенный многоугольник. Координаты точек, составляющих многоугольник, должны записываться в текстовый файл.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/convex/"
    },{
      
      "title": "Задания для курсовой работы",
      
      "content": "Задание\n\nМеханизм состоит из абсолютно-твёрдых тел, соединённых  цилиндрическими, универсальными и сферическими шарнирами. Одно из звеньев механизма присоединено к неподвижному телу (“земля”). Механизм движется под действием силы тяжести. Вариант схемы механизма выбирается по номеру в ведомости.\n\nЭтап 1\n\n\n  Нарисовать схему механической системы, обозначив системы координат, связанные с телами, инерциальную систему координат. Выбрать обобщенные координаты в шарнирах.\n  Построить матрицу инцидентности \\(S\\), матрицу \\(T\\).\n  Показать на схеме системы шарнирные векторы \\(c_{ia}\\), векторы \\(d_{ij}\\).\n  Найти и показать на схеме системы положение барицентров, векторы \\(b_{i0}\\).\n  Разработать код (MATLAB/OCTAVE) для вычисления векторов \\(d_{ij}\\) по заданным векторам \\(c_{ia}\\).\n  Разработать код (MATLAB/OCTAVE) для вычисления векторов \\(b_{i0}\\) по заданным векторам \\(d_{ij}\\) и массам.\n\n\nЭтап 2\n\n\n  Разработать программу моделирования движения механизма.\n\n\nРезультатом этапа 2 является работающая программа моделирования движения механизма, которая для любых начальных условий движения строит графики изменения кинематических параметров механизма (углов, угловых скоростей), кинетической, потенциальной и полной энергии механической системы.\n\nЭтап 3\n\n\n  Подготовить пояснительную записку.\n  Построить анимацию движения механизма (Blender 3D, Mathematica).\n\n\nВ пояснительной записку включить графики изменения обобщенных координат, их производных, кинетической, потенциальной и полной энергии механизма для двух вариантов начальных условий. Пояснительная записка представляется в электронном виде.\n\nВарианты заданий\n\nНа всех схемах ось z неподвижной системы координат, с началом которой совпадает первая шарнирная точка, соединяющая первое тело с “землей”, направлена вертикально вверх.\n\nВарианты 1, 2, 3\n\n\n\nВарианты 4, 5, 6\n\n\n\nВарианты 7, 8, 9\n\n\n\n",
      "url": "/pages/mbs/course-work/"
    },{
      
      "title": "Движение наноспутника внутри пускового контейнера",
      
      "content": "Наноспутник типоразмера 3U массой \\(m\\) (от 2 до 6 кг) выталкивается из транспортно-пускового контейнера при помощи пружинного толкателя с известным начальным усилием \\(P_0\\), конечными усилием \\(P_k\\) и ходом \\(h\\).\n\n\n  Напишите MATLAB-функцию, которая определяет для заданной массы наноспутника, начального, конечного усилия пружины и её хода:\n    \n      скорость отделения наноспутника от носителя;\n      продолжительной движения наноспутника внутри контейнера от момента начала движения до окончания работы пружины.\n    \n  \n  Постройте график перемещения наноспутника от времени.\n  Постройте график изменения скорости наноспутника от времени.\n\n\nШаблон функции:\n\nfunction [dv dt] = get_v_t(...)\t\n\t...\nend \n\n\nНаноспутник выталкивается из контейнера при помощи пружины, усилие которой зависит от положения наноспутника внутри контейнера. Ход пружины обычно равен длине наноспутника. Наноспутник типоразмера 3U имеет длину 340.5 мм.\n\n\n\nСила пружины $P$ толкателя изменяется по линейному закону:\n\n[P = P_0 - c x, \\quad 0 \\leq x \\leq h,]\n\nгде \\(P\\) – начальное усилие пружины, \\(c\\) – жёсткость пружины: \n\\(c = \\frac{P_0 - P_k}{h}\\)\n\n\\(P_k\\) – конечное усилие пружины. Работа пружины определяется выражением:\n\n[A = \\frac{P_0 + P_k}{2} h]\n\nЕсли масса носителя, от которого отделяется наноспутник, значительно больше массы наноспутника, то можно принять допущение о том, что вся потенциальная энергия толкателя расходуется на приращение скорости наноспутника. В этом случае изменение кинетической энергии наноспутника равно работе пружинного толкателя:\n\n[T_k - T_0 = A]\n\nгде \\(T_0=0\\) начальная кинетическая энергия наноспутника, \\(A\\) – работа пружинны, \\(T_k\\) – конечная кинетическая энергия наноспутника:\n\n[T_k = \\frac{m V^2}{2}]\n\nСкорость наноспутника определяется выражением:\n\n[V = \\sqrt{\\frac{2 A}{m}}.]\n\nУравнение движения наноспутника под действием силы \\(P\\) имеет вид:\n\n[m \\ddot x = P_0 - c x.]\n\nЭто линейное неоднородное дифференциальное уравнение второго порядка с постоянными коэффициентами. Решение уравнения для нулевых начальных условий \\(x(0)=0\\), \\(\\dot{x}(0) = 0\\) имеет вид:\n\n[x = \\frac{P_0}{c}\\left[1-\\cos \\left(\\sqrt{\\frac{c}{m}}t\\right)\\right].]\n\nВремя движения наноспутника до выхода из пускового контейнера \\(x(t) = h\\) определяется формулой:\n\n[t = \\sqrt{\\frac{m}{c}} \\arccos \\frac{P_k}{P_0}.]\n\n",
      "url": "/pages/matlab/cubesat_motion/"
    },{
      
      "title": "Интегрирование уравнений движения со связями",
      
      "content": "Рассмотрим процедуру формирования и интегрирования уравнений движения механической системы совместно с уравнениями связей на примере модели двойного физического маятника.\n\nМеханическая система состоит из двух однородных стержней, связанных цилиндрическими шарнирами. Известны масса \\(m_1\\) и длина первого стержня \\(l_1\\), а также масса \\(m_2\\) и длина второго стержня \\(l_2\\). Движение системы происходит в вертикальной плоскости под действием силы тяжести, действующей на каждый стержень.\n\n\n\nУравнения движения этой системы можно записать, используя формализм Лагранжа (уравнения Лагранжа второго рода). В результате могут быть получены два уравнения движения для двух обобщенных координат, например, для углов \\(\\varphi_1\\) и \\(\\varphi_2\\), показанных на рисунке, которые однозначно определяют положение рассматриваемой системы.\n\nУравнения движения можно записать, используя избыточный набор координат, количество которых превышает число степеней свободы. В этом случае уравнений будет больше, но они  будут иметь более простую структуру. Для записи таких уравнений заменим действие связей в двух шарнирах силами реакции и запишем уравнения движения каждого стержня как свободного твердого тела, движущегося в плоскости.\n\n\n\nПоложение стержня \\(i\\) будет определяется тремя параметрами, определяющими положение центра масс стержня и угол наклона к оси x: \\(x_i\\), \\(y_i\\), \\(\\varphi_i\\). Для каждого стержня необходимо записать 3 уравнения движения под действием активных сил и сил реакций отброшенных связей. В каждой шарнирной точке будет действовать сила реакции, неизвестная по направлению и модулю, которую удобнее разложить по осям неподвижной системы координат. Уравнения движения будут иметь вид:\n\n[\\left{\n      \\begin{aligned}\n        m_1 \\ddot x_1          &amp; =F_{1x}-R_{1x}+R_{2x},                            \n        m_1 \\ddot y_1          &amp; =F_{1y}-R_{1y}+R_{2y},                            \n        J_{1z} \\ddot \\varphi_1 &amp; =M_{1z}-\\frac{l_1}{2} R_{1x} \\sin \\varphi_1 + \\frac{l_1}{2} R_{1y} \\cos \\varphi_1 - \\frac{l_2}{2} R_{2x} \\sin \\varphi_1 + \\frac{l_2}{2} R_{2y} \\cos \\varphi_1, \n        m_2 \\ddot x_2          &amp; =F_{2x}-R_{2x},                                                         \n        m_2 \\ddot y_2          &amp; =F_{2y}-R_{2y},                                                         \n        J_{2z} \\ddot \\varphi_2 &amp; =M_{2z}-R_{2x} \\frac{l_2}{2} \\sin \\varphi_2 + R_{2y} \\frac{l_2}{2} \\cos \\varphi_2 \n      \\end{aligned}\\right.]\n\nгде \\(J_{1z}\\), \\(J_{2z}\\) – моменты инерции первого и второго стержня относительно поперечной оси, проходящей через центр масс, \\(F_{1x}\\), \\(F_{1y}\\), – проекции главного вектора внешних сил, действующих на стержень 1. В рассматриваемом примере \\(F_{1x} = 0\\), \\(F_{1y} = -m_1 g\\), Аналогично для второго тела \\(F_{2x} = 0\\), \\(F_{2y} = -m_2 g\\). Внешние моменты на тела также не действуют \\(M_{1z} = 0\\), \\(M_{2z} = 0\\).\n\nВ систему уравнений свободного движения стержней входят неизвестные проекции силы реакции связей \\(R_{1x}\\), \\(R_{1y}\\), \\(R_{2x}\\), \\(R_{2y}\\), величина которых должна быть такой, чтобы точка \\(A_1\\) первого стержня совпадала с началом координат, а точка \\(A_2\\) второго стержня в процессе движения совпадала с точкой \\(A_1\\) первого стержня. Необходимо дополнить систему уравнений движения уравнениями связей.\n\nПервые два уравнения связей говорят о том, что точка \\(А_1\\), принадлежащая первому стержню, должна совпадать в процессе движения с точкой \\(A_0\\) неподвижной системы координат, которая имеет нулевые координаты:\n\n[\\left{\n      \\begin{aligned}\n        \\boxed{x_{A_1} = x_{A_0}} = x_1 - \\frac{l_1}{2} \\cos \\varphi_1 &amp; = 0 \n        \\boxed{y_{A_1} = y_{A_0}} = y_1 - \\frac{l_1}{2} \\sin \\varphi_1 &amp; = 0 \n      \\end{aligned}\\right.]\n\nТретье и четвертое уравнение связей требует совпадения координат точек \\(B_1\\) и \\(B_2\\), принадлежащих первому и второму стержню соответственно:\n\n[\\left{\n      \\begin{aligned}\n        \\boxed{x_{B_1} = x_{B_2}} = x_1 + \\frac{l_1}{2} \\cos \\varphi_1 &amp; = x_2 - \\frac{l_2}{2} \\cos \\varphi_2 &amp; \n        \\boxed{y_{B_1} = y_{B_2}} = y_1 + \\frac{l_1}{2} \\sin \\varphi_1 &amp; = y_2 - \\frac{l_2}{2} \\sin \\varphi_2 &amp; \n      \\end{aligned}\\right.]\n\nСистема 6 дифференциальных уравнений движения и 4 уравнений связей образуют систему дифференциально-алгебраических уравнений. Для решения этой системы дважды продифференцируем уравнения связей. В результате первого дифференцирования четырёх уравнений связей получим\n\n[\\left{\n\\begin{aligned}\n  \\dot{x}_1 + \\dot{\\varphi}_1 \\frac{l_1}{2} \\sin \\varphi_1 &amp; = 0 \n  \\dot{y}_1 - \\dot{\\varphi}_1 \\frac{l_1}{2} \\cos \\varphi_1 &amp; = 0 \n  \\dot{x}_1 - \\dot{\\varphi}_1 \\frac{l_1}{2} \\sin \\varphi_1 &amp; = \\dot{x}_2 + \\dot{\\varphi}_2 \\frac{l_2}{2} \\sin \\varphi_2 &amp; \n  \\dot{y}_1 + \\dot{\\varphi}_1 \\frac{l_1}{2} \\cos \\varphi_1 &amp; = \\dot{y}_2 - \\dot{\\varphi}_2 \\frac{l_2}{2} \\cos \\varphi_2 &amp; \n\\end{aligned}\\right.]\n\nПервые два уравнения требуют совпадения уже не координат, а скоростей точек \\(A_1\\) и \\(A_0\\). Также последние два уравнения требуют совпадения скоростей точек \\(B_1\\) и \\(B_2\\). Продифференцируем уравнения связи еще раз и получим уравнения связей, которые требуют совпадения ускорений точек \\(A_1\\), \\(A_0\\) и \\(B_1\\), \\(B_2\\):\n\n[\\left{\n\\begin{aligned}\n  \\ddot{x}_1 + \\ddot{\\varphi}_1 \\frac{l_1}{2} \\sin \\varphi_1 + \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\cos \\varphi_1 &amp; = 0 \n  \\ddot{y}_1 - \\ddot{\\varphi}_1 \\frac{l_1}{2} \\cos \\varphi_1 + \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\sin \\varphi_1 &amp; = 0 \n  \\ddot{x}_1 - \\ddot{\\varphi}_1 \\frac{l_1}{2} \\sin \\varphi_1 - \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\cos \\varphi_1 &amp; = \\ddot{x}_2 + \\ddot{\\varphi}_2 \\frac{l_2}{2} \\sin \\varphi_2 + \\dot{\\varphi}_2^2 \\frac{l_2}{2} \\cos \\varphi_2 &amp; \n  \\ddot{y}_1 + \\ddot{\\varphi}_1 \\frac{l_1}{2} \\cos \\varphi_1 - \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\sin \\varphi_1 &amp; = \\ddot{y}_2 - \\ddot{\\varphi}_2 \\frac{l_2}{2} \\cos \\varphi_2 + \\dot{\\varphi}_2^2 \\frac{l_2}{2} \\sin \\varphi_2 &amp; \n\\end{aligned}\\right.]\n\nСистему дифференциально-алгебраических уравнений с дважды продифференцированными уравнениями связей можно представить как систему линейный уравнений относительно ускорений и сил реакции. Запишем эту систему уравнений в матричной форме\n\n[\\begin{bmatrix}\nm_1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 &amp; 0 \n0 &amp; m_1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \n0 &amp; 0 &amp; J_1 &amp; 0 &amp; 0 &amp; 0 &amp; \\frac{l_1}{2} \\sin \\varphi_1 &amp; -\\frac{l_1}{2} \\cos \\varphi_1 &amp; \\frac{l_1}{2} \\sin \\varphi_1 &amp; - \\frac{l_1}{2} \\cos \\varphi_1 \n0 &amp; 0 &amp; 0 &amp; m_2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \n0 &amp; 0 &amp; 0 &amp; 0 &amp; m_2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \n0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; J_2 &amp; 0 &amp; 0 &amp; \\frac{l_2}{2} \\sin \\varphi_2 &amp; - \\frac{l_2}{2} \\cos \\varphi_2 \n1 &amp; 0 &amp; \\frac{l_1}{2} \\sin \\varphi_1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \n0 &amp; 1 &amp; -\\frac{l_1}{2} \\cos \\varphi_1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \n1 &amp; 0 &amp; - \\frac{l_1}{2} \\sin \\varphi_1 &amp; -1 &amp; 0 &amp; -\\frac{l_2}{2} \\sin \\varphi_2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \n0 &amp; 1 &amp; \\frac{l_1}{2} \\cos \\varphi_1 &amp; 0 &amp; -1 &amp; \\frac{l_2}{2} \\cos \\varphi_2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \n\\end{bmatrix}\n\\begin{bmatrix}\n\\ddot{x}1 \n\\ddot{y}_1 \n\\ddot{\\varphi}_1 \n\\ddot{x}_2 \n\\ddot{y}_2 \n\\ddot{\\varphi}_2 \nR{1x} \nR_{1y} \nR_{2x} \nR_{2y} \n\\end{bmatrix} = \n\\begin{bmatrix}\n0 \n-m_1 g \n0 \n0 \n-m_2 g \n0 \\\n\n  \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\cos \\varphi_1 \\\n  \\dot{\\varphi}_1^2 \\frac{l_1}{2} \\sin \\varphi_1 \n\\dot{\\varphi}_1^2 \\frac{l_1}{2} \\cos \\varphi_1 + \\dot{\\varphi}_2^2 \\frac{l_2}{2} \\cos \\varphi_2 \n\\dot{\\varphi}_1^2 \\frac{l_1}{2} \\sin \\varphi_1 + \\dot{\\varphi}_2^2 \\frac{l_2}{2} \\sin \\varphi_2\n\\end{bmatrix}]\n\n\nДля записи уравнений движения системы в форме Коши необходимо решить эту систему, исключив из первых шести уравнений реакции связей. Аналитическое решение этой системы приведет к громоздким выражениям, поэтому целесообразно эту систему решать численным методом на каждом шаге численного интегрирования.\n\nНачальные условия движения системы должны удовлетворять как исходным уравнениям связей, так и уравнениям связей после первого и второго дифференцирования. Учитывая, что интегрируется система уравнений движения с дважды продифференцированными уравнениями связей, в результате неизбежных погрешностей численного интегрирования исходные уравнения связей могут нарушаться.\n\nНиже приведен пример программы для моделирования движения двойного физического маятника в системе MATLAB.\n\nКод программы на языке MATLAB\n\nГлавный файл-скрипт\n\n% Основной исполняемый файл-скрипт \nclear all; clc; \n% масса стержня 1, его длина и момент инерции относительно оси Oz\np.m1 = 1; \np.L1 = 1; \np.J1 = (p.m1*p.L1^2)/12;\n% масса стержня 2, его длина и момент инерции относительно оси Oz\np.m2 = 1;\np.L2 = 1;\np.J2 = (p.m2*p.L2^2)/12;\n% Ускорение свободного падения\np.g  = 9.807;\n% Начальные условия движения\nx10  = 0.5*p.L1; % начальное положение ЦМ стержня 1, координата x\ny10  = 0;        % начальное положение ЦМ стержня 1, координата y\nf10  = 0;        % начальное положение стержня 1, угол поворота\nvx10 = 0;        % начальное положение ЦМ стержня 1, скорость вдоль x\nvy10 = 0;        % начальное положение ЦМ стержня 1, скорость вдоль y\nw10  = 0;        % начальное положение стержня 1, угловая скорость\n\nx20  = p.L1 + 0.5*p.L2; % начальное положение ЦМ стержня 2, координата x\ny20  = 0;        % начальное положение ЦМ стержня 2, координата y\nf20  = 0;        % начальное положение стержня 2, угол поворота\nvx20 = 0;        % начальное положение ЦМ стержня 2, скорость вдоль x\nvy20 = 0;        % начальное положение ЦМ стержня 2, скорость вдоль y\nw20  = 0;        % начальное положение стержня 2, угловая скорость\n\n% Формируем столбец начальных условий\nq0 = [x10;y10;f10;vx10;vy10;w10;x20;y20;f20;vx20;vy20;w20];\n\n[t,q] = ode113(@(t,q) dqdt(t,q,p), 0:0.02:5, q0);\n\n%% Графики изменения углов поворота\nplot(t,q(:,3)*180/pi,'LineWidth',3)\nhold on;\nplot(t,q(:,9)*180/pi,'LineWidth',3)\nhold off;\nlegend('\\phi_1','\\phi_2');\nylabel('Угол поворота, ...\\circ');\n\n%% Графики изменения угловых скоростей\nplot(t,q(:,6)*180/pi,'LineWidth',3)\nhold on;\nplot(t,q(:,12)*180/pi,'LineWidth',3)\nhold off;\nlegend('\\omega_1','\\omega_2');\nxlabel('t, c');\nylabel('Угловая скорость, ...\\circ/c');\n\n%% Анимация движения системы\nhold on;\naxis([-2.0 , 2.0, -2.0, +0.5]);\n\nfor i=1:size(t)\n    cla;\n    \n    xA  = q(i,1)-p.L1*0.5*cos(q(i,3));\n    yA  = q(i,2)-p.L1*0.5*sin(q(i,3));\n    \n    xB1 = q(i,1)+p.L1*0.5*cos(q(i,3));\n    yB1 = q(i,2)+p.L1*0.5*sin(q(i,3));    \n    \n    xB2 = q(i,7)-p.L2*0.5*cos(q(i,9));\n    yB2 = q(i,8)-p.L2*0.5*sin(q(i,9));    \n    \n    xC2 = q(i,7)+p.L2*0.5*cos(q(i,9));\n    yC2 = q(i,8)+p.L2*0.5*sin(q(i,9));    \n    \n    line([xA xB1],  [yA  yB1] ,'LineWidth',6,'Color','Red');\n    line([xB2 xC2], [yB2 yC2],'LineWidth',6,'Color','Blue');\n    \n    grid on;\n    \n    getframe;\n    \nend\nhold off;\n\n\nФайл функция правых частей\n\nfunction [dq, R] = dqdt(t,q,p)\n%   В этой функции вычисляются правые части дифференциальных уравнений\n%   движения. \n%\n%   Входные переменные:\n%   t   -   текущее время\n%   q   -   столбец обобщенных координат и скоростей системы\n%           в том-же порядке, что и в матрице исходных данных\n%           в файле pendulum.m\n%   p   -   структура с параметрами системы\n%\n%   Выходные:\n%   dq  -   производная столбца q\n%   R   -   столбец сил реакций       \n\n% Для наглядности обозначим элементы матрицы q собственными именами\n% Координаты и скорости первого стержня \nx1 = q(1);  vx1 = q(4);\ny1 = q(2);  vy1 = q(5);\nf1 = q(3);  wz1  = q(6);\n% Координаты и скорости второго стержня \nx2 = q(7);  vx2 = q(10);\ny2 = q(8);  vy2 = q(11);\nf2 = q(9);  wz2 = q(12);\n% Формируем матрицу коэффициентов системы\nA = [p.m1  0  0  0  0  0   1               0             -1              0 ;\n     0  p.m2  0  0  0  0   0               1              0             -1 ;\n     0   0  p.J1 0  0  0  p.L1*0.5*sin(f1) -p.L1*0.5*cos(f1) p.L1*0.5*sin(f1) -+p.L1*0.5*cos(f1);\n     0   0  0  p.m2 0  0   0               0              1               0;\n     0   0  0  0  p.m2 0   0               0              0                1;\n     0   0  0  0  0  p.J2  0               0  p.L2*0.5*sin(f2)        -p.L2*0.5*cos(f2);\n     1   0   p.L1*0.5*sin(f1)  0 0 0 0 0 0 0;\n     0   1  -p.L1*0.5*cos(f1)  0 0 0 0 0 0 0;\n     1   0  -p.L1*0.5*sin(f1) -1 0 -p.L2*0.5*sin(f2) 0 0 0 0;\n     0   1  +p.L1*0.5*cos(f1) 0 -1 +p.L2*0.5*cos(f2) 0 0 0 0];\n% Сила тяжести, действующая на первый и второй стержень (вдоль оси y)\nF1y = -p.m1*p.g;\nF2y = -p.m2*p.g;\n% Столбец правых частей\nB = [0; F1y; 0;\n     0; F2y; 0;\n    -p.L1*0.5*cos(f1)*wz1^2;\n    -p.L1*0.5*sin(f1)*wz1^2; \n    +p.L1*0.5*cos(f1)*wz1^2+p.L2*0.5*cos(f2)*wz2^2;\n     p.L1*0.5*sin(f1)*wz1^2+p.L2*0.5*sin(f2)*wz2^2];\n% Решаем систему линейных уравнений и получаем ускорения и реакции связей\nx = A\\B;\n% Реакции связей\nR = x(7:10);\n% Столбец результата функции (dq) представляет собой производную столбца q.\n% Так первые три элемента столбца q есть координаты и угол поворота первого\n% стержня, поэтому первые три элемента dq должны содержать проекции\n% линейной скорости первого стержня и его угловой скорости вокруг оси z.\n% Там где у столбца q расположены скорости, у столбца dq должны быть\n% помещены ускорения, вычисленные на предыдущем этапе x=B/A.\n% Можно написать проще, используя специальный синтаксис оператора (), \n% возвращающего сразу несколько элементов матрицы:\ndq = [q(4:6);x(1:3);q(10:12);x(4:6)];\n\n\n",
      "url": "/pages/mbs/dae/"
    },{
      
      "title": "Типы даты и времени в MATLAB",
      
      "content": "Работа с датой и временем\n\nОбъект дата и время\n\nДля создания объекта типа дата используется функция datetime\n\n&gt;&gt; a = datetime(2014,6,28,6,0,0)\n\na = \n  datetime\n   28-Jun-2014 06:00:00\n\n\nФункция позволяет создавать диапазон дат, если указан диапазон изменения одного из аргументов\n\n&gt;&gt; a = datetime(2014,6,28:30,6,0,0)\n\na = \n  1×3 datetime array\n   28-Jun-2014 06:00:00   29-Jun-2014 06:00:00   30-Jun-2014 06:00:00\n\n\n&gt;&gt; a(1)   \n\nans = \n  datetime\n   28-Jun-2014 06:00:00\n\n\nДля создания может быть использован оператор :\n\ndate_array = datetime(2020,4,1,0,0,0):minutes(20):datetime(2020,4,2,0,0,0)\n\ndate_array = \n  1×10 datetime array\nColumns 1 through 5\n   01-Apr-2020 00:00:00   01-Apr-2020 02:40:00   01-Apr-2020 05:20:00   01-Apr-2020 08:00:00   01-Apr-2020 10:40:00\nColumns 6 through 10\n   01-Apr-2020 13:20:00   01-Apr-2020 16:00:00   01-Apr-2020 18:40:00   01-Apr-2020 21:20:00   02-Apr-2020 00:00:00\n\n\nили функция linspace\n\ndate_array = linspace(datetime(2020,4,1,0,0,0),datetime(2020,4,2,0,0,0),10)\n\n\nФормат отображения даты задается свойством datetime.Format\n\n&gt;&gt; a.Format = 'dd.MM.yyyy';\n&gt;&gt; a\n\na = \n  1×3 datetime array\n   28.06.2014   29.06.2014   30.06.2014\n\n\nИнтервал между двумя датами\n\n&gt;&gt; d = a(2) - a(1)\n\nd = \n  duration\n   24:00:00\n\n\nПо умолчанию разница дат отображается в часах. Чтобы изменить формат отображения используется свойство Format\n\n&gt;&gt; d.Format = 'h'\n\nd = \n  duration\n   24 hr\n\n&gt;&gt; d.Format = 'd'\n\nd = \n  duration\n   1 day\n\n\nДля создания интервалов дат могут использоваться функции calmonth, caldays, calweeks, calquarters, calyears\n\nНа 10 дней вперед от 20 февраля 2020 года\n\n&gt;&gt; d1 = datetime(2020,2,20,0,0,0);\n&gt;&gt; d2 = d1 + caldays(10)\n\nd2 = \n  datetime\n   01-Mar-2020 00:00:00\n\n\nНа 1 месяц вперед от 20 февраля 2020 года\n\n&gt;&gt; d2 = d1 + calmonths(1)\n\nd2 = \n  datetime\n   20-Mar-2020 00:00:00\n\n\nНа 1 квартал вперед от 20 февраля 2020 года\n\n&gt;&gt; d2 = d1 + calquarters(1)\n\nd2 = \n  datetime\n   20-May-2020 00:00:00\n\n\n",
      "url": "/pages/matlab/datetime/"
    },{
      
      "title": "Начало работы в DBeaver",
      
      "content": "Скачать DBeaver. Необходимо скачать версию для Вашей системы в левой части страницы — версия Community Edition.\n\nПосле первого запуска DBeaver необходимо создать соединение, нажав на кнопку с изображением «вилки со знаком +» в верхней левой части окна программы.\n\n\n\nНа следующем шаге необходимо выбрать тип соединения, т.е. базу данных, к которой будет устанавливаться соединение, и после этого нажать кнопку «Далее».\n\n\n\nВ открывшемся окне необходимо ввести следующие параметры устанавливаемого соединения:\n\n\n  IP-адрес сервера БД, этот адрес для всех одинаковый (показан на следующем рисунке).\n  Имя базы данных, которое совпадает с номером зачетной книжки, у которой знак тире в номере заменён на знак подчеркивания (пример: 2018_02407).\n  Имя пользователя, которое совпадает с именем базы данных.\n  Пароль, который для каждой базы данных свой, см. сообщение в группе.\n\n\nПосле ввода параметров соединения необходимо нажать кнопку «Готово».\n\n\n\nПосле нажатия кнопки «Готово» слева появится значок подключения с надписью MySQL — имя БД (номер зачетной книжки со знаком подчеркивания).\n\n\n\nПосле того, как соединение установлено необходимо создать новый сценарий (скрипт), в котором записываются выражения на языке SQL.\n\n\n\nВидеоинструкция: подключение БД SQLite в DBeaver\n",
      "url": "/pages/databases/dbeaver/"
    },{
      
      "title": "Пример создания базы данных",
      
      "content": "Предположим, что необходимо создать базу данных (систему связанных таблиц), в которой будет храниться информация о выпускных работах студентов. Иходные данные для разработки базы представлены в виде следующей таблицы:\n\n\n\nРисунок 1 - Исходная таблица\n\nВ первых двух столбцах таблицы фамилия, имя и отчество студента, номер его зачетной книжки, в третьем столбце – фамилия, имя и отчество преподавателя - руководителя выпускной квалификационной работы (ВКР) студента, в четвертом – должность руководителя ВКР, в пятом столбце – оценка, полученная студентом при защите ВКР.\n\nУменьшаем избыточность\n\nПервое, что можно сказать, глядя на таблицу с исходными данными, это то, что в ней содержится много повторяющейся информации. Например, мы видим, что имя и должность преподавателя Полоскова встречается в таблице 3 раза: очевидно, что преподаватель может быть руководителем у нескольких студентов.\n\nХранение таблицы в базе данных (БД) в таком “сыром” виде нецелесообразно. Во-первых, такая таблица занимает больше места: представьте, что в этой таблице не 10, а миллион строк с повторяющимися элеменами. Во-вторых, изменение информации о преподавателе, пусть, например, изменилась его должность или фамилия, приведет  к необходимости поиска в таблице всех строк с именем этого преподавателя и изменение необходимой информации. В большой таблице это приведет к длительному поиску и большой нагрузке на сервер баз данных.\n\nСотрудники и студенты\n\nПопытаемся уменьшить избыточность данных. Для начала разобъём рассматриваемую таблицу на две. В первой таблице (“Студенты”) мы будем хранить информацию о студентах и их оценках за ВКР:\n\n\n\nРисунок 2 - Таблица “Студенты” (первая версия)\n\nво второй (“Преподаватели”) – информацию о преподавателях или сотрудниках:\n\n\n\nРисунок 3 - Таблица “Преподаватели” (первая версия)\n\nТаким образом, мы выделили две сущности, информация о которых будет храниться в базе данных, и выделили для двух этих сущностей две таблицы: это сущность “Студент” и “Преподаватель”. Конечно, атрибутов и преподавателя и у студента гораздно больше: год рождения, адрес, телефонный номер, но мы для ясности ограничимся минимальным набором атрибутов.\n\nОднако, разделив исходную таблицу на две мы потеряли информацию о руководителях ВКР: теперь, глядя на таблицу студентов мы не сможем определить, кто у этих студентов является руководителем ВКР. Для того, чтобы не потерять эту информацию поступим следующим образом. К таблице “Преподаватели” добавим еще один столбец с табельным номером сотрудника (преподавателя). Пусть это будет целое число. По табельному номеру мы будем отличать одного сотрудника о другого, т.е. в таблице “Преподаватели” не может быть двух строк с одинаковым табельным номером. Мы полагаем, что в таблице могут присутствовать записи о преподавателях полных тезках, поэтому для их различения мы будет использовать искусственный уникальный номер или суррогатный ключ. Таким образом, атрибут “Табельный номер сотрудника” сущности “Преподаватель” будет её ключевым атрибутом.\n\nК таблице “Студенты” добавим столбец “Руководитель ВКР”, в котором будем хранить табельный номер преподавателя – руководителя ВКР студента. Таким способом мы сформировали отношение “один ко многим” между сущностями “Преподаватель” и “Студент”: у одного студента может быть только один руководитель ВКР, но у сотрудника (преподавателя) может быть нескольк студентов, у которых этот преподаватель является руководителем.\n\n\n\nРисунок 4 - Таблицы “Преподаватели” и “Студенты” (вторая версия)\n\nТеперь в обновленной таблице “Студенты” мы не храним имя преподавателя и другие его атрибуты (их может быть много), а только ссылку (“табельный номер сотрудника”) на этого преподавателя в таблице “Преподаватели”.\n\nСущность “ВКР”\n\nВыделим еще одну очевидную сущность в рассматриваемой информационной системе. Во второй версии таблицы “Студенты” содержится информация о двух сущностях – о сущности “Студент” и о сущности “ВКР”. Отношение между этими сущностями “один к одному”, т.е. каждый студент выполняет одну ВКР и ВКР выполняется только одним студентом. Целесообразно разделить эти сущности и хранить информацию о них в разных таблицах.\n\nПреобразуем таблицу “Студенты”. Теперь она будет содержать только два столбца для хранения номера зачетной книжки и имени студента. Номер зачетной книжки будет ключевым атрибутом сущности “Студент”: будем считать, что не может быть двух студентов с одинаковыми номерами зачетных книжек.\n\n\n\nРисунок 5 - Таблица “Студенты” (третья версия)\n\nТаблица “ВКР” будет содержать три столбца для хранения номера зачетной книжки студента – автора ВКР – это ссылка на таблицу “Студенты”, ссылки на табельный номер руководителя ВКР в таблице “Преподаватели” и оценку по ВКР. В этой таблице может также хранится и наименование выпускной работы, дата защиты и другие атрибуты ВКР. Здесь же мы рассматриваем упрощенную версию этой таблицы.\n\n\n\nРисунок 6 - Таблица “ВКР”\n\nСотрудник и должность\n\nВернемся к таблице, где хранится информация о преподавателях. В этой таблице также повторяется информация о должностях: “Профессор”, “Доцент”. Также можно сказать, что в этой таблице хранится информация о двух сущностях о преподавателях и о дожностях.\n\n\n\nРисунок 7 - Таблица “Преподаватели” (вторая версия)\n\nРазделим эту таблицу на две. Создадим таблицу “Должности”, в которой будет содераться информация только о должностях сотрудников. Это будет своего рода справочником должностей университета.\n\nТаблицу “Преподаватели” исправим: теперь столбец должность будет содержать не наименование должности, а ссылку на номер должности в справочнике должностей.\n\n\n\nРисунок 8 - Таблица “Преподаватели” (третья версия)\n\nТаким образом, в результате преобразований исходной таблицы мы получили 4 таблицы для хранения четырех различных сущностей рассматриваемой информационной системы. ER-диаграмма информационной системы приведена на следующем рисунке:\n\n\n\nРисунок 9 - Диаграмма сущность-связь предметной области\n\nSQL\n\nСоздадим эти таблицы в СУБД MySQL/MariaDB. Предположим, что база данных уже создана, необходимо написать SQL скрипты для создания таблиц и сформировать отношения между ними.\n\nДолжности\n\nВ таблице “Должности” (справочник должностей сотрудников) два столбца:\n\n  первый столбец (ID) это уникальный номер должности (большое целое число), которе не может быть пустым (NULL); этот атрибут будет ключевым атрибутом сущности “Должности”;\n  второй столбц (POSITION_NAME) это наименование должности (“профессор”, “доцент”, …).\n\n\nCREATE TABLE POSITIONS\n(\nID BIGINT UNSIGNED NOT NULL PRIMARY KEY,\nPOSITION_NAME VARCHAR(100)\n);\n\n\nСотрудники (преподаватели)\n\nВ таблице “Сотрудники” три столбца:\n\n  ID – уникальный идентификатор (целое беззнаковое число), которое не может быть пустым  NULL;\n  имя преподавателя, под которе выделяется 255 символов;\n  номер должности – ссылка на таблицу “Должности”;\n\n\nСсылка на поле “ID” таблицы “POSITIONS” это внешний ключ (FOREIGN KEY) – ссылка на значение в столбеце другой таблицы. В нашем случае “POSITION_ID” ссылается на значение в столбце ID таблицы “POSITIONS”.\n\nCREATE TABLE TEACHERS\n(\nID BIGINT UNSIGNED NOT NULL PRIMARY KEY,\nNAME VARCHAR(255),\nPOSITION_ID BIGINT UNSIGNED NOT NULL,\nFOREIGN KEY (POSITION_ID) REFERENCES POSITIONS(ID)  \n);\n\n\nСтуденты\n\nВ таблице “Студенты” два столбца:\n\n  номер зачетной книжки (10 символов), которое не может быть пустым и является главным ключом сущности;\n  имя студента (до 255 символов).\n\n\nCREATE TABLE STUDENTS\n(\nRECORD_BOOK CHAR(10) NOT NULL PRIMARY KEY,\nNAME VARCHAR(255)\n);\n\n\nВКР\n\nТаблица с информацией о ВКР, называемая в базе данных “Q_WORKS”, содержит два столбца со ссылками на таблицу студентов и преподавателей и столбец с оценкой типа TINYINT:\n\nCREATE TABLE Q_WORKS\n(\n    STUDENT_ID CHAR(10),\n    SUPERVISER_ID BIGINT UNSIGNED,\n    MARK TINYINT,       \n    FOREIGN KEY (STUDENT_ID) REFERENCES STUDENTS(RECORD_BOOK),\n    FOREIGN KEY (SUPERVISER_ID) REFERENCES TEACHERS(ID),\n    PRIMARY KEY (STUDENT_ID, SUPERVISER_ID)\n);\n\n\nТо, что столбцы “STUDENT_ID” и “SUPERVISER_ID” хранят ссылки на значения из других таблиц указывается при помощи ключевого слова FOREIGN KEY:\n\n  STUDENT_ID ссылается на поле RECORD_BOOK из таблицы STUDENTS;\n  SUPERVISER_ID ссылается на поле ID таблицы TEACHERS.\n\n\nГлавным ключем сущности “ВКР” является составной ключ, включающий в свой состав табельный номер руководителя и номер зачетной книжки студента. В этом случае мы предполагаем, что у студента не может быть две выпускных работы с одним и тем же руководителем. Если это возможно, то необходимо добавить в составной ключ еще какой-то атрибут (дополнительный столбец), который бы отличал одну запись о ВКР от другой. Это может быть, например, дата защиты или код специальности, по которой защищет работу студент.\n\n\n\nРисунок 10 - Диаграмма сущность-связь предметной области\n\n",
      "url": "/pages/databases/ddl-example/"
    },{
      
      "title": "Дисциплины",
      
      "content": "Механика\n\n\n  Динамика твёрдого тела и систем тел\n  Прикладные задачи динамики твердого тела и систем тел\n  Теоретическая механика\n  Компьютерные и экспериментальные методы в механике\n\n\nЧисленные методы\n\n\n  Методы вычислений\n  Основы Wolfram Mathematica\n  Основы MATLAB\n  Интегрированные математические пакеты\n  Основы SimInTech\n\n\nИнформатика\n\n\n  Основы Python\n  Компьютерная графика\n  Информатика\n  Управление IT-сервисом и контентом\n  Базы данных\n  Управление IT-контентом и анализ больших данных\n\n\n",
      "url": "/pages/disciplines/"
    },{
      
      "title": "Расстояние между многоугольниками",
      
      "content": "\n  Даны два многоугольника координатами своих вершин в порядке обхода их по контуру по часовой стрелке.\n  Найти расстояние между многоугольниками. Программа должна показать на экране сами многоугольники, отрезок, обозначающий минимальное расстояние между ними, с указанием длины этого отрезка.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/dist_polygon/"
    },{
      
      "title": "Дубликаты файлов",
      
      "content": "Написать программу, которая сканирует заданный каталог и определяет дубли файлов изображений с расширением jpg, анализируя значения хэш-функции MD5 от содержимого файла. Каталог поиска задается параметром командной строки, например:\n\nfind_duplicates c:\\MyFolder\n\n\nРезультат должен выводится в текстовый файл. В текстовом файле результата должны выводиться имена файлов-дублей с указанием их длины в килобайтах.\n\nc:\\dir1\\file1.jpg : 100 Кб = c:\\dir1\\file2.jpg : 100 Кб = c:\\dir1\\file7.jpg : 100 Кб\nc:\\dir1\\file3.jpg : 150 Кб = c:\\dir1\\file4.jpg : 150 Кб\n\n\nДля вычисления хэш-функции использовать библиотеку hashlib\n\nСписок заданий\n",
      "url": "/pages/python/course_works/duplicate/"
    },{
      
      "title": "Углы Эйлера и углы Брайнта",
      
      "content": "Углы Эйлера\n\n\n\nОсобые положения\n\n\n\nУглы Брайнта\n\n\n\nОсобые положения\n\n\n",
      "url": "/pages/mbs/euler-angles-video/"
    },{
      
      "title": "Экзаменационные билеты",
      
      "content": "Дан текстовый файл с вопросами по некому курсу лекций. Каждый вопрос в текстовом файле занимает одну строчку. Вопросы сгруппированы по темам. Блоки тем разделяются пустой строкой:\n\nВопрос 1 темы 1\nВопрос 2 темы 1\n...\nВопрос n темы 1\n\nВопрос 1 темы 2\nВопрос 2 темы 2\n...\nВопрос n темы 2\n\n\nНапишите программу, которая для заданного количества вопросов в экзаменационном билете и для заданного количества билетов случайным образом генерирует файл с экзаменационными билетами по заданному шаблону.\nШаблон задается текстовым файлом в котором квадратных скобках заданы поля для замены. Например:\n\nЭкзаменационный билет №[НОМЕР]\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n[ВОПРОСЫ]\n\n\nНапример, 10 билетов с 3 вопросами в каждом.\n\nЭкзаменационный билет №1\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n1. Вопрос 1\n2. Вопрос 2\n3. Вопрос 3\n\n\nЭкзаменационный билет №2\nИнститут ракетно-космической техники. \nТеоретическая механика \n\n1. Вопрос 1\n2. Вопрос 2\n3. Вопрос 3\n\n\nВопросы в билетах не должны повторятся. Вопросы в каждом билете должны быть из разных тем.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/exam/"
    },{
      
      "title": "Вопросы к экзамену",
      
      "content": "В экзаменационном билете один вопрос и при нём задача. Задачи решаются при помощи функций библиотеки scipy.stat.\n\nВопросы\n\n\n  Что такое большие данные. Характеристики больших данных.\n  В чем отличие систем хранения больших данных (масштабируемость, отказоустойчивость).\n  Модель распределенных вычислений MapReduce.\n  Зачем нужны NoSQL базы данных. Типы NoSQL баз данных.\n\n\nЗадачи\n\n\n  Сравнение средних двух генеральных совокупностей.\n  Сравнение дисперсий двух генеральных совокупностей.\n  Построение доверительного интервала.\n  Однофакторный дисперсионный анализ (ANOVA F-test).\n  Оценка вероятности по частоте.\n  Задача на линейную регрессию.\n\n\nСписок литературы\n\n  Введение. Что такое большие данные?\n  Базы данных NoSQL.\n  Анализ современных технологий хранения сверхбольших объемов информации\n.\n  Масштабируемость баз данных.\n  Системы хранения данных.\n  Доверительные интервалы.\n  Проверка статистических гипотез. Часть 1..\n  Проверка статистических гипотез. Часть 2..\n  Линейная регрессия.\n  Гмуртан В. Е. Теория вероятностей и математическая статистика: Учеб. пособие для вузов. - 8-е изд. стер. - М.: Высш. шк. 2002..\n  Высшая математика - просто и доступно! Проверка статистических гипотез.\n  Введение в анализ данных с помощью Pandas.\n  Критерии нормальности распределения\n  Статистические гипотезы. Презентация..\n  F-tests for Equality of Two Variances.\n  Emory Oxford college. Exercises - Comparing Means 2.\n  Confidence Interval and Hypothesis Testing: Exercises and Solutions.\n  MS-A0503 First course in probability and statistics Department of mathematics and systems analysis.\n  Exercises - One Way Analysis of Variance (ANOVA).\n  Chapter: Biostatistics for the Health Sciences: One-Way Analysis of Variance.\n\n\n",
      "url": "/pages/bigdata/exam/"
    },{
      
      "title": "Статистические гипотезы.",
      
      "content": "Задания для лабораторных работ по курсу “Управление ИТ-контентом и анализ больших данных”.\n\nЗадание 1\n\n\nЗадача 1.1\n\nИз продукции двух автоматических линий извлечены по 50 гвоздей и вычислены их выборочные средние длины \\(\\hat{x}_1=180.3\\) мм и \\(\\hat{x}_1=180.9\\) мм. Нормативная погрешность линий есть нормальная случайная величина с дисперсией \\(\\sigma_1^2 = \\sigma_2^2 = 4.2\\) мм\\(^2\\).\n\nНа уровне значимости 0,05 проверить гипотезу о равенстве генеральных средних \\(a_1 = a_2\\) против конкурирующих гипотез \\(a_1 &lt; a_2\\) и \\(a_1 \\neq a_2\\).\n\nЗадача 1.2\n\nПроизводитель портативных компьютеров использует аккумуляторные батареи, поставляемые двумя компаниями, A и B. Хотя обе марки имеют одинаковое среднее время автономной работы между зарядками (ВАР), производитель компьютеров, похоже, получает больше жалоб на более короткий ВАР, чем ожидалось для аккумуляторных батарей, поставляемых компанией B.\n\nПроизводитель компьютеров подозревает, что это может быть вызвано более высокой дисперсией ВАР для марки B. Чтобы проверить это, выбираются десять новых батарейных блоков от каждой марки, устанавливаются на одни и те же модели ноутбуков, и ноутбуки работают до тех пор, пока аккумуляторные батареи полностью не разрядятся. Ниже приведены наблюдаемые ВАР в часах.\n\n\n  \n    \n      Brand A\n      Brand B\n    \n  \n  \n    \n      3.2\n      3.0\n    \n    \n      3.4\n      3.5\n    \n    \n      2.8\n      2.9\n    \n    \n      3.0\n      3.1\n    \n    \n      3.0\n      2.3\n    \n    \n      3.0\n      2.0\n    \n    \n      2.8\n      3.0\n    \n    \n      2.9\n      2.9\n    \n    \n      3.0\n      3.0\n    \n    \n      3.0\n      4.1\n    \n  \n\n\nПротестируйте на уровне значимости 5%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что ВАР бренда B имеют большую дисперсию, чем у бренда A.\n\nЗадание 2\n\n\nЗадача 2.1\n\nЗаписи о 40 подержанных легковых автомобилях и 40 подержанных пикапах (ни один из них не использовался в коммерческих целях) были выбраны случайным образом, чтобы выяснить, была ли какая-либо разница в среднем времени в годах, в течение которого они находились у первоначального владельца перед продажей. Для автомобилей среднее значение составило 5,3 года при стандартном отклонении 2,2 года. Для пикапов среднее значение составило 7,1 года при стандартном отклонении 3,0 года.\n\n\n  Постройте 95% доверительный интервал для разницы средних на основе этих данных.\n  Проверьте гипотезу о том, что средние значения различаются, против нулевой гипотезы об отсутствии различий.\n  Используйте уровень значимости 1%.\n\n\nЗадача 2.2\n\nПроизводитель устройства для измерения артериального давления для домашнего использования утверждает, что его устройство более стабильно, чем устройство ведущего конкурента. При посещении медицинского магазина потенциальный покупатель неоднократно примерял на себе оба устройства в течение короткого промежутка времени. Ниже приведены показания систолического давления.\n\n\n  \n    \n      Производитель\n      Конкурент\n    \n  \n  \n    \n      132\n      129\n    \n    \n      134\n      132\n    \n    \n      129\n      129\n    \n    \n      129\n      138\n    \n    \n      130\n       \n    \n    \n      132\n       \n    \n  \n\n\nПроверьте на уровне значимости 5%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что заявление производителя верно.\n\nЗадание 3\n\n\nЗадача 3.1\n\nЛиния по разливу сока должна наливать 0.500 л в бутылку. Замер объема сока в выборке из 36 бутылок показал среднее значение 0,485 л. Проверьте нулевую гипотезу о том, что среднее значение зополненности бутылок равно 0,500 л с уровнем значимости 5\\%.\n\nЗадача 3.2\n\nКаждый год большое количество потенциальных оценщиков письменной части вступительного экзамена проходят строгую программу обучения, прежде чем им будут даны оценочные задания. Чтобы оценить, действительно ли такая учебная программа способствует постоянству оценок, статистик провел эксперимент, в ходе которого 61 подготовленному оценщику и 31 неподготовленному оценщику было дано справочное эссе. Информация о баллах, выставленных этими оценщиками, представлена ниже:\n\nПодготовленные оценщики:\n\n[n_1=61, s_1^2=2.15]\n\nНеподготовленные оценщики:\n\n[n_2=31, s_2^2=3.91]\n\nПротестируйте на уровне значимости 5%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что программа обучения повышает согласованность оценок эссе.\n\nЗадание 4\n\n\nЗадача 4.1\n\nЧтобы определить, существует ли значительная разница в длине рыб из двух рыбоводных заводов, 11 рыб были случайным образом отобраны из рыбоводного завода А и 10 рыб были случайным образом выбраны из рыбоводного завода В. Их длины в сантиметрах приведены ниже. Предположим, что оба набора данных являются приблизительно нормальными. Протестируйте утверждение об отсутствии разницы в длине рыбы для двух инкубаториев, используя метод критического значения с \\(\\alpha\\) = 0,05.\n\nЗавод A: 12.4 12.7 12.9 13.3 14.2 14.3 14.3 14.8 14.8 15.3 15.3\nЗавод B: 10.7 12.2 12.8 13.9 14.1 14.3 14.6 15.6 16.8 18.1\n\n\nЗадача 4.2\n\nОбщая проблема, с которой сталкиваются многие радиостанции классической музыки, заключается в том, что их слушатели принадлежат к все более узкой возрастной группе населения. Новый генеральный менеджер радиостанции классической музыки считал, что новый плейлист, предложенный профессиональным агентством по программированию, привлечет слушателей более широкого возраста. Новый список использовался в течение года. Были взяты две случайные выборки до и после принятия нового плейлиста. Информация о возрасте слушателей в выборке представлена ниже:\n\n  Выборка до замены плейлиста: \\(n_1=21\\), \\(s_1^2=56.25\\)\n  Выборка после замены плейлиста: \\(n_2=16\\), \\(s_2^2=76.56\\)\n\n\nПротестируйте на уровне значимости 10%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что новый плейлист расширил диапазон возрастов слушателей.\n\nЗадание 5\n\n\nЗадача 5.1\n\nПредположим, мы хотим знать, приводят ли три разные программы подготовки к экзаменам к разным средним баллам на определенном экзамене. Чтобы проверить это, мы набираем 30 студентов для участия в исследовании и разделяем их на три группы. Студенты в каждой группе случайным образом назначаются для использования одной из трех программ подготовки к экзамену в течение следующих трех недель для подготовки к экзамену. По истечении трех недель все студенты сдают один и тот же экзамен.\n\nНиже представлены результаты экзаменов для каждой группы:\n\nГруппа 1: 85 86 88 75 78 94 98 79 71 80 \nГруппа 2: 91 92 93 85 87 84 82 88 95 96 \nГруппа 3: 79 78 88 94 92 85 83 85 82 81\n\n\nМожно ли сказать, что существует статистически значимая разница между средними экзаменационными баллами трех групп?\n\nЗадача 5.2\nРиск инвестирования в акции измеряется волатильностью или дисперсией изменений цены этих акций. Взаимные фонды представляют собой наборы акций и, как правило, предлагают инвесторам меньший риск. Различные взаимные фонды имеют разную направленность и предлагают разные уровни риска.\n\nИммануил Гедеонович выбирает между двумя взаимными фондами, А и В, с одинаковыми ожидаемыми доходами. Чтобы принять окончательное решение, он изучил годовые доходы двух фондов за последние десять лет и получил следующую информацию:\n\n\n  Взаимный Фонд A: \\(n_1=10$,\\) s_1^2=0.012 $$\n  Взаимный Фонд В: \\(n_2=10$,\\) s_2^2=0.005 $$\n\n\nПроверьте на уровне значимости 5%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что два взаимных фонда предлагают разные уровни риска.\n\nЗадание 6\n\n\nЗадача 6.1\n\nФермер рассматривает возможность увеличения времени, в течение которого горит свет в его курятнике. В эксперименте отбирали десять кур и регистрировали количество яиц, снесенных каждой из них в течение недели при нормальных и повышенных условиях освещения. При α=0.05 можно ли сделать вывод, что увеличение светового времени изменило яйценоскость?\n\n\n  \n    \n      Курица\n      Нормальный свет\n      Увеличенный свет\n    \n  \n  \n    \n      1\n      4\n      6\n    \n    \n      2\n      3\n      5\n    \n    \n      3\n      8\n      9\n    \n    \n      4\n      7\n      7\n    \n    \n      5\n      6\n      4\n    \n    \n      6\n      4\n      5\n    \n    \n      7\n      9\n      10\n    \n    \n      8\n      7\n      6\n    \n    \n      9\n      6\n      9\n    \n    \n      10\n      5\n      6\n    \n  \n\n\nЗадача 6.2\n\nЯпонский осетр — подвид семейства осетровых, обитающий в Японии и северо-западной части Тихого океана. В одном из рыбоводных заводов только что вылупившиеся детеныши японского осетра содержатся в резервуарах в течение нескольких недель, прежде чем их переводят в более крупные пруды. Растворенный кислород в воде резервуара очень тщательно контролируется электронной системой и строго поддерживается на целевом уровне 6,5 миллиграммов на литр (мг/л).\n\nРыбоводный завод надеется модернизировать свои системы мониторинга воды для более жесткого контроля растворенного кислорода. Новая система оценивается по сравнению со старой, используемой в настоящее время, с точки зрения дисперсии измеренного содержания растворенного кислорода. В течение дня была отобрана 31 проба воды из резервуара, работающего с новой системой, и 16 проб воды из резервуара, работавшего со старой системой. Образцы дают следующую информацию:\n\n\n  Новая выборка : \\(n_1=31\\), \\(s_1^2=0.0121\\)\n  Старая выборка: \\(n_2=16\\), \\(s_2^2=0.0319\\)\n\n\nПроверьте на уровне значимости 10%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что новая система обеспечит более жесткий контроль содержания растворенного кислорода в резервуарах.\n\nЗадание 7\n\n\nЗадача 7.1\nИсследователи дикой природы отловили и измерили длину шести взрослых самцов ошейниковых леммингов. Данные (в миллиметрах):\n\n104, 99, 112, 115, 96, 109.\n\n\nПредположим, что длины всех леммингов распределены нормально. Используя эти данные, постройте 90% доверительный интервал для средней длины всех взрослых самцов ошейниковых леммингов.\n\nЗадача 7.2\n\nЧтобы исследовать реальную стоимость владения новыми автомобилями различных марок и моделей, агентство по защите прав потребителей отследило 16 владельцев новых автомобилей четырех популярных марок и моделей, назвав их TC, HA, NA и FT, и вело учет каждого из них. реальная стоимость владельца в долларах за первые пять лет. Ниже приведены пятилетние затраты 16 автовладельцев:\n\nTC:  8423, 7889,  8665\nHA:  7776, 7211,  6870, 7129, 7359\nNA:  8907, 9077,  8732, 9747, 8677\nFT: 10333, 9217, 10540\n\n\nПроверьте, используя F-критерий ANOVA на уровне значимости 5%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о наличии различий между средними реальными затратами на владение этими четырьмя моделями.\n\nЗадание 8\n\n\nЗадача 8.1\nДаны две независимые выборки из нормально-распределенной генеральной совокупности:\n\nA: 3.61, 4.03, 1.8 , 6.21, 6.59, 5.92, 6.53, 4.11, 2.09, 5.88\nB: 2.76, 4.92, 4.15, 4.51, 2.7 , 2.1 , 5.5 , 6.05\n\n\nПри уровне значимости 10% проверить нулевую гипотезу о равенстве генеральных дисперсий при альтернативной гипотезе D(A)&gt;D(B)\n\nЗадача 8.2\n\nСлучайная выборка 9-летних детей дала следующие данные об их росте (в сантиметрах):\n\n\n  Девочки:   \\(\\hat{x} = 126.2\\) см, \\(s = 10.95\\) см, \\(n = 50\\)\n  Мальчики:  \\(\\hat{x} = 123.5\\) см, \\(s = 9.9\\) см, \\(n = 60\\)\n\n\nПроверьте утверждение о том, что в возрасте 9 лет средний рост мальчиков и девочек одинаков.\n\nЗадание 9\n\n\nЗадача 9.1\n\nКоличество граммов углеводов, содержащихся в порциях по 100 грамм случайно выбранных шоколадных и нешоколадных конфет, указано ниже. Предположим, образцы примерно нормальные.\n\n  Шоколад: 17, 24, 25, 25, 27, 29, 29, 29, 29, 32, 34, 36, 38, 41\n  Без шоколада: 10, 12, 29, 29, 30, 37, 38, 39, 41, 41, 55\n\n\n\n  Значительно ли различаются дисперсии выборок при \\(\\alpha\\) = 0.05?\n  Проверьте утверждение о том, что нет никакой разницы в содержании углеводов в двух видах конфет при \\(\\alpha\\) = 0.05$.\n\n\nЗадача 9.2\n\nИсторически фабрика могла производить очень специализированный компонент нанотехнологий с надежностью 35%, т. е. 35% компонентов соответствовали требованиям обеспечения качества.\n\nСейчас руководство завода изменило производственный процесс и надеется, что это повысило надежность. Чтобы проверить это, была взята выборка из 24 компонентов, произведенных с использованием нового процесса, и обнаружили, что 13 компонентов прошли тест на качество. Означает ли это значительное улучшение по сравнению со старым процессом?\n\nЗадание 10\n\n\nЗадача 10.1\n\nДиетолог хочет увидеть, есть ли какая-либо разница в прибавке в весе спортсменов, соблюдающих одну из трех специальных диет. Спортсменов случайным образом распределяют по трем группам и помещают на диету на 6 недель. Указаны прибавки в весе (в фунтах). Предположим, что прибавка в весе распределяется нормально, а дисперсии равны.\n\nС уровнем значимости 0,05 может ли исследователь заключить, что рационы различаются?\n\n     Диета А: 3, 6, 7, 4\n     Диета Б: 10, 12, 11, 14, 8, 6\n     Диета С: 8, 3, 2, 5\n\n\nЗадача 10.2\n\nДве случайные выборки взяты из двух нормальных генеральных совокупностей. Известны количество элементов и дисперсии двух выборок:\n\n  \\(n_1 = 11\\), \\(s_1^2 = 61\\)\n  \\(n_2 = 8\\), \\(s_2^2 = 44\\)\n\n\nПроверьте гипотезу\n\n[H_0 : \\sigma_1^2 = \\sigma_2^2, \\quad \\text{при альтернативной } H_1: \\sigma_1^2 &gt; \\sigma_2^2]\n\nпри уровне значимости 5%.\n\nЗадание 11\n\n\nЗадача 11.1\n\nЭффект Моцарта относится к увеличению средней успеваемости на тестах для учащихся начальной школы, если ученики слушают камерную музыку Моцарта в течение определенного периода времени непосредственно перед тестом. Многие педагоги считают, что такой эффект не обязательно связан с музыкой Моцарта как таковой, а скорее с периодом релаксации перед тестом. Чтобы подтвердить это убеждение, учительница начальной школы провела эксперимент, разделив свой класс из 15 учеников третьего класса на три группы по 5 человек. Учащихся первой группы попросили сделать себе массаж лица самостоятельно; студенты второй группы слушали камерную музыку Моцарта в течение 15 минут; Студенты третьей группы слушали камерную музыку Шуберта в течение 15 минут перед тестом. Оценки 15 учащихся представлены ниже:\n\n  G1 = [79, 81, 80, 89, 86] \n  G2 = [82, 84, 86, 91, 82]\n  G3 = [80, 81, 71, 90, 86]\n\n\nПроверьте, используя F-критерий ANOVA с уровнем значимости 10%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод, что какой-либо из трех методов релаксации работает лучше, чем другие.\n\nЗадача 11.2\n\nЦех предприятия выпускает гвозди длина которых должна быть быть 10,00 см. Из-за неточностей производственного процесса каждый произведенный гвоздь может иметь отклонения длины, при этом эти отклонения распределены по нормальному закону с неизвестным средним значением μ и неизвестным стандартным отклонением σ. Для контроля качества была проверена выборка из 120 гвоздей. В выборке среднее значение составляло 10,08 см, а стандартное отклонение - 0,40 см.\n\n\n  Вычислите 95% и 99% доверительные интервалы для неизвестного среднего.\n  Рассчитайте p-значение для проверки гипотезы с нулевой гипотезой μ = 10.00 по сравнению с альтернативной гипотезой \\(\\mu \\neq 10.00\\).\n  Используя p-значение из (b), определите, принимается или отвергается нулевая гипотеза при уровень значимости α = 0,05.\n  Используя значение p из (b), определите, принимается или отвергается нулевая гипотеза при уровень значимости α = 0,01.\n\n\nЗадание 12\n\n\nЗадача 12.1\n\nПрецизионные весовые устройства чувствительны к условиям окружающей среды. Температура и влажность в лабораторном помещении, где установлено такое устройство, жестко контролируются для обеспечения высокой точности взвешивания. Утверждается, что недавно разработанное весовое устройство более устойчиво к небольшим колебаниям температуры и влажности. Чтобы подтвердить такое утверждение, лаборатория тестирует новое устройство при четырех настройках температурно-влажностного режима. Во-первых, выделяют два уровня высокой и низкой температуры и два уровня высокой и низкой влажности. Пусть T обозначает температуру, а H — влажность. Четыре экспериментальных параметра определены и отмечены как (T, H): (высокий, высокий), (высокий, низкий), (низкий, высокий) и (низкий, низкий). Предварительно калиброванный эталонный груз массой 1 кг взвешивался новым прибором четыре раза в каждой установке. Результаты с точки зрения погрешности (в микрограммах мкг) приведены ниже:\n\nвысокий, высокий : -1.5, -6.73, 11.69, -5.72\nвысокий, низкий  : 11.47, 9.28, 5.58, 10.80\nнизкий, высокий  : -14.29, -18.11, -11.16, -10.41\nнизкий, низкий   : 5.54, 10.34, 15.23, -5.69\n\n\nПротестируйте, используя F-критерий ANOVA с уровнем значимости 1%, предоставляют ли данные достаточные доказательства, чтобы сделать вывод о том, что средние показания веса, полученные с помощью вновь разработанного устройства, изменяются при изменении внешних условий.\n\nЗадача 12.2\n\nУ четырехсот случайно выбранных работающих взрослых в определенной области страны, включая тех, кто работал дома, спросили, какое расстояние от их дома до места работы. Среднее расстояние составило 5,84 км со стандартным отклонением 2,70 км. Постройте 99% доверительный интервал для среднего расстояния от дома до работы для всех жителей этой области.\n\nСписок использованных источников\n\n\n  F-tests for Equality of Two Variances\n  Emory Oxford college. Exercises - Comparing Means 2\n  Confidence Interval and Hypothesis Testing:\nExercises and Solutions\n  MS-A0503 First course in probability and statistics Department of mathematics and systems analysis\n  Exercises - One Way Analysis of Variance (ANOVA)\n  Chapter: Biostatistics for the Health Sciences: One-Way Analysis of Variance\n\n",
      "url": "/pages/bigdata/exersises-hypotesis/"
    },{
      
      "title": "Регрессия. Задания.",
      
      "content": "Часть 1\n\n  Загрузить таблицу из файла regr_data_V.csv (V - номер варианта), расположенного в сети интернет.\n  Разделить выборку на тестовый и обучающий набор данных в пропорции 1/3.\n  Решить задачу мультилинейной регрессии, полагая, что независимыми переменнами в наборе расположены в столбцах VARi таблицы, а значение функции в столбце Y.\n  Найдите среднеквадратичную ошибку, максимальную по модулю ошибку, среднюю процентную ошибку и коэффициент детерминации модели.\n  Выведите таблицу, содержащую тестовый набор данных, столбец с предсказанными моделью значениями функции и столбец с абсолютной погрешностью прогнозного значения.\n\n\nВарианты\n\n\n  regr_data_1.csv\n  regr_data_2.csv\n  regr_data_3.csv\n  regr_data_4.csv\n  regr_data_5.csv\n  regr_data_6.csv\n  regr_data_7.csv\n  regr_data_8.csv\n  regr_data_9.csv\n  regr_data_10.csv\n  regr_data_11.csv\n  regr_data_12.csv\n\n\nЧасть 2\n\n\n  Загрузить данные из таблицы NL_Data_V.csv (V - номер варианта), в которой приведена статистическая зависимость параметра Y от X. Постройте график этой зависимости (диаграмму рассеяния).\n  Предложите вариант нелинейной функции f(X) и определите ее параметры, для аппроксимации зависимости между X и Y.\n  Выведите на экран значения параметров функции, округленных до трех знаков после запятой и значения стандартных отклонений этих параметров.\n  Постройте диаграмму рассеивания с аппроксимирующей кривой.\n  Найти коэффиценты полинома, аппроксимирующего зависимость Y от Х.\n  Постройте диаграмму рассеяния с аппроксимирующей кривой.\n\n\nВарианты\n\n\n  NL_Data_1.csv\n  NL_Data_2.csv\n  NL_Data_3.csv\n  NL_Data_4.csv\n  NL_Data_5.csv\n  NL_Data_6.csv\n  NL_Data_7.csv\n  NL_Data_8.csv\n  NL_Data_9.csv\n  NL_Data_10.csv\n  NL_Data_11.csv\n  NL_Data_12.csv\n\n",
      "url": "/pages/bigdata/exersises-regression/"
    },{
      
      "title": "Динамика отделения створок головного обтекателя",
      
      "content": "Рассматривается схема отделения створок головного обтекателя по “параллельной” схеме без разворота.\n\n\n\nЭтап 1\n\nСтворка головного обтекателя имеет массу 1200 кг. Модель створки представлена тремя тонкими оболочками: полуцилиндром, усеченным конусом, и конусом. Масса створки равномерно распределена по  поверхности. Геометрические параметры створки приведены в таблице.\n\n\n  \n    \n      Параметр\n      Значение\n      Параметр\n      Значение\n    \n  \n  \n    \n      \\(H_1\\)\n      10 м\n      \\(H_2\\)\n      5,5 м\n    \n    \n      \\(H_3\\)\n      0,5 м\n      \\(R_1=R_2\\)\n      3 м\n    \n    \n      \\(R_3\\)\n      0,7 м\n       \n       \n    \n  \n\n\nНайти положение центра масс створки относительно базовой системы координат \\(C_1 x_{b1}y_{b1}z_{b1}\\).\n\nНайти моменты инерции створки относительно осей центральной системы координат \\(B_1 x_{1}y_{1}z_{1}\\).\n\n\n\nЭтап 2\n\nРассматривая створку головного обтекателя, как плоскую фигуру для известного положения центра масс (см. этап 1), известных значений \\(d_2\\) и \\(H\\) найти силы натяжения тросов \\(T_{A1}\\), \\(T_{D1}\\) и размер \\(d_2\\), при которых створка находится в покое в вертикальном положении.\n\n\n\nЭтап 3\n\nСторки отделяются при помощи четрех пневмотических толкателей: два толкателя расположены выше центра масс, два – ниже центра масс. В момент начала движения створок после разделения головного обтекателя на две створки момент сил толкателей относительно центра масс равен нулю.\n\nРассматривая створки как две материальные точки, движущиеся под действием суммарной силы четырех толкателей определить их силовые характеристики (начальное и конечное усилие), обеспечивающие отделение створок с горизонтальной скоростью 5 м/с.\n\nПринять допущение о том, что сила толкателя меняется по линейному закону:\n\n[\\begin{cases}\nF = F_0 - \\frac{F_0 - F_k}{s_k-s_0} s, \\quad s \\leq s_k, \nF = 0, \\quad s &gt; s_k,\n\\end{cases}]\n\nгде \\(F_0\\) – начальное усилие толкателя, \\(F_k\\) – конечное усилие толкателя, \\(s_0 = 1\\) м – начальная длина толкателя, \\(s_k = 2\\) м – конечная длина толкателя (длина, при которой толкатель заканчивает работу).\n\n\n\nЭтап 4\n\nПостроить модель плоского движения створок головного обтекателя при наземной отработке процесса отделения.\n\n",
      "url": "/pages/mechanics-in-space/fairing-side-separation/"
    },{
      
      "title": "Модель мягкой посадки многоразовой ракеты-носителя Falcon-9",
      "description": "Простейшая модель взаимодействия посадочной опоры многоразовой первой ступени РН Falcon-9 с поверхностью земли в процессе мягкой посадки.\n",
      "content": "\n  Схема посадочной опоры\n  Математическая модель    \n      Кинематические соотношения\n      Уравнения движения\n      Энергия, поглощаемая демпфером\n    \n  \n  Численное интегрирование уравнения движения    \n      Задание\n    \n  \n\n\nСхема посадочной опоры\n\nРассмотрим упрощенную модель взаимодействия посадочной опоры многоразовой ступени ракеты-носителя с поверхностью земли. На рисунке 1 приведена фотография посадочных опор возвращаемой ступени РН Falcon-9. Ступень садится на 4 опоры. Каждая опора состоит из демпфирующего подкоса переменной длины BK и опорного подкоса АК постоянной длины, которые шарнирно закрепляются на корпусе РН.\n\n\n\nРисунок 1 - Посадочные опоры\n\nСхема взаимодействия опоры с поверхностью земли приведена на рисунке 2. На рисунке показан корпус возвращаемого блока АВ, подкос постоянной длины \\(AK = l\\), демпфирующий подкос \\(BK = s\\). Со стороны поверхности земли на опору действуют сила реакции опоры \\(\\mathbf N\\) и сила трения \\(F\\). После касания опорой поверхности земли демпфирующий подкос BK поглощает кинетическую энергию, уменьшаясь в длине.\n\n\n\nРисунок 2 - Силы, действующие на посадочную опору\n\nПредположим, что в демпфирующем подкосе используется простейшее демпфирующее устройство – сотовый демпфер, который сминается при сжатии поглощая энергию. Такой способ поглощения кинетической энергии использовался в посадочных модулях Аполлон (рисунок 3). Предположим, что при смятии демпфера создается постоянная сила сопротивления \\(D\\).\n\n\n\nРисунок 3 - Сотовый демпфер\n\nМатематическая модель\n\nЗапишем уравнение вертикального поступательного движения возвращаемой ступени в процессе взаимодействия всех четырех посадочных опор с поверхностью земли, пологая, что все опоры “работают” одинаково, т.е. все опоры создают одинаковую силу сопротивления  \\(\\mathbf D\\) при сжатии демпфера и силу реакции опоры (земли) \\(\\mathbf N\\). Уравнения движения запишем в форме уравнений Лагрнажа II-го рода, выбрав в качестве обобщенной координаты длину демпфирующего подкоса \\(s = BK\\).\n\nКинематические соотношения\n\nИз теоремы косинусов для треугольника ABK найдём зависимость длины демпфирующего подкоса от высоты шарнира А над поверхностью земли h = AE, который определяет вертикальное положение ступени:\n\n[s^2 = l^2 + a^2 - 2 a l \\cos \\alpha = l^2 + a^2 + 2 a l \\cos (\\pi - \\alpha)]\n\nКосинус угла \\(\\cos (\\pi - \\alpha)\\) определим из треугольника AEK\n\n[\\cos (\\pi - \\alpha) = \\frac{h}{l}]\n\nТогда:\n\n[s^2 = l^2 + a^2 - 2 a l \\cos \\alpha = l^2 + a^2 + 2 a h]\n\nПродифференцировав это уравнение, получим зависимость скорости деформации подкоса \\(\\dot s\\) от изменения вертикальной скорости ступени \\(\\dot h\\):\n\n[2 s \\dot s = 2 a \\dot h \\quad \\rightarrow  \\quad  \\dot s = \\frac{a}{s} \\dot h]\n\nСкорость деформации демпфера телескопического подкоса в \\(s/a\\) раз меньше вертикальной скорости посадочной ступени. Найденная зависимость \\(s\\) от \\(h\\) также позволяет записать уравнение в вариациях:\n\n[s \\cdot \\delta s = a \\cdot \\delta h \\quad \\rightarrow \\quad \\delta s = \\frac{a}{s} \\delta h,]\n\nкоторое пригодится для определения обобщенных сил при выводе уравнения Лагранжа II-го рода.\n\nУравнения движения\n\nУравнение вертикального движения корпуса возвращаемой ступени при взаимодействии четырех опор с поверхностью земли будет иметь вид:\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot s} - \\frac{\\partial T}{\\partial s} = Q_s]\n\nБудем считать, что масса посадочных опор мала в сравнении с массой всей ступени. В этом случае кинетическая энергия \\(T\\) рассматриваемой механической системы будет определяться кинетической энергией корпуса:\n\n[T = \\frac{m \\dot{h}^2}{2}]\n\nгде \\(m\\) – масса возвращаемой ступени в момент посадки. Перепишем выражение для кинетической энергии, учитывая что \\(\\dot{h} = \\dot h = \\frac{s}{a} \\dot s\\):\n\n[T = \\frac{m \\dot{s}^2}{2} \\frac{s^2}{a^2}]\n\nЛевая часть уравнения Лагранжа запишется в виде:\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot s} - \\frac{\\partial T}{\\partial s} =  m \\frac{d}{dt} \\left( \\frac{s^2}{a^2} \\dot{s} \\right) - m  \\frac{s}{a^2} \\dot{s}^2 = \\frac{ms}{a^2} \\left( \\dot s^2 + s \\ddot s \\right)]\n\nОбобщенную силу \\(Q_s\\) определим, записав выражение для элементарной работы сил на элементарном перемещение \\(\\delta s\\):\n\n[\\delta A = \\delta A_g + 4 \\delta A_D + 4 \\delta A_F]\n\nКоэффициент 4 учитывает то, что ступень садится на 4 посадочные опоры и при взаимодействии опор с поверхностью земли все четыре силы демпфера и все четыре силы трения совершают работу. Элементарная работа силы тяжести при вертикальном перемещении корпуса ступени определяется как\n\n[\\delta A_g = - m g \\delta h = - m g \\frac{s}{a} \\delta s]\n\nЗнак минус учитывает, что при положительной вариации \\(\\delta h\\) (высота увеличивается) работа совершаемая силой тяжести будет отрицательной. Элементарная работа демпфера при отрицательном элементарном перемещении (сжатии демпфера) будет отрицательной, поэтому\n\n[\\delta A_D = D \\delta s,]\n\nгде \\(D\\) - сила сопротивления демпфера при его деформации. Элементарная работа силы трения при элементарном перемещении точки К  вдоль поверхности земли \\(\\delta K\\):\n\n[\\delta A_F = - F \\delta K = - N \\mu \\frac{\\partial }{\\partial h} \\left( \\sqrt{l^2-h^2} \\right) \\delta h = \n    N \\mu \\frac{hs}{a \\sqrt{l^2-h^2}} \\delta s]\n\nгде \\(\\mu\\) – коэффициент трения. Силу реакции опоры \\(N\\) определим, записав уравнение вертикального движения центра масс возвращаемой ступени под действием внешних сил:\n\n[m \\ddot{h} = 4N - m g]\n\nиз которого следует, что\n\n[N = (m \\ddot{h} + m g)/4.]\n\nВертикальное ускорение \\(\\ddot h\\) определим из полученного ранее кинематического уравнения\n\n[\\dot s = \\frac{a}{s} \\dot h]\n\nпродифференцировав его\n\n[\\ddot h = \\frac{1}{a}(\\ddot s s + \\dot{s}^2)]\n\nВыражение для элементарной работы примет вид:\n\n[\\delta A = - m g \\frac{s}{a} \\delta s + 4 D \\delta s + \\mu m \\frac{hs(\\frac{1}{a}(\\ddot s s + \\dot{s}^2) + g)}{a \\sqrt{l^2-h^2}} \\delta s]\n\nЗапишем обобщенную силу:\n\n[Q_s = - m g \\frac{s}{a} + 4 D + \\mu m \\frac{hs(\\frac{1}{a}(\\ddot s s + \\dot{s}^2) + g)}{a \\sqrt{l^2-h^2}}]\n\nУравнение движения примет вид:\n\n[m s \\dot s^2 + m s^2 \\ddot s = - m g s a + 4 D a^2 + \\mu m \\frac{hs(\\ddot s s + \\dot{s}^2 + a g)}{\\sqrt{l^2-h^2}}]\n\nРазрешив это уравнение относительно старшей производной, получим:\n\n[\\ddot{s} = \\frac{1}{s} \\left( \\frac{4 a^2 x}{m s \\left(x-\\mu  h\\right)}D-a g-\\dot s^2 \\right)]\n\nгде \\(x = \\sqrt{l^2-h^2}\\).\n\nСтационарное решение этого уравнения при \\(\\ddot s = \\dot s = 0\\)\n\n[\\frac{4 a^2 x}{m s \\left(x-\\mu  h\\right)}D - a g = 0]\n\nИз стационарного решения можно вывести минимальное усилие, создаваемое демпфером, при котором система будет находится в равновесии:\n\n[D_{min} = ag \\frac{m s \\left(x-\\mu  h\\right)}{4 a^2 x},]\n\nкоторое в случае отсутствия трения опоры о поверхность земли (\\(\\mu = 0\\)) примет вид:\n\n[D_{min} = \\frac{mg}{4} \\frac{s}{a}]\n\nЭнергия, поглощаемая демпфером\n\nПосле касания опорами поверхности земли уменьшается кинетическая энергия ступени и её потенциальная энергия в поле силы тяжести за счет перемещения центра масс вниз на \\(h_0 - h_k\\).\n\n\n\nЭта энергия поглощается демпферами посадочных опор:\n\n[\\frac{m V_0^2}{2} + m g (h_0-h_k) = 4 D(s_0-s_k)]\n\nВ правой части этого уравнения энергия поглощаемая всеми четырьмя демпферами посадочных опор. Энергия поглощаемая одним демпфером:\n\n[E_D = \\frac{1}{4} \\left[ \\frac{m V_0^2}{2} + m g (h_0-h_k) \\right]]\n\nУчитывая зависимость \\(s\\) от \\(h\\), получим\n\n[\\frac{m V_0^2}{2} + m g \\frac{s_0^2-s_k^2}{2a} = 4 D(s_0-s_k)]\n\nВыполнив замену \\(s_k = s_0 - \\Delta s\\), запишем квадратное уравнение для определения  деформации демпфера \\(\\Delta s\\) при заданной силе сопротивления \\(D\\):\n\n[-\\frac{mg}{2a} (\\Delta s)^2 + (\\frac{mg}{a}s_0 - 4D)\\Delta s + \\frac{m V_0^2}{2} = 0]\n\nи выражение для определения силы смятия демпфера \\(D\\) при заданной его деформации и начальной вертикальной скорости:\n\n[D  = \\frac{m g}{4 a}\\left[s_0 + \\frac{V_0^2 a}{2 g \\Delta s} - \\frac{\\Delta s}{2} \\right]]\n\nНа следующем рисунке показаны графики минимального усилия смятия демпфера в зависимости от его максимальной деформации и начальной вертикальной скорости возвращаемого блока.\n\n\n\nЭнергия поглощаемая демпфером одной посадочной опоры:\n\n[E_D  = \\frac{m g}{4 a}\\left[s_0 + \\frac{V_0^2 a}{2 g \\Delta s} - \\frac{\\Delta s}{2} \\right] \\Delta s]\n\nЧисленное интегрирование уравнения движения\n\nЧисленно проинтегрируем полученное уравнение движения в среде python.\n\n# Именованный кортеж для хранения параметров системы\nfrom collections import namedtuple\n# Массивы и матрицы\nimport numpy as np\n# Численное интегрирование дифференциальных уравнений\nfrom scipy.integrate import solve_ivp\n# Графики\nimport matplotlib.pyplot as plt\n\n\nФункция правых частей системы дифференциальных уравнений:\n\ndef dydt(t, y, p):  \n    # Длина демпфера\n    s     = y[0]\n    # Скорость изменения длины демпфера ds/dt\n    ds    = y[1]    \n    # Высота \n    h     = np.sqrt((s**2 - p.l**2 - p.a**2)/(2*p.a))    \n    # x\n    x     = np.sqrt(p.l**2-h**2)     \n    D = p.D\n    # dv/dt =   \n    d2s   = 4*p.a*p.a*D*x/(p.mass*(x-p.mu*h)*s*s) - (p.a*p.g+ds*ds)/s \n    return np.array([ds,d2s])\n\n\nФункция для остановки процесса интегрирования, когда скорость изменения деформации демпфера достигнет нуля:\n\ndef event_ds_eq_0(t, y):\n    # Функция-\"детектор\", передаваемая в интегратор (параметр events), \n    # для определения времени достижения нулевой скорости вертикальной скорости \n    # остановки процесса интегрирования    \n    return y[1]\n\n# функция определяется условие h = 0 при движении \"вниз\"\nevent_ds_eq_0.direction = 1\n# функция-детектор активна\nevent_ds_eq_0.terminal  = True  \n\n\nСоздаем именованный кортеж params с параметрами системы\n\nparams = namedtuple(\"params\", \"l a mass g D\")\n\n# Масса ступени\nparams.mass = 30000.0 \n# Расстоянием между шарнирами подкосов\nparams.a    = 3.0\n# Длина подкоса постоянной длины\nparams.l    = 6.5\n# Ускорение свободного падения\nparams.g    = 9.807\n# Коэффициент трения\nparams.mu   = 0.0\n# Сила, создаваемая демпфером\nparams.D    = 250000\n\n# Начальные условия:\n# начальная вертикальная скорость\ndh0 = -2.0\n# начальная длина демпфирующего подкоса\ns0  = 8.5\n# начальная скорость деформации демпфера\nds0 = dh0*params.a/s0\n\n\nЗапуск процесса численного интегрирования:\n\n# Без учета трения\nsol      = solve_ivp(lambda t,y: dydt(t,y,params), [0, 1], [s0, ds0], method='LSODA', events = [event_ds_eq_0], rtol = 1e-9)\n# С учетом трения\nparams.mu   = 0.4\nsol_mu01 = solve_ivp(lambda t,y: dydt(t,y,params), [0, 1], [s0, ds0], method='LSODA', events = [event_ds_eq_0], rtol = 1e-9)\n\n\nДля сравнения получены решения для нулевого трения и для трения \\(\\mu = 0.4\\). Используя полученные решения, вычисляем (таблицы) высоту и вертикальную скорость:\n\n# Определяем таблицу изменения высоты \nh        = (sol.y[0]**2-params.l**2-params.a**2)*0.5/params.a\nh_mu01   = (sol_mu01.y[0]**2-params.l**2-params.a**2)*0.5/params.a\n# и вертикальной скорости\ndh       = sol.y[0]*sol.y[1]/params.a\ndh_mu01  = sol_mu01.y[0]*sol_mu01.y[1]/params.a\n# и время остановки (достижение нулевой скорости)\ntmax      = sol.t.max()\n\n\nПостроение графиков изменения длины подкоса BК:\n\nplt.figure(figsize=[11,5])\nplt.subplot(121)\nplt.plot(sol.t,sol.y[0]-s0);\nplt.plot(sol_mu01.t,sol_mu01.y[0]-s0);\nplt.xlabel('t, c'); plt.ylabel('$\\Delta s$, м');plt.xlim([0,tmax])\nplt.grid(True,ls=':')\nplt.legend(['$\\mu=0.0$','$\\mu=0.4$'])\nplt.title('Деформация демпфера')\nplt.subplot(122)\nplt.plot(sol.t,sol.y[1]);\nplt.plot(sol_mu01.t,sol_mu01.y[1]);\nplt.xlabel('t, c'); plt.ylabel('ds/dt, м/c'); plt.xlim([0,tmax])\nplt.grid(True,ls=':')\nplt.legend(['$\\mu=0.0$','$\\mu=0.4$'])\nplt.title('Скорость деформации демпфера')\nplt.tight_layout()\nplt.savefig('Falcon_s_ds.png',dpi=160)\n\n\n\n\nПри выбранных параметрах сотовый демпфер поглощает кинетическую энергию на перемещении (деформации) около 0,33 м за 0,9 секунд. Можно оценить поглощенную энергию или суммарную по модулю работу демпферов : \\(А = 4 D \\cdot \\Delta s = 4 \\cdot 250 кН \\cdot 0.33 м = 83 кДж\\).\n\nПостроение графиков изменения высоты:\n\nplt.figure(figsize=[14,4])\n\nplt.subplot(121)\nplt.plot(sol.t,h);\nplt.plot(sol_mu01.t,h_mu01);\nplt.xlabel('t, c'); plt.ylabel('h, м');plt.xlim([0,tmax])\nplt.grid(ls=':')\nplt.legend(['$\\mu=0.0$','$\\mu=0.4$'])\nplt.title('Высота')\n\nplt.subplot(122)\nplt.plot(sol.t,dh);\nplt.plot(sol_mu01.t,dh_mu01);\nplt.xlabel('t, c'); plt.ylabel('dh/dt, м/c');plt.xlim([0,tmax])\nplt.grid(ls=':')\nplt.legend(['$\\mu=0.0$','$\\mu=0.4$'])\nplt.title('Вертикальная скорость')\n\nplt.savefig('Falcon_h_dh.png',dpi=150)\n\n\n\n\nЗадание\n\nМасса возвращаемой ступени в момент посадки равна 30 т, AK=6.5 м, BK = 8 м, \\(a\\) = 3 м. Ступень касается земли с начальной вертикальной скоростью 3 м/с.\n\n  Найти минимальное необходимое усилие смятия демпфера \\(D_{0.4}\\) при \\(\\mu = 0.4\\) и деформации демпфера не более 0.5 м.\n  Найти минимальное необходимое усилие смятия демпфера \\(D_{0.0}\\) при \\(\\mu = 0.0\\) и деформации демпфера не более 0.5 м.\n  Верифицировать модель, убедившись в равенстве нулю суммы начальной кинетической энергии возвращаемой ступени, работы сили тяжести, работы демпферов и сил трения опор.\n\n",
      "url": "/pages/mechanics-in-space/falcon-leg/"
    },{
      
      "title": "Статистические функции и сортировка",
      
      "content": "Рассмотрим в качестве примера матрицу 4x3\n\na = [1.0 2.0 3.0;\n     1.2 5.2 6.1;\n     1.3 8.0 9.6;\n     1.5 3.6 1.6];\n\n\nСтатистические функции\n\nСумма\n\nФункция sum вычисляет сумму элементов в столбцах или строках. Если аргумент функции является строка и столбец, то вычисляется сумма всех элементов, если матрица, то по умолчанию вычисляется сумма элементов в столбцах\n\n&gt;&gt; sum(a)\n\nans =\n    5.0000   18.8000   20.3000\n\n\nВторой аргумент функции sum это номер измерения, в котором требуется вычислить сумму: 1 – сумма элементов в столбцах (это действие по умолчанию), 2 – в строках\n\n&gt;&gt; sum(a,2)\n\nans =\n    6.0000\n   12.5000\n   18.9000\n    6.7000\n\n\nДля того, чтобы найти сумму всех элементов матрицы, можно дважды применить функцию sum\n\n&gt;&gt; sum(sum(a))\n\n\nили вызвать функцию один раз для матрицы преобразованной в один столбец a(:)\n\n&gt;&gt; sum(a(:))\n\n\nМаксимальное значение\n\nАналогично действует функция определения максимального значения max. Функция вычисляет максимальное значение элемента в каждом столбце, если первым аргументом в функцию передана матрица\n\n&gt;&gt; max(a)\n\nans =\n    1.5000    8.0000    9.6000\n\n\nВ отличие от функции sum, для того, чтобы найти максимальные значения в строках матрицы a, номер измерения необходимо передать третьим аргументом\n\n&gt;&gt; max(a,[],2)\n\nans =\n    3.0000\n    6.1000\n    9.6000\n    3.6000\n\n\nВторым аргументом в функцию max можно передать еще одну матрицу той же размерности, что и матрица a. В этом случае будет определятся максимальное значение в двух матрицах:\n\n&gt;&gt; a = [1 2; \n        3 4];\n\n&gt;&gt; b = [2 0;\n        5 1];\n\n&gt;&gt; max(a,b)\n\nans =\n     2     2\n     5     4\n\n\nМинимальное значение\n\nАналогичным образом действует функция min\n\na = [1.0 2.0 3.0;\n     1.2 5.2 6.1;\n     1.3 8.0 9.6;\n     1.5 3.6 1.6];\n\n&gt;&gt; min(a)\n\nans =\n    1.0000    2.0000    1.6000\n\n&gt;&gt; min(a,[],2)\n\nans =\n    1.0000\n    1.2000\n    1.3000\n    1.5000    \n\n\nЧтобы определить не только минимальное или максимальное значение в матрице, то и положение (индекс) минимального или максимального элемента, необходимо вызвать функцию min или max с двумя возвращаемыми значениями\n\n&gt;&gt; [min_values, min_index] = min(a)\n\nmin_values =\n\n    1.0000    2.0000    1.6000\n\n\nmin_index =\n\n     1     1     4\n\n\nВ этом случае min_values  будет содержать найденные минимальные значения в столбцах матрицы, а min_index – номера строк этих элементов.\n\nСреднее значение\n\nСреднее значение элементов в столбцах. Для матрицы \\(a\\) \\(m \\times n\\)\n\n[M_1(a) = \\sum_{i=1}^m a_{i,j} / m]\n\n&gt;&gt; mean(a)\n\nans =\n    1.2500    4.7000    5.0750\n\n\nСреднее значение элементов в строках\n\n[M_2(a) = \\sum_{j=1}^n a_{i,j} / n]\n\n&gt;&gt; mean(a,2)\n\nans =\n    2.0000\n    4.1667\n    6.3000\n    2.2333\n\n\nСтандартное отклонение\n\nДля вычисления несмещенной оценки стандартного отклонения элементов в столбцах используется функция std\n\n[\\sigma_1(a) = \\sqrt{\\sum_{i=1}^m (a_{i,j} - M_1)^2 / (m-1)}]\n\n&gt;&gt; std(a)\n\nans =\n    0.2082    2.5586    3.5547\n\n\nДля вычисления смещенной оценки\n\n[\\sigma_1(a) = \\sqrt{\\sum_{i=1}^m (a_{i,j} - M_1)^2 / m}]\n\nфункция std вызывается со вторым аргументом равным 1 (по умолчанию он равен 0)\n\n&gt;&gt; std(a,1)\n\nans =\n    0.1803    2.2159    3.0785\n\n\nТретий аргумент функции – номер размерности\n\n&gt;&gt; std(a,0,2)\n\nans =\n    1.0000\n    2.6083\n    4.4034\n    1.1846\n\n\nСортировка\n\nДля сортировки элементов матрицы в столбцах или строках используется функция  sort. Сортировка элементов в столбцах\n\n&gt;&gt; a = [1.0 2.0 3.0;\n        1.2 5.2 6.1;\n        1.3 8.0 9.6;\n        1.5 3.6 1.6];\n\n&gt;&gt; sort(a)\n\nans =\n    1.0000    2.0000    1.6000\n    1.2000    3.6000    3.0000\n    1.3000    5.2000    6.1000\n    1.5000    8.0000    9.6000\n\n\nи в строках\n\n&gt;&gt; sort(a,2)\n\nans =\n    1.0000    2.0000    3.0000\n    1.2000    5.2000    6.1000\n    1.3000    8.0000    9.6000\n    1.5000    1.6000    3.6000\n\n\nЧтобы узнать порядковые номера элементов из старого массива в новом необходимо вызвать функцию sort с двумя возвращаемыми значениями\n\n&gt;&gt; [sorted, index] = sort(a)\n\nsorted =\n    1.0000    2.0000    1.6000\n    1.2000    3.6000    3.0000\n    1.3000    5.2000    6.1000\n    1.5000    8.0000    9.6000\n\nindex =\n     1     1     4\n     2     4     1\n     3     2     2\n     4     3     3\n\n\nВ первую переменную sorted запишется отсортированная матрица, а во вторую index номера строк первой матрицы, в которых располагался соответствующий элемент столбца. Например, глядя на матрицу index, можно сказать, что после сортировки элементы в первом столбце остались на своих местах, четвертый элемент второго столбца переместился на вторую позицию, второй элемент – на третью и третий элемент (максимальный) на четвертую.\n\nЕсли необходимо отсортировать элементы столбцов в соответствии с сортировкой, например, третьего столбца необходимо сделать так:\n\n&gt;&gt; [sorted, index] = sort(a);\n&gt;&gt; a(index(:,3),:)\n\nans =\n    1.5000    3.6000    1.6000\n    1.0000    2.0000    3.0000\n    1.2000    5.2000    6.1000\n    1.3000    8.0000    9.6000\n\n\nПервым действием выполняем сортировку матрицы (независимо каждый столбец). Вторым действием выбираем из исходной матрицы строки в соответствии с новым положением элементов в третьем столбце: 4, 1, 2 и 3 строки.\n\n",
      "url": "/pages/matlab/functions/"
    },{
      
      "title": "Игра \"Жизнь\"",
      
      "content": "Разработать программу игры “Жизнь” на замкнутой поверхности (на торе) размером \\(N \\times M\\).\n\n\n  Начальная конфигурация колонии задается в текстовом файле в виде пар координат клеток или в виде матрицы.\n  В этом же файле (в начале файла) указывается размер поля (если колония задана парами координат).\n  Программа должна загружать начальное положение колонии из заданного пользователем текстового файла, задаваемого параметром командной строки\n  Программа должна показывать на экране в графическом виде развитие колонии на протяжении заданного числа поколений (параметр командной строки) или пока пользователь не остановит выполнение программы.\n  На экране должны отображатья номер поколения и количество клеток колонии.\n  Программа должна создавать файл с анимацией развития колонии на протяжении заданного числа поколений.\n  Цвет клеток, цвет поля (фон), цвет сетки должен задаваться в конфигурационном файле. При отсутвии файла эти цвета принимают значения по умолчанию.\n\n\nИспользуемые пакеты и модули: numpy, matplotlib\n\nСм. также: https://nickcharlton.net/posts/drawing-animating-shapes-matplotlib.html\n\nСписок заданий\n",
      "url": "/pages/python/course_works/game_life/"
    },{
      
      "title": "Игра \"Жизнь\" на языке Python",
      
      "content": "Правила\n\nДано бесконечное поле, разделенное на ячейки. Ячейка может быть свободной или занятой “живой” клеткой. Клетки на поле образуют колонию. У каждой ячейки есть восемь ближайших смежных (граничащих) с ней ячеек, которые могут быть заняты другими клетками.\n\nКолония изменяется по следующим правилам:\n\n\n  Если у клетки заняты соседями две или три смежных ячейки, то клетка “выживает” и  переходит в следующее поколение, в противном случае она “умирает” от перенаселения или недостатка соседей.\n  Если рядом с пустой ячейкой находятся ровно три живые клетки, то на месте этой ячейки  появляется новая клетка.\n  В процессе смены поколения “умирающие” клетки считаются принадлежащими колонии до определения всех новых клеток и клеток, переходящих в следующее поколение. Также и рождающиеся считаются принадлежащими следующему поколению и не оказывают влияние на количество соседей клеток текущего поколения.\n\n\n\n\nКолония\n\nКолония задана множеством пар координат клеток на бесконечном поле, например:\n\ncolony = { (2,2), (3,2), (4,2), (4,3), (3,4) }\n\n\nСписок соседей\n\nФункция, формирующая список пар координат смежных ячеек для клетки с координатами (x,y). Функция создает список координат смежных ячеек, а затем при помощи функции filter оставляет только те ячейки, которые заняты клетками.\n\ndef get_neighbours(cell, colony):\n    # Кортеж смещений координат смежных ячеек\n    dxdy = ((1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1),(1,0))\n    # Пары координат 8 смежных ячеек\n    nearest_pairs = [(cell[0]+dx,cell[1]+dy) for dx,dy in dxdy]\n    # Оставляет только те из них, которые заняты живыми клетками\n    neighbours = set(filter(lambda c: c in colony,nearest_pairs))\n    return neighbours\n\n\nНапример, для колонии\n\ncolony = { (2,2), (3,2), (4,2), (4,3), (3,4) }\n\n\nфункция вернет\n\nget_neighbours((3,2),colony)\n\n&gt; {(2, 2), (4, 2), (4, 3)}\n\n\nАреал колонии\n\nАреал колонии это множество пустых ячеек, с каждой из которых граничит хотя бы одна живая клетка (занятая ячейка) колонии. Функция get_areal при помощи списочного выражения формирует список смежных ячеек для каждой клетки колонии, объединяя затем все смежные клетки в одно множество. Из полученного множества вычитается множество ячеек, занятых клетками колонии, чтобы получить только ареал колонии.\n\ndef get_areal(colony):\n    dxdy  = [(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1),(1,0)]\n    areal = set([(cell[0]+dx,cell[1]+dy) for dx,dy in dxdy for cell in colony])\n    return areal.difference(colony)\n\n\nДля рассматриваемого примера колонии функция get_areal вернёт:\n\narea = get_areal(colony)    \nprint(area)\n\n&gt; {(4, 4), (2, 4), (1, 2), (2, 1), (4, 1), (3, 1), (5, 4), (1, 1), (5, 1), (2, 3), (4, 5), (3, 3), (5, 3), (2, 5), (1, 3), (3, 5), (5, 2)}\n\n\nСледующее поколение\n\ndef next_generation(colony):  \n    # Рождающиеся клетки (клетка из ареала колонии с 3 соседями)      \n    born = set(filter(lambda c: len(get_neighbours(c, colony))==3,get_areal(colony)))\n    # Клетка переходящая в следующее поколение (2 или 3 соседа)\n    live = set(filter(lambda c: len(get_neighbours(c, colony)) in (2,3), colony))\n    # Объединяем рождающиеся клетки с выжившими клетками в одно множество\n    next_generation = born.union(live)\n    return next_generation\n\n\nДля рассматриваемого примера колонии функция next_generation вернёт:\n\nprint(next_generation(colony))\n\n&gt; {(2, 3), (4, 3), (3, 1), (3, 2), (4, 2)}\n\n\ncolony = { (2,2), (3,2), (4,2), (4,3), (3,4) }\nfor i in range(0,5):\n    fig,ax = plt.subplots(figsize=[3,3])\n    [ax.add_patch(Rectangle((x, y), 1, 1)) for x,y in colony]\n    plt.xlim([-1,7])\n    plt.ylim([-1,7])\n    plt.grid(ls=':')\n    colony = next_generation(colony)    \n\n\n\n  \n    \n      Поколение 1\n      Поколение 2\n      Поколение 3\n    \n  \n  \n    \n      \n      \n      \n    \n    \n      Поколение 4\n      Поколение 5\n       \n    \n    \n      \n      \n       \n    \n  \n\n\n\n  Игра “Жизнь” на языке MATLAB\n  Игра “Жизнь” на языке SQL\n\n",
      "url": "/pages/python/game_life/"
    },{
      
      "title": "Игра Жизнь",
      
      "content": "Главная\n\nФайл-функция get_neighbours_cells.m\n\nФункция get_neighbours_cells возвращает матрицу (8x2) координат смежных (ближайших восьми) клеток для клетки cell.\n\nfunction neighbours = get_neighbours_cells(cell)\n% Координаты ближайших (смежных) клеток для клетки cell = [x, y]\n%\n    neighbours = [-1 -1; 0 -1; 1 -1;\n                  -1  0;       1  0;\n                  -1  1; 0  1; 1  1];\n    \n    neighbours = repmat(cell,8,1) + neighbours;\n\n\nФайл-функция cell_in_colony.m\n\nФункция cell_in_colony определяет принадлежность клетки cell колонии colony. Для определения принадлежности клетки cell колонии colony, список пар координат colony рассматривается как множество пар координат и определяется пересечение этого множество с множеством, состоящем из одной пары координат – клетки cell. Если результатом будет пустое множество, то клетки cell в колонии нет.\n\n%\n% Принадлежит ли клетка cell колонии\n%\nfunction res = cell_in_colony(cell, colony)\n    % Пересечение множества colony с множеством cell\n    сс = intersect(cell,colony,'rows')\n    % Если результат это пустое множество, \n    % то слетки cell в колонии colony нет\n    res = ~isempty(сс);\nend\n\n\nКороткая форма функции cell_in_colony\n\n%\n% Принадлежит ли клетка cell колонии\n%\nfunction res = cell_in_colony(cell, colony)\n  res = ~isempty(intersect(cell,colony,'rows'));\nend\n\n\nФайл-функция count_cell_neighbours.m\n\nФункция count_cell_neighbours определяет количество соседей у клетки cell в колонии colony\n\n%\n% Количество соседей у клетки с координатами cell = [x, y]\n%\nfunction count = count_cell_neighbours(cell, colony)    \n    % 8 ближайших клеток\n    neighbours = get_neighbours_cells(cell);                \n    count = sum(arrayfun(@(i) cell_in_colony(neighbours(i,:), colony), 1:size(neighbours,1)));\nend    \n\n\nФайл-функция get_colony_area.m\n\nФункция get_colony_area, возвращающая ареал колонии colony: все клетки, принадлежащие колонии или смежные с клетками колонии.\n\nfunction cells = get_colony_area(colony)\n    % результат -- это все клетки колонии\n    cells = colony;\n    % и клетки смежные с клетками колонии\n    for i=1:size(colony,1)\n        % список ближайших для клетки i\n        nearest = get_neighbours_cells( colony(i,:) );\n        cells = union(cells, nearest, 'rows');\n    end\n\n\nФайл-функция next_generation.m\n\nФункция next_generation возвращает следующее поколение для colony\n\nfunction next_gen = next_generation(colony)    \n    next_gen = [];\n    % Список клеток -- ареал колонии \n    area = get_colony_area(colony);\n    % Для каждой клетки из ареала\n    for i=1:size(area,1)\n        cell = area(i,:);\n        % Количество соседей у клетки i из ареала\n        n = count_cell_neighbours(cell, colony);\n        % Если 3 или (2 и клетка занята), \n        % то добавляем клетку в новое поколение\n        if n == 3 || (n == 2 &amp;&amp; cell_in_colony(cell, colony))\n            next_gen = [next_gen; cell];\n        end        \n    end\n\n\nОсновной файл-скрипт (main.m)\n\n% Начальное состояние колонии\ncells = [ 1, 1; \n          1, 2;\n          1, 3;\n          2, 1;\n          3, 2;          \n          10 10;\n          10 11;\n          10 12];\n\n% Координаты вершин квадрата, изображающего клетку \n% (относительно центра клетки)\nvert  = [-0.5,-0.5, 0.5,-0.5, 0.5,+0.5, -0.5,+0.5];\n\n% границы области\nxlim([-20,20]);\nylim([-20,20]);\n\n% количество поколений\nn_gen = 50;\n\n% Для каждого поколения\nfor i=1:n_gen    \n    % очистить изображение\n    cla;\n    % получить список клеток для следующего поколения\n    cells = next_generation(cells);\n    % сформировать список полигонов для функции patch \n    cells_vertices = repmat(cells,1,4)+repmat(vert,size(cells,1),1);\n    x = (cells_vertices(:,1:2:end))';\n    y = (cells_vertices(:,2:2:end))';    \n    % нарисовать клетки\n    patch(x,y,'r');\n    % включить сетку\n    grid on;\n    % включить рамку\n    box on;\n    % сохранить кадр\n    getframe;\n    % подождать 0.2 с\n    pause(0.2);\nend\n\n\n\n  Игра “Жизнь” на языке Python\n  Игра “Жизнь” на языке SQL\n\n",
      "url": "/pages/matlab/game_life/"
    },{
      
      "title": "Игра Жизнь на SQL",
      "description": "Пример реализации алгоритма игры “Жизнь” на языке SQL.\n",
      "content": "Определения\n\nДано бесконечное поле, разделенное на ячейки. Ячейка может быть свободной или занятой  клеткой. Клетки на поле образуют колонию. У каждой ячейки есть восемь ближайших смежных (граничащих) ячеек, которые могут быть заняты другими клетками.\n\nКолония изменяется по следующим правилам:\n\n\n  Если у клетки заняты соседями две или три смежных ячейки, то клетка “выживает” и  переходит в следующее поколение, в противном случае она “умирает” от перенаселения или недостатка соседей.\n  Если рядом с пустой ячейкой находятся ровно три клетки, то на месте этой ячейки  появляется новая клетка.\n  В процессе смены поколения “умирающие” клетки считаются принадлежащими колонии до определения всех новых клеток и клеток, переходящих в следующее поколение. Также и рождающиеся считаются принадлежащими следующему поколению и не оказывают влияние на количество соседей клеток текущего поколения.\n\n\n\n\nТаблицы и представления\n\nКолония описывается множеством пар координат клеток. Таблица cells хранит координаты клеток колонии и номер поколения, которому они принадлежат:\n\nCREATE TABLE cells (\n    x BIGINT,\n    y BIGINT,\n    gen BIGINT,\nCONSTRAINT UQ_xy UNIQUE (x, y, gen)\n);\n\n\nПредставление (VIEW), которое возвращает координаты клеток последнего поколения из таблицы cells:\n\nCREATE VIEW LastGen AS \n    SELECT x,y,gen \n    FROM \n        cells \n    WHERE \n        gen = (SELECT max(gen) from cells);\n\n\nВспомогательная неизменяемая таблица относительных координат смежных ячеек:\n\nCREATE TABLE dxdy (\n    x BIGINT,\n    y BIGINT,\n    CONSTRAINT UQ_xy UNIQUE (x, y)\n);\n\n\nВ таблице dxdy восемь записей: у каждой ячейки восемь смежных ей ячеек, которые отличаются на единицу по любой координате:\n\nINSERT INTO dxdy (x,y) VALUES \n ( 1, 1),\n ( 0, 1),\n (-1, 1),\n (-1, 0),\n (-1,-1),\n ( 0,-1),\n ( 1,-1),\n ( 1, 0);\n\n\nПроцедура\n\nПроцедура, вычисляющая следующее поколение и добавляющая координаты клеток нового поколения в таблицу  cells.\n\nНа первом шаге определяется номер текущего поколения, который записывается в локальную переменную current_gen:\nDECLARE current_gen BIGINT DEFAULT 0;\nSELECT max(gen) from cells into current_gen;\n\n\nДалее используется синтаксис INSERT INTO … SELECT для формирования множества координат клеток нового поколения при помощи двух запросов SELECT, результаты которых объединяются оператором UNION.\n\nПервый SELECT выбирает из таблицы cells координаты клеток текущего поколения\n\nC1.gen=current_gen and C2.gen=current_gen\n\n\nи у которых смежные ячейки (C1.x+dxdy.x, C1.y+dxdy.y) заняты\n\nC2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y\n\n\nдвумя или тремя клетками из текущего поколения:\n\nHAVING COUNT(*)=3 OR COUNT(*)=2\n\n\nВторой SELECT выбирает координаты смежных ячеек колонии, у которых ровно три соседа. Смежные ячейки колонии – это множество незанятых смежных ячеек всех её клеток. Незанятые ячейки определяются при помощи левого соединения множества координат смежных ячеек (cells C1) с координатами клеток колонии (cells C2) при условии\n\n(C2.x IS NULL OR C2.y IS NULL) \n\n\nОбъявление процедуры:\n\nDELIMITER $$;\n\nCREATE PROCEDURE NextGen()  \nBEGIN\nDECLARE current_gen BIGINT DEFAULT 0;\nSELECT max(gen) from cells into current_gen;\nINSERT INTO cells (x,y,gen)\n\tSELECT \n\t\tC1.x,C1.y,current_gen+1\tas gn\n\tFROM \n\t\tLastGen C1\n\tJOIN dxdy\n\tJOIN LastGen C2 ON C2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y \n\tGROUP BY \n\t\tx,y,gn\n\tHAVING COUNT(*)=3 OR COUNT(*)=2\nUNION\n\tSELECT \n\t\tC1.x+dxdy.x as nearx,  \n\t\tC1.y+dxdy.y as neary,\n\t\tcurrent_gen+1 as gn\n\tFROM \n\t\tLastGen C1\n\tJOIN dxdy\n\tLEFT JOIN LastGen C2 ON C2.x = C1.x+dxdy.x and C2.y = C1.y+dxdy.y AND (C2.x IS NULL OR C2.y IS NULL)\n\tGROUP BY \n\t\tnearx,neary,gn\n\tHAVING COUNT(*) = 3;\nEND $$\n\nDELIMITER ;\n\n\nПример\n\nКолония “Глайдер”, которая через 4 поколения смещает вниз и вправо на одну клетку:\n\nINSERT INTO cells (x,y,gen) VALUES \n\t( 1, 1, 1),\n\t( 2, 1, 1),\n\t( 3, 1, 1),\n\t( 3, 2, 1),\n    ( 2, 3, 1),\n\n\nПервое поколение:\n\n\n\nselect * from LastGen;\n\nx|y|gen|\n-|-|---|\n1|1|  1|\n2|1|  1|\n2|3|  1|\n3|1|  1|\n3|2|  1|\n\n\nСостояние колонии через четыре поколения:\n\nCALL NextGen();\nCALL NextGen();\nCALL NextGen();\nCALL NextGen();\n\nselect * from LastGen;\n\n\nselect * from LastGen;\n\nx|y|gen|\n-|-|---|\n2|0|  5|\n3|0|  5|\n3|2|  5|\n4|0|  5|\n4|1|  5|\n\n\n\n\n\n  Игра “Жизнь” на языке Python\n  Игра “Жизнь” на языке MATLAB\n\n",
      "url": "/pages/databases/gamelife_sql/"
    },{
      
      "title": "Пример базы данных сети магазинов бытовой техники",
      
      "content": "База данных продавца бытовой техники содержит информацию о продаваемых товарах, их категориях, производителях, филиалах (магазинах), поставках товаров, изменений цен на товары, покупателях и покупках. База данных состоит из 8 таблиц:\n\n  clients (покупатели)\n  products (товары)\n  purchases (покупки)\n  purchase_item (элемент покупки)\n  deliveries (поставки)\n  price_change (изменения цены товаров)\n  categories (категории товара)\n  manufacturers (производители товара)\n\n\nСкачать базу данных SQLite\n\nТаблицы\n\nКатегории (categories)\n\nТаблица категорий (типов) товаров состоит из двух столбцов: столбца идентификатора категории и столбца наименования категории.\n\n\n  \n    \n      Идентификатор категории (PK)\n      Наименование категории\n    \n  \n  \n    \n      category_id\n      category_name\n    \n  \n\n\nПример содержимого таблицы:\n\ncategory_id | category_name\n------------|-----------------------\n1           | Компьютерная техника\n2           | Офис и канцелярия\n3           | Мелкая бытовая техника\n\n\nПроизводители товара (manufacturers)\n\nВ таблице содержится информация об идентификаторе производителя товара и его наименовании.\n\n\n  \n    \n      Идентификатор производителя (PK)\n      Наименование производителя\n    \n  \n  \n    \n      manufacturer_id\n      manufacturer_name\n    \n  \n\n\nПример содержимого таблицы:\n\nmanufacturer_id | manufacturer_name\n----------------|------------------\n1               | Calve\n2               | TESCOMA\n3               | Haier\n4               | Nescafe\n5               | Be quiet\n\n\nТовары (products)\n\nВ таблице содержатся идентификатор товара, его наименование, ссылка на идентификатор поставщика (внешний ключ), ссылка на идентификатор категории (внешний ключ), к которой относится товар.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Наименование товара\n      Идентификатор поставщика (FK)\n      Идентификатор категории (FK)\n    \n  \n  \n    \n      product_id\n      product_name\n      manufacturer_id\n      category_id\n    \n  \n\n\nПример содержимого таблицы\n\nproduct_id | product_name                        | manufacturer_id | category_id\n-----------|-------------------------------------|-----------------|------------\n1          | Кухонный комбайн KitchenAid 5KSM156 | 71              | 3\n2          | Видеокарта Asus GeForce GT 1030     | 29              | 1\n3          | Ноутбук HP ENVY 13-ad000            | 486             | 1\n4          | Фен Dewal 03-401                    | 124             | 3\n5          | Кофеварка Gastrorag CM-717          | 225             | 3\n\n\nИзменения цен на товары (price_change)\n\nЦены на товары могут изменяться. Для учета изменения цен на товары используется таблица price_change. В таблице содержатся ссылка на товар (внешний ключ), дата изменения цены товара и новая цена. Таким образом, для того, чтобы узнать цену товара на заданную дату необходимо найти ближайшую дату (в прошлом) изменения его цены.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Дата изменения цены\n      Новая цена\n    \n  \n  \n    \n      product_id\n      date_price_change\n      new_price\n    \n  \n\n\nВ базе SQLite Дата изменения цены хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года. В базе данных MySQL/MariaDB используется тип DATE.\n\nПример содержимого таблицы в базе SQLite:\n\nproduct_id | date_price_change | new_price\n-----------|-------------------|----------\n1          | 1546300800        | 58399\n2          | 1546300800        | 5717.8\n3          | 1546300800        | 54890\n4          | 1546300800        | 2632.3\n5          | 1546300800        | 32854.8\n\n\nФилиалы (stores)\n\nВ таблице содержаться идентификаторы филиалов и их наименования.\n\n\n  \n    \n      Идентификатор филиала (PK)\n      Наименование филиала\n    \n  \n  \n    \n      store_id\n      store_name\n    \n  \n\n\nПример:\n\nstore_id | store_name\n---------|-----------\n1        | Филиал №1\n2        | Филиал №2\n3        | Филиал №3\n4        | Филиал №4\n\n\nПоставки (deliveries)\n\nВ таблице содержатся идентификаторы поставленных товаров, филиал, куда бы поставлен товар, дата поставки и количество товара поставленного товара.\n\n\n  \n    \n      Идентификатор товара (PK)\n      Идентификатор филиала\n      Дата поставки\n      Количество товара\n    \n  \n  \n    \n      product_id\n      store_id\n      delivery_date\n      product_count\n    \n  \n\n\nВ базе SQLite дата поставки товара хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года.\n\nПример содержимого таблицы в SQLite:\n\nproduct_id | store_id | delivery_date | product_count\n-----------|----------|---------------|--------------\n0          | 0        | 1546300800    | 5\n0          | 0        | 1556125138    | 9\n1          | 0        | 1546300800    | 5\n1          | 0        | 1575852670    | 9\n2          | 3        | 1546300800    | 5\n\n\nКлиенты (customers)\n\nТаблица содержит идентификаторы и имена клиентов (покупателей).\n\n\n  \n    \n      Идентификатор клиента (PK)\n      Фамилия\n      Имя\n    \n  \n  \n    \n      customer_id\n      customer_lname\n      customer_lname\n    \n  \n\n\nПример содержимого таблицы:\n\ncustomer_id | customer_fname    | customer_lname\n------------|-------------------|---------------\n1           | Митофан Демидович | Дорофеев\n2           | Софрон            | Панов\n3           | Демьян            | Мартынов\n4           | Гостомысл         | Белоусов\n\n\nДля упрощения имя отчество и фамилия клиента (покупателя) хранится в одном столбце.\n\nПокупки (purchases)\n\nТаблицу покупок можно представить как таблицу счетов на оплату товаров, покупаемых в рамках одной покупки (покупка характеризуется уникальным сочетанием: дата, покупатель, филиал). Таблица содержит идентификатор покупки, идентификатор покупателя, совершившего покупку, идентификатор филиала, где была совершена покупка, и дату покупки.\n\n\n  \n    \n      Идентификатор покупки\n      Идентификатор покупателя\n      Идентификатор филиала\n      Дата покупки\n    \n  \n  \n    \n      purchase_id\n      customer_id\n      store_id\n      purchase_date\n    \n  \n\n\nВ базе SQLite дата покупки хранится в формате Unix-время: целое число секунд с полуночи (00:00:00 по Гринвичу) 1 января 1970 года.\n\nПример содержимого таблицы:\n\npurchase_id | customer_id | store_id | purchase_date\n------------|-------------|----------|--------------\n1           | 5           | 3        | 1562533957\n2           | 8           | 2        | 1550822768\n3           | 10          | 1        | 1573857286\n4           | 7           | 2        | 1561828953\n5           | 9           | 3        | 1573889112\n\n\nЗапись в счете (purchase_item)\n\nТаблица содержит информацию о товарах, купленных в рамках одной покупки (товары в счете на оплату). Для упрощения анализа информации о покупках в таблицу введено поле цена продукта, которое заполняется автоматически на основе цены товара на момент покупки.\n\n\n  \n    \n      Идентификатор покупки\n      Идентификатор товара\n      Количество товара\n      Цена товара\n    \n  \n  \n    \n      purchase_id\n      product_id\n      product_count\n      product_price\n    \n  \n\n\nПример содержимого таблицы:\n\npurchase_id | product_id | product_count | product_price\n------------|------------|---------------|--------------\n1           | 26         | 1             | 27929\n1           | 8          | 1             | 20879.1\n2           | 9          | 1             | 4939\n2           | 36         | 1             | 33000\n3           | 41         | 1             | 6356.9\n\n\nСхема связи таблиц базы данных\n\n\n\nSQL-сценарии для создания таблиц\n\nDDL SQL-сценарий для БД MySQL/MariaDB.\n\n\nDROP TABLE IF EXISTS purchase_items;\nDROP TABLE IF EXISTS purchases;\nDROP TABLE IF EXISTS price_change;\nDROP TABLE IF EXISTS deliveries;\nDROP TABLE IF EXISTS products;\nDROP TABLE IF EXISTS manufacturers;\nDROP TABLE IF EXISTS categories;\nDROP TABLE IF EXISTS stores;\nDROP TABLE IF EXISTS customers;\n\nCREATE TABLE categories \n(\n    category_id SERIAL PRIMARY KEY, \n    category_name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE manufacturers\n(\n    manufacturer_id SERIAL PRIMARY KEY, \n    manufacturer_name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE products\n(\n    product_id SERIAL PRIMARY KEY,\n    product_name VARCHAR(255)  NOT NULL,\n    manufacturer_id BIGINT UNSIGNED,    \n    category_id BIGINT UNSIGNED,\n    FOREIGN KEY (category_id) REFERENCES categories (category_id),\n    FOREIGN KEY (manufacturer_id) REFERENCES manufacturers (manufacturer_id)\n);\n\nCREATE TABLE price_change\n(\n    product_id BIGINT UNSIGNED NOT NULL,\n    date_price_change DATE NOT NULL,\n    new_price NUMERIC(9,2) NOT NULL,      \n    CONSTRAINT PK_PRICE_CHANGE PRIMARY KEY (product_id, date_price_change),  \n    FOREIGN KEY (product_id) REFERENCES products (product_id)   \n);\n\nCREATE TABLE stores\n(\n    store_id SERIAL PRIMARY KEY,\n    store_name VARCHAR(255) NOT NULL\n);\n\nCREATE TABLE deliveries\n(    \n    product_id BIGINT UNSIGNED NOT NULL,\n    store_id BIGINT UNSIGNED,\n    delivery_date  DATE NOT NULL,\n    product_count  INTEGER UNSIGNED NOT NULL,    \n    FOREIGN KEY (product_id) REFERENCES products (product_id),\n    FOREIGN KEY (store_id) REFERENCES stores (store_id)\n);\n\n\nCREATE TABLE customers\n(\n    customer_id SERIAL PRIMARY KEY,\n    customer_fname VARCHAR(100) NOT NULL,\n    customer_lname VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE purchases\n(\n    purchase_id SERIAL PRIMARY KEY,\n    customer_id BIGINT UNSIGNED NOT NULL,\n    store_id BIGINT UNSIGNED NOT NULL,    \n    purchase_date DATETIME NOT NULL,\n    FOREIGN KEY (customer_id) REFERENCES customers (customer_id),\n    FOREIGN KEY (store_id) REFERENCES stores (store_id)\n);\n\nCREATE TABLE purchase_items\n(\n    purchase_id BIGINT UNSIGNED NOT NULL,\n    product_id BIGINT UNSIGNED NOT NULL,\n    product_count BIGINT UNSIGNED NOT NULL,\n    product_price NUMERIC(9,2) NOT NULL,\n    CONSTRAINT PK_PURCHASE_ITEMS PRIMARY KEY (purchase_id, product_id),  \n    FOREIGN KEY (product_id) REFERENCES products (product_id),\n    FOREIGN KEY (purchase_id) REFERENCES purchases (purchase_id)\n);\n\n\n\nSQL-сценарий для БД SQLite.\n\n\nDROP TABLE IF EXISTS categories;\nDROP TABLE IF EXISTS manufacturers;\nDROP TABLE IF EXISTS products;\nDROP TABLE IF EXISTS price_change;\nDROP TABLE IF EXISTS stores;\nDROP TABLE IF EXISTS deliveries;\nDROP TABLE IF EXISTS customers;\nDROP TABLE IF EXISTS purchases;\nDROP TABLE IF EXISTS purchase_items;\n\nCREATE TABLE IF NOT EXISTS categories \n(\n    category_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, \n    category_name text  NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS manufacturers\n(\n    manufacturer_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    manufacturer_name TEXT NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS products\n(\n    product_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    product_name text  NOT NULL,\n    manufacturer_id INTEGER  NOT NULL,    \n    category_id INTEGER NOT NULL,\n    FOREIGN KEY ([category_id]) REFERENCES \"categories\" ([category_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([manufacturer_id]) REFERENCES \"manufacturers\" ([manufacturer_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE IF NOT EXISTS price_change\n(\n    product_id INTEGER NOT NULL,\n    date_price_change integer NOT NULL,\n    new_price REAL NOT NULL,      \n    CONSTRAINT PK_PRICE_CHANGE PRIMARY KEY (product_id, date_price_change),  \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION   \n);\n\nCREATE TABLE IF NOT EXISTS stores\n(\n    store_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    store_name text  NOT NULL\n);\n\n\nCREATE TABLE IF NOT EXISTS deliveries\n(    \n    product_id  INTEGER NOT NULL,\n    store_id INTEGER NOT NULL,\n    delivery_date  INTEGER NOT NULL,\n    product_count  INTEGER NOT NULL,    \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([store_id]) REFERENCES \"stores\" ([store_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\n\nCREATE TABLE IF NOT EXISTS customers\n(\n    customer_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    customer_name text  NOT NULL\n);\n\n\nCREATE TABLE IF NOT EXISTS purchases\n(\n    purchase_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n    customer_id INTEGER NOT NULL,\n    store_id INTEGER  NOT NULL,    \n    purchase_date INTEGER NOT NULL,\n    FOREIGN KEY ([customer_id]) REFERENCES \"customers\" ([customer_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([store_id]) REFERENCES \"stores\" ([store_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\nCREATE TABLE IF NOT EXISTS purchase_items\n(\n    purchase_id INTEGER NOT NULL,\n    product_id INTEGER NOT NULL,\n    product_count INTEGER NOT NULL,\n    product_price REAL NOT NULL,\n    CONSTRAINT PK_PURCHASE_ITEMS PRIMARY KEY (purchase_id, product_id),  \n    FOREIGN KEY ([product_id]) REFERENCES \"products\" ([product_id]) ON DELETE NO ACTION ON UPDATE NO ACTION,\n    FOREIGN KEY ([purchase_id]) REFERENCES \"purchases\" ([purchase_id]) ON DELETE NO ACTION ON UPDATE NO ACTION\n);\n\n\n",
      "url": "/pages/databases/goods/"
    },{
      
      "title": "Кратчайший путь",
      
      "content": "\n  \n    Дорожная сеть описывается графом. Вершины графа – населенные пункты, дуги – дороги, сединяющие населенные пункты. Для каждой дуги графа задан её вес (целое положительное число) или путь между двумя вершинами (городами), которые соединяет дуга (дорога). Написать программу поиска кратчайшего пути из вершины \\(i\\) графа к вершине \\(j\\).\n  \n  \n    Исходные данные о сети дорог должны загружаться из текстового файла, в котором должно содержаться не менее 20 населенных пунктов.\n  \n\n\n\n# Пункты\n1 Москва\n2 Самара\n3 Уфа\n...\n\n# Дороги\n1-2 1000\n1-3 458\n...\n\n\n\n\n  Начальная и конечная точки маршрута должны задаваться в диалоговом режиме\n\n\n~~\nВведите пункт отправления: Самара\nВведите пункт назначения: Владивосток \n~~\n\n\n  Результат должен выводится на экран\n\n\nСамара-Уфа-...Владивосток : **** км.\n\n",
      "url": "/pages/python/course_works/graph/"
    },{
      
      "title": "Графики",
      
      "content": "\n  Основы графики    \n      Функция, заданная выражением\n      Табличная функция\n      Несколько графиков на одном рисунке\n      Столбчатые диаграммы\n      Круговые диаграммы\n    \n  \n\n\nОсновы графики\n\nФункция, заданная выражением\n\nДля построения графика функции, заданной выражением в m-файле\n\n% Файл-функция f.m\nfunction res = f(x)\n    res = sin(10*x)+2*x;\n\n\nили при помощи анонимной функции\n\nf = @(x) sin(10*x)+2*x;\n\n\nиспользуется функция fplot\n\nfplot(f,[0 5]);\nxlabel('x, c');\nylabel('f, м');\ngrid on;\ntitle('График зависимости f от x');\n\n\n\n\nТабличная функция\n\nДля построения графиков табличных функций используется функция plot.\n\nx = 0:0.05:5;\ny = sin(10*x)+2*x;\n\n\nТретьим аргументом функции plot можно передать строковую константу, описывающую свойства графика: цвет, тип маркера и тип линии:\n\nplot(x,y,'r--');\nplot(x,y,'k-.','LineWidth',2);\n% размер шрифта и толщина линий  шкал\nset(gca,'FontSize',14,'LineWidth',1.5);\n% подписи осей с указанием размеров шрифтов\nxlabel('x, c','FontSize',14);\nylabel('y, м','FontSize',14);\ngrid on;\n\n\nНекоторые коды цветов, маркеров и типов линий приведены в таблице\n\n\n  \n    \n      Код цвета\n      Цвет\n      Код  маркера\n      Тип маркера\n      Код  линии\n      Тип линии\n    \n  \n  \n    \n      r\n      красный\n      о\n      кружок\n      -\n      сплошная\n    \n    \n      g\n      зеленый\n      .\n      точка\n      –\n      пунктирная\n    \n    \n      b\n      голубой\n      s\n      квадрат\n      -.\n      штрих-пунктирная\n    \n    \n      y\n      желтый\n      *\n      звездочка\n      :\n      пунктирная\n    \n    \n      k\n      черный\n      ^\n      треугольник\n       \n       \n    \n  \n\n\nДля создания рисунка определенного размера можно использовать функцию figure с параметром position, который позволяет задать положение нижней левой точки окна рисунка и его ширину и высоту\n\nx0 = 10; y0 = 10;\nwidth = 500; height = 300;\nfigure('position',[x0, y0, width, height]);\nx = 0:0.5:5;\ny = sin(x);\nplot(x,y);\n\n\nРазмер рисунка можно изменить после его построения, задав свойство position при помощи функции изменения свойств текущего рисунка set(gcf, ….)\n\nx = 0:0.5:5;\ny = sin(x);\nplot(x,y);\n\nx0 = 10; y0 = 10;\nwidth = 500; height = 300;\nset(gcf,'Position',[x0, y0, width, height]);\n\n\ngcf это глобальная переменная-ссылка на выбранный объект figure.\n\nНесколько графиков на одном рисунке\n\nПо умолчанию при нескольких вызовах функции plot на графике будет показана только последняя кривая, поскольку вызов функции plot удаляет предыдущий график. Чтобы изменить это поведение и показать на одном графике несколько кривых, необходимо использовать директиву hold on.\n\nx  = 0:0.1:10;\ny1 = sin(x);\ny2 = cos(x);\n\nplot(x, y1 , 'r-');\n% \"Удерживаем\" предыдущий график\nhold on;\n% строим еще одну кривую (синим пунктиром)\nplot(x, y2, 'b--');\n% Выключаем \"удержание\" \nhold off;\n\n\n\n\n\nНа одном рисунке можно показать несколько графиков мозаикой. Для этого используется функция subplot. Предположим, что необходимо построить 4 графика.\n\nРазбиваем рисунок на 4 ячейки 2x2 и строим график в первой ячейке (1,1)\n\nsubplot(2,2,1);\nx  = linspace(0,2*pi,50); y1 = sin(x);\nplot(x, y1,'r-','LineWidth',2)\n\n\nДвигаемся справа налево, сверху вниз: первые два аргумента – число строк и столбцов, на которое разбит рисунок, третий аргумент – номер ячейки в котором будет строиться следующий график. Порядок нумерации ячеек не такой как у матрицы, а слева-направо и сверху-вниз.\n\nsubplot(2,2,2);\ny2 = cos(x);\nplot(x, y2,'g-','LineWidth',2);\n\n\nАналогично для оставшихся графиков во второй строке рисунка\n\nsubplot(2,2,3);\ny3 = exp(x);\nplot(x, y3,'b-','LineWidth',2);\n\nsubplot(2,2,4);\ny4 = x.^2+2*x;\nplot(x, y3,'y-','LineWidth',2);\n\n\n\n\nСтолбчатые диаграммы\n\nx = 0:0.5:5;\ny = sin(x);\nbar(x,y)\n\n\n\n\nКруговые диаграммы\n\nx = [1, 2, 3, 4];\npie (x);\n\n\n\n\nВторой аргумент – логический массив, указывающий на необходимость изображения соответствующего сектора отдельно от круговой диаграммы.\n\nx = [1, 2, 3, 4];\ny = [0, 0, 1, 0];\npie (x);\n\n\nЕсли сумма элементов массива данных больше или равна единице, то эта сумма принимается за 100%, в противном случае строится диаграмма с пропущенным сектором.\n\nx = [0.1 , 0.2 , 0.5];\npie(x);\n\n\n\n\n",
      "url": "/pages/matlab/graphics/"
    },{
      
      "title": "Проверка статистических гипотез. Часть 1.",
      "description": "Проверка статистических гипотез при помощи функций библиотеки scipy.stats.\n",
      "content": "Статистическая гипотеза – всякое высказывание о генеральной совокупности, которое проверяется (подтверждается или опровергается) по выборке из генеральной совокупности. Предположение о виде распределения и свойствах случайной величины, которое можно подтвердить или опровергнуть применением статистических методов к данным выборки. Гипотеза принимается или не принимается на основе анализа выборки из генеральной совокупности, следовательно может быть ошибочным как принятие так и отвержение гипотезы:\n\n  если нулевая нулевая гипотеза отвергается, когда на самом деле она верна, то совершается ошибка первого рода (ложно-отрицательный ответ).\n  если нулевая нулевая гипотеза принимается, когда на самом деле она не верна, то совершается ошибка второго рода (ложно-положительный ответ).\n\n\nВероятность совершить ошибку первого рода называется уровнем значимости и обычно обозначается как \\(\\alpha\\). Вероятность совершить ошибку второго рода обозначается как \\(\\beta\\), а вероятность не допустить ошибку второго рода \\(1 - \\beta\\) называется мощностью критерия. При проверке статистических гипотез уровень значимости обычно принимают равным 0.1 0.05 или 0.01.\n\nДля проверки гипотезы используют специально-подобранную случайную величину, которая называется статистический критерий. Наблюдаемым значением критерия называют значение критерия, вычисленное по выборке. Критическая область это совокупность значений критерия, при которых нулевая гипотеза отвергается. Критическими точками называют точки, отделяющие критическую область от областей принятия гипотезы.\n\nФункции пакета scipy.stats для проверки гипотез обычно возвращают значение критерия и p-значение, которое сравнивается с уровнем значимости. Если р-значение больше уровня значимости, то нет основания отвергнуть нулевую гипотезу.\n\nСравнение средних значений двух нормальных генеральных совокупностей\n\n\n  Генеральные совокупности X и Y распределены нормально и известны их дисперсии\n  По независимым выборкам объемами n и m найдены выборочные средние \\(\\hat{x}\\) и \\(\\hat{y}\\).\n  Требуется по выборочным средним оценить нулевую гипотезу о том, что генеральные средние рассматриваемых совокупностей равны:\n\n\n[H_0: M(X) = M(Y)]\n\nДля проверке гипотезы о равенстве средних генеральных совокупностей используется функция scipy.stats.ttest_ind.\n\nАргументы функции:\n\n  выборка 1\n  выборка 2\n  equal_var - принимается ли допущение о равенстве дисперсий двух выборок (True/False)\n  alternative альтернативная гипотеза (‘greater’, ‘less’, ‘two-sided’)\n\n\n# Создаем два массива случайных чисел \n# Математическое ожидание равно нулю, стандартное отклонение равно 1 \na = np.random.normal(loc=0.0, scale=1.0, size=30)\nb = np.random.normal(loc=0.0, scale=1.0, size=30)\n\n# Построим эмпирические плотности распределения \ndf = pd.DataFrame( np.vstack((a,b)).transpose(), columns = ('Массив а','Массив b') )\nsns.kdeplot(data = df);\n\n\nАльтернативная гипотеза \\(H_1: M(X) \\neq M(Y)\\). alternative=’two-sided’\n\ns, pvalue = scipy.stats.ttest_ind(a, b, equal_var=True, alternative='two-sided')\nprint('p-значение равно {:5.3f}'.format(pvalue))\n\n\nРезультат:\n\np-значение равно 0.375\n\n\nПредположим, что принятый уровень значимости равен 0,05. Полученное p-значение велико - гораздо больше уровня значимости, следовательно нет оснований отвергнуть нулевую гипотезу о равенстве средних двух генеральных совокупностей. Ожидаемый результат, с учетом того, что массивы a и b сгенерированы с одинаковыми математическими ожиданиями.\n\nАльтернативная гипотеза \\(H_1: M(X) &gt; M(Y)\\). alternative=’greater’\n\ns, pvalue = scipy.stats.ttest_ind(a, b, equal_var=True, alternative='greater')\nprint('p-значение равно {:5.3f}'.format(pvalue))\n\n\nРезультат:\n\np-значение равно 0.621\n\n\nПолученное p-значение велико - гораздо больше уровня значимости, следовательно нет оснований отвергнуть нулевую гипотезу о равенстве средних двух генеральных совокупностей в пользу альтернативной гипотезы.\n\nАльтернативная гипотеза \\(H_1: M(X) &lt; M(Y)\\). alternative=’less’\n\ns, pvalue = scipy.stats.ttest_ind(a, b, equal_var=True, alternative='less')\nprint('p-значение равно {:5.3f}'.format(pvalue))\n\n\nРезультат:\n\np-значение равно 0.379\n\n\nПолученное p-значение велико - гораздо больше уровня значимости, следовательно нет оснований отвергнуть нулевую гипотезу о равенстве средних двух генеральных совокупностей в пользу альтернативной гипотезы.\n\nСравнение выборочной средней с гипотетической генеральной средней нормальной совокупности\n\nПусть генеральная совокупность Х распределена нормально, при это генеральная средняя \\(m\\) неизвестна, но есть основания полагать, что она равна \\(m_0\\). Для проверки этой гипотезы определяется средняя выборки из генеральной совокупности \\(\\hat m\\) и устанавливают значимо или незначимо различаются \\(\\hat m\\) и \\(m_0\\).\n\nГипотеза:\n\n[H_0: \\hat{m} = m_0]\n\nАльтернативная гипотеза:\n\\(H_1: \\hat{m} \\neq m_0\\)\n\nили\n\n[H_1: \\hat{m} &gt; m_0]\n\nили\n\n[H_1: \\hat{m} &lt; m_0]\n\nДля проверки гипотезы о равенстве математического ожидания генеральной совокупности некоторому значения, по результатам оценки математичексого ожидания выборки используется функция scipy.stats.ttest_1samp.\n\nАргументы функции:\n\n  выборка\n  popnmean: предполагаемое математическое ожидание генеральной совокупности\n  alternative: вид альтернативной гипотезы (‘two-sided’, ‘less’, ‘greater’)\n\n\nДля оценки гипотезы используется критерий\n\n[k = \\frac{\\hat{x}-a}{s}]\n\nгде \\(\\hat{x}\\) - среднее значение выборки, \\(a\\) - гипотетическое математическое ожидание генеральной совокупности, \\(s\\) - стандартное отклонение выборки.\n\n# Вычисляем статистику\ntest_4_mean = 0\nk, p_value = scipy.stats.ttest_1samp(a, popmean=test_4_mean)\nprint(\"Критерий = {:4.2f}, p-значение = {:4.2f}\".format(k, p_value) )\n# Вычислим для сравнения значение критерия по приведенной выше формуле\nprint(\"Критерий = {:4.2f}\".format( (np.mean(a)-test_4_mean)*np.sqrt(a.size)/np.std(a,ddof=1) ) )\n\n\nРезультат\n\nКритерий = 0.01, p-значение = 0.99\nКритерий = 0.01\n\n\nПолученное p-значение велико - гораздо больше уровня значимости, следовательно нет оснований отвергнуть нулевую гипотезу о равенстве математического ожидания генеральной совокупности, из которой взята выборка a, значения  test_4_mean = 0.\n\nСравнение двух дисперсий нормальных генеральных совокупностей\n\nНа практике задача сравнения двух дисперсий возникает, когда необходимо сравнить точность приборов, методов измерений или инструментов. Пусть генеральные совокупности X и Y распределены нормально. По независимым выборкам с объемом \\(n_1\\) и \\(n_2\\) определены исправленные выборочные дисперсии \\(s_x^2\\) и \\(s_y^2\\). Требуется по исправленным дисперсиям при заданном уровне значимости $\\alpha$ проверить нулевую гипотезу о том, что генеральные дисперсии рассматриваемых совокупностей равны между собой\n\n[H_0: D(X)=D(Y)]\n\nВ качестве критерия для проверки нулевой гипотезы используется отношение дисперсии:\n\n[F = \\frac{S_1}{S_2}]\n\nЭта величина при справедливости нулевой гипотезы имеет распределение Фишера-Снедекора со степенями свободы \\(k_1 = n_1-1\\), \\(k_2 = n_2-1\\). В зависимости от альтернативной гипотезы определяют правостороннюю, левостороннюю или двухстороннюю критическую области.\n\nПри \\(H_1: D(X)&gt;D(Y)\\) критическую точку находят из условия\n\n[P[F&gt;F_{\\text{кр}}(\\alpha,k_1,k_2)] = \\alpha]\n\nиспользуя функцию scipy.stats.f.isf(alpha, k1, k2)\n\nПример. Пусть даны две выборки размером 12 и 15. Найдем с уровнем значимости 0,05 правую границу критической области для альтернативной гипотезы  \\(H_1: D(X)&gt;D(Y)\\):\n\nalpha = 0.05\nn1 = 12\nn2 = 15\n\nscipy.stats.f.isf(alpha, n1-1,n2-1)\n\n\nРезультат:\n\n2.5654974067604948\n\n\nЕсли наблюдаемое значение критерия, определенного по выборкам, больше критического значения, то нулевую гипотезу отвергают.\n\nДля альтернативной гипотезы $H_1: D(X)&lt;D(Y)$ критическую точку находят из условия\n\n[P[F&lt;F_{\\text{кр}}(\\alpha,k_1,k_2)] = \\alpha]\n\nиспользуя функцию scipy.stats.f.ppf(alpha, k1, k2)\n\nalpha = 0.05\nn1 = 12\nn2 = 15\n\nscipy.stats.f.ppf(alpha, n1-1,n2-1)\n\n\nРезультат:\n\n0.3651436481381948\n\n\nЕсли наблюдаемое значение критерия, определенного по выборкам, меньше критического значения, то нулевую гипотезу отвергают в пользу альтернативной.\n\nДля альтернативной гипотезы $H_1: D(X) \\neq D(Y)$ находят двухстороннюю критическую область\n\n[P[F &lt; F_{\\text{кр,лев}}(\\alpha/2,k_1,k_2)] = \\alpha/2]\n\n[P[F &lt; F_{\\text{кр,пр}}(\\alpha/2,k_1,k_2)] = \\alpha/2]\n\nиспользуя функцию scipy.stats.f.ppf(alpha/2, k1, k2) и scipy.stats.f.isf(alpha/2, k1, k2)\n\nalpha = 0.05\nn1 = 12\nn2 = 15\n\n[scipy.stats.f.ppf(alpha/2, n1-1,n2-1), scipy.stats.f.isf(alpha/2, n1-1,n2-1)]\n\n\nРезультат:\n\n[0.2977244718626554, 3.094589790898802]\n\n\nНулевая гипотеза отвергается, если наблюдаемое значение критерия, определенного по выборкам, не принадлежит определенному интервалу.\n\nПример\n\n# Создаем два массива случайных чисел\n# Математическое ожидание равно нулю, стандартное отклонение равно 1.00 \na = np.random.normal(loc=0.0, scale=1.0, size=50)\n# Математическое ожидание равно нулю, стандартное отклонение равно 1.15 \nb = np.random.normal(loc=0.0, scale=1.15, size=50)\n\n# Вычисляем исправленное среднеквадатичное отклонение выборок\ns_a = np.std(a,ddof=1) \ns_b = np.std(b,ddof=1)\n\n# Вычисляем критерий\nf = (s_a/s_b)**2\n\n# Число степеней свободы \ndf_a = len(a)-1\ndf_b = len(b)-1\n\n# Граница правосторонней области для альтернативной гипотезы D(a)&gt;D(b)\nprint(\"Правая граница критической области {:4.2f}\".format(scipy.stats.f.isf(alpha, df_a,df_b)))\nprint(\"Наблюдаемое значение {:4.2f}\".format(f))\n\npvalue = scipy.stats.f.sf(f, df_a,df_b)\nprint(\"p-значение {:5.3f}\".format(pvalue))\n\n\nРезультат:\n\nПравая граница критической области 1.61\nНаблюдаемое значение 0.57\np-значение 0.973\n\n\nНаблюдаемое значение 0,57 меньше критического 1,61, поэтому нет оснований отвергнуть нулевую гипотезу в пользу альтернативной \\(H_1: D(A)&gt;D(B)\\).\n\nТест Бартлетта проверяет нулевую гипотезу о том, что все входные выборки взяты из популяций с одинаковыми дисперсиями. Для выборок из значительно ненормальных популяций тест Левена более надежен.\n\n# Использование критерия Бартлетта\nscipy.stats.bartlett(a,b)\n\n\nРезультат:\n\nBartlettResult(statistic=3.716836122429798, pvalue=0.05386634897365303)\n\n\np-значение больше уровня значимости 0.05, нулевая гипотеза не может быть отвергнута.\n\n# Использование критерия Левена\nscipy.stats.levene(a,b)\n\n\nРезультат:\n\nLeveneResult(statistic=4.313548588953809, pvalue=0.040426160819560755)\n\n\np-значение больше уровня значимости 0.05, нулевая гипотеза не может быть отвергнута.\n\nСравнение выборочной (исправленной) дисперсии с гипотетической генеральной дисперсией нормальной совокупности\n\nПусть генеральная совокупность распределена нормально, при этом генеральная дисперсия неизвестна, но имеются основания полагать, что она равна предполагаемому значения \\(\\sigma_0^2\\). Из генеральной совокупности извлекается выборка объема n и по этой выборке определяется исправленная дисперсия \\(s^2\\). Требуется по исправленной выборочной дисперсии при заданном уровне значимости проверить нулевую гипотезу:\n\n[H_0: M(s^2) = \\sigma_0^2]\n\nТ.е. необходимо установить, значимо или нет различаются исправленная выборочная и гипотетическая генеральная дисперсии.\n\nКритерий для проверки нулевой гипотезы:\n\n[\\chi^2 = (n-1) \\frac{s^2}{\\sigma_0^2}]\n\nгде \\(s\\) - исправленное стандартное отклонение выборки, \\(\\sigma_0\\)  - предполагаемое стандартное отклонение генеральной совокупности.\n\nКритическая область строится в зависимости от вида альтернативной гипотезы.\n\nЕсли\n\n[H_1: \\sigma &gt; \\sigma_0,]\n\nто строят правостороннюю критическую область и критическая точка определяется при помощи функции scipy.stats.chi2.ppf. Нулевая гипотеза принимается, если \\(\\chi^2&lt;\\chi_{крит}^2\\)\n\n# Уровень значимости\nalpha = 0.01\n# Количество точек в выборке \nn = 13\n# Критическое ПРАВОСТОРОННЕЕ значение определяем при помощи обратной функции надежности распределения \n# xi2 - isf, передавая первым аргументом уровень значимости, вторым - число степеней свободы,\n# равное уменьшенному на 1 количеству элеметов в выборке \ncritical = scipy.stats.chi2.isf(alpha, n-1)\n# Предполагаемое значение стандартного отклонения генеральной совокупности\npopulation_std = 1.9\n# Тестовый массив\na = np.random.normal(loc=0.0, scale=1.9, size=n)\nc = (n-1)*(np.std(a,ddof=1)**2)/(population_std**2)\n\nprint('Наблюдаемое значение {:4.2f}'.format(c))\n\n\nНаблюдаемое значение 11.38\n\n\nЕсли наблюдаемое значение меньше критического, то нет оснований отвергнуть нулевую гипотезу.\n\nЕсли конкурирующая гипотеза:\n\n[H_1: \\sigma \\neq \\sigma_0,]\n\nто строят двухстороннюю критическую область. Нулевая гипотеза принимается, если \\(\\chi^2&lt;\\chi_{крит, прав}^2\\) и \\(\\chi^2&gt;\\chi_{крит, лев}^2\\).\n\n# Правая граница определяется при помощи обратной функции надежности \n# первый аргумент - половина принятого уровня значимости\nchi_crit_right = scipy.stats.chi2.isf(alpha/2, n-1)\n# Левая граница определяется при помощи обратной функции распределения \n# первый аргумент - половина принятого уровня значимости\nchi_crit_left  = scipy.stats.chi2.ppf(alpha/2, n-1)\n\nprint('Критическое значение левое  {:4.2f}'.format(chi_crit_left))\nprint('Критическое значение правое {:4.2f}'.format(chi_crit_right))\n\n\nРезультат:\n\nКритическое значение левое  3.07\nКритическое значение правое 28.30\n\n\nНулевая гипотеза не отвергается, если наблюдаемое значение лежит внутри этого интервала.\n\nЕсли конкурирующая гипотеза\n\n[H_1: \\sigma &lt; \\sigma_0,]\n\nто строят левостороннюю критическую область. Нулевая гипотеза принимается, если \\(\\chi^2&gt;\\chi_{крит, лев}^2\\).\n\n# Левая граница определяется при помощи обратной функции распределения \n# первый аргумент -  уровень значимости\nchi_crit_left  = scipy.stats.chi2.ppf(alpha, n-1)\nprint('Критическое значение левое  {:4.2f}'.format(chi_crit_left))\n\n\nРезультат:\n\nКритическое значение левое  3.57\n\n\nСписок использованных источников\n\n\n  F-tests for Equality of Two Variances\n  Гмуртан В. Е. Теория вероятностей и математическая статистика: Учеб. пособие для вузов. - 8-е изд. стер. - М.: Высш. шк. 2002.\n  Высшая математика - просто и доступно! Проверка статистических гипотез\n  Введение в анализ данных с помощью Pandas\n  Критерии нормальности распределения\n  Статистические гипотезы. Презентация.\n  Emory Oxford college. Exercises - Comparing Means 2\n  Confidence Interval and Hypothesis Testing:\nExercises and Solutions\n  MS-A0503 First course in probability and statistics Department of mathematics and systems analysis\n  Exercises - One Way Analysis of Variance (ANOVA)\n  Chapter: Biostatistics for the Health Sciences: One-Way Analysis of Variance\n\n",
      "url": "/pages/bigdata/hypotesis1/"
    },{
      
      "title": "Проверка статистических гипотез при помощи scipy.stats. Часть 2.",
      "description": "Проверка статистических гипотез при помощи функций библиотеки scipy.stats.\n",
      "content": "Проверка статистических гипотез при помощи scipy.stats. Часть 1.\n\nСравнение наблюдаемой относительной частоты с гипотетической вероятностью появления события\n\nПусть по достаточно большому числу n независимых испытаний, в каждом из которых вероятность p появления события A постоянна, но неизвестна, найдена относительная частота m/n (m - количество произошедших событий А). Пусть имеются основания полагать, что неизвестная вероятность события А равна гипотетическому значению \\(p_0\\). Требуется при заданном уровне значимости \\(\\alpha\\) проверить нулевую гипотезу о том, что неизвестная вероятность события А равна гипотетической вероятности \\(p_0\\).\n\nНапример, поставщик деталей утверждает, что не больше 10% деталей в поставляемой партии бракованные. Было проверено 15 деталей, 3 из них были бракованные. Верно ли утверждение поставщика или брака в партии больше?\n\n\n  Нулевая гипотеза: в партии 10% деталей бракованные.\n  Альтернативная гипотеза: в партии больше 10% деталей бракованные.\n\n\nИспользуем функцию scipy.stats.binom_test. Аргументы функции:\n\n  m - сколько раз произошло событие А\n  n - количество испытаний (объем выборки деталей)\n  гипотетическая вероятность\n  альтернативная гипотеза\n\n\nЗададимся критическим значением p-критерия 5% (0,05).\n\nscipy.stats.binom_test(3, n=15, p=0.1, alternative='greater')\n\n\nПараметр alternative может принимать значение ‘two-sided’, ‘greater’ или ‘less’ в зависимости от альтернативной гипотезы.\n\nРезультат работы функции scipy.stats.binom_test:\n\n&gt;&gt; 0.18406106910639106\n\n\nНулевая гипотеза не может быть отвергнута с уровнем доверия 5%, поскольку полученное p-значение больше чем критическое значение 5%.\n\nОднофакторный дисперсионный анализ (ANOVA F-test)\n\nОднофакторный дисперсионный анализ проверяет нулевую гипотезу о том, что две или более групп имеют одинаковое среднее значение генеральной совокупности.\nМетод однофакторного дисперсионного анализа применяется в тех случаях, когда исследуются изменения результативного признака под влиянием изменяющихся условий или градаций какого-либо фактора. В данном варианте метода влиянию каждой из градаций фактора подвергаются разные выборки испытуемых.\n\nПример. Исследователи изучали связь между курением биологических матерей и массой тела их детей при рождении. В 1-ю группу вошли некурящие. Во 2-ю группу вошли курильщики, выкуривающие менее одной пачки сигарет в день. Группа 3 выкуривала более одной, но менее двух пачек в день. Группа 4 выкуривала более двух пачек в день. Ниже приведен массив значений масс тела младенцев при рождении (n = 11 в каждой группе) в зависимости от курения матери:\n\nG1 = [3510, 3174, 3580, 3232, 3884, 3982, 4055, 3459, 3998, 3852, 3421]\nG2 = [3344, 3211, 3190, 3102, 2995, 3101, 3600, 3350, 2997, 3431, 3120]\nG3 = [2908, 2555, 3100, 2775, 2985, 2479, 2901, 2778, 2199, 2500, 2422]\nG4 = [2223, 2331, 2200, 2121, 2001, 1566, 1676, 1783, 2002, 2118, 1882]\n\n\nЕсть ли различия в средних значениях массы тела между группами? Каково p-значение для этого теста?\n\nДля проверки этой гипотезы используем функцию scipy.stats.f_oneway.\n\nscipy.stats.f_oneway(G1, G2, G3, G4)\n\n\nРезультат работы функции:\n\nF_onewayResult(statistic=14.736466253517861, pvalue=0.0010253111436286351)\n\n\nПолученное p-значение также мало, следовательно между первой и второй группой различие в массе значимо.\n\nПостроим диаграммы размаха четырех групп.\n\ndata = pd.DataFrame(np.array([G1,G2,G3,G4]).transpose(),columns = ['G1','G2','G3','G4'])\ndata.plot(kind='box', xlabel='Группа', ylabel='Масса, г')\n\n\n\n\nСписок использованных источников\n\n\n  F-tests for Equality of Two Variances\n  Гмуртан В. Е. Теория вероятностей и математическая статистика: Учеб. пособие для вузов. - 8-е изд. стер. - М.: Высш. шк. 2002.\n  Высшая математика - просто и доступно! Проверка статистических гипотез\n  Введение в анализ данных с помощью Pandas\n  Критерии нормальности распределения\n  Статистические гипотезы. Презентация.\n  Emory Oxford college. Exercises - Comparing Means 2\n  Confidence Interval and Hypothesis Testing:\nExercises and Solutions\n  MS-A0503 First course in probability and statistics Department of mathematics and systems analysis\n  Exercises - One Way Analysis of Variance (ANOVA)\n  Chapter: Biostatistics for the Health Sciences: One-Way Analysis of Variance\n\n",
      "url": "/pages/bigdata/hypotesis2/"
    },{
      
      "title": "Импорт и экспорт данных",
      
      "content": "Импорт данных\n\nПусть в текущем рабочем каталоге MATLAB находится текстовый файл mat1.txt со следующим содержанием\n\n1 2 3\n4 5 6\n7 8 9\n10 11 12\n\n\nФункция dlmread\n\nФункция dlmread (чтение из текстовых файлов) предназначена для чтения матриц из текстовых файлов. Первый аргумент функции – имя файла. Результат записывается в матрицу.\n\n&gt;&gt; a = dlmread('mat1.txt')\n\na =\n     1     2     3\n     4     5     6\n     7     8     9\n    10    11    12\n\n\nВторым аргументом можно явно указать разделитель чисел в файле, например ‘,’\n\n&gt;&gt; b = dlmread('mat2.txt',',');\n\n\nЧтобы узнать размер прочитанной матрицы по каждому измерению используется функция size, которая возвращает массив двух значений: количество прочитанных строк и столбцов:\n\n&gt;&gt; size(b)\n\nans =\n     3     2\n\n\nЧтобы узнать общее число прочитанных чисел можно перемножив размеры матрицы, используя функцию prod\n\n&gt;&gt; prod(size(b))\n\nans =\n     6\n\n\nили использовать функцию numel (количество всех элементов)\n\n&gt;&gt; numel(b)\n\nans =\n     6\n\n\nТретий и четвертый аргумент dlmread смещение строки и столбца, начиная с которых нужно начинать считывать данные из файла. Например, чтобы пропустить 1 строку и один столбец, необходимо вызвать функцию со следующими дополнительными параметрами\n\n&gt;&gt; b = dlmread('mat2.txt',',', 1, 1)\n\nb =\n     5     6\n     8     9\n    11    12\n\n\nЧтение данных из Excel файлов\n\nДля чтение данных из XLS файлов используется функция xlsread\n\n&gt;&gt; xlsNum = xlsread('Данные.xlsx');\n&gt;&gt; xlsNum \n\n     5     6\n     8     9\n    11    12\n\n\n### Функция readtable\n\nФункция позволяет импортировать таблицы из файлов различных форматов. В отличие от результата работы функции xlsread результатом работы функции readtable является объект table, который содержит дополнительную информацию о таблице: об именах столбцов, строк. Без дополнительных указаний функция readtable считает, что в первой строке таблицы записаны имена её столбцов.\n\nВ рабочем каталоге MATLAB находится xls-файл следующего на листе “Лист1” которого находятся следующие данные:\n\n\n\nРезультатом работы функции readtable будет таблица (объект table)\n\n&gt;&gt; data = readtable('Книга1.xlsx')\n\ndata =\n  \n  3×3 table\n\n     Var1     COL1    COL2\n    ______    ____    ____\n\n    'ROW1'    1.5      2  \n    'ROW2'    1.6      3  \n    'ROW3'    1.9      4  \n\n\nПервая строка в первом столбце таблицы не содержит никаких значений (ячейка А1 пустая), поэтому первому столбцу было присвоено имя автоматически Var1. Второй и третий столбцы в таблице имеют имена COL1 и COL2 соответственно. Функция readtable рассматривает эти значения как имена столбцов. Если такое поведение функции readtable нежелательно, то можно передать функции значение ‘ReadVariableNames’ равное false\n\n&gt;&gt; data = readtable('Книга1.xlsx', 'ReadVariableNames', false)\n\ndata =\n  4×3 table\n     Var1      Var2      Var3 \n    ______    ______    ______\n\n    ''        'COL1'    'COL2'\n    'ROW1'    '1.5'     '2'   \n    'ROW2'    '1.6'     '3'   \n    'ROW3'    '1.9'     '4'  \n\n\nВидно, что в этом случае, поскольку столбцы исходной таблицы в таком представлении содержат неоднородные данные (и числа и строки), все значения в столбцах рассматриваются как строковые без попыток их преобразования в числовые значения. Для корректного чтения данных из таблицы ‘Книга1.xlsx’ необходимо использовать поведение функции readtable  по умолчанию, т.е.\n\n&gt;&gt; data = readtable('Книга1.xlsx')\n\ndata =\n  \n  3×3 table\n\n     Var1     COL1    COL2\n    ______    ____    ____\n\n    'ROW1'    1.5      2  \n    'ROW2'    1.6      3  \n    'ROW3'    1.9      4  \n\n\nВ этом случае можно получить содержимое столбца, используя его имя. Например data.COL1 представляет собой матрицу столбец\n\n&gt;&gt; data.COL1\n\nans =\n    1.5000\n    1.6000\n    1.9000\n\n\nСтолбец data.Var1 это матрица ячеек, содержащая строковые значения\n\n&gt;&gt; data.Var1\n\nans =\n  3×1 cell array\n    {'ROW1'}\n    {'ROW2'}\n    {'ROW3'}\n\n\nСписок имен столбцов содержится в атрибуте (свойстве) таблицы data.VariableNames, которое считывается следующим образом\n\n&gt;&gt; data.Properties.VariableNames\n\nans =\n  1×3 cell array\n    {'Var1'}    {'COL1'}    {'COL2'}\n\n\nДля того, чтобы значения в первом столбце рассматривались как имена строк, необходимо использовать опцию ReadRowNames\n\n&gt;&gt; data = readtable('Книга1.xlsx','ReadRowNames',true)\n\ndata =\n  3×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n    ROW2    1.6      3  \n    ROW3    1.9      4  \n\n\nДля чтения извлечения данных из строки по её имени используется следующий синтаксис\n\n&gt;&gt; data('ROW1',:)\n\nans =\n  1×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n\n\nРезультатом является объект типа table. Можно извлечь несколько строк по их именам, например так\n\n&gt;&gt; data({'ROW1', 'ROW2'},:)\n\nans =\n  2×2 table\n            COL1    COL2\n            ____    ____\n    ROW1    1.5      2  \n    ROW2    1.6      3  \n\n\nЧтобы извлечь данные в виде матрицы необходимо использовать свойство таблицы Variables\n\n&gt;&gt; data('ROW1',:).Variables\n\nans =\n    1.5000    2.0000\n\n\nДля исходной таблицы это свойство вернет все числовые значения в виде матрицы\n\n&gt;&gt; data.Variables\n\nans =\n    1.5000    2.0000\n    1.6000    3.0000\n    1.9000    4.0000\n\n\nЭкспорт данных\n\nСохранение таблицы в файле ‘data.txt’\n\nwritetable(data,'data.txt')\n\n\nСохранение в файле имён строк\n\nwritetable(data,'data.txt','WriteRowNames',true)\n\n\n",
      "url": "/pages/matlab/import/"
    },{
      
      "title": "Blog",
      
      "content": "\n",
      "url": "/blog/"
    },{
      
      "title": "Методы вычислений",
      
      "content": "Презентации\n\n",
      "url": "/pages/numerical_methods/"
    },{
      
      "title": "Интегрированные математические пакеты",
      
      "content": "Материалы лекций\n\nMathematica\n\n\n  Списки, функции, элементы функционального программирования\n  Тросовая буксировка. Модель движения системы материальных точек\n  Вывод и интегрирование уравнений движения двойного физического маятника (уравнения Лагранжа)\n  Численные методы\n  Вывод уравнений движения системы с двумя степенями свободы (курсовая работа по теоретической механике)\n  Анимация.\n\n\nPython\n\n\n  Библиотека numpy\n  Библиотека scipy\n  Библиотека matplotlib\n\n\nMATLAB\n\n\n  Типы данных\n  Функции\n  Файл-функции и скрипты\n  Программирование\n  Графика\n\n\nПримеры\n\nMathematica\n\n\n  Построение модели движения системы точек, связанных пружинами\n\n\nMATLAB\n\n\n  Продольные колебания стержня.\n  Аттрактор Лоренца.\n  Управление процессом численного интегрирования (триггеры/события)\n  Построение модели физического маятника в SIMULINK.\n\n\nPython\n\n\n  Игра “Жизнь”\n  Движение спускаемого аппарата в атмосфере\n  Математическая статистика. Доверительные интервалы\n  Математическая статистика. Проверка статистических гипотез. Часть 1.\n  Математическая статистика. Проверка статистических гипотез. Часть 2.\n  Математическая статистика. Линейная регрессия\n  Истечение газа из ёмкости постоянного объёма\n  Движение механической системы с двумя степенями свободы\n  Движение системы материальных точек, связанных пружинами\n  Интегрирование обыкновенных дифференциальных уравнений. Задача баллистики\n\n\nЗадания для лабораторных работ\n\nWolfram Mathematica\n\n\n  Списки, элементы функционального программирования\n  Движение системы материальных точек\n  Уравнения Лагранжа\n  Численные методы\n\n\nPython\n\n\n  Матрицы и массивы\n  Модель движения системы с двумя степенями свободы\n  Численные методы.\n  Посадка на Луну.\n\n\nMATLAB / OCTAVE\n\n\n  Матрицы\n  Игра “Жизнь”\n  Интегрирование дифференциальных уравнений системы с двумя степенями свободы. Приведение уравнений к форме Коши\n  Модель движения троса\n  Орбитальное движение\n  Движение спускаемого аппарата в атмосфере.\n  Модель одноканальной системы ориентации в SIMULINK.\n\n\n",
      "url": "/pages/imp/"
    },{
      
      "title": "Компьютерная графика",
      "description": "Курс для бакалавров второго года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Презентации\n",
      "url": "/pages/graphics/"
    },{
      
      "title": "Компьютерные и экспериментальные методы в механике",
      
      "content": "Элементы математической статистики и обработка опытов\n\nПрезентации\n\n\n  Вариационный ряд. Плотность и функция распределения. Оценки параметров генеральной совокупности\n  Статистические гипотезы. Гипотеза о среднем значении генеральной совокупности. Гипотеза о дисперсии генеральной совокупности.\n  Сравнение двух средних нормальных генеральных совокупностей\n  Сравнение двух дисперсий нормальных генеральных совокупностей\n  Гипотеза о нормальном распределении генеральной совокупности. Критерий Пирсона.\n  Однофакторный дисперсионный анализ.\n\n\nСтатистический анализ при помощи Python (функции scipy.stats)\n\n\n  Доверительные интервалы\n  Проверка статистических гипотез. Часть 1.\n  Проверка статистических гипотез. Часть 2.\n  Линейная регрессия\n\n\nПланирование эксперимента\n\n\n  Основные определения.\n  Факторы\n  Полный факторный эксперимент.\n  Дробный факторный эксперимент.\n\n\nКомпьютерные методы в механике\n\n\n  Построение модели физического маятника в SIMULINK.\n  Построение модели четрехзвенного механизма в MSC.ADAMS\n  Построение модели эллиптического маятника в MSC.ADAMS\n\n\nЗадания\n\n\n  Построение модели одноканальной системы ориентации в MATLAB Simulink\n\n",
      "url": "/pages/ecmm/"
    },{
      
      "title": "Информатика",
      "description": "Курс Информатика для студентов Института экономики и управления Самарского университета.\n",
      "content": "Материалы курса\n\nУчебные пособия и методические указания\n\nЕ.А. Симановский Введение в информатику\n\nЕ.А. Симановский Методические указания к лабораторным работам\n\nЛабораторные работы\n\nЕ.А. Симановский Сборник заданий к лабораторным работам\n\nШаблон отчёта по лабораторной работе\n\nКомментарии к лабораторной работе №1\n\nКомментарии к лабораторной работе №2\n\nКомментарии к лабораторной работе №3\n\nКомментарии к лабораторной работе №4\n\nКомментарии к лабораторной работе №5\n\nКомментарии к лабораторной работе №6\n\nСсылки\n\nПрограммы\n\nСвободная среда разработки Lazarus для Free Pascal\n\nУчебные материалы\n\nКафедра Суперкомпьютеры и общая информатика Самарского университета\n\nКоманды среды разработки Turbo Pascal\n\nTurbo Pascal 7.0 Электронный учебник для студентов и школьников\n\nПаскаль для начинающих. Основы грамматики в таблицах и примерах\n\nБлок-схема\n\nСайт Валерия Семёнова\n\nСтандарты и шаблоны\n\nОбщие требования к учебным текстовым документам\n",
      "url": "/pages/informatics/"
    },{
      
      "title": "Основы Wolfram Mathematica",
      
      "content": "Лабораторные работы\n\n\n  Списки\n  Движение системы материальных точек\n  Уравнения Лагранжа\n  Анимация\n  Численные методы\n  Символьные вычисления\n\n\nПо каждой лабораторной работе оформляется отчёт в соответствии с шаблоном.\n\nПримеры\n\n\n  Списки, функции, элементы функционального программирования\n  Построение модели движения системы точек, связанных пружинами\n  Вывод и интегрирование уравнений движения двойного физического маятника (уравнения Лагранжа)\n  Численные методы\n  Вывод уравнений движения системы с двумя степенями свободы (курсовая работа по теоретической механике)\n  Анимация. Построение анимации.\n  Относительное орбитальное движение. Уравнения относительного орбитального движения двух космических аппаратов при движении одного из них (ведущий) по круговой орбите.\n  Преобразование поворота. Поворот в пространстве. Матрица поворота. Пример в Wolfram Mathematica.\n  Движение спускаемого аппарата (pdf) (nb).\n\n",
      "url": "/pages/wolfram/"
    },{
      
      "title": "Задания для ВКР (весна, 2025)",
      
      "content": "Бакалавриат\n\n\n  \n\n\nМагистратура\n\n\n  Динамика отделения от орбитального блока двух малых космических аппаратов, связанных тросом.\n\n\n",
      "url": "/pages/thesis/2025/"
    },{
      
      "title": "Основы MATLAB",
      
      "content": "Быстрое знакомство\n\n\n  Матрицы\n  Индексы и элементы\n  Матричная алгебра\n  Файл-скрипты и файл-функции\n  Ячейки\n  Структуры\n  Статистики и сортировка\n  Структурное программирование\n  Основы графики\n  Дата и время\n  Импорт и экспорт данных\n  Временные ряды\n  Таблицы\n  Хронологические таблицы (timetable)\n\n\nЧисленные методы\n\n\n  Численные методы\n  Интегрирование ОДУ\n  Интегрирование уравнений движения эллиптического маятника\n\n\nПрезентации\n\n\n  Типы данных\n  Функции\n  Файл-функции и скрипты\n  Программирование\n  Графика\n  Относительное орбитальное движение\n  Численные методы\n  Интегрирование ОДУ\n\n\nЛабораторные работы\n\n\n  Задания\n  Шаблон отчета по лабораторной работе (LaTeX)\n\n\nПримеры\n\n\n  Продольные колебания стержня.\n  Построение модели физического маятника в SIMULINK.\n  Аттрактор Лоренца.\n  Управление процессом численного интегрирования (триггеры/события)\n\n",
      "url": "/pages/matlab/"
    },{
      
      "title": "Основы SimInTech",
      "description": "Разработка комплексных цифровых моделей технических систем и процессов в среде динамического моделирования SimInTech\n",
      "content": "Примеры\n\n\n  Моделирования движения механизма с двумя степенями свободы\n  Модель движения маятника с точкой подвеса на колесе\n  Модель движения летающего стенда возвращаемой ступени РН в SimInTech\n  Модель отделения головного обтекателя ракеты-носителя\n  Эффект Джанибекова\n  Модель движения вращающейся тросовой системы\n\n\nЛекции\n\n\n  Интерфейс. Создание и запуск простого проекта. Визуализация результатов.\n  Настройки проекта. Интегрирование дифференциальных уравнений.\n  Глобальные переменные и сигналы. Скрипты и связи.\n  Создание и использование субмоделей.\n  Анимация\n  Библиотека “Механика”.\n  Библиотека “Механика 3D.\n  Библиотека “Гидро- и пневмосистемы”.\n  Пакеты проектов для создания комплексных моделей.\n\n\nПроекты\n\n\n  Модели SimInTech (GitVerse)\n\n",
      "url": "/pages/simintech/"
    },{
      
      "title": "Теоретическая механика",
      
      "content": "Презентации\n\nКинематика точки\n\n",
      "url": "/pages/mechanics/"
    },{
      
      "title": "Динамика твёрдого тела и систем тел",
      
      "content": "\n  Презентации\n  Задания для лабораторных работ\n  Задания для курсовой  работы\n\n\nПримеры\n\n\n  Построение годографа продольной оси тела при движении в случае Лагранжа.\n  Уравнения движения со связями\n  Отделение створок головного обтекателя\n  Отделение космического аппарата\n  Вывод уравнений движения системы тел методом Кейна\n  Видеоиллюстрации: углы Эйлера и углы Брайнта\n\n\nЛитература\n\n\n  Журавлев В. Ф. Основы теоретической механики. Изд. 2-е, перераб. - М.: Издательство Физико-математической литературы, 2001. - 320 с.\n  Й. Виттенбург, Динамика систем твердых тел. М.: Мир, 1980.\n  Wittenburg, J. Dynamics of multibody systems. Springer., 1980.\n  Featherstone, R. Rigid Body Dynamics Algorithms. Springer Science+Business Media, LLC, 2008.\n\n",
      "url": "/pages/mbs/"
    },{
      
      "title": "Управление IT-сервисом и контентом",
      
      "content": "Курс “Управление ИТ-сервисом и контентом” включает в себя лекционные занятия и лабораторные работы. Заканчивается курс промежуточной аттестацией в форме экзамена. В течение курса каждый обучающийся готовит один реферат (не менее 10 страниц) и представляет его на лабораторных работах (презентация в течение 5-10 минут). К экзамену допускаются обучающиеся, сдавшие все лабораторные работы и представившие один реферат. Оценка “отлично” может быть выставлена по итогам семестра тем студентам, которые сдали в срок все лабораторные работы, посетили не менее 75% лекций и выполнили все тестовые задания.\n\nПрезентации\n\n\n  Управление ИТ-сервисом и контентом. Введение\n  ИТ-служба, ИТ-инфраструктура и ИТ-сервис\n  ITIL\n  Управление инцидентами, проблемами и ошибками\n  Управление конфигурациями\n  Управление изменениями\n  Основы информационной безопасности\n  Системы управления контентом\n  MOF\n\n\nЛабораторные работы\n\n\n  Разработка ИТ-инфраструктуры малого предприятия.\n  Система iTop. База данных конфигурационных элементов.\n  Разработка каталога услуг и SLA.\n  Системы управления веб-контентом.\n  Шифрование с открытым ключом.\n\n\nШаблон отчёта по лабораторной работе.\n\nРефераты\n\nРекомендуемый список тем рефератов.\n\n\n  Лицензирование программного обеспечения: свободные, несвободные, условно-бесплатные, коммерческие, BSD, MIT, и другие лицензии и их сравнение.\n  Практика использования свободных лицензий на предприятиях.\n  Криптографические методы защиты информации: история, алгоритмы, программное обеспечение, правовое регулирование в области криптографии в России и других странах.\n  Электронная цифровая подпись: история, алгоритмы, программное обеспечение, правовое регулирование электронной цифровой подписи в России и других странах.\n  Сравнение нескольких решений Service Desk.\n  Обзор систем управления базами данных конфигурациями (CMDB): открытые и коммерческие.\n  Облачные технологии в бизнесе.\n  Обзор систем видеоконференцсвязи.\n  Обзор корпоративных мессенджеров (чатов).\n  Обзор программного обеспечения мониторинга ИТ-инфраструктуры.\n  Обзор программных систем электронного документооборота.\n  Системы управления контентом предприятия (Enterprise Content Management).\n  Корпоративный VPN (назначение, виды, решения).\n  Программные системы управления персоналом.\n  Реклама в Интернет: виды, особенности, эффективность.\n  Интернет вещей в промышленности.\n  Частные LTE сети.\n  ИТ и искусственный интеллект: революция на рабочем месте.\n  Роль ИТ в оказании медицинской помощи и управлении ею.\n  Облачные решения для IT-инфраструктуры.\n\n\nРеферат оформляется в соответствии с “СТО 02068410-004-2018 Общие требования к учебным текстовым документам” и представляется в виде презентации (не более 10 минут) на одной из лабораторных работ.\n\nИсточники\n\n\n  Артюшина, Л. А. Управление ИТ-сервисами и контентом : учеб. пособие / Л. А. Артюшина, Е. А. Троицкая ; Владим. гос. ун-т им. А. Г. и Н. Г. Столетовых. ‒ Владимир : Изд-во ВлГУ, 2021. ‒ 280 c. \n  Бараксанов Д. Н. Управление ИТ-сервисами и контентом : учебное пособие / Д. Н. Бараксанов, Ю. П. Ехлаков. — Томск : ФДО, ТУСУР, 2015. — 144 с.\n  Конспект лекций по дисциплине “Управление ИТ-сервисами и контентом”. Составил: к.т.н., Бакаев М. А.\n  Практическая методика внедрения методов ИТИЛ\n  ITIL. IT Service Management по стандартам V.3.1\n  Service Desk быстрый старт. 2 часть — создание каталога услуг\n  Козырев А. А. Информационные технологии в экономике и управлении: Учебник. – СПб.: Изд-во Михайлова В. А., 2000.\n  Сети для начинающего IT-специалиста. Обязательная база\n  ИТ-инфраструктура предприятия - что нужно бизнесу?\n  Построение ИТ инфраструктуры небольшого офиса\n  ИТ-инфраструктура как сервис: от сервера до приложения\n\n\n",
      "url": "/pages/it/"
    },{
      
      "title": "Прикладные задачи динамики твердого тела и систем тел",
      
      "content": "Презентации\n\n\n  Относительное орбитальное движение. Линейные уравнения относительного орбитального движения\n  Отделение створок головного обтекателя Математическая модель процесса отделения створок головного обтекателя от ракеты-носителя\n  Отделение космического аппарата. Математическая модель процесса отделения космического аппарата от носителя\n  Гравитационный момент.\n  Буксировка космического мусора на тросовой связи.\n  Работа посадочной опоры возвращаемой ступени РН Falcon-9.\n  Раскрытие солнечной батареи КА.\n\n\nПримеры\n\n\n  Модель посадочных опор многоразовой ракеты-носителя Falcon-9\n  Модель раскрытия посадочной опоры многоразовой ракеты-носителя Falcon-9\n  Посадка на Луну\n\n\nЗадания\n\nДвижение КА\n\n\n  Относительное орбитальное движение\n  Отделение космического аппарата\n  Раскрытие солнечной батареи КА\n\n\nТросовые системы\n\n\n  Дискретная модель троса\n  Космическая тросовая система\n  Тросовая буксировка\n  Тросовая буксировка (с учётом массы троса)\n  Вращающаяся космическая тросовая система\n\n\n",
      "url": "/pages/mechanics-in-space/"
    },{
      
      
      
      "content": "\n  Дисциплины\n  Статьи\n  Патенты\n  Презентации\n  Видео\n\n\n",
      "url": "/pages/"
    },{
      
      
      
      "content": "\n",
      "url": "/"
    },{
      
      "title": "Основы Python",
      "description": "Курс для бакалавров первого года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Лекции\n\nСеместр 1\n\n\n  Введение\n  Основы Python 1. Синтаксис\n  Основы Python 2. Списки, кортежи, множества\n  Основы Python 3. Словари\n  Функции\n  Элементы функционального программирования\n  Модули и пакеты\n  Ввод и вывод\n\n\nСеместр 2\n\n\n  Обработка ошибок\n  Основы ООП 1.\n  Основы ООП 2.\n  Библиотека numpy\n  Библиотека scipy\n  Машинная арифметика\n  Библиотека matplotlib\n\n\nЛабораторные работы\n\n\n  Шаблон отчёта по лабораторной работе в формате docx\n  Задания для лабораторных работ\n\n\nКурсовая работа\n\n\n  Задания для курсовых работ\n\n\nПримеры\n\n\n  Движение спускаемого аппарата в атмосфере\n  Математическая статистика. Доверительные интервалы\n  Математическая статистика. Проверка статистических гипотез. Часть 1.\n  Математическая статистика. Проверка статистических гипотез. Часть 2.\n  Математическая статистика. Линейная регрессия\n  Истечение газа из ёмкости постоянного объёма\n  Движение механической системы с двумя степенями свободы\n  Игра “Жизнь”\n  Движение системы материальных точек, связанных пружинами\n  Интегрирование обыкновенных дифференциальных уравнений. Задача баллистики\n  Задача баллистики. Проверка корректности решения.\n\n",
      "url": "/pages/python/"
    },{
      
      "title": "Базы данных",
      
      "content": "Лекции\n\n\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 6. Основы SQL. Манипулирование данными.\n  Лекция 7. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 8. Основы NoSQL.\n\n\nЛабораторные работы\n\nЗадания для лабораторных работ\n\n\n  Модель Сущность-Связь\n  Создание таблиц\n  SQL DML. Часть 1\n  SQL DML. Часть 2\n  Представления\n  Процедуры и триггеры\n  Основы работы в MongoDB\n\n\nОтчеты по лабораторным работам\n\nОтчет по каждой лабораторной работе оформляется в соответствии с требованиями к учебным документам. Пример отчета по лабораторной работе №1 с примером в формате DOCX, в формате PDF.\n\nПрограммное обеспечение\n\nДля выполнения лабораторных работ рекомендую использовать следующее программное обеспечение и сервисы:\n\n\n  draw.io для создания ER-диаграмм;\n  DBeaver для работы с БД MySQL, SQLite\n\n\nПримеры\n\n\n  Пример создания таблиц базы данных пиццерии.\n  Пример создания таблиц базы данных с информацией о выпускных квалификационных работах.\n  Пример построения сложного запроса к базе данных.\n  Игра “Жизнь” на SQL.\n  Подключение из Google Colab к базе данных SQLite, расположенной на Google диске.\n  Подключение к базе данных MySQL.\n  Подключение к БД SQLite в Google Colab.\n\n\n",
      "url": "/pages/databases/"
    },{
      
      "title": "Управление IT-сервисом и анализ больших данных",
      
      "content": "Презентации\n\nАнализ больших данных\n\n\n  Введение. Что такое большие данные?\n\n\nОсновы Python\n\n\n  Основы Python 1. Синтаксис\n  Основы Python 2. Списки, кортежи, множества\n  Основы Python 3. Словари\n  Функции\n  Элементы функционального программирования\n  Модули и пакеты\n  Ввод и вывод\n  Обработка ошибок\n  Основы ООП 1.\n  Основы ООП 2.\n  Машинная арифметика\n\n\nБиблиотеки Python\n\n\n  Библиотека numpy\n  Библиотека scipy\n  Библиотека matplotlib\n\n\nСтатистический анализ при помощи Python (scipy.stats)\n\n\n  Доверительные интервалы\n  Проверка статистических гипотез. Часть 1.\n  Проверка статистических гипотез. Часть 2.\n  Линейная регрессия\n\n\nЛабораторные работы\n\n\n  Лабораторная работа: основы Python\n  Лабораторная работа: numpy\n  Математическая статистика. Проверка гипотез.\n  Математическая статистика. Регрессия.\n\n\n",
      "url": "/pages/bigdata/"
    },{
      
      "title": "Обращение к элементам матрицы",
      
      "content": "Пусть задана матрица 4x3:\n\na = [1 2 3;\n     4 5 6;\n     7 8 9;\n     10 1 12];\n\n\nЭлемент во второй строке, третьем столбце\n\n&gt;&gt; a(3,2)\n\nans =\n     8\n\n\nВесь второй столбец (оператор :)\n\n&gt;&gt; a(:,2)\n\nans =\n     2\n     5\n     8\n     1\n\n\nВся третья строка\n\n&gt;&gt; a(3,:)\n\nans =\n     7     8     9\n\n\nК элементу прямоугольной матрицы можно обратиться при помощи одного индекса\n\n&gt;&gt; a(6)\n\nans =\n     5\n\n\nВ этом случае используется сквозная нумерация элементов в столбцах.\n\nБлок матрицы\n\n&gt;&gt; a(2:3,1:2)\n\nans =\n     4     5\n     7     8\n\n\nСтроки 2 и 4, столбцы 1 и 4\n\n&gt;&gt; a([2,4],[1,3])\n\nans =\n     4     6\n    10    12\n\n\nВсе элементы матрицы одним столбцом (столбцы склеиваются друг за другом)\n\n&gt;&gt; a(:)\n\nans =\n     1\n     4\n     7\n    10\n     2\n     5\n     8\n     1\n     3\n     6\n     9\n    12\n\n\nЗаменить все элементы в 3 строке нулями\n\n&gt;&gt; a(3,:) = 0\n\na =\n     1     2     3\n     4     5     6\n     0     0     0\n    10     1    12\n\n\nЛогическое индексирование\n\nСоздадим последовательность\n\n&gt;&gt; a = 1:10\n\na =\n     1     2     3     4     5     6     7     8     9    10\n\n\nРезультатом сравнения массива a с некоторым числом является логический массив единиц и нулей той же размерности, что и исходный массив, элементы которого заменяются на 1 (ИСТИНА) или 0 (ЛОЖЬ) в зависимости от результата сравнения этого элемента со сравниваемым значение (в примере ниже это число 3):\n\n&gt;&gt; a &gt; 3\n\nans =\n  1×10 logical array  \n   0   0   0   1   1   1   1   1   1   1\n\n\nМеньше или равно 3\n\n&gt;&gt; a &lt;= 3\n\nans =\n  1×10 logical array\n   1   1   1   0   0   0   0   0   0   0\n\n\nЛогическое индексирование можно использовать для выборки значений из матрицы, например, чтобы извлечь из  матрицы a все значения, которые меньше 3 и больше 8 можно написать так\n\n&gt;&gt; a(a &lt; 3 | a &gt; 8)\n\nans =\n     1     2     9    10\n\n",
      "url": "/pages/matlab/indexing/"
    },{
      
      "title": "Определение матрицы тензора инерции",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Задание\n\nСистема твердых тел состоит из трех или четырех тел. Каждое тело представляет собой  однородный цилиндр или усеченный конус заданных размеров.\n\n\n  \n    Найти положение центра масс относительно системы координат, расположенной на пересечении продольной оси первого тела с плоскостью нижнего среза первого тела (точка А).\n  \n  \n    Определить главный центральный тензор инерции представленной системы тел. Определить ориентацию осей главной центральной системы координат по отношению к базовой системе координат \\(Axyz\\), представленной на рисунке: найти матрицу преобразования координат из главного центрального базиса в базис \\(Axyz\\).\n  \n\n\n\n\nВарианты\n\n\n  \n    \n      Вариант\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n    \n  \n  \n    \n      \\(m_1\\)\n      5000\n      6000\n      6000\n      7000\n      8000\n      8500\n      9000\n      9000\n      9000\n      9000\n      9000\n    \n    \n      \\(m_2\\)\n      1000\n      1000\n      1000\n      1000\n      1000\n      1000\n      1000\n      300\n      300\n      500\n      500\n    \n    \n      \\(m_3\\)\n      500\n      700\n      900\n      1000\n      2000\n      3000\n      4000\n      1000\n      1000\n      1000\n      1000\n    \n    \n      \\(m_4\\)\n      100\n      200\n      200\n      400\n      -\n      -\n      -\n      100\n      200\n      200\n      400\n    \n    \n      \\(L_1\\)\n      5\n      6\n      7\n      5\n      6\n      7\n      8\n      7\n      5\n      6\n      7\n    \n    \n      \\(L_2\\)\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      0.5\n      0.5\n      0.5\n      0.5\n    \n    \n      \\(L_3\\)\n      1\n      1,5\n      1,5\n      2\n      1\n      1\n      1\n      2\n      1\n      1\n      1\n    \n    \n      \\(L_4\\)\n      1\n      1\n      2\n      2\n      -\n      -\n      -\n      2\n      1\n      1\n      1\n    \n    \n      \\(D_1\\)\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n      4\n    \n    \n      \\(D_2\\)\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n      3\n    \n    \n      \\(D_3\\)\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n      1\n    \n    \n      \\(D_4\\)\n      1\n      1\n      1\n      1\n      -\n      -\n      -\n      0,9\n      0,9\n      0,9\n      0,9\n    \n    \n      \\(d_3\\)\n      0,5\n      0,6\n      0,5\n      0,6\n      0,2\n      0,3\n      0,3\n      0,2\n      0,3\n      0,3\n      0,2\n    \n    \n      \\(d_4\\)\n      0,3\n      0,2\n      0,1\n      0,1\n      -\n      -\n      -\n      0,5\n      0,5\n      0,5\n      0,5\n    \n    \n      Рисунок\n      2\n      2\n      3\n      3\n      1\n      1\n      1\n      2\n      2\n      3\n      3\n    \n  \n\n\nРазмерности величин в таблице в системе СИ.\n\nНомер варианта определяется по формуле: (1 + NNNNN mod 11), где NNNNN - последние пять цифр зачетной книжки.\n\nПример\n\nСистема твердых тел состоит из параллелепипеда со сторонами \\(a_1 = 1\\), \\(b_1 = 2\\), \\(h_1 = 2\\) и двух цилиндров с радиусами оснований \\(r_2 = 0.3\\), \\(r_3 = 0.4\\) и высотами \\(h_2 = 2\\) и \\(h_3 = 3\\) соответственно. Масса параллелепипеда \\(m_1 = 10\\), массы цилиндров: \\(m_2 = 5\\), \\(m_3 = 7\\).\n\nЦентры оснований цилиндров (точки \\(B_2\\) и \\(B_3\\)) лежат на оси, параллельной оси \\(B_1 z_{b}\\) базовой системы координат, как показано на рисунке. Координаты центров оснований цилиндров: \\(z_2 = -0.7\\), \\(z_3 = 1.5\\).\n\n\n\nПоложение центра масс\n\nОпределим положение центра масс системы тел относительной базовой системы координат \\(B_1 x_{b} y_{b} z_{b}\\)\n\n[r_c^{(1)} = \\frac{1}{m_1+m_2+m_3} \\left{ m_1 \\begin{bmatrix} h_1/2 \\ 0 \\ 0 \\end{bmatrix} + m_2 \\begin{bmatrix} h_1 + h_2/2 \\ 0 \\ z_2 \\end{bmatrix} + m_3 \\begin{bmatrix} h_1+ h_3/2 \\ 0 \\ z_3 \\end{bmatrix} \\right}]\n\n% *** Тело 1 ***\n% Масса\nm1 = 10;\n% Размеры\na1  = 1; b1  = 2; h1  = 3;\n% Положение центра масс \nrc1 = [h1/2;0;0];\n\n% *** Тело 2 ***\n% Масса\nm2 = 5;\n% Размеры\nr2 = 0.3; h2 = 2;\n% Положение центра масс \nz2  = -0.7; \nrc2 = [h1+h2/2;0;z2];\n\n% *** Тело 2 ***\n% Масса\nm3 = 7;\n% Размеры\nr3 = 0.4; h3 = 3;\n% Положение центра масс \nz3  = 1.5;\nrc3 = [h1+h3/2;0;z3];\n\n% Положение центра масс системы\nrc = (rc1*m1+rc2*m2+rc3*m3)/(m1+m2+m3)\n\n\nМатрицы тензоров инерции в главных центральных осях тел\n\nТело 1\n\nМоменты инерции параллелепипеда относительно его главных центральных осей \\(C_1 x_1 y_1 z_1\\), параллельных соответствующим осям базовой системы координат \\(B_1 x_{b} y_{b} z_{b}\\):\n\n[J_{1x} = m_1 (a1^2+b1^2)/12, \\; J_{1y} = m_1 (b1^2+h1^2)/12, \\; J_{1z} = m_1 (a1^2+h1^2)/12.]\n\nJ1cx = m1*(a1^2+b1^2)/12;\nJ1cy = m1*(b1^2+h1^2)/12;\nJ1cz = m1*(a1^2+h1^2)/12;\n\nJ1c = diag([J1cx,J1cy,J1cz]);\n\n\nТело 2\n\nМоменты инерции первого цилиндра относительно его главных центральных осей \\(C_2 x_2 y_2 z_2\\), параллельных соответствующим осям базовой системы координат:\n\n[J_{2x} = m_2 r_2^2/2, \\; J_{2x} = m_2(3 r_2^2 + h_2^2)/12, \\; J_{2z} = J_{2y}.]\n\nJ2cx = 0.5*m2*r2^2;\nJ2cy = m2*(3*r2^2+h2^2)/12;\nJ2cz = J2cy;\n\nJ2c = diag([J2cx,J2cy,J2cz]);\n\n\nТело 3\n\nМоменты инерции второго цилиндра относительно его главных центральных осей \\(C_3 x_3 y_3 z_3\\), параллельных соответствующим осям базовой системы координат:\n\n[J_{3x} = m_3 r_3^2/2, \\; J_{3x} = m_3(3 r_3^2 + h_3^2)/12, \\; J_{3z} = J_{3y}.]\n\nJ3cx = 0.5*m3*r3^2;\nJ3cy = m3*(3*r3^2+h3^2)/12;\nJ3cz = J3cy;\n\nJ3c = diag([J3cx,J3cy,J3cz]);\n\n\nТензор инерции системы относительно центра масс системы\n\nНайдём матрицу тензора инерции системы относительно центральной системы координат \\(C x_s y_s z_s\\), оси которой параллельны осям базовой системы координат. Определим функцию вычисления тензора инерции тела при переносе базиса из центра масс в некоторую точку P.\n\nJp = @(Jc, r2c) Jc + (r2c'*r2c*eye(3)-r2c*r2c');\n\n\nПервый аргумент функции – матрица тензора инерции в центральном базисе тела, второй - координатный столбец вектора, проведенного из точки P в центр масс тела, записанный в центральном базисе тела. В рассматриваемой задаче точкой P будет центр масс системы тел, определенный на первом шаге решения задачи, поэтому\n\n\n  тензор инерции параллелепипеда:\n\n\nJ1cs = Jp(J1c, rc1-rc)\n\n\nJ1cs =\n\n    4.2679         0   -0.4845\n         0   13.2533         0\n   -0.4845         0   10.6520\n\n\n\n  тензор инерции цилиндра 1:\n\n\nJ2cs = Jp(J2c, rc2-rc);\n\nJ2cs =\n\n    1.2617         0    0.9950\n         0    3.7709         0\n    0.9950         0    2.7342\n\n\n\n  тензор инерции цилиндра 2:\n\n\nJ3cs = Jp(J3c, rc3-rc);\n\nJ3cs =\n\n    1.9567         0   -1.7459\n         0    9.1090         0\n   -1.7459         0    7.7123\n\n\nТензор инерции системы\n\nJs   = J1cs + J2cs + J3cs\n\nJs =\n\n    7.4863         0   -1.2353\n         0   26.1332         0\n   -1.2353         0   21.0986\n\n\nМатрица тензора инерции не диагональная, поскольку тензор инерции системы записан в центральных, но не главных осях системы. Для определения тензора инерции системы в главных центральных осях решим задачу на собственные значения матрицы Js:\n\n[e,Jii] = eig(Js)\n\ne =\n\n   -0.9960   -0.0897   -0.0000\n    0.0000    0.0000   -1.0000\n   -0.0897    0.9960    0.0000\n\n\nJii =\n\n    7.3751         0         0\n         0   21.2098         0\n         0         0   26.1332\n\n\n\n  \n    В матрицу e записываются собственные векторы матрицы тензора инерции системы, из которых можно составить (после некоторых преобразований) матрицу преобразования координат из главного центрального базиса системы \\(C x y z\\) в систему координат \\(C x_s y_s z_s\\).\n  \n  \n    В матрицу Jii записывается диагональная матрица собственных чисел матрицы тензора инерции Js. Эти числа представляют собой главные моменты инерции системы.\n  \n\n\nОбратим внимание на то, что единичные векторы главных осей инерции (столбцы матрицы e) определяются с точностью до знака, поскольку они определяют только положение главных осей в пространстве как прямых. Умножим первый и третий столбец матрицы e на минус 1 и затем переставим столбы 2 и 3 матриц e и Jii. В результате получим:\n\n\n  главные центральные моменты инерции системы\n\n\n[J_x = 7.3751, \\; J_y = 26.1332, \\; J_z = 21.2098;]\n\n\n  матрица преобразования координат из главного центрального базиса системы \\(C x y z\\) в исходный базис \\(C x_s y_s z_s\\)\n\n\n[A = \\begin{bmatrix} 0.9960 &amp; 0.0000 &amp; -0.0897 \\ 0.0000 &amp; 1.0000 &amp; 0.0000 \\ 0.0897 &amp; 0.0000 &amp; 0.9960 \\end{bmatrix}.]\n",
      "url": "/pages/mbs/inertia/"
    },{
      
      "title": "Лабораторная работа №3",
      
      "content": "Задание\n\nЧасть 1\n\nОзнакомиться с современными пятью программными средствами, которые могут использоваться для управления веб-контентом. Собрать и проанализировать информацию об особенностях таких программных средств и их возможностях.\n\nКритерии сравнения\n\n\n  Условия использования (лицензии): бесплатные и open-source, коммерческие (платные), собственные разработки («внутренние»).\n  Возможность переноса (отчуждения): отчуждаемые, «ПО как услуга» (Software as a Service), т.е. предоставляемые на сервере автора.\n  Функциональность: блог, личный сайт, сайт-визитка, интернет-магазин, сайт сообщества, универсальные (расширяемые).\n  По используемым технологиям: языки программирования, базы данных.\n  По возможности расширения функциональности: наличие ядра и модулей расширения, легкость внедрения собственного кода, легкость настройки внешнего вида для посетителя.\n  Объем рынка.\n\n\nПримеры\n\nDrupal, WordPress, Joomla, Jekyll, …\n\nЧасть 2\n\nОформить сайт о культуре и традициях страны/города с помощью любой системы управления вэб-контентом, например, WordPress. Оформление, текст и изображения подобрать самостоятельно. Сайт должен содержать продуманную структуру навигации сайта, содержательный контент, продуманный дизайн. Необходимо создать не менее 10 страниц.\n\nОпределения\n\nСистема управления содержимым (англ. Content management system, CMS, система управления контентом) — информационная система или компьютерная программа, используемая для обеспечения и организации совместного процесса создания, редактирования и управления содержимым\n\nВ общем случае системы управления содержимым делятся на системы управления корпоративным контентом (англ. Enterprise Content Management System) — для работы с содержимым внутри какой-либо организации и системы управления веб-содержимым (англ. Web Content Management System) для поддержки работы веб-сайта.\n\n\n  Система управления веб-содержимым (Web Content Management System или WCMS) – программный комплекс, предоставляющий функции создания, редактирования, контроля и организации веб-страниц. WCMS часто используются для создания блогов, личных страниц и интернет-магазинов и нацелены на пользователей, мало знакомых с программированием.\n  ECM-система — программное обеспечение для управления корпоративным контентом.\n\n\nМетодические указания\n\nСсылки\n\n\n  6 бесплатных конструкторов сайтов\n  Бесплатные конструкторы сайтов\n\n\n",
      "url": "/pages/it/lab-cms/"
    },{
      
      "title": "Движение твердого тела в случае Эйлера",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Твердое тело с известными главными центральными моментами инерции \\(J_x, J_y, Jz\\) движется вокруг центра масс по инерции (внешний момент равен нулю) cо следующими начальными значениями проекций угловой скорости тела на его главные оси:\n\n[\\omega_x(0) = \\omega_{x0},\\; \\omega_y(0) = \\omega_{y0},\\; \\omega_z(0) = \\omega_{z0}.]\n\nНайдите аналитическое решения для законов изменения проекций угловой скорости тела на главные оси и сравните его с численным решением на интервале от t=0 до t=10 с (постройте графики).\n\nМоменты инерции тела и начальные условия приведены в таблице. Размерность моментов инерции в таблице – [кг∙м²], угловых скоростей – градус в секунду. Номер варианта определяется по порядковому номеру в ведомости.\n\n\n  \n    \n      Вариант\n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n    \n  \n  \n    \n      \\(J_x\\)\n      1\n      2\n      3\n      3\n      1\n      6\n      2\n      2\n      1\n      2\n      3\n    \n    \n      \\(J_y\\)\n      2\n      1\n      2\n      5\n      2\n      3\n      3\n      4\n      6\n      3\n      4\n    \n    \n      \\(J_z\\)\n      3\n      3\n      4\n      2\n      4\n      2\n      1\n      3\n      2\n      4\n      6\n    \n    \n      \\(\\omega_{x0}\\)\n      5\n      3\n      3\n      1\n      5\n      1\n      5\n      2\n      1\n      2\n      5\n    \n    \n      \\(\\omega_{y0}\\)\n      2\n      2\n      3\n      2\n      2\n      2\n      3\n      6\n      5\n      3\n      6\n    \n    \n      \\(\\omega_{z0}\\)\n      8\n      6\n      5\n      5\n      4\n      5\n      5\n      2\n      5\n      2\n      5\n    \n  \n\n\n",
      "url": "/pages/mbs/lab-euler-case/"
    },{
      
      "title": "Углы Эйлера",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Положение начала системы координат \\(O_1 x_1 y_1 z_1\\) относительно системы координат \\(O_0 x_0 y_0 z_0\\) определяется радиус-вектором \\(\\vec {r}_1\\). Координатный столбец вектора \\(\\vec {r}_1\\) в базисе  \\(O_0 x_0 y_0 z_0\\):\n\n[r_1^{(0)} = \\begin{bmatrix} 1 \\ 2 \\ 3 \\end{bmatrix}]\n\nОриентация базиса \\(O_1 x_1 y_1 z_1\\) по отношению к базису \\(O_0 x_0 y_0 z_0\\) определяется тремя углами Эйлера (последовательность поворотов ZX’Z’’):\n\n[\\psi = 30 + (\\text{NNNNN} \\mod 30), \\quad \\theta = 60 + (\\text{NNNNN} \\mod 30), \\quad \\varphi = 10 + (\\text{NNNNN} \\mod 30)]\n\nгде NNNNN - последние пять цифр номера зачетной книжки.\n\nПоложение точки А в базисе \\(O_1 x_1 y_1 z_1\\) определятся координатным столбцом\n\n[\\rho_A^{(1)} = \\begin{bmatrix} 2 \\ 4 \\ 6 \\end{bmatrix}]\n\n\n\nПоложение начала системы координат \\(O_2 x_2 y_2 z_2\\) относительно системы координат \\(O_0 x_0 y_0 z_0\\) определяется радиус-вектором \\(\\vec {r}_2\\). Координатный столбец вектора \\(\\vec {r}_2\\) в базисе  \\(O_0 x_0 y_0 z_0\\):\n\n[r_2^{(0)} = \\begin{bmatrix} -2 \\ 3 \\ 1 \\end{bmatrix}]\n\nОриентация базиса \\(O_2 x_2 y_2 z_2\\) по отношению к базису \\(O_0 x_0 y_0 z_0\\) определяется тремя углами Эйлера (последовательность поворотов XY’Z’’):\n\n[\\alpha_1 = 20 + (\\text{NNNNN} \\mod 30), \\quad \\alpha_2 = 30 + (\\text{NNNNN} \\mod 30), \\quad \\alpha_3 = 40 + (\\text{NNNNN} \\mod 30)]\n\nПоложение точки А в базисе \\(O_2 x_2 y_2 z_2\\) определятся координатным столбцом\n\n[\\rho_A^{(1)} = \\begin{bmatrix} 2 \\ 2 \\ 1 \\end{bmatrix}]\n\n\n  Найти модуль вектора \\(\\vec{AB}\\).\n  Найти координаты вектора \\(\\vec{AB}\\) в базисе \\(O_1 x_1 y_1 z_1\\).\n  Найти координаты вектора \\(\\vec{AB}\\) в базисе \\(O_2 x_2 y_2 z_2\\).\n\n\n",
      "url": "/pages/mbs/lab-euler/"
    },{
      
      "title": "Лабораторная работа №5",
      
      "content": "Шифрование с помощью открытого ключа или асимметричное шифрование, представляет собой схему шифрования, в которой используются два ключа — открытый и закрытый. В отличие от симметричных алгоритмов, в которых один ключ используется и для шифрования, и для расшифровки, здесь каждый ключ выполняет только одну функцию. Открытый ключ используется для шифрования сообщения, а закрытый ключ — для расшифровки.\n\nЗадание\n\n\n  Установить ПО GPG и Kleopatra\n  Создать свой открытый и закрытий ключ.\n  Экспортировать открытый ключ в файл и отправить его в CДО moodle, как отчет по лабораторной работе (прикрепить файл с ключом)\n  Импортировать открытый ключ преподавателя.\n  Расшифровать файл из ответа преподавателя в CДО moodle. Проверить электронную подпись преподавателя.\n  Ответить на вопрос, заданный в расшифрованном файле. Ответ записать в текстовый документ формата TXT или MS Word.\n  Зашифровать документ открытым ключом преподавателя и прикрепить зашифрованный файл вторым файлом отчета по лабораторной работе в системе Moodle.\n\n\n\n\nПрограммное обеспечение\n\n\n  gpg4win – пакет программ для шифрования электронной почты и файлов для большинства версий Microsoft Windows\n\n\nУстановка и использование Gpg4win\n\nУстановка\n\nСкачайте файл установки пограммы Gpg4win в разделе Download на странице Gpg4win.org\n\n\n\nУкажите $0 и нажмите кнопку “Download”.\n\n\n\nПосле скачивания файла установки запустите его и нажмите кнопку “Далее”\n\n\n\nВыберите компоненты установки (поставьте галочки, если они не установлены):\n\n  GnuPG (обязательный);\n  Kleopatra;\n  GpgEX;\n  Browser Integration.\n\n\n\n\nУкажите место установки и нажмите установить.\n\n\n\nНачнется процесс установки.\n\n\n\nПосле заваршения мастер установки предложит запустить установленную программу управления ключами Kleopatra. Нажмите “Готово”.\n\n\n\nСоздание ключей\n\nПосле первого запуска программы управления ключами Kleopatra необходимо создать пару ключей (открытый и закрытый). Нажмите кнопку “Создать новую пару ключей” в разделе “Сертификаты”.\n\n\n\nВ диалоговом окне “Создание сертификата OpenPGP” необходимо указать Ваше имя и  адрес электронной почты, а также установить галочку “Защитить созданный ключ паролем”. Защита ключа паролем позволит предотвратить его использование (от Вашего имени) в случае кражи ключа (ключ хранится в файле на диске Вашего компьютера). Нажмите “ОК”\n\n\n\nУкажите пароль для защиты ключа. Этот пароль необходимо будет вводить при зашифровке и подписании электронной подписью файлов.\n\n\n\nПосле завершения генерации ключа в главной окне программы “Kleopatra” в разделе “Сертификаты” появится запись о созданном ключе.\n\n\n\nЭкспорт открытого ключа\n\nДля того, чтобы Вам могли отправлять зашифрованные сообщения необходимо экспортировать Ваш открытый ключ из  созданной пары ключей и переслать его Вашему корреспонденту. Нажмите кнопку “Экспорт” на панели инструментов в верхней части окна или нажмите правую кнопку мыши на строчке с Вашим сертификатом и выберите пункт “Экспорт”.\n\n\n\nВыберите место, куда будет сохранен файл открытого ключа и исправьте имя файла (при необходимости).\n\n\n\nСозданный файл с Вашим открытым ключом необходимо отправить Вашему корреспонденту. При выполнении лабораторной работы его необходимо прикретить как отчет в системе Moodle.\n\nИмпорт открытого ключа\n\nДля того, чтобы Вы могли зашифровывать файлы для Вашего корреспондента Вам также необходимо импортировать его открытый ключ. Для этого нажмите кнопку “Импорт” в верхней части главного окна программы “Kleopatra”.\n\n\n\nВ появившемся диалоговом окне выберите файл открытого ключа, который Вам прислал Ваш корреспондент. В лабораторной работе это будет файл открытого ключа преподавателя дисциплины.\n\n\n\nПри импорте ключа требуется его проверка в процессе которой необходимо убедится, что ключ действительно принадлежит тому человеку – Вашему корреспонденту. Злоумышленик вполне может прислать Вам ключ от имени Вашего корреспондента, что позводит в дальнейшем перехватывать и читать сообщения которые Вы отправляете Вашему коореспонденту.\n\nПрограмма импорта предлагает способы проверки. В этом месте мы упростим процесс и будем считать, что проверка прошла и мы подтвердим, что ключ действительно принадлежит преподавателю. Нажмите кнопку “Certify”.\n\n\n\nВ появившемся диалоговом окне показан импортируемый открытый ключ и его отпечаток (уникальная для ключа последовательность букв и цифр). Этот отпечаток и нужно сверить. Вы можете, например, позвнить Вашему корреспонденту и попросить его прочитать отпечаток, убедившись, что не произошла подмена ключа и полученный ключ действительно принадлежит Вашему корреспонденту. Нажмите кнопку “Заверить”.\n\n\n\nПосле нажатия кнопки “Заверить” необходимо будет ввести пароль, который защищен Ваш ключ. В результате этого будет поставлена Ваша электронная подпись на открытй ключ корреспондента: Вы заверяете, что в результате проверки Вы установили, что ключ принадлежит именно ему.\n\n\n\nВ главном окне программы “Kleopatra” появится еще одна запись о ключе. Ваш ключ будет выделен полужирным шрифтом поскольку он содержит закрытый ключ. Обычным шрифтом отмечаются импортированные открытые ключи.\n\n\n\nЗашифровываем файл\n\nДля того, чтобы зашифровать файл для последующей отправки Вашему корреспонденту нажмите кнопку “Подписать/Зашифровать”.\n\n\n\nВ появившемся окне выбора файла выберите файл, который Вы хотите зашифровать и нажмите кнопку “Открыть”\n\n\n\nВ появившемся окне будут установлены галочки “Сертификат подписи” в блоке “Доказательство подлинности (подпись)”. Установленная галочка означает, что Вы хотите подписать зашифровываемый файл, чтобы получатель был уверен, что этот файл получен именно от Вас. Отправить  зашифрованный файл Вашему корреспонденту может любой, кто имеет его открытый ключ. Подписав зашифровываемый файл, Вы указывайте на то, что этот файл отпарвлен именно Вами. Для того, чтобы “узнать” и проверить Вашу подпись получатель должен иметь Ваш открытый ключ.\n\nВторая галочка установлена в блоке “Шифрование” напротив строки “Зашифровать для себя”. Это означате, что файл будет зашифрован также при помощи Вашего открытого ключа, чтобы при необходимости Вы тоже смогли расшифровать его.\n\nВторая галочка установлена в блоке “Шифрование” напротив строки “Зашифровать для других”. Здесь необходмио указать (выбрать ключи) получателей, для которых зашифровывается файл. Нажмите кнопку в строке “Зашифровать для других” для выбора ключа Вашего корреспондента, как указано на этой картинке\n\n\n\nВыберите ключ Вашего корреспондента – получателя файла\n\n\n\nИмя Вашего корреспондента появится в строке “Зашифровать для других”. Файл можно зашифровать сразу для нескольких получателей, если у Вас есть их открытые ключи. Нажмите “Sign/Encrypt”.\n\n\n\nПоявится диалоговое окно с сообщение о том, что файл зашифрован и подписан. Найдите зашифрованный файл (с расширением gpg) рядом с исходном файлом и отправьте его получателю.\n\n\n\nРасшифровываем файл\n\nЛюбой человек, у которог оесть Ваш открытый ключ может при помощи программы “Kleopatra” зашифровывать для Вас файлы, расшифровать которые можете только Вы при помощи Вашего закрытого ключа. Преподоложим Вы получили такой файл. Для его расшифровки нажмите кнопку “Расшифровать и проверить” в главном окне программы “Kleopatra”.\n\n\n\nВ появившемся диалоговом окне выбора файла найдите и выберите полученный от Вашего корреспондента файл и нажмите кнопку “Открыть”.\n\n\n\nФайл расшифруется и сохранится рядом с зашифрованный файлом. В появившемся окне Вы увидите результат проверки электронной подписи отпарвителя.\n\n\n\nДополнительная информация\n\n\n  GPGTools – пакет программ для шифрования электронной почты и файлов для MacOS\n  VeraCrypt – программа для создания и использования зашифрованных файлов-контейнеров, которые подключаются как диски.\n  Курс по анонимности и безопасности в сети\n  Создание и использование защищенных криптоконтейнеров TrueCrypt и VeraCrypt\n\n",
      "url": "/pages/it/lab-gpg/"
    },{
      
      "title": "Ортогональные матрицы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Положение и скорость первого космического аппарата, движущегося по орбите определяется координатными столбцами в геоцентрической инерциальной системе координат:\n\n[\\mathbf r_1 = [-2770.4, 2339.6, 5599.4]^T\\,м, \\quad \\mathbf v_1 = [-4414.6, -6328.6, 460.1]^T\\,м/с.]\n\nПоложение и скорость второго космического аппарата определяется координатными столбцами в геоцентрической инерциальной системе координат:\n\n[\\mathbf r_2 = [-3472.1, 1207.9, 5566.7]^T\\,м, \\quad \\mathbf v_2 = [-3688.9, -6741.0, -838.1]^T\\,м/с.]\n\nДля каждого космического аппарата определена орбитальная подвижная система координат \\(C_i x_{oi} y_{oi} z_{oi}\\), начало которой расположено в центре масс КА. Ось \\(C_i x_{oi}\\) направлена вдоль радиус-вектора КА относительно центра Земли, \\(C_i y_{oi}\\) лежит в плоскости орбиты КА и направлена в сторону орбитального движения КА, ось \\(C_i z_{oi}\\) дополняет систему координат до правой.\n\n\n  \n    Найдите матрицу преобразования координат из базиса орбитальной системы координат в базис геоцентрической инерциальной системы координат для первого космического аппарата.\n  \n  \n    Найдите матрицу преобразования координат из базиса орбитальной системы координат в базис геоцентрической инерциальной системы координат для второго космического аппарата.\n  \n  \n    Найдите координаты единичного вектора, направленного из центра масс КА1 в центр масс КА2 в  орбитальной системы координат первого КА.\n  \n  \n    Найдите угол между осями \\(C_1 x_{o1}\\) и \\(C_2 x_{o2}\\)  орбитальных систем координат двух КА.\n  \n\n\nОтвет:\n\n\nA01 =\n\n   -0.4153   -0.5711    0.7081\n    0.3507   -0.8187   -0.4546\n    0.8394    0.0595    0.5403\n\n\nA02 =\n\n   -0.5205   -0.4772    0.7081\n    0.1811   -0.8721   -0.4546\n    0.8345   -0.1084    0.5403\n\n\ne12_1 =\n\n   -0.0998\n    0.9950\n    0.0000\n\nУгол C1x1-C2x2 = \n\n11.46 градусов\n\n\n",
      "url": "/pages/mbs/lab-hill-frame-matrix/"
    },{
      
      "title": "Каталог ИТ-услуг",
      
      "content": "\n  Задание\n  Методические указания    \n      Определение\n      Каталог услуг в iTop\n      Соглашение об уровне сервиса:\n      Пример каталога услуг        \n          A. Поддержка настольных компьютеров.\n          B. Службы электронной почты.\n          C. Поддержка СУБД\n        \n      \n      Пример соглашение об уровне обслуживания.\n      Источники\n    \n  \n\n\nЗадание\n\n\n  Создайте каталог услуг для организации (подразделения), описание ИТ-инфраструктуры которой было выполнено в первой лабораторной работе. Каталог услуг должен включать список ИТ-услуг, предлагаемых организацией, с кратким описанием каждой услуги. Для каждой услуги укажите следующую информацию:\n    \n      Наименование услуги: название услуги, предлагаемой клиентам.\n      Описание услуги: подробное описание услуги и того, что она влечет за собой.\n    \n  \n  Добавьте каталог услуг в систему iTop.\n    \n      Создайте пакет услуг с наименованием “Пакет услуг для НАИМЕНОВАНИЕ КОМПАНИИ”.\n      Создайте список услуг, связанный с пакетом услуг.\n      Создайте подкатегории для каждой услуги.\n    \n  \n  Для трех разработанных услуг напишите соглашение об уровне сервиса.\n\n\nКаталог услуг должен включать в себя не менее 6 категорий с не менее чем 5 услугами в каждой категории.\n\nМетодические указания\n\nОпределение\n\nКаталог услуг – это структурированный перечень услуг, предлагаемых заказчику. Обычно он включает в себя как услуги, доступные для заказа и потребления в настоящий момент времени, так и услуги которые выводятся на рынок и станут доступны заказчикам в обозримом будущем, а пока предназначены для формирования и оценки их спроса, а возможно и для формирования предварительных заказов (применимо для коммерческих поставщиков услуг) [1].\n\nКаталог услуг ITIL включает описание каждой услуги, ее цели, группы клиентов, которые она обслуживает, используемую технологию, а также связанные с ней процессы и соглашения об уровне обслуживания. Каталог услуг — важный инструмент управления ИТ-услугами (ITSM), поскольку он помогает определять ожидания клиентов и управлять ими, а также обеспечивает соответствие услуг бизнес-целям. Кроме того, каталог услуг используется для измерения и составления отчетов о производительности ИТ-услуг, а также для обеспечения их эффективного и результативного предоставления.\n\nРазработка каталога ИТ-услуг нацелена на решение следующих задач заказчика:\n\n  определение/выделение ИТ-услуг, предоставляемых пользователям;\n  формирование описания ИТ-услуг в форме каталога услуг;\n  актуализация описания ИТ-услуг в каталоге услуг.\n\n\nПреимущества каталога услуг:\n\n  улучшаются коммуникации между подразделениями компании и ИТ- службой;\n  появляется возможность формирования отчётности по различным параметрам, что значительно повышает качество управленческих решений;\n  услуги приобретают очередность и приоритетность, что позволяет из- бежать «нецелевого» использования ИТ;\n  затраты на ИТ становятся прозрачными и обоснованными.\n\n\nКаталог позволяет оказывать пользователям согласованные по качеству услуги путем предоставления полной и актуальной информации по всем оказываемым ИТ-услугам [2].\n\nКаталог услуг в iTop\n\nКаталог услуг в iTop находится в разделе “Управление услугами”\n\n\n\nВ разделе Управление услугами ⇒ Пакеты услуг создаются пакеты услуг.\n\n\n\nВ разделе Управление услугами ⇒ Услуги создаются категории услуг, которые принадлежат ранее созданным пакетам.\n\n\n\nДля кажой услуги может быть детализирован список подкатегорий.\n\n\n\nСоглашение об уровне сервиса:\n\nSLA (Service Level Agreement, соглашение об уровне сервиса) — соглашение между заказчиком и поставщиком услуг, описывающее параметры качества предоставления этих услуг. В SLA содержится:\n\n  перечень услуг и сервисов;\n  условия их предоставления и сроки;\n  измеряемые параметры качества предоставляемой услуги: например минимально допустимая скорость передачи данных;\n  измеряемые параметры качества решения возникающих проблем: например время реакции на поступившую заявку на обслуживание, время устранения неисправности и т. п.;\n  ответственность за несоблюдение условий соглашения.\n\n\nПример каталога услуг\n\nНиже приведен фрагмент каталога услуг.\n\nA. Поддержка настольных компьютеров.\n\nУслуга обеспечивает техническую поддержку и обслуживание настольных компьютеров и ноутбуков.\n\n\n  А.1. Ремонт и замена оборудования ПК и ноутбуков. Ремонт рабочих персональных компьютеров и ноутбуков, замена оборудования стационарных компьютеров, обновление обурудования (замена жестких дисков, видеокарт, памяти)\n  A.2. Обслуживание переферийных устрйоств. Услуга по установке и обслуживанию принтеров и периферийных устройств включает установку, настройку и текущее обслуживание принтеров и периферийных устройств, таких как сканеры, копировальные аппараты и факсимильные аппараты.\n  А.2. Установка и обновление операционной системы. Периодическое обновление опреационных систем, переустановка операционных систем.\n  А.3. Установка и обновление программного обеспечения безопасности. …\n  A.4. Управление учетными записями пользователей и паролями. …\n\n\nB. Службы электронной почты.\n\nCлужба предоставляет сотрудникам инструменты для общения по электронной почте и совместной работы.\n\n\n  B.1 Управление запросами. Процесс управления запросами на новые учетные записи электронной почты, изменения существующих учетных записей электронной почты, удаление учетных записей электронной почты.\n  B.2. Создание учетной записи. Процесс создания новых учетных записей электронной почты для сотрудников, подрядчиков или партнеров, включая назначение адресов электронной почты, паролей и соответствующих разрешений безопасности.\n  B.3 Архивирование электронной почты. Служба предоставляет пользователям возможность архивировать сообщения электронной почты для соблюдения нормативных требований или в целях долгосрочного хранения.\n  B.4 …\n\n\nC. Поддержка СУБД\n\n  …\n\n\nПример соглашение об уровне обслуживания.\n\nСоглашение об уровне обслуживания для служб управления учетными записями пользователей и паролями.\n\nКомпания “ИТ-комм” предоставит компании “Phoenix Frontier Solutions” поддержку Управления учетными записями пользователей и паролями, при этом:\n\n  Все проблемы будут записаны.\n  Проблемы будут решены или переданы соответствующему специалисту.\n  Проблемы будут отслеживаться.\n  Пользователи будут уведомлены о времени выполнения обязательства и любых проблемах, возникающих при выполнении установленного обязательства.\n  Решение проблемы будет задокументировано и доступно в статусе отчета.\n  Будут предоставляться ежемесячные отчеты.\n\n\nЕдиной точкой контакта является телефонный номер 322-32-22, который будет иметь две линии для приема звонков. Когда обе линии заняты, вызовы будут переадресовываться на голосовую почту, где можно оставить сообщение. Служба поддержки гарантирует ответный звонок в течение 15 минут после сообщения голосовой почты.\n\nВсе сообщения, оставленные на голосовой почте, будут подтверждены для получения в течение четырех часов. Отдельный номер телефона (322-32-23) будет доступен для проверки состояния работоспособности системы (мейнфрейм, AS/400, файловый сервер, голосовая почта). С этого номера звонящий также может быть переведен на сотрудников службы поддержки. Телефонный номер 322-32-24 доступен для отправки информации по факсу.\n\nВремя ответа. Поставщик услуг должен ответить на запрос на управление учетной записью пользователя и паролем в течение 4 часов с момента получения запроса.\n\nВремя решения. Поставщик услуг должен решить проблемы с управлением учетными записями пользователей и паролями в течение 4 часов с момента получения запроса.\n\nДоступность. Службы управления учетными записями пользователей и паролями должны быть доступны 24 часа в сутки, 7 дней в неделю, за исключением периодов планового технического обслуживания.\n\nОтчетность. Поставщик услуг должен предоставлять еженедельные отчеты о производительности службы управления учетными записями пользователей и паролями:\n\n  количество запросов на обслуживание;\n  количество инцидентов;\n  время ответа;\n  время решения;\n  уровень удовлетворенности пользователей;\n  количество и перечень неразрешенных инцидентов и запросов.\n\n\nЭскалация. В случае каких-либо перебоев в обслуживании или недоступности Поставщик услуг должен передать проблему соответствующему персоналу и предоставлять регулярные обновления до разрешения.\n\nТехническое обслуживание. Поставщик услуг должен выполнять необходимое техническое обслуживание и обновления служб управления учетными записями пользователей и паролями, а также должен заранее информировать клиентов о любых запланированных периодах технического обслуживания.\n\nБезопасность. Поставщик услуг должен обеспечить безопасность служб управления учетными записями пользователей и паролями и их соответствие отраслевым стандартам информационной безопасности.\n\nОбучение. Поставщик услуг должен проводить обучение клиентов тому, как использовать службы управления учетными записями пользователей и паролями, в том числе, как сбрасывать пароли, управлять учетными записями пользователей и получать отчеты о доступе.\n\nДокументация. Поставщик услуг должен предоставить исчерпывающую документацию по службам управления учетными записями пользователей и паролями, включая процедуры запроса услуг и сообщения о проблемах.\n\nУдовлетворенность конечного пользователя. Мы стремимся достичь уровня удовлетворенности 95% или выше, согласно нашему ежемесячному опросу удовлетворенности клиентов.\n\nСервисные кредиты.  В случае, если мы не соблюдаем согласованное SLA, клиент может иметь право на кредиты за уровень обслуживания. Если группа ИТ-поддержки не ответит на запрос в течение 4 часов или не удовлетворит запрос в течение 4 рабочих часов, группа ИТ-поддержки предоставит кредит на обслуживание в размере 5 % от ежемесячной платы за сервис.\n\nИсточники\n\n\n  Каталог ИТ-услуг. Главное\n  Ложкова Ю.Н. Управление ИТ-сервисами и контентом: методические рекомендации к лабораторным работам по дисциплине «Управление ИТ-сервисами и контентом» для студентов, обучающихся по направлению подготовки 38.03.05 «Бизнес-информатика» / Ю.Н. Ложкова; Алт. гос. техн. ун-т, БТИ. - Бийск: Изд-во Алт. гос. техн. ун-та, 2017. - 20 с.\n  Service Level Agreement (SLA): все о соглашении об уровне сервиса.\n  Пример №1 SLA на английском языке\n  Пример №2 SLA на английском языке\n\n\n",
      "url": "/pages/it/lab-it-catalog/"
    },{
      
      "title": "ИТ-инфраструктура предприятия",
      
      "content": "Разработать ИТ-инфраструктуру малого предприятия. Пример организационной диаграммы предприятия представлен на рисунке 1. При разработке ИТ-инфраструктуры необходимо уточнить специфику рассматриваемого предприятия (виды деятельности).\n\n\n\nРисунок 1 – Пример организационной диаграммы малого предприятия\n\nЗадачи\n\n1) Разработать организационную диаграмму малого предприятия\n\nВ организационной диаграмме должно быть не менее 4 подразделений и не менее 16 сотрудников\n\n2) Разработать план помещений\n\nНа схеме должно быть не менее 4 комнат (расположений).\n\n3) Определить необходимое количество компьютеров для работы организации\n\n\n  Cтационарные рабочие станции\n  Мониторы\n  Ноутбуки, плашеты\n  Серверы\n\n\nСоставить таблицу с перечислением компьютеров и их основных характеристик: производитель, марка процессора, объем оперативной памяти и памяти дискового пространства, производитель монитора, разрешение монитора.\n\nПример:\n\nТаблица 1 - Серверы\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n      CPU\n      RAM, МБ\n      HDD/SDD, Гб\n    \n  \n  \n    \n      SRV-001\n      Dell\n      PowerEdge T40\n      Intel Xeon E-2200\n      32\n      1000\n    \n    \n      SRV-002\n      HP\n      ProLiant Gen 10\n      Intel Pentium G5420 2C 3.8GHz\n      8\n      1000\n    \n  \n\n\nТаблица 2 - Рабочие станции\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n      CPU\n      RAM, МБ\n      HDD/SDD, Гб\n    \n  \n  \n    \n      WS-001\n      DELL\n      Dell Precision T5820 5820-8109\n      Xeon W-2223\n      16\n      1000\n    \n    \n      WS-002\n      DELL\n      Dell Precision T5820 5820-8109\n      Xeon W-2223\n      16\n      1000\n    \n  \n\n\nТаблица 3 - Мониторы\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n      Диагональ\n      Разрешение\n    \n  \n  \n    \n      DSP-001\n      DELL\n      S2721D\n      27\n      2560x1440@75 Гц\n    \n    \n      DSP-001\n      iiyama\n      G-Master Red Eagle GB3466WQSU-B1\n      34\n      3440x1440@144 Гц\n    \n  \n\n\n4) Определить и составить перечень программного обеспечения\n\nТаблица 4 - Программное обеспечение\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n      Место установки\n    \n  \n  \n    \n      SW-001\n      Microsoft\n      Windows 10\n      WS-001\n    \n    \n      SW-002\n      Microsoft\n      Windows 10\n      WS-002\n    \n    \n      SW-002\n      Kaspersky Lab\n      Kaspersky internet securety\n      WS-005\n    \n  \n\n\n5) Определить необходимое количество оргтехники для работы организации\n\nОпределить необходимое количество и перечень оргтехники для работы организации.\n\nТаблица 5 - Переферийные устройства\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n    \n  \n  \n    \n      PR-001\n      HP\n      LaserJet P1606dn\n    \n    \n      PR-002\n      HP\n      LaserJet P1606dn\n    \n    \n      SC-001\n      Canon\n      CanoScan 9000 Mark II\n    \n  \n\n\n6) Определить необходимое количество сетевого оборудования для работы организации\n\nОпределить необходимое количество и перечень сетевого оборудования для работы организации (коммутаторы, маршрутизаторы, …). Составить перечень оборудования. Предполагается, что организация подключена к Интернет-провайдеру при помощи Ethernet-кабеля.\n\nТаблица 6 -  Активное сетевое оборудование\n\n\n  \n    \n      ID\n      Производитель\n      Наименование\n    \n  \n  \n    \n      NE-001\n      TP-Link\n      Маршрутизатор TL-ER7206\n    \n    \n      NE-002\n      MikroTik\n      Коммутатор CRS305-1G-4S+IN\n    \n    \n      NE-003\n      TP-Link\n      Точка доступа TP-LINK EAP265 HD\n    \n  \n\n\n6) Разработать схему размещения элементов ИТ-инфраструктуры в помещениях предприятия\n\nРазработать план помещений (не менее 4 комнат), показать размещение элементов ИТ-инфраструктуры. Показать на плане помещений структуру локальной сети, указав соединения серверов, рабочих станций, сетевых принтеров, активного сетевого оборудования (коммутаторов).\n\n7) Оценить затраты на инфраструктуру\n\n\n  cтоимость приобретённого оборудования (персональные компьютеры, оргтехника, сервер, материалы для локальной сети, сетевое оборудование, оборудование резервного копирования, оборудование для бесперебойного энергообеспечения); для оценки стоимости использовать информацию из интернет-магазинов оргтехники;\n  cтоимость приобретённого программного обеспечения (начиная с операционной системы, антивирусной защиты, заканчивая бизнес-приложениями);\n  оценить годовые затраты на расходные материалы для оргтехники (картриджей, бумаги для печати);\n  оценить средние затраты на оплату электроэнергии, потребляемой оборудованием (в год).\n\n\n\n  Электроприбор с мощностью \\(W\\) Ватт в течение \\(t_h\\) часов потребляет \\(E = 0.001 \\cdot W \\cdot t_h\\) киловатт-час электрической энергии.\n\n\nВ отчете должны быть приведены:\n\n  организационная диаграмма предприятия;\n  схемы расположения офисов (план помещений) и рабочих мест в помещениях;\n  схема локальной вычислительной сети с расположением элементов ИТ-инфраструктуры;\n  перечень программного обеспечения (в зависимости от бизнес-процессов предприятия)\n  перечень рабочих станций, серверов, переферийных устройств, оргтехники, сетевого оборудования\n\n\nМетодические указания\n\nПример отчета по лабораторной работе\n\nПО для разработки диаграмм DRAW.IO\n\nДля разработки схемы расположения офисов (плана помещений) рекомендуется использовать веб-сервис для создания схем и диаграмм draw.io.\n\n\n\nРисунок 2 – Окно веб-приложения draw.io\n\nВ левой части окна приложения расположена панель с библиотеками блоков (форм). Для разработки планов помещения и размещения элементов ИТ-инфраструктуры необходимо включить дополнительные блоки Floorplans, Office, Network, Active Directory, нажав на ссылку “+ More Shapes” в левой нижней части окна.\n\n\n\nРисунок 3 –   Добавление дополнительных библиотек блоков\n\nПосле разработки схемы размещения элементов инфраструктуры файл схемы можно сохранить на локальном диске компьютера или в одном из предлагаемых облачных сервисов.\n\n\n\nРисунок 4 –   Добавление дополнительных библиотек блоков\n\nДля экспорта изображения необходимо выделить ту часть схемы, которую необходимо сохранить в графическом формате (например, png) (для вставки в отчет) в меню “File” выберите пункт “Export As” и тип сохраняемого файла (png, jpg).\n\n\n\nРисунок 5 –   Экспорт в графический файл\n\nВ открывшемся диалоговом окне укажите масштаб не менее 300 % (это определяет размер растрового изображения, а следовательно его качество). Если экспортируется не весь лист со схемой, а только выделенная её часть необходимо отметить пункт “Selection Only”.\n\n\n\nРисунок 6 –   Настройки экспорта\n\nСхема соединения рабочих станций в офисе\n\nНа рисунке показан пример схемы подключения сети в двух офисах с выходом в интеренет. Для каждого устройства проведён отдельный провод и все провода подключаются к сетевому коммутатору. Коммутатор от каждой комнаты подключается к общему коммутатору, который в свою очередь подключается к маршрутизатору, соединющему сеть офиса с сетью провайдера Интернет.\n\n\n\nИТ-Инфраструктура\n\nДля обеспечения  эффективности работы современной компании ей нужна качественная полноценная ИТ-инфраструктура, включающая целый комплекс служб, подсистем и решений. Это сочетание сервисов должно по своей надежности не только соответствовать сегодняшнему состоянию предприятия, но и иметь запас прочности на будущее развитие.\n\nИТ-инфраструктура представляет собой набор программных, технических и информационных средств, который делает возможным работу приложений для  бизнеса – таких, как электронная почта, CRM и все столь привычные и делающие жизнь удобной вещи, как банковские переводы, онлайн-транзакции.\n\n\n  ИТ-инфраструктура – это организационно-техническое объединение программных, вычислительных и телекоммуникационных средств, связей между ними и эксплуатационного персонала, обеспечивающее предоставление информационных, вычислительных и телекоммуникационных ресурсов, возможностей и услуг работникам (подразделениям) предприятия (организации), необходимых для осуществления профессиональной деятельности и решения соответствующих бизнес-задач [1].\n\n\nИТ-инфрастуктура включает в себя:\n\n  серверы, компьютеры (рабочие станции);\n  периферийные устройства (принтеры, факсы);\n  программное обеспечение;\n  сети для передачи данных;\n  телефонные станции.\n\n\nИТ-инфраструктуру можно рассмотреть как набор четырех групп сервисов [2]:\n\n  технологические сервисы;\n  сервисы для совместной работы;\n  сервисы сообщений;\n  сервисы для обеспечения безопасности.\n\n\nИсточники\n\n\n  Сети для начинающего IT-специалиста. Обязательная база\n  cyclowiki.org: ИТ-инфраструктура\n  Конспект лекций по дисциплине «Управление ИТ-сервисами и контентом» Составил: к.т.н., Бакаев М. A.\n  ИТ-инфраструктура предприятия - что нужно бизнесу?\n  Построение ИТ инфраструктуры небольшого офиса\n  Описание ИТ-инфраструктуры предприятия\n  ИТ-инфраструктура как сервис: от сервера до приложения\n  Компоненты ИТ-инфраструктуры предприятия\n  ИТ-инфраструктура.\n\n",
      "url": "/pages/it/lab-it-structure/"
    },{
      
      "title": "Движение спускаемого аппарата в атмосфере",
      
      "content": "Разработать программу интегрирования уравнений движения спускаемого аппарата (СА) в атмосфере (баллистический спуск). Процесс интегрирования должен завершаться при достижении спускаемым аппаратом нулевой высоты.\n\nУравнения движения записать, используя декартовы координаты СА относительно геоцентрической системы координат \\(OX_oY_o\\):\n\n[\\boldsymbol{r}= \\begin{bmatrix} x \\ y \\end{bmatrix}.]\n\nВ начальный момент времени СА находится в точке с координатами \\((0,y_0)\\) и движется со скоростью \\(V_0\\).\n\nДвижение СА происходит в центральном гравитационном поле Земли. На СА действуют сила притяжения \\(\\boldsymbol G\\), определяемая выражением:\n\n[\\boldsymbol G = - \\frac{\\mu m}{r^3} \\boldsymbol{r},]\n\nгде \\(\\mu\\) – гравитационный параметр Земли; и сила лобового аэродинамического сопротивления \\(\\boldsymbol{F}_d\\):\n\n[\\boldsymbol{F}_d = - \\boldsymbol{e}_v C_d q S_m,]\n\nгде \\(\\boldsymbol{e}_v\\) – единичный вектор, определяющий направление скорости СА\n\n\n  \n    \n      [\\boldsymbol{e}_v = \\frac{\\boldsymbol{V}}{\n      \\boldsymbol{V}\n      }, \\quad \\boldsymbol{V} = \\begin{bmatrix} \\dot{x} \\ \\dot{y} \\end{bmatrix},]\n    \n  \n\n\nгде \\(C_d\\) – коэффициент лобового сопротивления, \\(S_m\\) – характерная площадь (площадь миделя), \\(q\\) – скоростной напор, зависящий от плотности воздуха и скорости движения СА:\n\n[q = \\frac{\\rho V^2}{2}]\n\nПри определении скорости движения спускаемого аппарата в атмосфере вращение Земли не учитывается.\n\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса СА, кг\n      3000\n    \n    \n      \\(C_d\\)\n      1.6\n    \n    \n      \\(S_m\\), м\\(^2\\)\n      15\n    \n    \n      \\(R_e\\), м\n      6371000\n    \n    \n      \\(y_0\\), м\n      6461000\n    \n    \n      \\(V_0\\), м/c\n      7000\n    \n    \n      \\(\\mu\\), м\\(^3/c^{-2}\\)\n      398600.4415\\(\\cdot 10^9\\)\n    \n  \n\n\n\n  Проинтегрируйте уравнение движения спускаемого аппарата до достижения нулевой высоты.\n  Постройте график траектории движения спускаемого аппарата.\n  Постройте зависимость скорости движения спускаемого аппарата от времени.\n  Постройте зависимость скорости движения спускаемого аппарата от высоты.\n  Постройте зависимость высоты спускаемого аппарата от времени.\n  Постройте зависимость скоростного напора от высоты.\n  Найдите высоту, на которой скоростной напор достигает максимального значения.\n  Постройте график изменения перегрузки.\n\n\nМетодические указания\n\n\n  \n    Для определения плотности воздуха используйте функцию интерполирования по таблице плотности воздуха по стандартной атмосфере в диапазоне высот от -1000 до 100000 м над уровнем моря. Таблица должна загружаться из текстового файла (см. функции dlmread, interp1) до запуска процесса интегрирования.\n  \n  \n    Для определения момента окончания процесса интегрирования используйте функцию Event Locator, передаваемую в функцию численного интегрирования:\n  \n\n\nfunction [value,isterminal,direction] = h0EventsFcn(t,q)\n  h = ... % вычисление высоты  \n  value      =  h; % Отслеживаемая величина (высота)\n  isterminal =  1; % Остановить процесс интегрирования\n  direction  = -1; % Процесс интегрирования останавливается при уменьшении высоты dh/dt&lt;0, h=0\nend\n\n\n",
      "url": "/pages/matlab/lab-reentry/"
    },{
      
      "title": "Модель одноканальной системы ориентации космического аппарата.",
      
      "content": "Цель работы\n\nПостроить модель одноканальной реактивной системы ориентации космического аппарата (КА) в SIMULINK.\n\nЗадачи\n\n\n  Построить модель одноканальной системы ориентации космического аппарата.\n  Задать следующие начальные условия \\(\\varphi_0 = 20^\\circ\\), \\(\\dot{\\varphi}_0 = 15^\\circ/c\\).\n  Построить фазовый портрет (\\(\\varphi, \\dot{\\varphi}\\)).\n  Построить график изменения угла \\(\\varphi\\) по времени.\n  Построить график изменения угловой скорости \\(\\dot{\\varphi}\\) по времени.\n  Построить график изменения момента, создаваемого двигателями, по времени.\n  Построить фазовый портрет системы при \\(k_\\omega = 0\\).\n  Построить график изменения угла \\(\\varphi\\) при \\(k_\\omega = 0\\).\n  Построить график изменения угловой скорости при \\(k_\\omega = 0\\).\n\n\nРеактивная система ориентации\n\nВ состав системы ориентации КА входят датчик угла, датчик угловой скорости и исполнительные органы. Датчик угла определяет угол между осью \\(x_c\\), связанной КА, и некоторой осью \\(x_0\\) фиксированной в пространстве (неподвижная система координат). Датчик угловой скорости определяет угловую скорость КА по отношению к неподвижной системе координат.\n\nИсполнительными органами системы ориентации являются два реактивных двигателя, создающие постоянный момент относительно центра масс КА. Сила \\(P_-\\) создает отрицательный момент, направленный в сторону уменьшения угла \\(\\varphi\\). Сила \\(P_+\\) создает положительный момент, направленный в сторону увеличения угла \\(\\varphi\\). Далее будем считать, что \\(P_+ = P_- = P\\) и плечи этих сил относительно центра масс КА равны (рисунок 1). Система ориентации должна поддерживать угол и угловую скорость КА близкими к нулю.\n\n\n\nРисунок 1 -  Работа реактивной системы ориентации\n\nСигналы, поступающие с датчика угла и угловой скорости, суммируются с заданными коэффициентами:\n\n[s = k_\\varphi \\phi + k_\\omega \\dot{\\varphi}]\n\nгде \\(k_\\varphi\\) и \\(k_\\omega\\) –  коэффициенты усиления угла и угловой скорости.\n\nИтоговый сигнал \\(s\\) используется для управления включением и выключением двигателей ориентации. Модель функции \\(s\\) в SIMULINK, выполненная в виде отдельной подсистемы показана на рисунке 2.\n\n\n\nРисунок 2 -  Модель подсистемы “Функция s”\n\nДля создания подсистемы в SIMULINK выберите в разделе “Commonly Used Blocks” блок Subsystem и поместите его в область модели.\n\n\n\n\n\nДвойным щелчком мыши перейдите на уровень подсистемы для построения ее модели.\n\n\n\nКогда значение функции (сигнала) \\(s\\) по модулю превышает некоторое пороговое значение \\(s_{max}\\) происходит включение двигателя. В процессе работы двигатель создает постоянный момент относительно центра масс КА. Знак этого момента зависит от знака величины \\(u\\):\n\n[u(s) = \n\\begin{cases}\n+1, &amp; s \\geq s_{max} \n-1, &amp; s \\leq -s_{max} \n0, &amp; |s| \\leq s_{max} \n\\end{cases}]\n\nЕсли значение сигнала \\(s\\) меньше некоторого порогового значения, то функция \\(u\\) равна нулю, таким образом у рассматриваемой системы ориентации есть зона нечувствительности (\\(\\mid s\\mid \\leq s_{max}\\)). График функции переключения \\(u(s)\\) показан на рисунке 3. В общем случае уровень, при котором включается реле может отличаться от уровня, при котором реле отключается. Это явление называется гистерезисом.\n\n\n\nРисунок 3 - Функция управления u(s)\n\nВеличина управляющего момента будет определяться выражением\n\n[M = - u(s) \\cdot P \\cdot h.]\n\nМодель функции переключения в SIMULINK в виде подсистемы показана на рисунке 4.\n\n\n\nРисунок 4 - Подсистема “Функция u(s)”\n\nОсновой модели является блок “реле”. Настройки блока “Реле” приведены на рисунке 5. Выходной сигнал блока “Реле” равен значению, указанному в поле ввода  “Output when on”, если входной сигнал, увеличиваясь, превышает значение “Switch on point”. При уменьшении входного сигнала до уровня ниже “Switch off point” выходной сигнал равен “Output when off”. На вход блока “реле” подается модуль функции u(s). Для учета знака функции u(s) определяется ее знак при помощи блока “Sign” (Знак): +1 или -1, далее это значение умножается на результат работы блока “реле”.\n\n\n\nРисунок 5 - Настройки блока “Реле”\n\nЗначение сигнала с выхода подсистемы “Функция u(s)”, который может принимать значения минус 1, 0 или +1 умножается на момент силы тяги. Результат этой операции (момент силы тяги) подается в подсистему, моделирующую динамику КА.\n\nСхема подсистемы, описывающей модель КА, приведена на рисунке 6. На вход подается величина момента, создаваемого двигателями. Момент делится на момент инерции КА относительно центра масс, для этого используется блок “усилитель” (Gain) с коэффициентом усиления 1/J, где J – момент инерции КА. Далее сигнал дважды интегрируется: таким образом интегрируется дифференциальное уравнение движения (вращения) КА в плоскости:\n\n[J \\ddot{\\varphi} = M(s).]\n\n\n\nРисунок 6 - Подсистема “Модель КА”\n\nОбщий вид модели показан на рисунке 7.\n\n\n\nРисунок 7 - Модель реактивной системы ориентации КА\n\nНа рисунке 8 показан пример фазового портрета системы. Фазовый портрет показывает, что каждый последующий цикл колебаний начинается с меньшей угловой скоростью благодаря наклону линий включения и выключения.\n\n\n\nРисунок 8 - Фазовый портрет\n\nНачиная с некоторой угловой скорости крутизна параболы (траектория, на которой работает двигатель) становится больше наклона линии переключения и фазовая траектория перейдет в траекторию ступенчатого вида. Колебания происходят между линиями включения и выключения. На рисунке 9 в правой части показана одна “ступенька” таких односторонних колебаний. Даже если включение и выключение двигателя происходит при одном и том же  уровне сигнала на входе “реле” (гистерезис отсутствует), скользящий режим будет возникать поскольку у реальных двигателей есть минимальная продолжительность работы.\n\n\n\nРисунок 9 - Фазовый портрет\n\nВасильев В.Н. Системы ориентации космических аппаратов / В.Н. Васильев. - М.: ФГУП «НПП ВНИИЭМ», 2009. - 310 с.\n\n",
      "url": "/pages/matlab/lab-stabilization/"
    },{
      
      "title": "Лабораторная работа №1",
      
      "content": "Задание\n\n\n  Найти на домашней странице пяти Интернет-провайдеров Самары информацию о технических характеристиках предоставляемых услуг для физических или юридических лиц (скорость, доступность, …).\n  Найти на домашней странице (в договоре или других формах) пяти хостинг-провайдеров информацию о технических характеристиках предоставляемых услуг (заявляемое качество предоставляемых услуг, работа службы поддержки).\n\n\nМетодические рекомендации\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab1/"
    },{
      
      "title": "Лабораторная работа 1",
      "description": "Задание для лабораторной работы 1.\n",
      "content": "Подгруппа 1\n\nНаписать программу решения квадаратного уравнения\n\nimport math\n\nprint(\"Введите коэффициенты для уравнения (ax^2 + bx + c = 0):\")\n\na = float(input(\"a=\"))\nb = float(input(\"b=\"))\nc = float(input(\"c=\"))\n\ndiscr=b**2-4*a*c\n\nif discr&gt;0:  \n  x1 = (-b+math.sqrt(discr))/(2*a)\n  x2 = (-b-math.sqrt(discr))/(2*a)\n  print('x1 = {:5.2f}, x2 = {:5.2f}'.format(x1, x2))\nelse:  \n  print('Корней нет')  \n\n\nПодгруппа 2\n\nДля заданного списка\ndata = [4, 5, 2, 3, 8, 7, 4, 5, 0, 5, 2, 1, 2, 8, 7, 4, 3, 5, 2, 1]\n\nвыведите на экран при помощи функции print:\n\n  item первые пять элементов\n  каждый третий элемент\n  каждый третий элемент с конца\n  последние пять элементов (в исходном порядке)\n  последние пять элементов (в обратном порядке)\n  количество элементов, равных 5\n\n",
      "url": "/pages/python/lab1/"
    },{
      
      "title": "Лабораторная работа №1",
      
      "content": "\n  Сгенерируйте 100 значений случайной величины, равномерно распределенной в интервале от 0 до 100\n  Определите количество чисел больше 30\n  Найдите среднее арифметическое первых 20 чисел\n  Найдите среднее арифметическое последних 20 чисел\n  Найдите сумму произведений первых 50 и последних 50 чисел последовательности\n  Постройте последовательность средних значений смежных чисел последовательности, например: {1,2,3} -&gt; {1.5, 2.5}\n  Найдите позицию максимального числа последовательности\n  Отсортируйте последовательность по возрастанию и найдите номера позиций двух смежных чисел в отсортированной последовательности, расстояние между которыми максимально\n  Удалите из последовательности числа, принадлежащие интервалу от 30 до 50.\n  Задайте положение пяти точек на плоскости при помощи генератора случайных чисел. Координаты точек должны принадлежать интервалу [0, 10].\n  Найдите площади всех треугольников, которые можно построить, используя полученные точки как вершины.\n  Найдите координаты трех точек-вершин из этого списка, по которым можно построить треугольник с максимальной площадью.\n\n\n",
      "url": "/pages/wolfram/lab1/"
    },{
      
      "title": "Лабораторная работа 10",
      
      "content": "Задание 1\n\nПостроить график функций  \\(\\cos x\\), \\(\\sin x\\)  на интервале от 0 до  \\(2\\pi\\) на одном рисунке, обозначив  первую точку пересечения двух графиков окружностью с центром в точке пересечения и выносной линией от этой окружности с указанием значения \\(x\\) для точки пересечения и значения функции в этой точке.\n\nЗадание 2\n\nЗадать размер графика 18 x 10 см, размер шрифта 14, семейство шрифтов Times.\n\nЗадание 3\n\nСохранить изображение графика в формате png.\n\n\n",
      "url": "/pages/python/lab10/"
    },{
      
      "title": "NumPy. Векторы и матрицы",
      
      "content": "Движение наноспутника относительно станции определяется в орбитальной системе координат, движущейся вместе с орбитальной станцией по круговой орбите. Начало координат расположено в центре масс станции. Ось \\(x_o\\) орбитальной подвижной системы координат направлена от Земли вдоль радиус вектора станции. Ось \\(y_o\\) лежит в плоскости орбиты и направлена в сторону орбитальной скорости станции. Ось \\(z_o\\) дополняет систему координат до правой.\n\n\n\nПри отделении от станции с относительной скоростью \\(V_0 = [\\dot{x}_0, \\dot{y}_0, \\dot{z}_0]\\) закон движения наноспутника в координатной форме имеет вид:\n\n[\\begin{aligned}\n    &amp; x(t) = \\frac{1}{n} \\left[ \\dot{x}_0 \\sin n t + 2 \\dot{y}_0 (1-\\cos nt) \\right] \n    &amp; y(t) = \\frac{1}{n} \\left[ 2 \\dot{x}_0 ( \\cos nt - 1)\n\n  \\dot{y}_0 (4\\sin nt - 3nt) \\right] \n  &amp; z(t) =  \\frac{\\dot{z}_0}{n} \\sin nt\n\\end{aligned}]\n\n\nгде \\(n = 2\\pi/T\\) – угловая скорость орбитального движения станции, \\(T\\)  – орбитальный период станции.\n\nСоздать функцию определения положения спутника относительно орбитальной подвижной системы координат, связанной со станцией, в моменты времени, заданные массивом t_array:\n\ndef rho(t_array):\n    ...\n    ...\n    ...\n    return res\n\n\nФункция rho должна возвращать массив (numpy.array) \\(n \\times 4\\), где n - количество элементов в массиве моментов времени t_array. Первый столбец результата – время (копия массива t_array), второй, третий и четвертый столбцы – значения координат \\(x, y, z\\) наноспутника относительно станции.\n\n\n  Постройте траекторию движения спутника на интервале трёх орбитальных периодов станции, движущейся по круговой орбите высотой 400 км.\n  Постройте график изменения расстояния между спутником и станцией на интервале трёх орбитальных периодов при начальной скорости отделения наноспутника\n\n\n[\\dot{x}_0 = -0.5 м/с, \\quad \\dot{y}_0 = 0.05 м/с, \\quad \\dot{z}_0 = 0.0]\n\n\n  Постройте график изменения расстояния между наноспутником и станцией.\n  Определите расстояние и время минимального сближение наноспутника со станцией после его отделения (локальный экстремум - минимум) на интервале 3 орбитальных периодов. Алгоритм определения минимального расстояния должен работать для любого массива расстояний. В случае отсутствия локального минимума, если функция изменения расстояния монотонно возрастает, алгоритм должен возвращать numpy.Inf (бесконечность). Проверить работу алгоритма для различных начальных условий движения наноспутника. Оформите алгоритм в виде функции\n\n\ndef min_dist(t_d_array):\n    # t_d_array - массив n*2\n    # время, расстояние \n    ...\n    ...\n    ...\n    return (t_min,d_min) \n\n",
      "url": "/pages/python/lab11/"
    },{
      
      "title": "Относительное движение материальной точки",
      
      "content": "\n  Построить и проинтегрировать уравнения относительного движения шарика в механической системе, заданной для исследования в курсовой работе по теоретической механике.\n  Построить графики изменения координаты шарика относительно тела 1, относительной скорости шарика, силы реакции канала или направляющей, по которым движется шарик.\n\n\n\n\nВ отчет должны быть включены:\n\n  текст программы;\n  результаты моделирования (графики).\n\n\nНа всех графиках должны быть подписи осей с указанием размерностей величин с размером символов на шкалах не менее 2 мм.\n",
      "url": "/pages/wolfram/lab1_/"
    },{
      
      "title": "Лабораторная работа №2",
      
      "content": "iTop ITSM &amp; CMDB — это веб-продукт с открытым исходным кодом, предназначенный для автоматизации ИТ-подразделений предприятий и сервис провайдеров. iTop разработан на основе лучших практик ITIL/ITSM и в то же время является достаточно гибким, чтобы адаптироваться к процессам организации.\n\niTop ITSM &amp; CMDB позволяет организовать:\n\n  Управление инцидентами и запросами на обслуживание\n  Управление проблемами, изменениями и знаниями\n  Управление активами и конфигурациями\n  Управление уровнем сервиса, каталогом услуг и поставщиками\n\n\nЦентром архитектуры iTop является база данных управления конфигурацией (CMDB), которая хранит актуальную информацию об ИТ-инфраструктуре в виде конфигурационных элементов и взаимосвязей между ними:\n\n  Физические устройства\n  Программное обеспечение\n  Бизнес-процессы\n  Расположения\n  Документы\n  Контакты и многие другие\n\n\nЧем больше становится компания, тем сложнее понять ее внутреннюю структуру. На ИТ приходится значительная доля операционных расходов компании. То же относится и к ИТ-инфраструктуре. Чем больше к ней добавляется серверов, пользователей и лицензий на ПО (программное обеспечение), тем сложнее становятся процессы. В таких условиях легко упустить что-то важное из виду и допустить ошибку из-за того, что нужная информация затерялась или оказалась недоступна. Прежде всего это затраты на обслуживание инфраструктуры. CMDB консолидирует всю информацию об ИТ-активах, что помогает управлять ими рациональнее [1].\n\nЗадание\n\nЦелью лабораторной работы является знакомство с системой iTop ITSM &amp; CMDB. Используя результаты первой лабораторной работы, в системе iTop ITSM &amp; CMDB необходимо описать элементы базовой ИТ-инфраструктуру предприятия (организации, подразделения), включая информацию о расположениях (комнатах) и конфигурационных единицах (компьютеры, серверы, сетевое оборудование, …).\n\nДля выполнения лабораторной работы необходимо войти в систему iTop, используя выданные реквизиты учетной записи. С каждой учетной записью связан “Контакт” (Фамилия, Имя), привязанный к организации. Имя организации выбрано при создании учетной записи произвольно и может быть изменено на имя организации, которое использовалось при выполнении первой лабораторной работы. Для изменения имени организации необходимо перейти в раздел “Администрирование данных” - “Каталоги” - “Организации”.\n\n\n\nПосле перехода в этот раздел в необходимо найти в появившейся таблице наименование организации, привязанной к свой учетной записи. Нажать на ссылку с именем этой организации и затем выбрать на панели инструментов в левой верхней части экрана кнопку “Редактировать…”.\n\n\n\nДля того чтобы видеть конфигурационные единицы (компьютеры, ПО, расположения и т.д.) только своей организации, нажмите кнопку “Поиск в иерархии” и выберите в появившемся списке свою организацию.\n\n\n\nРасположения\n\nКонфигурационные единицы (компьютеры, серверы, оргтехника, …) располагаются в определенных помещениях. Схема расположения была разработана на первой лабораторной работе. В разделе “Управление конфигурациями” необходимо создать записи о расположениях (комнатах) организации.\n\n\n\nПри создании расположений (комнат) необходимо указать адрес и уникальное наименование каждой комнаты организации.\n\n\n\nКонтакты\n\nВ разделе “Управление конфигурациями” создать записи о контактах (сотрудниках организации) с привязкой их к расположениям предприятия: “Управление конфигурациями” - “Контакты” - “Новый контакт” (тип контакта - “Персона”).\n\nТипология\n\nВ разделе “Администрирование данных” - “Типология” создать записи о брендах, моделях, версиях и семействах операционных систем.\n\n\n\nБренд – производитель  конфигурационной единицы (сервера, компьютера, ПО). Модель – модель устройства, например “MacBook Pro 13 (M1, 2020)” Список моделей сгруппирован по брендам.\nНапример, для создания записи о конфигурационной единице – ноутбуке  “MacBook Pro 13 (M1, 2020)” предварительно необходимо создать запись о бренде Apple разделе “Администрирование данных” - “Каталоги” - “Типология”, а затем о модели “MacBook Pro 13 (M1, 2020)”. Создание записи о модели позволит в дальнейшем внести в базу запись о конкретном ноутбуке модели “MacBook Pro 13 (M1, 2020)”.\n\n\n\nПодобный образом необходимо описать операционные системы, установленные на компьютерах, создав записи о семействах используемых ОС и их конкретных версиях.\n\nВозможные значения атрибута «Семейство ОС» для серверов, виртуальных машин и ПК:\n\n  Debian\n  MacOS X\n  Ubuntu\n  Windows\n\n\nВерсии ОС упорядочены по семействам ОС. Для операционной системы семейства Windows версии могут быть:\n\n  7\n  7 SP 1\n  Server 2008\n  Server 2008 R2\n  10\n  11\n\n\nКонфигурационные единицы\n\nВ разделе “Управление конфигурациями” создать записи о следующих конфигурационных единицах:\n\n  компьютеры,\n  принтеры,\n  сетевые устройства (коммутаторы, маршрутизаторы),\n  программное обеспечение.\n\n\nПри создании записи о персональном компьютере указать его наименование, принадлежность организации, расположение, бренд, модель, семейство ОС, версию ОС, тип процессора, объем ОЗУ, серийный номер.\n\n\n\nПерсональные компьютеры необходимо связать с объектом типа контакт.\n\n\n\nПри создании записи о программном обеспечении, а также для каждой используемой операционной системы (версии ОС) создать объект “Лицензия”, который связать с ПО и ОС соответственно.\n\n\n\nПри создании сетевого устройства указать его тип (коммутатор, маршрутизатор), наименование, принадлежность организации, расположение, модель, бренд, серийный номер.\n\n\n\nСписок использованных источников\n\n\n  CMDB: что это и как может помочь бизнесу\n\n",
      "url": "/pages/it/lab2/"
    },{
      
      "title": "Движение системы материальных точек",
      
      "content": "Задание\n\n\n  Используя заготовку программы, разработать модель движения системы материальных точек с различными массами и различныеми жесткостями пружин.\n  Добавить в механическую систему сухое трение, полагая, что материальные точки движутся по шероховатой горизонтальной плоскости с заданным коэффициентом трения скольжения \\(f_d = 0.1\\) и покоя \\(f_s = 0.3\\).\n\n\nКоэффициент трения в зависимости от скорости точки \\(v\\) вычисляется по следующей формуле:\n\n\n  \n    \n      [f(v) = \\left[ f_d + (f_s-f_d) \\exp\\left(-\\frac{\n      v\n      ^2}{v_s^2}\\right) \\right] \\tanh(k \\cdot v) + k_v v]\n    \n  \n\n\nгде \\(v_s = 0.002\\), \\(k_v = 0.1\\), \\(k = 10^4\\).\n\nТребования к отчёту\n\nВ отчет должны быть включены:\n\n\n  Графики изменения расстояний между материальными точками.\n  Графики изменения координат материальных точек.\n  Графики изменения скоростей точек в направлении оси \\(x\\).\n  Графики изменения потенциальной энергии системы.\n  Графики изменения кинетической энергии системы.\n  Графики изменения полной механической энергии системы.\n\n",
      "url": "/pages/wolfram/lab2/"
    },{
      
      "title": "Лабораторная работа 2",
      "description": "Задание для лабораторной работы 2.\n",
      "content": "Задание 2.1 (для двух подгрупп)\n\nКоординаты ‘живых’ клеток колонии заданы списком пар координат \\(x\\) и \\(y\\):\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nНапишите программу, которая для заданных координат определяет занята клетка или свободна.\n\nПервый вариант программы\n\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nx = 1\ny = 3\n\nisOccuped = False\n\nfor cell in cells :\n    if x == cell[0] and y == cell[1] :\n      isOccuped = True\n      break\n\nprint(isOccuped)\n\n\nВторой вариант программы\n\ncells = [ [1, 1], [2, 1], [3, 1], [3, 2], [2, 3] ]\n\nx = 1\ny = 3\n\nisOccuped = [x, y] in cells      \n\nprint(isOccuped)\n\n\nЗадание 2.2 (для двух подгрупп)\n\nКоординаты ‘живых’ клеток колонии заданы списком пар координат \\(x\\) и \\(y\\):\ncells = [ [1,1], [2,1], [3,1], [3,2], [2,3] ]\n\nНапишите программу, которая для заданных координат клетки поля определяет количество её соседей:\nx = 1\ny = 1\n#\n# Текст программы\n#\nprint(neighbors)\n\n",
      "url": "/pages/python/lab2/"
    },{
      
      "title": "Лабораторная работа №3",
      
      "content": "Задание\nОзнакомиться с современными пятью программными средствами, которые могут использоваться для управления веб-контентом. Собрать и проанализировать информацию об особенностях таких программных средств и их возможностях.\n\nКритерии сравнения\n\n  Условия использования (лицензии): бесплатные и open-source, коммерческие (платные), собственные разработки («внутренние»).\n  Возможность переноса (отчуждения): отчуждаемые, «ПО как услуга» (Software as a Service), т.е. предоставляемые на сервере автора.\n  Функциональность: блог, личный сайт, сайт-визитка, интернет-магазин, сайт сообщества, универсальные (расширяемые).\n  По используемым технологиям: языки программирования, базы данных.\n  По возможности расширения функциональности: наличие ядра и модулей расширения, легкость внедрения собственного кода, легкость настройки внешнего вида для посетителя.\n\n\nПримеры\n\nJoomla, Drupal, WordPress, …\n\nОбзор ECM систем и СЭД\n\nЗадание\n\nОзнакомиться с современными пятью программными средствами, которые могут использоваться для управления контентом на предприятии и управления документооборотом. [https://www.itweek.ru/ecm/article/detail.php?ID=125346]\n\nКритерии сравнения\n\n\n  Архитектура (единая система, модули, отдельные продукты и т.п.)\n  Основное назначение\n  Тип лицензии\n  Требования к платформам и прочему обеспечению\n  Распространенность, доля рынка\n  Поддержка основных возможностей по управлению контентом:\n    \n      управление документами, файлами, записями, архивами (хранением данных) и поиском;\n      поддержка документооборота согласно бизнес-процессам и документо-ориентированного взаимодействия пользователей (включая средства для командной работы);\n      управление знаниями;\n      управлению веб-контентом (корпоративным веб-порталом);\n      управление базой клиентов;\n      управление каталогом товаров и услуг, запасами;\n      управление заказами, поставками и возвратами;\n      управление финансами и счетами, финансовый анализ.\n    \n  \n\n\nПримеры ECM систем и СДО\n\nAlfresco ECM, Directum, Documentum, ECM-система Дело, 1С: Документооборот, Тезис, Elma ECM, DocuWare, Docsvision ECM, Hyland, IBM, Laserfiche, LanDocs, M-Files, Microsoft SharePoint, OpenText, Seismic, THESIS ECM, XEROX Docushare, Nuxeo Content Platform, SynerDocs, DocsHouse\n\nОпределения\n\nECM\n\nСтратегии, организационные методы и инструментальные средства, используемые для сбора, ввода, администрирования, хранения, архивирования и доставки контента, относящегося к ключевым процессам организации.\n\nECM-система\n\nECM — это программное обеспечение для управления корпоративным контентом.\n\nСистемы электронного документооборота (СЭД)\nСЭД — это организационно-техническая система, обеспечивающая процесс создания, распространения электронных документов в компьютерных сетях и управления доступом к ним, а также обеспечивающая контроль над потоками документов в организации.  Процесс управления опирается на человеко-читаемые (в основном текстовые) документы, содержащие в слабоформализованной форме инструкции для сотрудников, необходимые к исполнению.\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab3/"
    },{
      
      "title": "Лабораторная работа 3",
      "description": "Задание для лабораторной работы 3.\n",
      "content": "Источник Е.А. Симановский Сборник заданий к лабораторным работам\n\nИндивидуальные задания (по номеру в ведомости)\n\nЗадание 3.1\n\nКоличество элементов массива и сами элемены вводятся в диалоговом режиме пользователем.\n\n\n  Дан массив натуральных чисел. Найти сумму элементов, кратных данному К.\n  Дан массив целых чисел, в котором есть нулевые элементы. Создать массив из номеров этих элементов.\n  Дан массив из N целых чисел. Выяснить, какое число встречается в массиве раньше – положительное или отрицательное.\n  Дан массив из N натуральных чисел. Создать массив из чётных чисел этого массива. Если таких чисел нет, то вывести сообщение об этом факте.\n  Дан массив из N чисел. Указать наименьшую длину числовой оси, содержащую все эти числа.\n  Дан массив из N действительных чисел. Заменить все его члены, большие данного Z, этим числом. Подсчитать количество замен.\n  Дан массив действительных чисел, размерность которого N. Подсчитать, сколько в нем отрицательных, положительных и нулевых элементов.\n  Дан массив действительных чисел, размерность которого N. Поменять местами наибольший и наименьший элементы массива.\n  Дан массив А из N целых чисел. Вывести на печать только те числа, для которых выполняется условие Аi ≤ i, где i – номер элемента массива.\n  Дан массив из N натуральных чисел. Указать те числа, остаток от деления которых на М равен L (0 ≤ L ≤ M-1).\n  В заданном одномерном массиве поменять местами соседние элементы, стоящие на чётных местах, с элементами, стоящими на нечётных.\n  При поступлении в вуз абитуриенты, получившие «двойку» на первом экзамене, ко второму не допускаются. В массиве A[n] записаны оценки экзаменующихся, полученные на первом экзамене. Подсчитать, сколько человек не допущено ко второму экзамену.\n  Дана массив чисел, среди которых имеется один нуль. Вывести на печать все числа включительно до нуля.\n  В одномерном массиве размещены: в первых элементах значения аргумента, а в следующих – соответствующие им значения функции. Напечатать элементы этого массива в виде двух параллельных столбцов: аргументы и значения функции.\n  Дан целочисленный массив с количеством элементов N. Напечатать те его элементы, индексы которых являются степенями двойки (1, 2, 4, 8, 16, …).\n  Дан массив из N действительных чисел. Напечатать те его элементы, которые принадлежат отрезку [c, d].\n  Дан массив целых положительных чисел. Найти произведение только тех чисел, которые больше заданного числа М. Если таких нет, то выдать сообщение об этом.\n  Массив из N элементов состоит из нулей и единиц. Поставить в начало этого массива нули, а затем единицы.\n  Дан массив из N действительных чисел, в котором есть только положительные и отрицательные элементы. Вычислить произведение отрицательных элементов P1 и произведение положительных элементов P2. Сравнить модуль P2 с модулем P1 и указать, какое из произведений по модулю больше.\n  Задан массив с количеством элементов N. Сформируйте два массива: в первый включите элементы исходного массива с чётными номерами, а во второй – с нечётными.\n  Составить программу нахождения наибольшего среди тех элементов одномерного массива А, что лежат в интервале [С, D].\n  Составить программу отыскания наименьшего среди тех элементов одномерного массива А, что лежат вне интервала [С, D].\n  Составить программу подсчёта среди элементов одномерного массива В количества чисел, больших С.\n  Составить программу отыскания наименьшего среди элементов одномерного массива А и его индекса.\n  Задан массив Y с количеством элементов N. Сформируйте массив, в котором элементы с чётными индексами будут равны соответствующим элементам исходного массива, а элементы с нечётными индексами будут равны нулю.\n  Составить программу подсчёта в одномерном массиве А суммы элементов с чётными индексами и суммы элементов, значения которых больше нуля.\n  Составить программу подсчёта в одномерном массиве С количества отрицательных и произведения положительных элементов массива.\n  Составить программу подсчёта в одномерном массиве В произведения элементов с нечётными индексами и суммы отрицательных элементов.\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с чётными индексами в массиве А и суммы элементов, значения которых больше нуля, в массиве В.\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с нечётными индексами в массиве B и произведения отрицательных элементов в массиве А.\n\n\nЗадание 3.2\n\n\n  Задан двумерный массив С из 4-х строк и 4-х столбцов (квадратная матрица). Составить программу подсчёта суммы всех отрицательных элементов и суммы элементов по главной диагонали.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу подсчёта суммы произведений элементов строк.\n  Задан двумерный массив А из 5-и строк и 2-х столбцов. Составить программу, которая формирует одномерный массив В, каждый элемент которого есть произведение элементов массива А в строке.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, элементы главной диагонали  которого равны соответствующим элементам исходного массива, а остальные элементы равны нулю.\n  Задан двумерный массив А из 2-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов исходного в столбце.\n  Задан двумерный массив Y из 5-и строк и 5-и столбцов. Составить программу подсчёта суммы всех положительных элементов и суммы элементов по главной диагонали.\n  Задан двумерный массив А из 4-х строк и 4-х столбцов. Составить программу, которая подсчитывает произведение элементов массива, лежащих вне главной диагонали.\n  Задан двумерный массив С из 6-и строк и 6-и столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу, которая вычисляет значение суммы произведений элементов строк\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов в столбце. Вычислить произведение элементов полученного массива.\n  Задан двумерный массив А из 5-и строк и 4-х столбцов. Составить программу, которая вычисляет значение произведения сумм строк.\n  Задан двумерный массив Y из 4-х строк и 4-х столбцов. Составить программу, которая вычисляет S – сумму элементов побочной диагонали и значение суммы всех элементов массива\n  Задан двумерный массив С из 6-и строк и 3-х столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие не на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С Вычислить произведение всех элементов нового массива.\n  Задан двумерный массив А из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть произведение элементов массива А в каждой строке. Затем вычислить сумму элементов полученного одномерного массива.\n  Задан двумерный массив C из 3-х строк и 5-и столбцов. Составить программу, которая вычисляет произведение всех элементов массива. Затем организовать новый массив С, в котором значения элементов, лежащих на главной диагонали, равны 1, а остальные элементы равны квадрату соответствующих элементов исходного массива С.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая вычисляет сумму всех элементов массива.\nЗатем организовать новый массив В, в котором заменить отрицательные элементы исходного массива на 1, а значения остальных элементов оставить без изменения. Подсчитать количество замен.\n  Задан двумерный массив А из 8-и строк и 3-х столбцов. Составить программу, которая подсчитывает общее число неотрицательных элементов в массиве. Затем организовать формирование нового массива В, в котором значения элементов исходного массива заменить на противоположные по знаку.\n  Задан двумерный массив В из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив С, элементы которого равны количеству положительных элементов в строке исходного массива В.\n  Задан двумерный массив D из 5-и строк и 5-и столбцов. Составить программу, которая организует одномерный массив, элементы которого равны элементам массива D , лежащим на побочной диагонали, а затем вычисляет сумму элементов полученного одномерного массива.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая подсчитывает количество положительных, отрицательных и нулевых элементов в массиве В и организует одномерный массив из полученных значений.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество положительных элементов исходного массива в столбце. Вычислить произведение элементов полученного массива.\n  Задан двумерный массив С из 2-х строк и 4-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество отрицательных элементов исходного массива в строке. Вычислить сумму элементов полученного массива.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть количество отрицательных элементов исходного массива в столбце. Вычислить сумму элементов полученного массива.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, одна строка которого содержит количество ненулевых элементов исходного массива в столбце, а вторая – количество нулевых. Организовать проверку правильности формирования массива путём вычисления суммы элементов полученного массива.\n  Задан двумерный массив D из 5-и строк и 5- столбцов. Составить программу, которая организует новый массив B путём деления всех элементов заданной матрицы на элемент, наибольший по абсолютной величине.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наибольший элемент среди элементов в строке исходного массива.\n  Задан двумерный массив X из 3-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наименьший по абсолютной величине элемент среди элементов в столбце исходного массива.\n  Задан двумерный массив А из 3-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наибольший элемент среди элементов в столбце исходного массива.\n  Задан двумерный массив X из 3-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть наименьший по абсолютной величине элемент среди элементов в строке исходного массива.\n  Задан двумерный массив A из 6-и строк и 6-и столбцов и одномерный массив Y из 6 строк. Составить программу, которая подсчитывает количество элементов, больших 1, а затем вычисляет произведение всех элементов массива.\n\n",
      "url": "/pages/python/lab3/"
    },{
      
      "title": "Аналитические преобразования",
      
      "content": "Положение материальных точек двойного маятника, показанного на рисунке 1, определяются выражениями:\n\n[\\boldsymbol{r}_1 = \\boldsymbol{A}_1 \\begin{bmatrix} 0 \\ -l_1/2 \\end{bmatrix},]\n\n[\\boldsymbol{r}_2 = \\boldsymbol{A}_1 ( \\begin{bmatrix} 0 \\ -l_1 \\end{bmatrix} + \\boldsymbol{A}_2 \\begin{bmatrix} 0 \\ -l_2/2 \\end{bmatrix})]\n\n\nРисунок 1 – Механические системы\n\nгде:\n\n[\\boldsymbol{A}_i =  \\begin{bmatrix} \\cos \\varphi_i &amp; -\\sin \\varphi_i \\ \\sin \\varphi_i &amp; \\cos \\varphi_i   \\end{bmatrix}, \\quad i=1,2.]\n\n\n  \n    Найдите и упростите выражение для кинетической энергии маятника.\n  \n  \n    Приведите выражение для кинетической энергии к виду:\n  \n\n\n[T = a_{11} \\dot{\\varphi}1^2 + 2 a{12} \\dot{\\varphi}1 \\dot{\\varphi}_2 + a{22} \\dot{\\varphi}_2]\n\n\n  \n    Постройте список обобщенных коэффициентов массы \\(a_{11}, a_{12}, a_{22}\\).\n  \n  \n    Постройте выражение для потенциальной энергии системы, которое равно нулю при \\(\\varphi_1 = 0\\), \\(\\varphi_2 = 0\\).\n  \n  \n    Упростите выражение для потенциальной энергии.\n  \n  \n    Разложите выражение для потенциальной энергии в ряд в окрестности \\(\\varphi_1 = 0\\), \\(\\varphi_2 = 0\\) до членов второго порядка и приведите её к виду:\n  \n\n\n[\\Pi = c_{11} \\varphi_1^2 + 2 c_{12} \\varphi_1 \\varphi_2 + c_{22} \\varphi_2]\n\n\n  Постройте список обобщенных коэффициентов жёсткости \\(a_{11}, a_{12}, a_{22}\\).\n\n",
      "url": "/pages/wolfram/lab3/"
    },{
      
      "title": "Лабораторная работа №4",
      
      "content": "Задание\n\nОформить сайт о культуре и традициях заданной страны в соответствии с заданным вариантом с помощью CMS (например WordPress). Оформление, текст и изображения подобрать самостоятельно. Сайт должен содержать продуманную структуру навигации сайта, содержательный контент, продуманный дизайн, организованную работу с пользователями. Сайт должен содержать не менее 10 страниц.\n\nМетодические рекомендации\n\nШаблон отчёта по лабораторной работе\n\n",
      "url": "/pages/it/lab4/"
    },{
      
      "title": "Движение системы с двумя степенями свободы",
      
      "content": "Задание\n\n\n  \n    Построить и проинтегрировать уравнения движения системы с двумя степенями свободы, заданной для исследования в курсовой работе по теоретической механике.\n  \n  \n    Построить графики изменения:\n    \n      координаты тела 2 (шарика) относительно тела 1 (\\(x\\));\n      угла поворота тела 1 (\\(\\varphi\\));\n      относительной скорости тела 2 (\\(\\dot x\\));\n      угловой скорости тела 1 (\\(\\dot \\varphi\\));\n      кинетической энергии системы;\n      потенциальной энергии системы.\n    \n  \n\n\n\n\nВ отчет должны быть включены:\n\n  текст программы;\n  результаты моделирования (графики).\n\n\nПример\n\nВывод уравнений движения системы с двумя степенями свободы\n",
      "url": "/pages/wolfram/lab4/"
    },{
      
      "title": "Лабораторная работа 4",
      "description": "Задание для лабораторной работы 4.\n",
      "content": "Дана клетка с координатами x, y. Построить список пар координат, смежных клеток. Координаты смежных клеток отличаются от координат x, y не больше чем на 1.\n\n\nx, y = 2, 3\n\n# Смещения \ndxdy = [ ( 1, 1), ( 0, 1), (-1, 1), \n         (-1, 0), (-1,-1), ( 0,-1),\n         ( 1,-1), ( 1, 0) ]\n\n# Пустой список, в который будут добалятся координаты смежных клеток\nnearest = list()\n\n# Для каждого элемента из списка смещений\nfor (dx,dy) in dxdy:\n    nearest_cell = (x+dx, y+dy)\n    nearest.append(nearest_cell)\n    \nprint(nearest)\n\n\nЗадание 4.1\n\nДля заданной колонии клеток, например\n\ncolony = [ (1, 1), (1, 2), (1, 3) ]\n\n\nи определенного при помощи предыдущей программы списка смежных клеток, получить список пар координат (кортежей) занятых клеток из числа смежных, т.е. определить список соседей клетки с координатами x и y\n\nx, y = 2, 3\n\nneighbours = list()\n\n#\n# Здесь ваш код\n#\n        \nprint(neighbours)\n\n\nКак определить количество соседей?\n\nЗадание 4.2\n\nДля заданной колонии клеток, например\n\n\ncolony = [ (1, 1), (1, 2), (1, 3) ]\n\n\nопределите список координат клеток (без повторений), составляющих ареал колонии. В ареал колонии входят все живые клетки колонии и клетки смежные живым клеткам колонии.\n\n\n# В ареал входят все клетки колонии \narea = list(colony)\n\n# и клетки смежные клеткам колонии \n\nfor cell in colony:\n    for (dx,dy) in dxdy:\n        x = cell[0]\n        y = cell[1]\n        nearest_cell = (x+dx, y+dy)\n        if nearest_cell not in area:\n            # Ваш код\n            # Ваш код\n            \nprint('Колония ', colony)\nprint('Ареал колонии ', area)\n\n\n\n",
      "url": "/pages/python/lab4/"
    },{
      
      "title": "Лабораторная работа 5",
      "description": "Задание для лабораторной работы 5.\n",
      "content": "Колония клеток заданна множеством (set) пар координат (множество кортежей), например:\n\ncolony = { (1,1), (2,1), (3,1), (3,2), (2,3) }  \n\n\n\n5.1 Напишите функцию count_neighbors(cell), которая возвращает количество соседей у клетки с координатами cell = (x, y).\n\n5.2 Напишите функцию get_colony_area(colony), которая возвращает множество (set) клеток, граничащих с колонией, включая клетки, занятые колонией.\n\n5.3 Напишите функцию next_generation(colony), которая возвращает множество (set) клеток следующего поколения, количество умерших и родившихся клеток.\n",
      "url": "/pages/python/lab5/"
    },{
      
      "title": "Анимация в Wolfram Mathematica",
      
      "content": "\n  \n    Построить анимацию движения механической системы с двумя степенями свободы, заданной для исследования в курсовой работе по теоретической механике.\n  \n  \n    Сохранить результат в файл формата avi/mp4/gif.\n  \n\n",
      "url": "/pages/wolfram/lab5/"
    },{
      
      "title": "Лабораторная работа 6",
      
      "content": "Загрузить произвольный файл с текстом на русском языке и заменить все русские буквы по правилам транслитерации, сохраняя регистр букв (верхний или нижний). Правила преобразования должны загружатсья из другого текстового файла (например ‘dictionary.txt’), каждая строка которого содержит русскую букву и её представление латиницей:\n\n\nб:b\nв:v\nг:g\n...\nж:zh\n\n\n\nПреобразованный вариант необходимо сохранить в текстовый файл и вывести на экран.\n\nПример функции, загружающей словарь\n\n\ndef load_dictionary(dictionary_file):\n    with open(dictionary_file, 'rt') as f:\n        res = dict(line.strip().split(':') for line in f)\n    return res    \n\n\n\n",
      "url": "/pages/python/lab6/"
    },{
      
      "title": "Лабораторная работа 7",
      
      "content": "Загрузить файл с текстом на русском языке и вывести на экран первые пять наиболее часто встречающихся  в тексте букв, исключая знаки препинания и пробелы, например\n\n\nа - 150\nе - 123\nо - 100\nи - 90\nу - 80\n\n\n",
      "url": "/pages/python/lab7/"
    },{
      
      "title": "Лабораторная работа 8",
      
      "content": "Объявлен класс Point – точка на плоскости\n\nclass Point:\n    def __init__(self, x, y):\n        ''' Конструктор \n        x - координата x точки\n        y - координата y точки\n        '''\n        self.x = x\n        self.y = y\n\n\nи класс Shape – фигура\n\nclass Shape:\n    def __init__(self, x, y):\n        ''' Конструктор \n        x - координата x центра окружности\n        y - координата y центра окружности\n        '''\n        self.x = x\n        self.y = y\n\n\nСоздайте класс Rectangle на основе класса Shape. Представитель класса Rectangle создаётся при помощи конструкутора с четырьмя параметрами, задающими положение центра прямоугольника его ширину и высоту.\n\nclass Rectangle(Shape):\n    def __init__(self, x, y, a, b):\n        super().__init__(x,y)\n        self.a = a\n        self.b = b\n\n\n\nДобавьте к классу Rectangle метод area, который вычисляет и возвращает площадь прямоугольника.\n\nclass Rectangle(Shape):\n    \n    def __init__(self, x, y, a, b):\n        super().__init__(x,y)\n        self.a = a\n        self.b = b\n    \n    def area(self):\n        return self.a*self.b\n\nR = Reactangel(0,0,3,2)\nprint(R.area())\n\n&gt; 6\n\n\nДобавьте к классу Rectangle метод perimeter, который вычисляет и возвращает периметр прямоугольника.\n\nR = Reactangel(0,0,3,2)\nprint(R.perimeter())\n\n&gt; 10\n\n\nСоздайте класс Circle на основе класса Shape. Параметры конструктора для создания экземляра класса Circle – положение центра окружности и её радиус.\n\nC = Circle(0,0,4)\n\n\nДобавьте к классу Circle метод area, который вычисляет и возвращает площадь, ограниченную окружностью.\n\nC = Circle(0,0,4)\nprint(C.area)\n\n\nДобавьте к классу Circle метод perimeter, который вычисляет и возвращает длину окружности.\n\nC = Circle(0,0,4)\nprint(C.perimeter)\n\n\nСоздайте класс Ellipse на основе класса Shape. Параметры конструктора для создания экземляра класса Ellipse – положение центра, большая и малая полуось.\n\nE = Ellipse(0,0,4,2)\n\n\nДобавьте к классу Ellipse метод area, который вычисляет и возвращает площадь, ограниченную эллипсом.\n\nE = Ellipse(0,0,4,2)\nprint(E.area())\n\n\nСоздайте класс отрезок – Line. Параметры конструктора для создания экземляра класса Line – две точки – объекты типа Point.\n\nL = Line( Point(0,0), Point(1,1) )\n\n\nДобавьте к классу Line метод length, который вычисляет и возвращает длину отрезка.\n\nL = Line( Point(0,0), Point(1,1) )\nprint(L.length())\n\n\nНапишите функцию intersect с двумя аргументами типа Line. Функция должна возвращать пустой кортеж, если отрезки не пересекаются, или кортеж с одним элементом типа Point – точкой пересечения отрезков.\n\nL1 = Line( Point(0, 0), Point(5,1) )\nL2 = Line( Point(0,-3), Point(5,6) )\n\nprint( intesect(L1, L2) )\n\n\nВ классе Rectangle определите get и set методы для всех свойств:\n\n  get_x, set_x\n  get_y, set_y\n  get_a, set_dx,\n  get_b, set_b.\n\n\nR = Rectangle(0,0,1,3)\nR.set_a(4)\nprint( R.get_a() )\n\n\nОпределите метод get_area, возвращающий площадь прямоугольника.\n\nR = Rectangle(0,0,1,3)\nprint( R.get_area() )\n\n\nОпределите метод get_vertices, который возвращает список пар координат вершин прямоугольника\n\n    ((x1, y1), (x2, y2), (x3,y3), (x4, y4))\n\n\nПерепишите класс Rectangle, защитив свойства (x, y, a, b) прямоугольника от прямого изменения.\n\nR = Rectangle(0,0,1,3)\nR.a = 3\n\n\nПерепишите класс Rectangle, используя синтаксис property для чтения и изменения свойств.\n\nR = Rectangle(0,0,1,3)\nR.a = 2\nprint(R.area)\n\n\nПерепишите класс Rectangle, используя синтаксис @property для чтения и изменения свойств, включая площадь прямоугольника.\n\nR = Rectangle(0,0,1,3)\nR.a = 2\nprint(R.area)\n\n",
      "url": "/pages/python/lab8/"
    },{
      
      "title": "Лабораторная работа 9",
      
      "content": "Задание 1\n\nНапишие функцию, выполняющую вычисление следа квадратной матрицы. След матрицы – это сумма её диагональных элементов.\n\n\nimport numpy as np\n\ndef trace(A):\n    ...\n    ...\n    ...\n    return tr\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = trace(M1)\n\nprint(result)\n\n\n\nЗадание 2\n\nНапишие функцию, выполняющую поворот квадратной матрицы против часовой стрелки на 90 градусов.\n\n\nimport numpy as np\n\ndef rotate90ccw(A):\n    ...\n    ...\n    ...\n    return res\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = rotate90ccw(M1)\n\nprint(result)\n\n\n\nЗадание 3\n\nНапишите функцию, вычисляющую произведение матрицы на вектор\n\n\nimport numpy as np\n\ndef MatrixVec(M, v):\n    ...\n    ...\n    ...\n    return res\n\n\nM = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0]])\na = np.array([1,2,3,4.0])\n\nresult = MatrixVec(M, a)\n\nprint(result)\n\n\n\nПроверьте результат при помощи функции dot библиотеки numpy.\n\nЗадание 4\n\nНапишите функцию, вычисляющую произведение двух матриц\n\n\nimport numpy as np\n\ndef MatrixMatrix(A, B):\n    ...\n    ...\n    ...\n    return res\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0]])\nM2 = np.array([[1,2],[1,2],[1,2],[1,2]])\n\nresult = MatrixMatrix(M1, M2)\n\nprint(result)\n\n\n\nПроверьте результат при помощи функции dot библиотеки numpy.\n\nЗадание 5\n\nПерепешите код функции в предыдущем задании, используя синтаксис A[:,0], A[:,1], для исключения одного цикла из кода функции, представив каждый столбец матрицы результата как линейную комбинацию столбцов матрицы A, например\n\n[\\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{bmatrix} \\begin{bmatrix} 5 &amp; 6 \\ 7 &amp; 8 \\end{bmatrix} = \\left( 5 \\begin{bmatrix} 1 \\ 3 \\end{bmatrix} + 7 \\begin{bmatrix} 2 \\ 4 \\end{bmatrix} \\quad 6 \\begin{bmatrix} 1 \\ 3 \\end{bmatrix} + 8 \\begin{bmatrix} 2 \\ 4 \\end{bmatrix} \\right)]\n\nЗадание 6\n\nНапишие функцию, выполняющую транспонирование квадратной матрицы без создания новой матрицы\n\n\nimport numpy as np\n\ndef transpose(A):\n    ...\n    ...\n    ...\n    return A\n\n\nM1 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12.0],[1,2,3,4]])\n\nresult = transpose(M1)\n\nprint(result)\n\n\n\n",
      "url": "/pages/python/lab9/"
    },{
      
      "title": "Лабораторная работа №1",
      "description": "Задания для лабораторной работы №1 первого семестра курса “Технологии и языки программирования”\n",
      "content": "Дан список:\np = [0.5, 0.3, 1.5, 0.1, 3.2, 0.9]\n\n\n\n  Вычислить значение функции \\(y=f(x)\\) для значения аргумента \\(x\\), заданного пользователем.\n  Изобразить блок-схему программы.\n\n\nВарианты заданий\n\nНапсиать программу, которая вычисляет\n\n\n  \n\\[y = 1 + \\sum_{i=0}^{4} (-1)^i x^{2*n+1}/(2)\\]\n  \n  сумму квадратов косинусов элементов списка\n  сумму квадратов косинусов удвоенных значений элементов списка\n  сумму синусов элементов списка\n\n\nПример\n\nНайти значение функции\n\n[y = 1 + \\sum_{i=1}^{4} \\frac{x^{i}}{2^i}]\n\nimport math\n\nx = input('Введите значение аргумент функции: x = ')\n\ny = 1\nfor i in range(1,5):  \n    y = y + x**i/(2**i)\n\nprint('Значение функции y = ',y)\n\n\nМетодические указания\n\nДля использования в программе математических функций необходимо подключить модуль math. Пример использования функции из модуля math:\nimport math\n\nx = 0.5\n\ny1 = math.sin(x)\n\n\nДругие функции модуля math\n\n\n  math.exp(X)\n  math.log(X)\n\n\nТригонометрические (угол – аргумент или результат функции задаётся в радианах):\n\n\n  math.cos(X)\n  math.sin(X)\n  math.tan(X)\n  math.acos(X)\n  math.asin(X)\n  math.atan(X)\n\n\nКонстанты\n\n\n  math.pi\n  math.e\n\n",
      "url": "/pages/python/lab_01/"
    },{
      
      "title": "Интегрирование уравнений движения механизма с двумя степенями свободы",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Задание\n\n\n  Разработать программу для численного интегрирования уравнений движения системы с двумя степенями свободы для механизма из задания для курсовой работы по теоретической механики (2 курс).\n  Построить графики изменения обобщенных координат и скоростей (четыре графика на четырёх отдельных рисунках).\n  Построить одном рисунке графики изменения потенциальной, кинетической и полной энергии системы. Убедитесь, что полная энергия системы остается постоянной.\n\n\nПример\n\nСхема механизма\n\n\n\nВывод уравнений\n\nВывод уравнений в Wolfram Mathematica\n\nПервое уравнение:\n\n[\\ddot \\varphi \\left(m_2 \\left(d^2-\\left(l_0+x\\right) \\left(2 d-l_0-x\\right)+4 h^2\\right)+J_1\\right)+2 m_2 \\dot \\varphi \\dot x \\left(-d+l_0+x\\right)+2 h\n   m_2 \\ddot x = - g m_2 \\left(\\cos \\varphi \\left(-d+l_0+x\\right)+2 h \\sin \\varphi \\right)-g m_1 y_{c1} \\sin \\varphi]\n\nВторое уравнение:\n\n[m_2 {\\dot \\varphi}^2 \\left(d-l_0-x\\right)+2 h m_2 \\ddot \\varphi +m_2 \\ddot x = -c x-g m_2 \\sin \\varphi]\n\nгде \\(l_0\\) – свободная длина пружины, \\(c\\) – жёсткость пружины, \\(m_1\\) – масса пластины,  \\(J_1\\) – момент инерции пластины относительно оси О, \\(m_2\\) масса груза на пружине, \\(d = AK/2\\), \\(y_{c1} = OC_1\\).\n\nПолученные уравнения движения можно записать в матричном виде:\n\n[\\begin{bmatrix}\nm_{11} &amp; m_{12} \nm_{21} &amp; m_{22} \n\\end{bmatrix} \n\\begin{bmatrix}\n\\ddot \\varphi \n\\ddot x \n\\end{bmatrix} =\n\\begin{bmatrix}\nb_1 \nb_2 \n\\end{bmatrix}]\n\nЭлементы матрицы масс:\n\n[\\begin{align}\n&amp; m_{11} = \\left(m_2 \\left(d^2-\\left(l_0+x\\right) \\left(2 d-l_0-x\\right)+4 h^2\\right)+J_1\\right) \n&amp; m_{12} = 2 h m_2 \n&amp; m_{21} = 2 h m_2 \n&amp; m_{22} = m_2 \n\\end{align}]\n\nСлагаемые, не зависящие от ускорений (правые части):\n\n[\\begin{align}\n&amp; b_1 = - g m_2 \\left(\\cos \\varphi \\left(-d+l_0+x\\right)+2 h \\sin \\varphi \\right)-g m_1 y_{c1} \\sin \\varphi - 2 m_2 \\dot \\varphi \\dot x \\left(-d+l_0+x\\right) \n&amp; b_2 = - c x-g m_2 \\sin \\varphi - m_2 \\left(\\dot \\varphi \\right)^2 \\left(d-l_0-x\\right)\n\\end{align}]\n\nMATLAB\n\nФайл-функция правых частей dqdt.m\n\nfunction dq  = dqdt(t, q, p)\n    % Обобщенные координаты и скорости\n    phi  = q(1);    x    = q(2);\n    dphi = q(3);    dx   = q(4);\n\n    % Элементы первой строки матрицы масс\n    m11 = p.m2*(p.d^2-(p.L0+x)*(2*p.d-p.L0-x)+4*p.h^2)+p.J1;\n    m12 = 2*p.h*p.m2;\n\n    % Первая строка правой части\n    b1  = -p.g*p.m2*(cos(phi)*(-p.d+p.L0+x)+2*p.h*sin(phi))-...\n          p.g*p.m1*p.yc1*sin(phi) - 2*p.m2*dphi*dx*(-p.d+p.L0+x);\n\n    % Элементы второй строки матрицы масс\n    m21 = 2*p.h*p.m2;\n    m22 = p.m2;\n    \n    % Вторая строка правой части\n    b2  = -p.c*x - p.g*p.m2*sin(phi) - p.m2*(p.d-p.L0-x)*dphi^2;\n\n    % Разрешаем систему относительно старших производных, решая \n    % систему линейных уравнений \n\n    % Матрица коэффициентов (симметричная)\n    A   = [m11 m12; m21 m22];\n\n    % Матрица правых частей\n    B   = [b1;b2];\n\n    % Решение системы линейных уравнений\n    d2q = A\\B;\n    \n    %  Обобщенные скорости и ускорения\n    dq  = [dphi;dx;d2q];\nend\n\n\nФайл-скрипт для запуска процесса интегрирования main.m\n\nclc;\n\np.m1  = 2;\np.m2  = 0.3;\np.L0  = 0.8;\np.c   = 5;\np.g   = 9.807;\np.R   = 1;\np.h   = p.R/2;\np.d   = sqrt(p.R^2 - p.h^2);\np.J1  = 1.258;\np.yc1 = 0.587;\n\nphi0  = 0.3;\ndphi0 = 1;\nx0    = 0;\ndx0   = 1;\n\n[t, q] = ode113(@(t,q) dqdt(t,q,p), [0; 5], [phi0;x0;dphi0;dx0]);\n\nfigure;\nplot(t,q(:,1),'LineWidth',2);\ngrid on;\nxlabel('t, c'); ylabel('\\phi, радиан');\n\nfigure;\nplot(t,q(:,2),'LineWidth',2);\ngrid on;\nxlabel('t, c'); ylabel('x, м');\n\n\n\n",
      "url": "/pages/matlab/lab_2dof/"
    },{
      
      "title": "Лабораторная работа №2. Создание таблиц",
      
      "content": "Задание\n\nИспользуя результаты лабораторной работы №1 (построение ER-диаграммы предметной области) разработайте базу данных для СУБД MySQL/MariaDB.\n\nМетодические рекомендации\n\n\n  Шаблон отчета по лабораторной работе с примером выполнения\n  Реквизиты для подключения к серверу баз данных приведены в СДО Moodle.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n\n",
      "url": "/pages/databases/lab_ddl/"
    },{
      
      "title": "Лабораторная работа №1. Построение ER-диаграмы",
      
      "content": "Задание\n\nПостройте диаграмму сущность-связь, предлагаемой предметной области, используя нотацию Чена и нотацию Мартина. В отчёте необходимо описать предлагаемые сущности предметной области и их атрибуты с указанием ключевых атрибутов. Приведенное в задание описание предметной области является приблизительным. Допускается уточнять список предлагаемых сущностей и атрибутов.\n\nМетодические рекомендации\n\n\n  Вариант задания выбирается по номеру в ведомости.\n  Шаблон отчета по лабораторной работе с примером построения ER-диаграммы в формате DOCX. В формате PDF\n  Для подготовки диаграмм можно использовать любой графичекий редактор. Рекомендуется использовать on-line приложение (сервис) draw.io, в котором есть библиотеки фигур для создания ER-диаграмм.\n\n\nДополнительная информация\n\n\n  Материалы лекции 2\n  ER-модель\n  Учимся проектированию Entity Relationship — диаграмм\n  Элементы модели “сущность-связь”\n\n\nВарианты заданий\n\n1. Библиотека\n\nИнформационная система библиотеки, состоящей из двух филиалов, предназначена для учета книг, передаваемых читателям. Каждый филиал библиотеки имеет адрес (улица, дом) и наименование (минимальный набор атрибутов). При записи в библиотеку читатель предоставляет следующую информацию: ФИО, год рождения и адрес. Экземпляры одной и той же книги могут хранится в любом филиале или в обоих филиалах. Минимальный набор атрибутов книги:\n\n  наименование;\n  наименование и адрес издательства;\n  тип обложки (мягкая, твердая, суперобложка);\n  год издания;\n  жанр / тип;\n  количество страниц.\n\n\nПростые запросы:\n\n  Список книг в библиотеке (наименование, жанр, год издания)\n  Список филиалов\n  Список читателей\n\n\nСложные запросы:\n\n  Читатели, у которых есть книги на руках\n  Книги у конкретного читателя\n\n\n2. Аптека\n\n\n  Лекарство\n    \n      Наименование\n      Производитель\n      Поставщик\n      Тип\n      Цена (может изменяться)\n      Возможна ли продажа без рецепта\n    \n  \n  Покупатель\n    \n      ФИО\n      Телефон\n    \n  \n  Поставщик\n    \n      Наименование\n      ИНН\n      Адрес\n    \n  \n\n\nИнформационная система предназначена для учета движения товаров от поставщиков в несколько филиалов аптечной сети, продажи товаров покупателям.\n\n3. Больница\n\nИнформационная система больницы (стационара) содержит информацию о врачах больницы и о пациентах. Запись о каждом враче содержит: ФИО, адрес, дату рождения, паспортные данные, специальность, стаж.\n\nИнформация о пациенте \n    - ФИО\n    - Дата рождения\n    - Полис\n    - Дата поступления\n    - Дата выписки \n    - Диагноз\n    - Лечащий врач \n    - Отделение\n    - Палата\n\n4. Предприятие\n\nМалое предприятие разрабатывает информационную систему, частью которой является информационная система учета персонала. В информационной системе хранится следующая информация о сотруднике:\n\n  ФИО\n  Дата рождения\n  Образование\n  Образовательное учреждение, год окончания, специальность\n  Стаж работы\n\n\nА также информация о его назначениях, включая информацию о должности, окладе, номере и дате приказа, по которому он переводится на другую должность, номер отдела. В информационной системе учитывается отпуски сотрудников и больничные листы,  с указанием периодов временной нетрудоспособности сотрудников.\n\n5. Курьерская доставка\n\nОрганизация осуществляет курьерскую доставку товаров. Филиалы организации – пункты приема и выдачи отправлений –  расположены в нескольких городах. Для отправки товара может самостоятельно прийти в филиал организации и отправить товар оплатив стоимость доставки ил вызвать курьера, который заберет посылку после оплаты услуг курьера и услуги доставки. Стоимость услуг курьера фиксирована. Стоимость доставки различна для каждой пары городов. Товар может быть доставлен до пункта выдачи или по адресу получается. Получатель и отправитель могут иметь несколько адресов приема товара для доставки и его получения.\n\n6. Повышение квалификации\n\nДля сотрудников университета организованы курсы по повышению квалификации. Курс ведёт также сотрудник университета. Курс характеризуется датой начала, датой окончания, наименованием. Каждый сотрудник университета может посещать несколько курсов. По окончании курса выдается свидетельство.\n\n7. Научная конференция\n\nВ университете организуется научная конференция, по результатам проведения которой публикуется сборник статей. Конференция имеет наименование и дату начала и дату окончания. Каждый участник конференции отправляет в адрес конференции статью, которая характеризуется наименованием, списком авторов и количеством листов, а также презентацию наименование которой  и список авторов совпадает с наименованием статьи. Конференция разделена на секции. Заседания секций происходит в разных аудиториях с 9:00 до 17:00 с перерывом с 12:00 до 13:00. На представление доклада выделяется 30 минут.\n\n8. Прокат велосипедов\n\nКомпания по прокату велосипедов имеет филиалы в нескольких городах. Каждый филиал имеет парк и нескольких сотен велосипедов разных трех марок. Для аренды велосипеда клиенты используют мобильное приложение, в котором указывается имя клиента и привязанная к приложению банковская карта или электронный кошелек. Для каждого типа велосипеда существует собственная стоимость одного часа аренды, котора также зависит от города, где находится филиал. В информационной системе учитывается продолжительность аренды, стоимость услуги (после возвращения велосипеда).\n\n9. Футбольный турнир (РФПЛ)\n\nИнформационная система поддержки проведения футбольного турнира. Учёт команд, игроков, тренеров, матчей и их результатов (голы, авторы голов), стадионов, количества зрителей каждой игры.\n\n10. Пиццерия\n\nСеть пиццерий доставляет пиццы клиентам, которые заказывают их по телефону или через интернет. Имеется ограниченный набор типов пицц. Каждый тип пиццы имеет свой набор продуктов для изготовления и количество. Заказ доставляется курьером по адресу, указанному клиентом.\n\n11. Кулинарная книга\n\n\n  Рецепты\n    \n      наименование\n      описание\n      источник\n      тип\n      время приготовления\n    \n  \n  Компоненты рецепта\n    \n      продукт\n      количество\n    \n  \n  Справочник продуктов\n    \n      наименование\n      цена\n      единица измерения\n      калорийность\n    \n  \n\n\n12. Поликлиника\n\nИнформационная система сети поликлиник содержит информацию о врачах и о пациентах. Запись о каждом враче содержит: ФИО, адрес, дату рождения, паспортные данные, специальность, стаж. Информация о пациенте (посетителе): ФИО, дата рождения, номер полиса. Информационная система должна вести учет посещений (дата, врач, посетитель, диагноз).\n\n13. Сессия\n\nСтуденты, экзаменаторы (преподаватели), зачетные книжки, экзамены, зачеты.\n\n14. Расписание занятий\n\n\n  Расписание\n    \n      неделя\n      день\n      пара\n      группа\n      преподаватель\n      вид занятий\n      аудитория\n    \n  \n  Преподаватель\n    \n      кафедра\n      должность\n      ученая степень\n    \n  \n  Пара\n    \n      номер\n      время начала\n      время окончания\n    \n  \n  Аудитория\n    \n      корпус\n      номер\n    \n  \n  Группа\n    \n      номер\n      количество студентов\n    \n  \n\n\n15. Социальная сеть\n\nИзобразите диаграмму сущность-связь для социальной сети ВКонтакте.\n\n16. Интернет-магазин мебели\n\nИнтернет-магазин мебели позволяет покупателю выбрать на сайте товар оплатить его, заказать при необходимости доставку товара, оплатить его на сайте (способ оплаты) или после доставки, заказать сборку товара.\n\n17. Онлайн кинотеатр\n\nВ онлайн-кинотеатре можно смотреть фильмы по подписке или покупать отдельные фильмы для просмотра в любое время или брать фильмы на прокат, для просмотра в течение одного месяца после оплаты. Подписка может быть индивидуальной или семейной на несколько пользователей (до пяти), связанных с “администратором” семьи. Каждый пользователь имеет жанровые предпочтения. Информационная система должна вести учет пользователей, их подписок, покупок, просмотренных фильмов, жанровых предпочтений.\n\n18. Бронирование авиабилетов\n\nНа сайте авиакомпании пассажир может заказать билеты для себя и еще нескольких человек для перелета из пункта А в пункт Б (может быть несколько перелетов) на определенную дату. При покупке билета для каждого пассажира указывается вес багажа и тип меню для обеда на борту самолета.\n\n19. Музыкальные альбомы\n\nКоллекция состоит из музыкальных альбомов, которые могут быть записаны на Audio CD, или на жестком диске. Каждый альбом создан одним автором (исполнителем). У каждого исполнителя может быть несколько альбомов. Каждый альбом содержит несколько треков (композиций), которые имеют определенную длину и порядок в альбоме. Каждый трек  может быть только в одном альбоме.\n\n20. Бронирование авиабилетов\n\nБаза данных рейсов хранит информацию о парке авиакомпании, рейсах и бронировании мест. У авиакомпании есть один или несколько самолетов. Самолет имеет номер модели, уникальный регистрационный номер и возможность принять одного или нескольких пассажиров. У рейса самолета есть уникальный номер рейса, аэропорт вылета, аэропорт назначения, дата и время вылета, а также дата и время прибытия. Каждый полет выполняется одним самолетом. Пассажир назвал имена, фамилию и уникальный адрес электронной почты. Пассажир может забронировать место на рейс.\n\n21. Курсы и студенты\n\nВ базе данных университета хранится информация о студентах, курсах, семестре, в котором студент проходил определенный курс (а также о его оценках, если он его закончил), а также о том, в какую программу обучения записан каждый студент.\n\nУниверситет предлагает одну или несколько программ. Программа состоит из одного или нескольких курсов. Студент должен зарегистрироваться в программе. Студент проходит курсы, которые являются частью ее программы. У программы есть название, идентификатор программы, общее количество баллов, необходимых для получения диплома, и год ее начала. У курса есть название, идентификатор курса, значение кредитной точки и год, когда он начался. Студенты имеют одно или несколько имен, фамилию, идентификатор студента, дату рождения и год, когда они впервые поступили. Когда студент проходит курс, записывается год и семестр, в котором он пытался его пройти. Когда он заканчивает курс, записывается оценка (например, A или B) и оценка (например, 60 процентов). Каждый курс в программе состоит из года (например, год 1) и семестра (например, 1 семестр).\n\n22. Компания и сотрудники\n\nВ компании есть несколько отделов. Каждый отдел имеет уникальную идентификацию, название, местонахождение офиса и конкретного сотрудника, который управляет отделом. Отдел контролирует ряд проектов, каждый из которых имеет уникальное имя, уникальный номер и бюджет. У каждого сотрудника есть имя, идентификационный номер, адрес, зарплата и дата рождения. Сотрудник назначен в один отдел, но может участвовать в нескольких проектах. необходимо вести учёт  дату начала работы сотрудника в каждом проекте, непосредственного руководителя каждого сотрудника. Необходимо хранить информацию об иждивенцах каждого сотрудника. У каждого иждивенца есть имя, дата рождения и отношения с работником.\n\n23. Галереи\n\nГалереи хранят информацию о художниках, их именах (которые уникальны), местах рождения, возрасте и стиле искусства. У каждого произведения искусства есть автор, год изготовления, название, вид произведения (например, живопись, литография, скульптура, фотография) и цена. Произведения искусства также подразделяются на группы различных видов, например, портреты, натюрморты, произведения Пикассо или произведения 19-го века; произведение может принадлежать более чем одной группе. Каждая группа идентифицируется именем, которое описывает группу. Наконец, галереи хранят информацию о клиентах. Для каждого покупателя галереи сохраняют уникальное имя, адрес, общую сумму денег, потраченных в галерее, а также художников и групп искусства, которые нравятся покупателю.\n\nby Jennifer Polack, Professor of Computer Science at University of Mary Washington\n\n24. Сеть отелей\n\nСеть отелей под названием B&amp;B состоит из множества филиалов отелей по всей стране. В каждом отеле есть различные номера. Каждый номер имеет свою цену в зависимости от типа. B&amp;B хранит информацию о своих гостях, чтобы можно было  отправлять им письма и электронные письма о специальных предложениях. Должна храниться информация о бронировании. Эта информация включает в себя дату, с которой гость забронировал номер и дату отъезда. Необходимо знать количество дней.\n\n25. Прокат автомобилей\n\nКомпания предлагает ряд моделей автомобилей на прокат. Клиент может забронировать любую модель или конкретную модель автомобиля. Бронь относится к к модели, но не к конкретному автомобилю этой модели. Когда автомобиль этой модели станет доступным, он будет проведен для клиента. Когда клиент берет автомобиль, то эта информация связывается с конкретным автомобилем, а не на моделью поскольку у компании может быть несколько автомобилей одной модели. Необходимо вести учет даны начала использования автомобиля и продолжительности.\n\n26. КХЛ\n\nВ континентальной хоккейной лиге много команд. У каждой команды есть название, город, тренер, капитан и набор игроков, каждый игрок принадлежит только одной команде. У каждого игрока есть имя, позиция (например, левое крыло или вратарь), уровень квалификации и набор записей травм. Капитан команды также игрок. Игра проводится между двумя командами (хозяева и гости) и имеет дату (например, 11 мая 1999 г.) и счет (например, от 4:2).\n\n27. Книжный онлайн-магазин\n\nВ онлайн-магазине продаются книги (включая электронные). Основные атрибуты книги: Автор, Наименование, Издатель, Количество страниц, Тип обложки, Масса (для оценки массы заказа). Покупатель выбирает книги, формирует и оплачивает заказ. Книги доставляются по указанному адресу. В одном заказе могут быть как “бумажные” книги, так и электронные. Электронные книги отправляются по электронной почте. Информационная система должна учитывать время формирования заказа, время его оплаты и время доставки.\n\n28. Мастерская\n\nМастерская производит ремонт бытовой техники разных типов (придумайте не менее трех). Клиент привозит неисправную технику и оформляет факт передачи техники с указанием ее необходимых свойств. После приема техники мастер (определенный сотрудник мастерской) в течение трех дней оценивает сложность ремонта и формирует список заменяемых частей и список действий (например: разборка и сборка, работа по замене экрана), которые определяют стоимость ремонта. Клиента уведомляют о стоимости ремонта и получают согласие на дальнейшие действия после первичного анализа (диагностики). Ремонт может быть выполнен “по гарантии”, в этом случае стоимость ремонта клиентом не оплачивается.\n\n29. Мастерская\n\nИнформационная система ЖЭКа обслуживает группу домов на нескольких улицах. Заявка поступает от квартиры. Заявку принимает диспетчер, он задает номер и дату поступления заявки, определяет тип заявки и срок ее выполнения. Заявку выполняет бригада специалистов. Каждый специалист может работать только в одной бригаде, у каждой бригады есть бригадир.\n\n30. Парки\n\nИнформационная система “Парки города” хранит информацию о парках. Каждый парк имеет собственное имя. В парке высажены определённые насаждения. База данных должна хранить информацию о количестве насаждений каждого типа. В парке могут находиться фонтаны и павильоны.\n\nАтрибуты парка:\n\n  наименование,\n  площадь,\n  место нахождения (адрес).\n\n\nНасаждения парка\n\n  тип культуры,\n  наименование,\n  средняя продолжительность жизни.\n\n\nФонтан\n\n  шифр,\n  дата постройки,\n  расход воды (максимальный и нормальный),\n  площадь.\n\n\nПавильон\n\n  наименование,\n  тип (кафе, продуктовый, развлекательный, прокат вещей),\n  занимаемая площадь.\n\n\n",
      "url": "/pages/databases/lab_er/"
    },{
      
      "title": "Игра \"Жизнь\"",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Задание\n\nРазработайте функцию next_generation, которая принимает в качестве аргумента массив \\(n \\times 2\\) координат \\(n\\) клеток колонии и возвращает массив колонии следующего поколения.\n\nНиже приведен пример файл-скрипта, отображающего развитие колонии для первого варианта задания.\n\n% Начальное состояние колонии\ncells = [ 1, 1; \n          1, 2;\n          1, 3;\n          2, 1;\n          3, 2;          \n          10 10;\n          10 11;\n          10 12];\n\n% Координаты вершин квадрата, изображающего клетку \n% (относительно центра клетки)\nvert  = [-0.5,-0.5, 0.5,-0.5, 0.5,+0.5, -0.5,+0.5];\n\n% границы области\nxlim([-20,20]);\nylim([-20,20]);\n\n% количество поколений\nn_gen = 50;\n\n% Для каждого поколения\nfor i=1:n_gen    \n    % очистить изображение\n    cla;\n    % получить список клеток для следующего поколения\n    cells = next_generation(cells);\n    % сформировать список полигонов для функции patch \n    cells_vertices = repmat(cells,1,4)+repmat(vert,size(cells,1),1);\n    x = (cells_vertices(:,1:2:end))';\n    y = (cells_vertices(:,2:2:end))';    \n    % нарисовать клетки\n    patch(x,y,'r');\n    % включить сетку\n    grid on;\n    % включить рамку\n    box on;\n    % сохранить кадр\n    getframe;\n    % подождать 0.2 с\n    pause(0.2);\nend\n\n\nПравила игры “Жизнь”\n\nДано бесконечное поле, разделенное на ячейки. Ячейка может быть свободной или занятой  клеткой. Клетки на поле образуют колонию. У каждой ячейки есть восемь ближайших смежных (граничащих) ячеек, которые могут быть заняты другими клетками.\n\nКолония изменяется по следующим правилам:\n\n\n  Если у клетки заняты соседями две или три смежных ячейки, то клетка “выживает” и  переходит в следующее поколение, в противном случае она “умирает” от перенаселения или недостатка соседей.\n  Если рядом с пустой ячейкой находятся ровно три клетки, то на месте этой ячейки  появляется новая клетка.\n  В процессе смены поколения “умирающие” клетки считаются принадлежащими колонии до определения всех новых клеток и клеток, переходящих в следующее поколение. Также и рождающиеся считаются принадлежащими следующему поколению и не оказывают влияние на количество соседей клеток текущего поколения.\n\n\n\n\n",
      "url": "/pages/matlab/lab_gamelife/"
    },{
      
      "title": "Игра \"Жизнь\" в ограниченном пространстве",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Задание\n\nРазработайте функцию next_generation, которая принимает в качестве аргумента массив \\(n \\times m\\), отображающий состояние ограниченного поля. Элемента массива содержит 1, если ячейка поля занята клеткой, 0 - если не занята. Функция должна возвращать массив \\(n \\times m\\) состояния поля для следующего поколения.\n\n",
      "url": "/pages/matlab/lab_gamelife_torus/"
    },{
      
      "title": "Относительное орбитальное движение",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Разработать программу для исследования движения наноспутника, отделившегося от орбитальной станции, движущейся по круговой орбите высотой \\(h=350\\) км.\n\nДвижение наноспутника относительно станции определяется в орбитальной системе координат, движущейся вместе с орбитальной станцией по круговой орбите. Начало координат расположено в центре масс станции. Ось \\(x_o\\) орбитальной подвижной системы координат направлена от Земли вдоль радиус вектора станции. Ось \\(y_o\\) лежит в плоскости орбиты и направлена в сторону орбитальной скорости станции. Ось \\(z_o\\) дополняет систему координат до правой.\n\n\n\nЗадание 1. Создать функцию определения положения и скорости спутника относительно орбитальной подвижной системы координат, связанной со станцией\n\n\nfunction x = get_orbital_state(x0, n, t)    \n%x = get_orbital_state(x0, n, t)\n% Аргументы:\n% x0 - 6x1 [x0;y0;z0;vx0;vy0;vz0] - начальное (t=0) положение и скорость наноспутника\n% n  - 1x1 угловая скорость орбитального движения станции рад/с\n% t  - 1x1 время\n% Результат\n% Вектор состояния 6x1 наноспутника для момента времени t\n\n    c   = cos(n*t);\n    s   = sin(n*t);\n   \n    A  = [4-3*c 0 0 s/n 2/n-2*c/n 0;\n          -6*n*t+6*s 1 0 -2/n+2*c/n  4*s/n-3*t 0;\n          0 0 c 0 0 s/n;\n          3*n*s 0 0 c 2*s 0; \n          -6*n+6*n*c 0 0 -2*s -3+4*c 0;\n          0 0 -n*s 0 0 c];\n    \n    x  = A*x0;\n    \nend\n\n\n\nЗадание 2. Спутник №1 отделяется от станции со скоростью 0,5 м/с, при этом угол между вектором скорости отделения и осью \\(y_o\\) орбитальной системы координат равен 80 градусам (проекция скорости на ось \\(x_o\\) положительная). Построить таблицу (матрицу)  координат спутника №1 в  орбитальной системе координат для 100 значений моментов времени, равномерно распределенных в интервале двух орбитальных периодов (100 точек от 0 до 2T, включая границы).\n\nt = linspace(....)\nsat1 = cell2mat( arrayfun(...) )\n\n\nИспользуемые функции: arrayfun, cell2mat, linspace\n\nЗадание 3. Сохранить результат (таблицу координат) в текстовый файл sat1.txt следующего вида:\n\nt, c    xo, км   yo, км   zo, км\n  00    000.000  000.000  000.000 \n  10    000.000  000.000  000.000\n...\n\n\nf = fopen(...)\nfprintf(...)\nfclose(f)\n\n\nИспользуемые функции: fopen, fprintf, fclose.\n\nЗадание 4. Спутник №2 отделяется от станции со скоростью 0,5 м/с в отрицательном направлении оси \\(y_o\\). Построить таблицу (матрицу)  координат спутника №2 в  орбитальной системе координат для 100 значений моментов времени, равномерно распределенных в интервале двух орбитальных периодов (100 точек от 0 до 2T, включая границы).\n\nsat2 = cell2mat( arrayfun(...) )\n\n\nЗадание 5. Построить таблицу (матрицу) 100x4 c расстояниями от станции до спутника  №1 (d1), от станции до спутника №2 (d2) и от спутника №1 до спутника  №2 (d12) для 100 значений моментов времени, равномерно распределенных в интервале двух орбитальных периодов (100 точек от 0 до 2T, включая границы).\n\nd1  = ... выражение с sat1\nd2  = ... выражение с sat2\nd12 = ... выражение с sat1 и sat2\n\ndist = [....];\n\n\n\nЗадание 6. Сохранить результат (таблицу расстояний) в текстовый файл dist.txt следующего вида.\n\nt, c    d1, км   d2, км   d12, км\n  00    000.000  000.000  000.000 \n  10    000.000  000.000  000.000\n...\n\n\nf = fopen(...)\nfprintf(...)\nfclose(f)\n\n\nИспользуемые функции fopen, fprintf, fclose.\n\nЗадание 7. Построить на одном графике траекторию движения наноспутника №1 и наноспутника №2 относительно станции в плоскости её орбиты на интервале её двух орбитальных периодов. Ось \\(x_o\\) на графике должна быть направлена вверх.\n\nИспользуемые функции: plot.\n\nЗадание 8. Загрузить матрицу расстояний из текстового файла dist.txt. Построить графики изменения расстояния между наноспутниками от времени.\n\ndist_matrix = dlmread(...\n\nplot(dist_matrix(:,1),...\n\nxlabel('Время, с');\nylabel('Расстояние d_{12}, км');\n\n\n\nИспользуемые функции: dlmread, plot\n\nМетодические указания\n\nДвижение наноспутника относительно станции в орбитальной подвижной системе координат, связанной со станцией, предполагая, что расстояние между станцией и наноспутником значительно меньше, чем расстояние от станции до центра Земли, описывается следующими уравнениями:\n\n[\\mathbf x = \n\t\\begin{bmatrix}\n\t\t4-3c &amp; 0 &amp; 0 &amp; s/n &amp; 2/n-2c/n &amp; 0 \n\t\t-6nt+6s &amp; 1 &amp; 0 &amp; -2/n + 2c/n &amp; 4s/n - 3t &amp; 0 \n\t\t0 &amp; 0 &amp; c &amp; 0 &amp; 0 &amp; s/n \n\t\t3ns &amp; 0 &amp; 0 &amp; c &amp; 2s &amp; 0 \n\t\t-6n +6nc &amp; 0 &amp; 0 &amp; -2s &amp; -3+4c &amp; 0 \n\t\t0 &amp; 0 &amp; -ns &amp; 0 &amp; 0 &amp; c \n\t\\end{bmatrix} \\mathbf x(0)]\n\nгде \\(s = \\sin nt, \\, c = \\cos nt\\), \\(n\\) – угловая скорость орбитального движения станции:\n\n[n = \\sqrt{\\frac{\\mu}{r^3}}]\n\n\\(r\\) – радиус круговой орбиты станции, \\(\\mu = 398600.448\\) км\\(^3\\)/c\\(^2\\) – гравитационный параметр Земли, \\(\\mathbf x\\) – вектор состояния наноспутника (координаты и скорость относительно станции):\n\n[\\mathbf x = \\begin{bmatrix} x \\ y \\ z \\ \\dot x \\ \\dot y \\ \\dot z \\end{bmatrix}, \\quad]\n\n\\(\\mathbf x(0)\\) – вектор начального состояния наноспутника:\n\n[\\mathbf x(0) = \\begin{bmatrix} x(0) \\ y(0) \\ z(0) \\ \\dot x(0) \\ \\dot y(0) \\ \\dot z(0) \\end{bmatrix}]\n\n",
      "url": "/pages/matlab/lab_hill_frame/"
    },{
      
      "title": "Матрицы и массивы",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "\n  \n    В первых двух заданиях разработанный код должен работать для любых размеров исходных массивов или матриц (двумерных массивов). Например, в задании 2 код с решением должен работать для двумерного массива (матрицы) Y с любым количеством строк и столбцов.\n  \n  \n    Задания 2 и 3 в каждом варианте должны быть выполнены с использованием операторов for или while и без них.\n  \n  \n    В задании 3 необходимо составить файл-функцию для вычисления значения функции, разложенной в ряд (сумму ряда). В формулах \\(\\varepsilon\\) – заданная степень точности; \\(n\\) – порядковый номер очередного члена ряда. Функцию оформить в виде файл-функции, которой передается значение \\(x\\) (или \\(\\phi\\)), требуемая точность \\(\\varepsilon\\) и необходимое число параметров, если функция от них зависит.\n  \n\n\nПример\n\nЗаданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с чётными индексами в массиве B и произведения положительных элементов в массиве А.\n\nРешение с использованием циклов\n\nСумма элементов с чётными индексами в массиве B может быть определена при помощи цикла для четных значений индекса i – от 2 до количества элементов в массиве B с шагом 2:\n\ns = 0;\nfor i=2:2:numel(B)\n  s = s + B(i);\nend\ndisp(s)\n\n\nПроизведение положительных элементов массива А:\n\np = 1;\nfor i=1:numel(A)\n  if A(i) &gt; 0 \n    p = p*A(i);\n  end\nend\ndisp(p)\n\n\nРешение без использования циклов\n\nСумма элементов с чётными индексами в массиве B:\n\nsum(B(2:2:end))\n\n\nПроизведение положительных элементов массива А:\n\nprod(A(A&gt;0))\n\n\nРассмотрим более сложный пример. Необходимо вывести на экран все первые положительные элементы массива до первого отрицательного или нулевого элемента. Например, для массива A = [1,2,3,4,-1,7,6] на экран нужно вывести [1,2,3,4].\n\n% список индексов массива А\ni       = 1:numel(A);\n% список индексов отрицательных значений массива\niA_le_0 = i(A&lt;0);\n% индекс первого отрицательного элемента массива\nimax    = iA_le_0(1);\n% Элементы массива до первого отрицательного\nA(1:imax-1)\n\n\nНайти приближенное значение функции, разложенной в ряд\n\n[Y = 1 - \\frac{1}{2} + \\frac{1}{3} - \\frac{1}{4} + … + {( - 1)^{n + 1}}\\frac{1}{n} + …,]\n\nучитывая слагаемые до выполнения условия:\n\n[1/n \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n\nfunction Y = my_series(epsilon)\nY = 0;\nfor i=1:1000\n    Y = Y + (-1)^(i+1)/i;\n    if 1/i &lt;= epsilon\n        break;\n    end\nend\n\n\nили\n\nfunction Y = my_series(epsilon)\nY = 1;\ni = 1;\nwhile 1/i&gt;epsilon\n    i = i + 1;\n    Y = Y + (-1)^(i+1)/i;\nend\n\n\nПроверка работоспособности функции\n\nY = my_series(0.001);\ndisp(Y);\n\n\nЗадания\n\nНомер варианта определяется остатком от деления числа, составленного из последних пяти цифр номера зачётной книжки на 20:\n\n[1 + (\\text{NNNNN} \\mod 20)]\n\nВариант 1\n\n\n  Дан массив из N натуральных чисел. Вывести те числа, остаток от деления которых на М равен L (0 ≤ L ≤ M-1).\n  Задан двумерный массив С из 4-х строк и 4-х столбцов (квадратная матрица). Составить программу подсчёта суммы всех отрицательных элементов и суммы элементов по главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[1/n \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n\nФункция:\n\n[Y = 1 - \\frac{1}{2} + \\frac{1}{3} - \\frac{1}{4} + … + {( - 1)^{n + 1}}\\frac{1}{n} + …]\n\nВариант 2\n\n\n  При поступлении в вуз абитуриенты, получившие «двойку» на первом экзамене, ко второму не допускаются. В массиве A[n] записаны оценки экзаменующихся, полученные на первом экзамене. Подсчитать, сколько человек не допущено ко второму экзамену.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу подсчёта суммы произведений элементов строк.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[| a^n \\cos n \\phi | \\leq \\varepsilon, \\quad  \\varepsilon = 0.005.]\n\nФункция:\n\n[F(a,\\phi ) = 1 + (a \\cdot \\cos \\phi  + {a^2} \\cdot \\cos 2\\phi  + {a^3} \\cdot \\cos 3\\phi  + …\n… + {a^n} \\cdot \\cos n\\phi  + …)]\n\nВариант 3\n\n\n  Дана массив чисел, среди которых имеется один нуль. Вывести на печать все числа включительно до нуля.\n  Задан двумерный массив А из 5-и строк и 2-х столбцов. Составить программу, которая формирует одномерный массив В, каждый элемент которого есть произведение элементов массива А в строке.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[1/(2n-1)^2 \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n\nФункция:\n\n[Y = \\frac{1}{1^2} + \\frac{1}{3^2} + \\frac{1}{5^2} + … + \\frac{1}{(2n - 1)^2} + …]\n\nВариант 4\n\n\n  В одномерном массиве размещены: в первых элементах значения аргумента, а в следующих – соответствующие им значения функции. Напечатать элементы этого массива в виде двух параллельных столбцов: аргументы и значения функции.\n  Задан двумерный массив В из 4-х строк и 4-х столбцов. Составить программу, которая организует двумерный массив, элементы главной диагонали  которого равны соответствующим элементам исходного массива, а остальные элементы равны нулю.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[|\\frac{x^{2n - 1}}{(2n - 1)!} | \\leq \\varepsilon, \\quad  \\varepsilon = 0.001.]\n\nФункция:\n\n[F(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + … + (-1)^{n-1} \\frac{x^{2n - 1}}{(2n - 1)!} + …]\n\nВариант 5\n\n\n  Дан целочисленный массив с количеством элементов N. Напечатать те его элементы, индексы которых являются степенями двойки (1, 2, 4, 8, 16, …).\n  Задан двумерный массив А из 2-х строк и 7-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов исходного в столбце.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\\(\\|\\sin (2n-1)x/(2n-1) \\| \\leq \\varepsilon, \\quad \\varepsilon = 0.001.\\):\n\nФункция:\n\n[F ( x ) = \\frac{4a}{\\pi} ( \\sin x + \\frac{\\sin 3x}{3} + … + \\frac{\\sin (2n - 1)x}{2n - 1} + … )]\n\nВариант 6\n\n\n  Дан массив из N действительных чисел. Напечатать те его элементы, которые принадлежат отрезку [c, d].\n  Задан двумерный массив Y из 5-и строк и 5-и столбцов. Составить программу подсчёта суммы всех положительных элементов и суммы элементов по главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[| x^{n-1}| \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n\nФункция:\n\n[F\\left( x \\right) = 1 - x + {x^2} - {x^3} + {x^4} - …. \\pm {x^{n - 1}} + …]\n\nВариант 7\n\n\n  Дан массив целых положительных чисел. Найти произведение только тех чисел, которые больше заданного числа М. Если таких нет, то выдать сообщение об этом.\n  Задан двумерный массив А из 4-х строк и 4-х столбцов. Составить программу, которая подсчитывает произведение элементов массива, лежащих вне главной диагонали.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n[| x(x-1)^n | \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n\n[Y\\left( x \\right) = x + \\left[ x\\left( x - 1 \\right) + x \\left( x - 1 \\right)^2 + … + x \\left( x - 1 \\right)^n + … \\right]]\n\nВариант 8\n\n\n  Массив из N элементов состоит из нулей и единиц. Поставить в начало этого массива нули, а затем единицы.\n  Задан двумерный массив С из 6-и строк и 6-и столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{\\sin (n + 1)x}{(2n - 1)} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F(x) = \\frac{\\sin 2x}{1} - \\frac{\\sin 3x}{3} + … + (-1)^{n - 1} \\cdot \\frac{\\sin (n + 1)x}{(2n - 1)} …]\n\nВариант 9\n\n\n  Дан массив из N действительных чисел, в котором есть только положительные и отрицательные элементы. Вычислить произведение отрицательных элементов P1 и произведение положительных элементов P2. Сравнить модуль P2 с модулем P1 и указать, какое из произведений по модулю больше.\n  Задан двумерный массив Y из 7-и строк и 3-х столбцов. Составить программу, которая вычисляет значение суммы произведений элементов строк\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{x^n}{n!} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!} + … + \\frac{x^n}{n!} \\right)]\n\nВариант 10\n\n\n  Задан массив с количеством элементов N. Сформируйте два массива: в первый включите элементы исходного массива с чётными номерами, а во второй – с нечётными.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть сумма элементов в столбце. Вычислить произведение элементов полученного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{\\sin nx}{n} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F(x) = 2 \\left[ \\sin x - \\frac{\\sin 2x}{2} + … + (-1)^{n - 1}\\frac{\\sin nx}{n}… \\right]]\n\nВариант 11\n\n\n  Составить программу нахождения наибольшего среди тех элементов одномерного массива А, что лежат в интервале [С, D].\n  Задан двумерный массив А из 5-и строк и 4-х столбцов. Составить программу, которая вычисляет значение произведения сумм строк.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{(2x)^n}{n!} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[S\\left( x \\right) = \\frac{2x}{1!} + \\frac{2^2}{x^2}{2!} + \\frac{2^3 x^3}{3!} + … + \\frac{(2x)^n}{n!} + …]\n\nВариант 12\n\n\n  Составить программу отыскания наименьшего среди тех элементов одномерного массива А, что лежат вне интервала [С, D].\n  Задан двумерный массив Y из 4-х строк и 4-х столбцов. Составить программу, которая вычисляет S – сумму элементов побочной диагонали и значение суммы всех элементов массива\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{x^n}{n} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x}{1} + \\frac{x^2}{2} + … + \\frac{x^n}{n} + … \\right)]\n\nВариант 13\n\n\n  Составить программу подсчёта среди элементов одномерного массива В количества чисел, больших С.\n  Задан двумерный массив С из 6-и строк и 3-х столбцов. Составить программу, которая подсчитывает сумму всех элементов массива. Затем организовать формирование нового массива С, в котором элементы, лежащие не на главной диагонали, равны 1, а остальные элементы равны соответствующим элементам исходного массива С Вычислить произведение всех элементов нового массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{a \\cos nx}{a^2 - n^2} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F(x) = \\frac{1}{2a} - \\left[ \\frac{a \\cos x}{a^2 - 1} - \\frac{a \\cos 2x}{a^2 - 2^2} + …(-1)^{n-1} \\cdot \\frac{a \\cos nx}{a^2 - n^2} + … \\right]]\n\nВариант 14\n\n\n  Составить программу отыскания наименьшего среди элементов одномерного массива А и его индекса.\n  Задан двумерный массив А из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив, каждый элемент которого есть произведение элементов массива А в каждой строке. Затем вычислить сумму элементов полученного одномерного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{n}{2^n} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[Y = \\frac{1}{2} + \\frac{2}{2^2} + \\frac{3}{2^3} + … + \\frac{n}{2^n} + …]\n\nВариант 15\n\n\n  Задан массив Y с количеством элементов N. Сформируйте массив, в котором элементы с чётными индексами будут равны соответствующим элементам исходного массива, а элементы с нечётными индексами будут равны нулю.\n  Задан двумерный массив C из 3-х строк и 5-и столбцов. Составить программу, которая вычисляет произведение всех элементов массива. Затем организовать новый массив С, в котором значения элементов, лежащих на главной диагонали, равны 1, а остальные элементы равны квадрату соответствующих элементов исходного массива С.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{\\cos nx}{n^2} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F\\left( x \\right) = \\frac{\\pi }{2} - \\frac{4}{\\pi }\\left( \\cos x + \\frac{\\cos 2x}{2^2} + \\frac{\\cos 3x}{3^2} + … + \\frac{\\cos nx}{n^2} + … \\right)]\n\nВариант 16\n\n\n  Составить программу подсчёта в одномерном массиве А суммы элементов с чётными индексами и суммы элементов, значения которых больше нуля.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая вычисляет сумму всех элементов массива. Затем организовать новый массив В, в котором заменить отрицательные элементы исходного массива на 1, а значения остальных элементов оставить без изменения. Подсчитать количество замен.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{x^{2n - 1}}{2n - 1} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F\\left( x \\right) = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\frac{x^7}{7} + … + \\left({-1}\\right)^{n-1} \\cdot \\frac{x^{2n - 1}}{2n - 1} + …]\n\nВариант 17\n\n\n  Составить программу подсчёта в одномерном массиве С количества отрицательных и произведения положительных элементов массива.\n  Задан двумерный массив А из 8-и строк и 3-х столбцов. Составить программу, которая подсчитывает общее число неотрицательных элементов в массиве. Затем организовать формирование нового массива В, в котором значения элементов исходного массива заменить на противоположные по знаку.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{\\sin (n + 1)x}{2n + 1} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F(x) =  - \\frac{1}{2}\\left[ \\frac{\\sin 2x}{3} + \\frac{\\sin 3x}{5} + … + \\frac{\\sin (n + 1)x}{2n + 1} + … \\right]]\n\nВариант 18\n\n\n  Составить программу подсчёта в одномерном массиве В произведения элементов с нечётными индексами и суммы отрицательных элементов.\n  Задан двумерный массив В из 6-и строк и 3-х столбцов. Составить программу, которая организует одномерный массив С, элементы которого равны количеству положительных элементов в строке исходного массива В.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{1}{2^{n - 1}} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[Y = 1 - \\frac{1}{2} + \\frac{1}{4} - \\frac{1}{8} + … + {( - 1)^{n - 1}} \\cdot \\frac{1}{2^{n - 1}} + …]\n\nВариант 19\n\n\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с чётными индексами в массиве А и суммы элементов, значения которых больше нуля, в массиве В.\n  Задан двумерный массив D из 5-и строк и 5-и столбцов. Составить программу, которая организует одномерный массив, элементы которого равны элементам массива D , лежащим на побочной диагонали, а затем вычисляет сумму элементов полученного одномерного массива.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия\n\n\n\n  \n    \n      [\\left\n      \\frac{\\sin nx}{2^n} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F(x) = \\frac{\\sin x}{2} + \\frac{\\sin 2x}{2^2} + … + \\frac{\\sin nx}{2^n} + …]\n\nВариант 20\n\n\n  Заданы два одномерных массива А и В с одинаковым количеством элементов. Составить программу подсчёта суммы элементов с нечётными индексами в массиве B и произведения отрицательных элементов в массиве А.\n  Задан двумерный массив В из 4-х строк и 5-и столбцов. Составить программу, которая подсчитывает количество положительных, отрицательных и нулевых элементов в массиве В и организует одномерный массив из полученных значений.\n  Найти приближенное значение функции, разложенной в ряд, учитывая слагаемые до выполнения условия:\n\n\n\n  \n    \n      [\\left\n      \\frac{x^{2n}}{\\left(2n\\right)!} \\right\n      \\leq \\varepsilon, \\quad \\varepsilon = 0.001.]\n    \n  \n\n\nФункция:\n\n[F\\left( x \\right) = 1 + \\left( \\frac{x^2}{2!} + \\frac{x^4}{4!} + \\frac{x^6}{6!} + … + \\frac{x^{2n}}{\\left(2n\\right)!} + … \\right)]\n\nИз сборника: Е.А. Симановский “Сборник заданий к лабораторным работам”.\n",
      "url": "/pages/matlab/lab_matrix/"
    },{
      
      "title": "Лабораторная работа 5. Основы работы в MongoDB",
      
      "content": "Цель работы\n\nЗнакомство с нереляционной документоориентированной СУБД MongoDB. Работа с БД из среды Python.\n\nЗадание\n\n\n  Создать подключение к СУБД Mongodb,\n  Создать коллекцию документов.\n  Написать пример документа в формате json из предметной области лабораторных работ 2 и 3.\n  Добавить в коллекцию четыре различных документа.\n  Вывести список документов в коллекции со всеми атрибутами, выполнив запрос к базе данных.\n  Вывести основные атрибуты части документов коллекции, удовлетворяющих некоторому условию (использовать условия «меньше», «больше»)\n\n\nПримеры документов\n\n\n  Библиотека. Читательский билет с записями о книгах, находящихся у читателя.\n  Аптека. Товарный чек с информацией о купленных лекарствах.\n  Больница. Информация о лечении: пациент, врач, дата начала, дата окончания, виды лечения (список).\n  Предприятие. Информация о сотруднике и истории его назначений.\n  Курьерская доставка. Информация о посылке: отправитель (Ф.И.О., адрес отправления, паспортные данные), получатель (Ф.И.О, адрес получения, паспортные данные), масса и габариты посылки, информация о курьере и датах отправления и получения.\n  Повышение квалификации. Список курсов университета: Даты проведения, информация о преподавателе, наименование, количество часов, записанные на курсы сотрудники (до 3).\n  Научная конференция. Программа конференции: дата и наименование конференции, несколько секций со списком статей в каждой секции.\n  Прокат велосипедов. Информация об использовании велосипеда: дата начала, дата окончания, марка (тип), информация о клиенте, стоимость.\n  Футбольный турнир (РФПЛ). Игры: команда 1, основной состав (достаточно указать 3 игроков), команда 2, основой состав (достаточно указать 3 игроков), счет, информация о голах.\n  Пиццерия. Информация о пиццерии со списком продаваемых пицц.\n  Кулинарная книга. Рецепт.\n  Поликлиника. Информация о посещениях: дата, врач, посетитель, диагноз.\n  Сессия. Результаты экзаменов с указанием информации о преподавателе и списке студентов с оценками (до 5 студентов).\n  Расписание занятий. Расписание занятий на 1 день (для нескольких групп)\n  Социальная сеть. Изобразите диаграмму сущность связь для социальной сети Сообщения с главной страницы: дата, текст, комментарии (автор, текст).\n  Интернет-магазин мебели. Товарный чек с информацией о товарах, покупателе и магазине.\n  Онлайн кинотеатр. Информация о пользователе: Имя, предпочтения, список просмотренных фильмов (жанр, наименование, дата просмотра, длительность).\n  Бронирование авиабилетов. Информация о заказанных билетах: пункт А в пункт Б,  дата, вес багажа, тип меню.\n  Музыкальные альбомы. Музыкальные альбомы.\n  Бронирование авиабилетов. Брони.\n  Курсы и студенты. Проекты: дата начала и окончания, информация о сотрудниках в проекте (до трех): имя, идентификационный номер, адрес, зарплата и дата рождения.\n  Галереи. Несколько групп со списком произведений в каждой группе.\n  Сеть отелей. Информация об истории бронирования номеров: дата начала, окончания, список постояльцев, стоимость.\n  Прокат автомобилей. Список автомобилей с историей их использования.\n  КХЛ. Информация об играх: команда 1, основной состав (достаточно указать 3 игроков), команда 2, основой состав (достаточно указать 3 игроков), счет, информация о голах.\n  Книжный онлайн-магазин. Товарный чек.\n  Мастерская. Коллекция документов с информациях о заказах: дана начала и окончания, имя мастера, имя клиента, техника, ее вид, список работ.\n  ЖЭК. Список заявок: дана начала и окончания работ, адрес клиента, бригада специалистов со списком специалистов.\n  Парки. Информация о трех парках, с указанием наименования, площади, место адреса и списка павильонов (до трех): наименование, тип (кафе, продуктовый, развлекательный, прокат вещей), занимаемая площадь.\n\n\nМетодические рекомендации\n\nИмя пользователя и пароль совпадают с именем и паролем для подключения к СУБД MySQL в лабораторной работе 3. Имя базы данных совпадает с именем пользователя.\n\nДокумент в формате json\n\n{\nid: 1155151,\ndate: \"2020-05-20\",\nbuyer: \"Луаврик Л. Луаврик\",\nitems: [\n\t\t{\n\t\tcode: 41155415,\n\t\tname: \"256 ГБ SSD-накопитель Transcend 230S\",\n\t\tprice: 4750.00\n\t\t},\n\t\t{\n\t\tcode: 115521856,\n\t\tname: \"Зеркальная камера Nikon D3500 Kit 18-140mm VR AF-S\",\n\t\tprice: 48000.00\n\t\t}\t\n\t\t],\ntotal: 52750.00,\npayment_type: \"наличные\"\n}\n\n",
      "url": "/pages/databases/lab_nosql/"
    },{
      
      "title": "Интегрирование системы дифференциальных уравнений",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Вдоль горизонтальной прямой движутся n материальных точек с массами \\(m_k\\) (\\(k=1,\\ldots,n\\)), связанные пружинами с заданными жесткостями \\(c_k\\)  и свободными длинами \\(L_k\\).\n\n\n\nДифференциальное уравнение движение первого тела:\n\n[m_1 \\ddot{x}1 = - c_1 (x{1}-L_1) + c_2 (x_{2}-x_{1}-L_{2})]\n\nДифференциальное уравнение движение \\(k\\)-го тела (\\(2 \\leq k \\leq n-1\\)):\n\n[m_k \\ddot{x}k = - c_k (x{k}-x_{k-1}-L_k) + c_{k+1} (x_{k+1}-x_{k}-L_{k+1}), \\quad k=2,\\ldots,n-1]\n\nДифференциальное уравнение движение \\(n\\)-го тела:\n\n[m_n \\ddot{x}n = - c_n (x{n}-x_{n-1}-L_n)]\n\nФайл-функция правых частей дифференциальных уравнений движения системы материальных точек\n\nfunction dq = dqdt(t, q, p)\n    % Матрица-столбец состояния механической системы имеет\n    % размерность (2n x 1):\n    % Количество тел (материальных точек)\n    n = size(q,1)/2;\n    % Первые n элементов столбца это координаты грузов:\n    x  = q(1:n);\n    % элементы с n+1 по 2n -- скорости тел:\n    v  = q(n+1:2*n);\n    % Столбец расстояний между соседними точками (для первой точки это сама координата x1)\n    dx = [x(1);diff(x)];\n    % Столбец сил растяжения пружин\n    Fs = (dx-p.L).*p.c;\n    % Столбец сил, действующих на точки\n    F  = -Fs + [Fs(2:n); 0];\n    % Столбец ускорений тел\n    a    = F./p.m;\n    dq = [v;a];\nend\n\n\nФайл-скрипт, запускающий процесс численного интегрирования\n\n% Массы тел\np.m = [5;10;8];\n% Свободные длины пружин\np.L = [1;1;1];\n% Жесткости пружин\np.c = [1000;1000;500];\n% Координатный столбец начальных условий\nq0 = [1.1;2.5;3.2;0;0;0];\n% Запускаем процесс интегрирования\n[t, q] = ode45(@(t,q) dqdt(t,q,p),[0 5], q0);\n% Графики изменений координат тел\nplot(t,q(:,1:3));\n\n\nЗадание\n\n\n  Добавить в модель силу сухого трения, действующую на тела, полагая, что система движется по горизонтальной плоскости в поле силы тяжести (\\(g = 9.81\\) м/с\\(^2\\)).\n  Построить графики изменения расстояний между телами от времени.\n  Построить график изменения кинетической энергии системы от времени.\n  Построить график изменения потенциальной энергии системы от времени.\n\n\nИспользовать следующую модель зависимости коэффициента трения f от скорости (модель Штрикбека - Кулона):\n\nVbr = 0.002;\nVst = Vbr*sqrt(2);\nVc  = Vbr/10;\nFbr = 0.2;\nFc  = 0.15;\nf   = @(v) sqrt(2)*exp(1)*(Fbr-Fc)*exp(-(v/Vst).^2).*v/Vst + Fc*tanh(v/Vc);\n\n",
      "url": "/pages/matlab/lab_ode/"
    },{
      
      "title": "Относительное и абсолютное орбитальное движение",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "Разработайте программу численного интегрирования уравнений движения материальной точки в центральном гравитационном поле Земли по отношению к геоцентрической инерциальной системе координат.\n\nФункция правых частей\n\nfunction dq = dqdt(t,q,p)    \n    r  = q(1:3);    \n    v  = q(4:6);    \n    mu = p.mu;\n    a  = - mu*r/norm(r)^3;\n    dq = [v; a];\nend\n\n\np.mu = ...\n...\n\n[t, q] = ode113(@(t,q,p) ... )\n...\n\n\n\n  Получить численное решение движения орбитальной станции по круговой орбите высотой 450 км на интервале трех орбитальных периодов станции. Установить требуемую абсолютную погрешность  метода численного интегрирования не более: \\(10^{-8}\\).\n  Получить численные решения движения наноспутника, отделившегося от станции со скоростью 1 м/с в направлении орбитальной скорости станции (случай А), в направлении противоположном орбитальной скорости станции (случай В). Установить требуемую абсолютную погрешность  метода численного интегрирования не более: \\(10^{-8}\\).\n  Построить на одном рисунке две траектории (для случаев А и В) движения наноспутника относительно станции в орбитальной подвижной системе координат станции на интервале её трех орбитальных периодов.\n  Построить на одном рисунке две траектории движения наноспутника относительно станции в орбитальной подвижной системе координат станции, используя приближенные уравнения  относительного орбитального движения) на интервале трех орбитальных периодов станции.\n  Построить два рисунка, соответствующие двум разным направлениям отделения наноспутника (A и B), на каждом из которых показать траектории движения наноспутника, полученные в результате численного интегрирования и с использованием приближенных уравнений относительного движения. Для двух рассматриваемых случаев найти абсолютную погрешность определения положения наноспутника через три орбитальных периода станции, используя приближенные уравнения относительного орбитального движения, приняв за точное положение результаты численного интегрирования движения наноспутника.\n\n\nПример рисунка для случая отделения наноспутника в направлении орбитальной скорости станции:\n\n\n\nМетодические указания\n\nВ каждый момент времени единичные вектора орбитальной системы координат станции определяются следующим образом. Единичный вектор оси \\(x_o\\) орбитальной системы координат, направленный вдоль радиус-вектора орбиты:\n\n\n  \n    \n      [\\mathbf{e}_r = \\frac{\\mathbf{r}_1}{\n      \\mathbf{r}_1\n      }]\n    \n  \n\n\nгде \\(\\boldsymbol r_1\\) координатный столбец радиус-вектора станции в геоцентрической инерциальной системе координат. Единичный вектор нормали к плоскости орбиты:\n\n\n  \n    \n      [\\mathbf{e}_n = \\frac{\\mathbf{e}_r \\times \\mathbf{v}_1}{\n      \\mathbf{e}_r \\times \\mathbf{v}_1\n      }]\n    \n  \n\n\nединичный вектор трансверсали\n\n[\\mathbf{e}_t = \\mathbf{e}_n \\times \\mathbf{e}_r]\n\nКоординаты наноспутника в орбитальной подвижной системе станции\n\n[\\mathbf{\\rho} = \\begin{bmatrix} (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot \\mathbf{e}_r \\ (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot \\mathbf{e}_t  \\ (\\mathbf{r}_2-\\mathbf{r}_1)\\cdot \\mathbf{e}_n \\end{bmatrix}]\n\nгде \\(\\mathbf r_2\\) координатный столбец радиус-вектора наноспутника в геоцентрической инерциальной системе координат.\n",
      "url": "/pages/matlab/lab_orbital/"
    },{
      
      "title": "Интегрирование уравнений движения механизма с двумя степенями свободы",
      "description": "Задание для по курсу “Интегрированные математические пакеты”\n",
      "content": "Задание\n\n\n  В среде Python разработать программу для численного интегрирования уравнений движения системы с двумя степенями свободы для механизма из задания для курсовой работы по теоретической механики (2 курс).\n  Построить графики изменения обобщенных координат и скоростей (четыре графика на четырёх отдельных рисунках).\n  Построить одном рисунке графики изменения потенциальной, кинетической и полной энергии системы. Убедитесь, что полная энергия системы остается постоянной.\n\n\nПримеры\n\n\n  Движение спускаемого аппарата в атмосфере\n  Истечение газа из ёмкости постоянного объёма\n  Движение механической системы с двумя степенями свободы\n\n\n",
      "url": "/pages/imp/lab_py_ode2dof/"
    },{
      
      "title": "Модель движения троса",
      "description": "Задание для лабораторной работы по курсу “Основы MATLAB”\n",
      "content": "\n  Доработать модель троса и программу, добавив в неё демпфирование колебаний троса, полагая, что сила демпфирования, действующая между двумя узлами, пропорциональна скорости изменения расстояния между ними.\n  Написать код, который определяет начальные положения узлов вертикально-висящего (вдоль оси \\(Oy_0\\))  и находящегося в равновесии троса в однородном поле силы тяжести с ускорением свободного падения \\(g\\), направленным в противоположном направлении оси \\(y_0\\).\n  Доработать модель троса и программу для случая вращения системы координат \\(Ox_0y_0\\) вокруг точки О с постоянной угловой скоростью \\(\\omega\\): добавить к силам упругости, действующим на узлы троса, переносные силы инерции (рисунок 1).\n  Написать код, который определяет начальные положения узлов троса, находящегося в равновесии во вращающейся системе координат (п. 3). В начальном положении трос вытянут вдоль оси \\(Oy_0\\).\n\n\n\n\nРисунок 1 -  К заданию 3\n\n",
      "url": "/pages/matlab/lab_tether/"
    },{
      
      "title": "Построение уравнений движения системы материальных точек.",
      "description": "Задание для по курсу “Интегрированные математические пакеты”\n",
      "content": "\n  На основе примера разработать программу моделирования движения системы материальных точек (n = 5), связанных пружинами, по горизонтальной шероховатой плоскости.\n  Первое тело соединено пружиной с неподвижной стенкой, жесткости всех пружин равны 200 Н/м. Массы всех тел равны 5 кг, количество тел равно 5. В начальный момент времени расстояние между смежными материальными точками равно 1,5 м. Свободная длина пружин, соединяющих точки равна 1 м.\n  На тела системы действует сила трения. Коэффициент трения скольжения \\(f_d = 0.1\\) и покоя \\(f_s = 0.3\\). Коэффициент трения в зависимости от скорости точки \\(v\\) вычисляется по следующей формуле:\n\n\n\n  \n    \n      [f(v) = \\left[ f_d + (f_s-f_d) \\exp\\left(-\\frac{\n      v\n      ^2}{v_s^2}\\right) \\right] \\tanh(k \\cdot v) + k_v v]\n    \n  \n\n\nгде \\(v_s = 0.002\\), \\(k_v = 0.1\\), \\(k = 10^4\\).\n\nЗадание\n\n\n  Построить графики изменения абсолютных скоростей всех точек системы (на одном графике).\n  Построить график изменения скорости центра масс системы.\n  Построить графики изменения кинетической энергии системы.\n  Построить графики изменения потенциальной энергии системы .\n  Построить графики изменения полной механической энергии системы.\n\n",
      "url": "/pages/imp/lab_wm_2/"
    },{
      
      "title": "Задания для лабораторных работ",
      "description": "Лабораторные работы к курсу “Динамика твёрдого тела и систем тел”\n",
      "content": "Семестр 1\n\n\n  Ортогональные матрицы\n  Углы Эйлера\n  Кватернионы\n  Тензор инерции\n  Угловая скорость\n  Орбитальное движение\n  Движение твердого тела\n  Случай Эйлера\n  Уравнение движения точки с уравнениями связей\n\n\nСеместр 2\n\n\n  Метод Кейна\n  Метод отдельных тел\n\n\nПо результатам выполнения всех заданий оформляется один отчёт лабораторным работам. Отчёт выполняется в системе LaTeX c использованием онлайн-системы OverLeaf. Шаблон отчета. Каждое задание оформляется отдельным разделом отчёта (section).\n\nШаблон отчета по лабораторной работе (LaTeX)\n",
      "url": "/pages/mbs/labs/"
    },{
      
      "title": "Сборник задания для лабораторных работ",
      "description": "Задания для лабораторных работ ко второй части курса “Интегрированные математические пакеты”.\n",
      "content": "Отчет по лабораторным работам выполняется в системе LaTeX. Шаблон отчета по лабораторной работе (LaTeX).\n\n\n  Матрицы\n  Игра “Жизнь”\n  Игра “Жизнь” на торе\n  Относительное орбитальное движение\n  Интегрирование дифференциальных уравнений системы с двумя степенями свободы. Приведение уравнений к форме Коши\n  Интегрирование дифференциальных уравнений\n  Модель движения троса\n  Орбитальное движение\n  Движение спускаемого аппарата в атмосфере.\n  Модель одноканальной системы ориентации в SIMULINK.\n\n\n",
      "url": "/pages/matlab/labs/"
    },{
      
      "title": "Лабораторные работы",
      "description": "Задания для лабораторных работ по курсу Технологии и языки программирования.\n",
      "content": "Семестр 1\n\n\n  Задание 1\n  Задание 2 (игра Жизнь)\n  Задание 3 (списки)\n  Задание 4 (игра Жизнь)\n  Задание 5 (игра Жизнь)\n\n\nСеместр 2\n\n\n  Задание 1\n  Задание 2\n  Задание 3\n  Задание 4\n  Задание 5\n\n",
      "url": "/pages/python/labs/"
    },{
      
      "title": "Построение годографа единичного вектора продольной оси тела при движении в случае Лагранжа",
      "description": "Динамика твёрдого тела и систем тел\n",
      "content": "Рассматривается движение твёрдого тела в случае Лагранжа. Необходимо построить годограф продольной оси тела (\\(Oz_2\\)).\n\n\n\nclear all;\n% Параметры тела\nm   = 4;    % Масса тела\nJxy = 0.5;  % Поперечный момент инерции\nJz  = 1;    % Продольный момент инерции\ns   = 0.5;  % Расстояние от точки опоры до центра масс\ng   = 9.807;% Ускорение свободного падения\n\n% Начальные условия\ntheta0 = 0.7;   dtheta0 = 0.0;\npsi0   = 0;     dpsi0   = 0.0;\nphi0   = 0;     dphi0   = 10;\n\n% Угловые скорости\nwx      =   dtheta0;\nwy      =   dpsi0*sin(theta0);\nwz      =   dphi0+dpsi0*cos(theta0);\n\n% Интегралы энергии и кинетического момента\nE       = 0.5*(Jxy*(wx^2+wy^2)+Jz*wz^2+2*m*g*s*cos(theta0));\n% Проекция веткора кинетического момента на направление вертикали\nL       = Jxy*dpsi0*sin(theta0)^2+Jz*wz*cos(theta0);\n\n\nКоэффициенты полинома относительно u (13)\n\ncoeff_dotu2  = [2*m*g*s/Jxy, -(2*E-Jz*wz^2)/Jxy-Jz^2*wz^2/Jxy^2,...\n    -2*m*g*s/Jxy+2*Jz*wz*L/Jxy^2, (2*E-Jz*wz^2)/Jxy-L^2/Jxy^2];  \n\n\nКорни полинома, отсортированные по возрастанию\n\nu = sort(roots(coeff_dotu2));\n\n\n\\(k^2\\) в выражении (16)\n\nk2 = (u(2)-u(1))/(u(3)-u(1));\n\n\nКоэффициент масштаба времени \\(\\tau\\) (18)\n\ntau_k = sqrt((u(3)-u(1))*m*g*s/Jxy);\n\n\nРешения для углов и их производных. Угол нутации \\(\\theta\\):\n\ntheta = @(t) acos(u(1)+(u(2)-u(1))*ellipj(tau_k*t,k2).^2);\n\n\nУгловая скорость прецессии \\(\\dot \\psi\\) и угол прецессии \\(\\psi\\):\n\ndpsi  = @(t) (L-Jz*wz*cos(theta(t)))./(Jxy*(1-cos(theta(t)).^2));\npsi   = @(t) integral(dpsi,0,t);\n\n\nУгловая скорость собственного вращения \\(\\dot \\varphi\\)\n\ndphi  = @(t) wz-dpsi(t)*cos(theta(t));\n\n\nГрафик изменения угла нутации\n\nfplot(@(t) theta(t),[0, 1]);\nxlabel('t, c'); \nylabel('\\theta, градус');\n\n\n\n\nФормируем массив значений моментов времени для построения графика.\n\ntime_array = (0:0.01:3)';\n\n\nПри помощи функции arrayfun вызываем функцию psi(t) для каждого элемента массива time_array. Такой способ формирования массива значений угла \\(\\psi\\) обусловлен тем, что функция integral, используемая для определения функции psi(t), не принимает только скалярные значение пределов интегрирования.\n\npsi_array = arrayfun(psi,time_array);\n\n\nЗначения углов \\(\\theta\\) может\n\ntheta_array = theta(time_array);\n\n\nКоординаты точек годографа единичного вектора, направленного по продольной оси тела:\n\ngodograph = [sin(theta_array).*sin(psi_array), ...\n            -sin(theta_array).*cos(psi_array), ...\n            cos(theta_array)];\n\n\nСтроим график:\n\nplot3(godograph(:,1), godograph(:,2), godograph(:,3),'r-','LineWidth',2);\n\nhold on;\n[xs,ys,zs] = sphere(64);\nsf = surf(xs,ys,zs); \nsf.EdgeColor = 'none';\nsf.FaceColor =[0.8 0.8 0.8];\nsf.FaceAlpha = 0.8;\nhold off;\n\nxlim([-1 1]); ylim([-1 1]); zlim([-1 1]);\nbox on; \ndaspect([1 1 1]);\n\n\n\n",
      "url": "/pages/mbs/lagrange_case/"
    },{
      
      "title": "Алгоритм Ли",
      
      "content": "\n  Написать программу, иллюстрирующую работу алгоритма поиска кратчайшего пути на планарном графе.\n  Результат работы программы выводится на экран и сохраняется в файл формата png.\n\n\nАлгоритм Ли\n\nСписок заданий\n",
      "url": "/pages/python/course_works/lee/"
    },{
      
      "title": "Ссылки",
      
      "content": "Космонавтика\n\n\n  Lunar Constants and Models Document\n\n\nКосмический мусор\n\n\n  Параметры орбит высокоорбитальных объектов (ПАО “МАК “Вымпел”)\n\n\nDevelopment\n\n\n  Use private repo to publish websites with github pages.\n  Working with Git remotes and pushing to multiple Git repositories\n\n\nGraphics\n\n\n  Plotting experimental data using pgfplots\n\n\nЧисленные методы\n\n\n  The Gauss-Jackson ODE Solver\n  \n\n",
      "url": "/pages/links/"
    },{
      
      "title": "Задания",
      "description": "Задания для курсовой работы\n",
      "content": "Задания\n\n\n  Игра жизнь\n  Многоугольник и точка\n  Колонизация\n  Лунолёт\n  Ломаная линия\n  Город\n  Анализ текста\n  Алгоритм Ли\n  Треугольники\n  Двухимпульсный перелет\n  TLE элементы\n  Выпуклая оболочка\n  Лабиринт\n  Шифр Виженера\n  Задача Прима-Краскала\n  Пересечение многоугольников\n  Экзаменационные билеты\n  Дубли файлов\n  Кратчайший путь\n\n\nТребования к оформлению курсовой работы\n\n\n  Пояснительная записка должна быть оформлена в соответсвии с СТП\n  Текст программы с комментариями помещается в приложение.\n  В пояснительной записке должен быть изложен алгоритм решения задачи, приведены блок-схемы.\n  Разрабатываемая программа должна состоять не менее чем из двух модулей: из главного (исполняемого) модуля, который использует функции и данные второго модуля, необходимые для решения задачи.\n\n\n",
      "url": "/pages/python/course_works/list/"
    },{
      
      "title": "Аттрактор Лоренца",
      
      "content": "Система Лоренца - это система обыкновенных дифференциальных уравнений, впервые изученная математиком и метеорологом Эдвардом Лоренцем:\n\n[\\begin{aligned}\n&amp; x’ = -s x + sy \n&amp; y’ = -xz+rx-y \n&amp; z’ = xy-dz \n\\end{aligned}]\n\nПри определенных значениях параметров и начальных условий эта система имеет хаотические решения, например, при\n\n[d = 8/3, \\quad s = 10, \\quad r = 28,]\n\n[x_0=-8, \\quad y_0 = 8, \\quad z_0 = 27]\n\nХаотические системы могут быть полностью детерминированными, но при этом оставаться непредсказуемыми на длительных интервалах времени.\n\nФайл-функция правых частей дифференциального уравнения (dqdt.m):\n\nfunction dq = dqdt(t,q,p)\n    x = q(1);\n    y = q(2);\n    z = q(3);\n    \n    s = p.s;\n    r = p.r;\n    d = p.d;\n\n    dx = -s*x+s*y;\n    dy = -x*z+r*x-y;\n    dz = x*y-d*z;\n\n    dq = [dx;dy;dz];\nend\n\n\nГлавный файл-скрипт (lorenz_system.m)\n\np.s = 10;\np.r = 28;\np.d = 2.67;\n\nx0 = -8;\ny0 = +8;\nz0 = +27;\n\nnp = 6;\n\ntlist = 0:0.01:200;\n\nq = zeros(numel(tlist),3,np);\n\n% Исследуем влияние параметра s \ns = [3, 4, 5.2, 10, 17.82, 18];\n\nopt = odeset('RelTol',1e-8,'AbsTol',1e-8);\n\nfor i = 1:np\n    p.s = s(i);\n    [t,q(:,:,i)] = ode45(@(t,q) dqdt(t,q,p),tlist,[x0;y0;z0],opt);\n    subplot(3,2,i);\n    plot3(q(:,1,i),q(:,2,i),q(:,3,i),'LineWidth',0.8);\n    xlabel('x');ylabel('y');zlabel('z');\n    view(45,20);    \n    box on;\n    title(sprintf('s=%4.2f',s(i)));\n    grid;\n    xlim([-30 30])\n    ylim([-30 30])\n    zlim([0 50])\nend\n\n\n\n",
      "url": "/pages/matlab/lorenz-system/"
    },{
      
      "title": "Лунолёт",
      "description": "Диалоговая игра Лунолёт\n",
      "content": "Космический корабль в начальный момент времени находится на высоте \\(h\\) от поверхности Луны.\n\nПрограмма выводит высоту полета, скорость (со знаком плюс или минус) и массу оставшегося топлива:\n\n--------------------\nВремя     :  20 c\nВысота    :  1063 м\nСкорость  : -10.3 м/с\nТопливо   :  100 кг\nМасса КА  :  1000 кг\n--------------------\nВведите массу топлива и время работы двигателя:\n\n\nКорабль управляется при помощи задания расхода топлива за заданное время, т.е. необходимо ввести через запятую или пробел два числа: количество топлива и время его расходования, например, 50 кг за 5 секунд:\n\n50 5\n\n\nПо умолчанию тяга двигателя корабля направлена вверх. Если необходимо направить силу тяги вниз, то необходимо перед массой топлива написать символ “-“\n\n-50 5\n\n\nПерегрузка корабля при работе двигателя не должна превышать предельного значения - 5 единиц. Если перегрузка превысит это значение, то считается, что корабль остается неуправляемым в течение 10 секунд.\n\nНеобходимо посадить корабль на поверхность Луны со скоростью не более 3 м/с, имея ограниченный запас топлива на борту.\n\nПосле окончания игры (посадки) программа должна выводить график изменения скорости и высоты c указанием интервалов манёвров и расхода топлива на каждый маневр.\n\nМодель движения\n\nПусть в момент времени \\(t_i\\) посадочный модуль имеет скорость \\(v_i\\) и находится на высоте \\(h_i\\) от поверхности Луны. Тогда после расходования \\(\\Delta m\\) кг топлива за \\(\\Detla t\\) секунд, т.е. через \\(t_{i+1} = t_{i} + \\Delta t\\) высота посадочного модуля над поверхностью Луны будет определяться:\n\n[h_{i+1} = h_i - \\frac{g \\Delta t^2}{2} + \\cdot u \\ln \\left(1 - \\Delta m/m_i \\right) \\Delta t + u \\Delta t + \\cdot v_i \\Delta t + \\frac{m_i}{\\Delta m} u \\ln (1-\\Delta m/m_i) \\Delta t]\n\nгде \\(g\\) – ускорение свободного падения на Луне, \\(u \\approx 3000\\) м/с - скорость истечения продуктов сгорания двигателя.\n\nСкорость:\n\n[v_{i+1} = v_i - g \\Delta t - 2 \\cdot \\text{atanh}\\left(\\frac{\\Delta m}{\\Delta m - 2 m_i}\\right) \\cdot u]\n\nМасса:\n\n[m_{i+1} = m_i - \\Delta m]\n\nУскорение посадочного модуля в процессе работы двигателя\n\n[a_i = \\frac{\\Delta m \\cdot u}{\\Delta t \\cdot m_i \\cdot g}]\n\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/lunolet/"
    },{
      
      "title": "Динамика твёрдого тела и систем тел",
      
      "content": "\n  Презентации\n  Учебное пособие\n  Задания для лабораторных работ\n  Задания для курсовой  работы\n\n\nПримеры\n\n\n  Уравнения движения со связями\n\n",
      "url": "/pages/mbs/main/"
    },{
      
      "title": "Основы Wolfram Mathematica",
      
      "content": "Лабораторные работы\n\n\n  Списки\n  Движение системы материальных точек\n  Уравнения Лагранжа\n  Символьные вычисления\n  Анимация\n  Численные методы\n\n\nПо каждой лабораторной работе оформляется отчёт в соответствии с шаблоном.\n\nПримеры\n\n\n  Списки, функции, элементы функционального программирования\n  Построение модели движения системы точек, связанных пружинами\n  Вывод и интегрирование уравнений движения двойного физического маятника (уравнения Лагранжа)\n  Вывод уравнений движения системы с двумя степенями свободы (курсовая работа по теоретической механике)\n  Анимация. Построение анимации.\n  Относительное орбитальное движение. Уравнения относительного орбитального движения двух космических аппаратов при движении одного из них (ведущий) по круговой орбите.\n  Преобразование поворота. Поворот в пространстве. Матрица поворота. Пример в Wolfram Mathematica.\n\n",
      "url": "/pages/wolfram/main/"
    },{
      
      "title": "Основы Python",
      "description": "Курс для бакалавров первого года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Лекции\n\nПрезентации к лекциям\n\nЛабораторные работы\n\nШаблон отчёта по лабораторной работе в формате docx\n\nЗадания для лабораторных работ\n\nКурсовая работа\n\nЗадания для курсовых работ\n\nПримеры\n\n\n  Движение спускаемого аппарата в атмосфере\n\n\n",
      "url": "/pages/python/main/"
    },{
      
      "title": "Основы MATLAB",
      
      "content": "Быстрое знакомство\n\n\n  Матрицы\n  Индексы и элементы\n  Матричная алгебра\n  Файл-скрипты и файл-функции\n  Ячейки\n  Структуры\n  Статистики и сортировка\n  Структурное программирование\n  Основы графики\n  Дата и время\n  Импорт и экспорт данных\n  Временные ряды\n  Таблицы\n  Хронологические таблицы (timetable)\n\n\nЧисленные методы\n\n\n  Численные методы\n  Интегрирование ОДУ\n  Интегрирование уравнений движения эллиптического маятника\n\n\nПрезентации\n\n\n  Типы данных\n  Функции\n  Файл-функции и скрипты\n  Программирование\n  Графика\n  Относительное орбитальное движение\n  Численные методы\n  Интегрирование ОДУ\n\n\nЛабораторные работы\n\n\n  Задания\n  Шаблон отчета по лабораторной работе (LaTeX)\n\n\nПримеры\n\n\n  Продольные колебания стержня.\n  Построение модели физического маятника в SIMULINK.\n\n\n",
      "url": "/pages/matlab/main/"
    },{
      
      "title": "Управление IT-сервисом и контентом",
      
      "content": "Курс “Управление ИТ-сервисом и контентом” включает в себя лекционные занятия и лабораторные работы. Заканчивается курс промежуточной аттестацией в форме экзамена. В течение курса каждый обучающийся готовит один реферат (не менее 10 страниц) и представляет его на лабораторных работах (презентация в течение 5-10 минут). К экзамену допускаются обучающиеся, сдавшие все лабораторные работы и представившие один реферат. Оценка “отлично” может быть выставлена по итогам семестра тем студентам, которые сдали в срок все лабораторные работы, посетили не менее 75% лекций и выполнили все тестовые задания.\n\nПрезентации\n\n\n  Управление ИТ-сервисом и контентом. Введение\n  ИТ-служба, ИТ-инфраструктура и ИТ-сервис\n  ITIL\n  Управление инцидентами, проблемами и ошибками\n  Управление конфигурациями и изменениями\n  MOF\n  Основы информационной безопасности\n  Системы управления контентом\n\n\nЛабораторные работы\n\n\n  Разработка ИТ-инфраструктуры малого предприятия.\n  Система iTop. База данных конфигурационных элементов.\n  Разработка каталога услуг и SLA.\n  Системы управления веб-контентом.\n  Шифрование с открытым ключом.\n\n\nШаблон отчёта по лабораторной работе.\n\nРефераты\n\nРекомендуемый список тем рефератов.\n\n\n  Лицензирование программного обеспечения: свободные, несвободные, условно-бесплатные, коммерческие, BSD, MIT, и другие лицензии и их сравнение.\n  Практика использования свободных лицензий на предприятиях.\n  Криптографические методы защиты информации: история, алгоритмы, программное обеспечение, правовое регулирование в области криптографии в России и других странах.\n  Электронная цифровая подпись: история, алгоритмы, программное обеспечение, правовое регулирование электронной цифровой подписи в России и других странах.\n  Сравнение нескольких решений Service Desk.\n  Обзор систем управления базами данных конфигурациями (CMDB): открытые и коммерческие.\n  Облачные технологии в бизнесе.\n  Обзор систем видеоконференцсвязи.\n  Обзор корпоративных мессенджеров (чатов).\n  Обзор программного обеспечения мониторинга ИТ-инфраструктуры.\n  Обзор программных систем электронного документооборота.\n  Системы управления контентом предприятия (Enterprise Content Management).\n  Корпоративный VPN (назначение, виды, решения).\n  Программные системы управления персоналом.\n  Реклама в Интернет: виды, особенности, эффективность.\n  Интернет вещей в промышленности.\n  Частные LTE сети.\n  ИТ и искусственный интеллект: революция на рабочем месте.\n  Роль ИТ в оказании медицинской помощи и управлении ею.\n\n\nРеферат оформляется в соответствии с “СТО 02068410-004-2018 Общие требования к учебным текстовым документам” и представляется в виде презентации (не более 10 минут) на одной из лабораторных работ.\n\nИсточники\n\n\n  Артюшина, Л. А. Управление ИТ-сервисами и контентом : учеб. пособие / Л. А. Артюшина, Е. А. Троицкая ; Владим. гос. ун-т им. А. Г. и Н. Г. Столетовых. ‒ Владимир : Изд-во ВлГУ, 2021. ‒ 280 c. \n  Бараксанов Д. Н. Управление ИТ-сервисами и контентом : учебное пособие / Д. Н. Бараксанов, Ю. П. Ехлаков. — Томск : ФДО, ТУСУР, 2015. — 144 с.\n  Конспект лекций по дисциплине “Управление ИТ-сервисами и контентом”. Составил: к.т.н., Бакаев М. А.\n  Практическая методика внедрения методов ИТИЛ\n  ITIL. IT Service Management по стандартам V.3.1\n  Service Desk быстрый старт. 2 часть — создание каталога услуг\n  Козырев А. А. Информационные технологии в экономике и управлении: Учебник. – СПб.: Изд-во Михайлова В. А., 2000.\n  Сети для начинающего IT-специалиста. Обязательная база\n  ИТ-инфраструктура предприятия - что нужно бизнесу?\n  Построение ИТ инфраструктуры небольшого офиса\n  ИТ-инфраструктура как сервис: от сервера до приложения\n\n\n",
      "url": "/pages/it/main/"
    },{
      
      "title": "Компьютерные и экспериментальные методы в механике",
      
      "content": "\n",
      "url": "/pages/stat/main/"
    },{
      
      "title": "Компьютерная графика",
      "description": "Курс для бакалавров второго года обучения Института ракетно-космической техники Самарского университета.\n",
      "content": "Презентации\n",
      "url": "/pages/graphics/main/"
    },{
      
      "title": "Информатика",
      "description": "Курс Информатика для студентов Института экономики и управления Самарского университета.\n",
      "content": "Материалы курса\n\nУчебные пособия и методические указания\n\nЕ.А. Симановский Введение в информатику\n\nЕ.А. Симановский Методические указания к лабораторным работам\n\nЛабораторные работы\n\nЕ.А. Симановский Сборник заданий к лабораторным работам\n\nШаблон отчёта по лабораторной работе\n\nКомментарии к лабораторной работе №1\n\nКомментарии к лабораторной работе №2\n\nКомментарии к лабораторной работе №3\n\nКомментарии к лабораторной работе №4\n\nКомментарии к лабораторной работе №5\n\nКомментарии к лабораторной работе №6\n\nСсылки\n\nПрограммы\n\nСвободная среда разработки Lazarus для Free Pascal\n\nУчебные материалы\n\nКафедра Суперкомпьютеры и общая информатика Самарского университета\n\nКоманды среды разработки Turbo Pascal\n\nTurbo Pascal 7.0 Электронный учебник для студентов и школьников\n\nПаскаль для начинающих. Основы грамматики в таблицах и примерах\n\nБлок-схема\n\nСайт Валерия Семёнова\n\nСтандарты и шаблоны\n\nОбщие требования к учебным текстовым документам\n",
      "url": "/pages/informatics/main/"
    },{
      
      "title": "Базы данных",
      
      "content": "Лекции\n\n\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра.\n  Лекция 4. Нормализация: четыре нормальные формы.\n  Лекция 5. Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 6. Основы SQL. Манипулирование данными.\n  Лекция 7. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 8. Основы NoSQL.\n\n\nЛабораторные работы\n\nЗадания для лабораторных работ\n\n\n  Модель Сущность-Связь\n  Создание таблиц\n  SQL DML. Часть 1\n  SQL DML. Часть 2\n  Представления\n  Процедуры и триггеры\n  Основы работы в MongoDB\n\n\nОтчеты по лабораторным работам\n\nОтчет по каждой лабораторной работе оформляется в соответствии с требованиями к учебным документам. Пример отчета по лабораторной работе №1 с примером в формате DOCX, в формате PDF.\n\nПрограммное обеспечение\n\nДля выполнения лабораторных работ рекомендую использовать следующее программное обеспечение и сервисы:\n\n\n  draw.io для создания ER-диаграмм;\n  DBeaver для работы с БД MySQL, SQLite\n\n\nПримеры кода\n\n\n  Подключение из Google Colab к базе данных SQLite, расположенной на Google диске.\n  Подключение к базе данных MySQL.\n  Игра “Жизнь” на SQL.\n  Пример построения сложного запроса к базе данных.\n  Подключение к БД SQLite в Google Colab.\n\n\n",
      "url": "/pages/databases/main/"
    },{
      
      "title": "Методы вычислений",
      
      "content": "Презентации\n\n",
      "url": "/pages/numerical_methods/main/"
    },{
      
      "title": "Теоретическая механика",
      
      "content": "Презентации\n\nКинематика точки\n\n",
      "url": "/pages/mechanics/main/"
    },{
      
      "title": "Дискретная модель троса",
      
      "content": "При исследовании движения тросовых систем часто используется дискретная модель троса. Трос разбивается на узлы (материальные точки), соединенные невесомыми пружинами, имитирующими упругие свойства троса.\n\nЗадание\n\nИспользуя пример программы моделирования движения груза на тросовой связи в однородном поле силы тяжести, оценить влияние количества узлов, на которые разбивается трос на точность моделирования движения тросовой системы.\n\n\n  Построить график изменения значения потенциальной энергии груза через 20 секунд после начала движения в зависимости от количества узлов (до 10 значений в интервале от от 5 до 100 ).\n  Построить график изменения значения кинетической энергии груза через 10 секунд после начала движения в зависимости от количества узлов (до 10 значений в интервале от от 5 до 100 ).\n  Построить график изменения значения потенциальной энергии системы через 20 секунд после начала движения в зависимости от количества узлов (до 10 значений в интервале от от 5 до 100 ).\n  Построить график изменения значения кинетической энергии системы через 10 секунд после начала движения в зависимости от количества узлов (до 10 значений в интервале от от 5 до 100 ).\n\n\nИсходные данные\n\n\n  Масса груза 5 кг.\n  Модуль упругости материала троса \\(10^9\\) Па.\n  Длина троса 100 м.\n  Диаметр троса 1 мм.\n  Плотность материала троса 4000 кг/м\\(^3\\).\n  В начальный момент трос расположен горизонтально.\n  Сила тяжести действует в отрицательном направлении оси y.\n\n\n",
      "url": "/pages/mechanics-in-space/mass-spring-model/"
    },{
      
      "title": "Ортогональные матрицы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Ориентация системы координат \\(C x_c y_c z_x\\), связанной с космическим аппаратом по отношению к орбитальной системе координат определяется тремя углами: углом рыскания, углом тангажа и углом крена в указанной последовательности.\n\nПервый разворот на угол рыскания \\(\\psi\\) выполняется вокруг оси \\(C x_c\\), второй разворот на угол на угол тангажа \\(\\vartheta\\) вокруг оси \\(C z_c\\), третий поворот на угол собственного вращения \\(\\varphi\\) вокруг оси \\(C y_c\\). При нулевых значениях углов система координат, связанная с космическим аппаратом, совпадает с орбитальной системой координат.\n\nЗадание 1.\n\nЗапишите матрицу преобразования координат \\(A\\) из базиса, связанного с космическим аппаратом в базис орбитальной системы координат\n\n[\\mathbf R^{(0)} = \\mathbf{A} \\mathbf R^{(c)}]\n\nЗадание 2.\n\nВ среде MATLAB напишите функцию, которая вычисляет матрицу преобразования координат \\(\\mathbf A\\).\n\nfunction A = OrientationMatrix(psi, theta, phi)\n\nA = ... ;\n\nend\n\n\nЗадание 3.\n\nКосмический аппарат освещается Солнцем, которое находится в положительном направлении оси \\(x_o\\) орбитальной системы координат. Найдите косинус угла между нормалью к панели солнечной батареи (нормаль к панели совпадает с направлением оси \\(Cx_c\\)) и направлением на Солнце. Ориентация космического аппарата определяется углами:\n\n[\\psi = 90^o]\n\n[\\vartheta = 5 + (\\text{NNNNN}\\mod 5) \\; ^o]\n\n[\\varphi = 10 + (\\text{NNNNN}\\mod 5) \\; ^o]\n\nгде NNNNN - последние пять цифр зачётной книжки.\n\n\n\nВ отчете должны быть приведены:\n\n  рисунок систем координат (орбитальной и связанной) с указанием углов между осями\n  алгоритм построения матрицы преобразования координат\n  текст MATLAB-функции (задание 2)\n  рисунок к заданию 3, алгоритм определения косинуса угла между нормалью к панели солнечной батареи и направлением на Солнце и найденное значение этого угла.\n\n",
      "url": "/pages/mbs/matrix/"
    },{
      
      "title": "Microsoft Operations Framework",
      
      "content": "Методология Microsoft Operations Framework (MOF) представляет собой библиотеку документов, опирающихся на идеи ITIL и обобщающих опыт администрирования ИТ по всему миру, накопленный консалтинговой службой компании Microsoft на основе анализа реализованных проектов и тенденций развития ИТ в компаниях разного размера и специфики бизнеса. MOF является расширением - а не замещением ITIL. Microsoft построил MOF на языке “здравого смысла” и руководствам по ITIL.\n\nMicrosoft Operations Framework (MOF). MOF является набором публикаций, обеспечивающих как наглядное (т.е.что делать и почему) так и инструктивное (т.е. как делать) пособие по Управлению Услугами ИТ. И хотя MOF предоставляет собой руководство, специфическое для продуктов и технологий Microsoft, она является моделью, которую специалисты-практики в области ИТ могут использовать для организации в целом и для распределенных и гетерогенных ИТ-инфраструктур и служб.\n\nЦель MOF\n\nЦель  MOF заключается в предоставлении ИТ-подразделениям руководств, помогающих создавать, эксплуатировать и поддерживать ИТ-услуги, обеспечивая получение ожидаемых коммерческих преимуществ от конкретных инвестиций в ИТ с приемлемым уровнем риска.\n\nМодель MOF предназначена для создания среды, в которой компания и ИТ-подразделение смогут совместно работать над совершенствованием деятельности и использовать при этом проактивную модель, определяющую процессы и стандартные процедуры, направленные на повышение эффективности и продуктивности ИТ услуг.\n\nЗадачи\n\nСледование рекомендациям MOF помогает решить ряд задач.\n\n  Снизить вероятность возникновения рисков благодаря улучшенной координации работы команд.\n  Выявить последствия несоответствия нормативным требованиям при проверке политик.\n  Предусмотреть проблемы, связанные с надежностью, и «смягчить» воздействие этих проблем.\n  Выявить возможные проблемы с интеграцией решения до внедрения его в рабочей среде.\n  Предотвратить проблемы с производительностью благодаря установке ее предусмотренных пороговых значений.\n  Эффективно адаптироваться к новым бизнес-потребностям.\n\n\nЦелевая аудитория\n\nРуководства написаны для разных целевых аудиторий:\n\n  директоров по ИТ;\n  руководителей ИТ-подразделений;\n  ИТ-специалистов.\n\n\nОбзорные руководства предназначены для директоров по ИТ, которым необходимо получить «общую картину» модели.\n\nФункциональные руководства, содержащие обзорную информацию и описание рабочих процессов, помогут руководителям ИТ-подразделений изучить стратегии предоставления ИТ-услуг.\n\nФункциональные руководства, с подробным перечнем действий, рассчитаны на ИТ-специалистов, занимающихся применением модели MOF на практике.\n\nОхват\n\nИнструкции в Microsoft Operations Framework охватывают все действия и процессы управления ИТ-услугами:\n\n  планирование;\n  разработка;\n  использование;\n  обслуживание;\n  вывод из эксплуатации.\n\n\nSMF-функция\n\nВ модели MOF эти действия и процессы упорядочены в виде функций управления ИТ-услугами (SMF-функций), которые группируются по этапам, отражающим жизненный цикл ИТ-услуги.\n\nКаждая SMF-функция относится к определенному этапу жизненного цикла и обладает уникальным набором целей и результатов, отвечающих предназначению этого этапа.\n\nКаждую SMF-функцию можно представить в виде автономного набора процессов.\n\nSMF-функции определяют процессы, персонал и действия, необходимые для приведения ИТ-услуги в соответствие с потребностями бизнеса.\n\nДля каждой SMF-функции разработано отдельное руководство с описанием самой функции, а также процессов и действий в ее составе.\n\nЖизненный цикл IT-услуги\n\nЖизненный цикл ИТ-услуги состоит из трех чередующихся этапов и одного основополагающего уровня, охватывающего все этапы.\n\n  Этап «Планирование».\n  Этап «Внедрение».\n  Этап «Эксплуатация».\n  Уровень «Управление».\n\n\nПервоначальный релиз ИТ-услуги, как правило, есть результат новой инициативы со стороны бизнеса или ИТ. На всем протяжении жизненного цикла услуги,  при внесении в нее изменений (как незначительных, так и кардинальных) необходимо придерживаться этапов жизненного цикла MOF.\n\nОбычно ИТ-подразделение одновременно управляет несколькими услугами, которые находятся на разных этапах своего жизненного цикла. Максимальные преимущества использования методологии  MOF можно получить только при условии полного понимания, как протекают и взаимодействуют этапы жизненного цикла.\n\n\n  Этап «Планирование», как правило, считается подготовительным. Он предполагает планирование и оптимизацию стратегии предоставления ИТ-услуг для соответствия бизнес-целям и задачам. На этапе «Планирование» определяются потребности компании, проверяются политики и выбирается компромиссный, с точки зрения надежности, вариант.\n  Затем начинается этап «Внедрение». Цель его - удостовериться, что все ИТ-услуги рационально разработаны, успешно внедрены и готовы к эксплуатации. На этапе «Внедрение» изменения разрабатываются и тестируются.\n  Далее следует этап «Эксплуатация», направленный на оптимальное  использование, обслуживание и поддержку ИТ-услуг в соответствии с потребностями и ожиданиями компании. На этапе «Эксплуатация» изменение внедряется в рабочую среду, по результатам мониторинга услуги в нее вносятся необходимые корректировки, а пользователям помогают устранить возникшие при этом проблемы.\n\n\nУровень управление\n\nОсновополагающими для всех вышеуказанных этапов являются процессы управления ИТ, управление рисками, обеспечение соответствия нормативным требованиям, управление ИТ персоналом и управление изменениями.\n\nУровень «Управление» — это основа жизненного цикла ИТ-услуги. Он описывает принципы и рекомендованные практики по предоставлению ИТ-услуг, обеспечивающие ожидаемые коммерческие преимущества от инвестиций  в ИТ с приемлемым уровнем риска. Процессы данного уровня выполняются на всех этапах жизненного цикла.\n\nЭтот уровень оперирует понятиями\n\n  управление ИТ,\n  риски,\n  соответствие нормативным требованиям,\n  роли и обязанности,\n  управление изменениями и конфигурациями.\n\n\nУправленческий анализ\n\nГотовность ИТ-услуги к переходу на следующий этап определяет управленческий анализ, который призван убедиться, что цели были достигнуты надлежащим образом, а цели ИТ соответствуют целям организации.\n\nЦели:\n\n  Управленческий контроль для руководства\n  Внутренний контроля на этапах жизненного цикла ИТ-услуги\n  Оценка состояния текущей деятельности\n  Предотвращение преждевременного перехода на следующий этап\n  Консолидация накопленных знаний в организации\n  Усовершенствование процессов\n\n\nВиды управленческого анализа\n\nСогласование услуги\n\nНа этапе планирование анализируются результаты обзора эксплуатационного состояния, Соглашения об уровне обслуживания (SLA), информация, полученная от  заказчика.\n\nРезультатом является возможность инициации нового  проекта или программы усовершенствования, запрос на изменение SLA.\n\nПортфолио\n\nНа этапе проектирования анализируются Планы проектов в результате формируются рабочие группы.\n\nУтверждение плана проекта\n\nАнализируются бизнес-требования, формулиру\n•\tФормулировка концепции\t\n•\tФормирование проектной группы\n•\tУтвержденный план проекта\n\nГотовность релиза\n\nЗдесь принимается решение о готовности или неготовности релиза, на основе анализа документации, подтверждающей, что релиз отвечает требованиям, что релиз стабилен, и готов к использованию.\n\nЭксплуатационное состояние\n\nАнализируются Документы по соглашениям об уровне операционного обслуживания (OLA), Отчеты о фактических значениях метрик OLA, Руководства по эксплуатации и специификации решения.\n\nРезультатами этого анализа могут быть Запросы на изменение OLA, Запрос на изменение ИТ-услуг, Изменение конфигурации ключевых компонентов технологии.\n\nПолитика и контроль\n\n\n  Политики эксплуатации и безопасности\n  Нарушения политик, инциденты, связанные с несоблюдением соответствия нормативным требованиям\n  Запросы на изменение политик\n  Изменение норм, стандартов или отраслевых образцов\n  Запросы на изменение политик и мер контроля\n  Запросы на изменение управления политиками и мерами контроля\n\n\nПланирование\n\nНа этапе «Планирование» бизнес-подразделения и ИТ совместно определяют, как ИТ-подразделение будет предоставлять услуги, необходимые для достижения успеха работы компании.\n\nЧто нужно знать на этом этапе\n\n\n  Понимание бизнес-стратегии и бизнес-требований, а также того, как текущие ИТ-услуги содействуют бизнесу.\n  Понимание значения понятия «надежности» для данной организации, а также способов ее измерения и повышения; анализ текущего состояния и его улучшение при необходимости.\n  Понимание требований организационных политик и их влияния на стратегию предоставления ИТ-услуг.\n  Финансовая структура для поддержки работы ИТ-специалистов и принятия правильных решений.\n  Создание стратегии предоставления ИТ-услуг, учитывающей особенности бизнес-стратегии, и принятие решений в отношении Портфолио услуг.\n\n\nЦель\n\nПринятие правильных решений по поводу стратегии предоставления ИТ-услуг и портфеля проектов.\n\nУслуги должны обладать следующими свойствами:\n\n  ценность и полезность с точки зрения бизнес-целей\n  прогнозируемость и надежность\n  экономическая эффективность\n  соответствие требованиям политик\n  способность адаптироваться к меняющимся потребностям компании.\n\n\nSMF-функции\n\nСоответствие ИТ и бизнеса\n\nРезультатом этой функции является стратегия предоставления ИТ-услуг. \nЦель — предоставление необходимого набора услуг бизнесу.\n\nСледствия:\n\n  Портфолио ИТ-услуг, составленный с учетом бизнес-процессов, функций и возможностей\n  Услуги, обеспечивающие конкретные бизнес-потребности\n  Информация о спросе на услуги и их использовании\n  Удовлетворенность заказчика\n\n\nНадежность\n\nКонечный результат: ИТ-стандарты\n\nЦель: Эффективность, доступность и непрерывность ИТ-услуг, а также целостность данных экономически-оправданно согласуются с бизнес-потребностями\n\nСледствия:\n\n  Планы надежности\n  Отчеты о надежности\n  Предсказуемые услуги\n\n\nПолитики\n\nКонечный результат: ИТ-политики\n\nЦель: Эффективное определение ИТ-политик и управление ими\n\nСледствия:\n\n  Документированные ИТ-политики, сопоставленные бизнес-политикам\n  ИТ-политики для эффективного управления ИТ\n  Документированные политики для следующих областей\n    \n      Безопасность\n      Конфиденциальность\n      Надлежащее использование\n      Управление отношениями с партнерами и сторонними компаниями\n      Защита активов\n    \n  \n\n\nУправление финансами\n\nКонечный результат: планирование и оценка финансирования ИТ\n\nЦель: Точное прогнозирование, учет и оптимизация затрат на ресурсы, необходимые для предоставления комплексных ИТ-услуг\n\nСледствие:\n\n  Точный учет расходов на ИТ\n  Затраты соотносятся с ИТ-услугами\n  Бюджет, в котором предусмотрены расходы на ИТ\n  Модель для определения возможностей инвестирования в ИТ и прогнозирования затрат на жизненный цикл\n\n\nВнедрение\n\nНа этапе «Внедрение» происходит планирование, проектирование, разработка и внедрение изменения для услуг.\n\nЦель\n\nЭтап «Внедрение» помогает ИТ-специалистам в сфере управления проектами эффективно разрабатывать, стабилизировать и развертывать ИТ-услуги, приложения и обновления для инфраструктуры.\n\nОсновная цель этапа «Внедрение» в том, чтобы ИТ-услуги, инфраструктурные проекты или разворачивания отдельных продуктов планировались, проектировались,  разрабатывались, стабилизировались и развертывались в соответствии с требованиями организации и спецификациями заказчика.\n\nВыполняемые задачи\n\nПроектная группа на этапе «Внедрение» выполняет следующие задачи:\n\n  Выявление потребностей и требований бизнеса перед планированием решения.\n  Подготовка функциональной спецификации и проекта решения.\n  Составление рабочих планов, смет и графиков предоставления конечных результатов.\n  \n    Разработка решения согласно спецификации заказчика (все функции имеют законченный вид, а решение готово к внешнему тестированию и стабилизации).\n  \n  Выпуск высококачественного решения, включая тщательное тестирование и пилотное развертывание версии-кандидата.\n  Развертывание устойчивого решения в рабочей среде и его стабилизация.\n  Подготовка групп эксплуатации и поддержки к сопровождению решения и обслуживанию заказчиков.\n\n\nSMF-функции\n\nПредварительное планирование (Видение)\n\nЦель\n\nЧеткое информирование о концепции, содержании и рисках проекта\n\nРезультат\nДокумент с описанием концепции проекта, в котором\n\n  Концепция и область действия проекта четко документированы и известны рабочей группе и заказчику\n  Концептуальный план предлагаемого решения входит в состав документа с описанием концепции\n  Проектные риски документированы и известны рабочей группе и заказчику\n\n\nПланирование проекта\n\nЦель\n\nПроектная группа, заказчик и заинтересованные стороны согласны с тем, что все промежуточные контрольные точки пройдены, проектные планы отражают потребности заказчика и достаточно реалистичны\n\nРезультат\n\nДокумент с описанием плана проекта:\n\n  Дизайн и функции решения четко документированы в функциональной специификации\n  Дизайн и функции решения соответствуют потребностям (бизнес, пользователи, эксплуатация и системы)\n\n\n%% 28 %%\n\nСоздание\n\nЦель\n\nСоздание решения, отвечающего ожиданиям заказчика и параметрам в функциональной спецификации\n\nКонечный результат\n\nРазработанное решение, которое, соответствует всем требованиям и ожиданиям заказчика и параметрам в функциональной спецификации\n\nСтабилизация\n\nЦель\n\nРазрешение всех проблем, обнаруженных в ходе тестирования и пилотного развертывания; выпуск высококачественного решения, отвечающего ожиданиям заказчика и параметрам в функциональной спецификации\n\nКонечный результат\nВысококачественное протестированное решение, отвечающее ожиданиям заказчика и параметрам в функциональной специификации. В решении устранены все проблемы, обнаруженные в ходе тестирования и пилотного развертывания.\n\nРазвертывание\n\nЦель\n\n\n  Развертывание стабильного решения, которое удовлетворяет заказчика.\n  Успешная передача решения от проектной группы группам эксплуатации и поддержки\n\n\nКонечный результат\n\nУслуга в действии:\n\n  Решение развернуто в рабочей среде\n  Заказчик доволен развернутым решением и принимает его\n  Решение успешно передано от проектной группы группам эксплуатации и поддержки\n\n\nЭксплуатация\n\nЭтап «Эксплуатация» — это своеобразная кульминация двух предшествующих этапов в составе жизненного цикла ИТ-услуги. Он охватывает действия, выполняемые после успешного внедрения услуги.\n\nКогда ИТ-услуга успешно внедрена, важно, чтобы она функционировала в четком соответствии с бизнес-потребностями и ожиданиями заказчика. Это и есть цель этапа «Эксплуатация».\n\nЦель\n\nЦель этапа «Эксплуатация» в том, чтобы развернутые ИТ-услуги эксплуатировались, обслуживались и поддерживались в соответствии с параметрами соглашений об уровне обслуживания (SLA), согласованными компанией и ИТ-подразделением.\n\nВ частности, это означает следующее:\n\n  Доступность ИТ-услуг благодаря более эффективному использованию ИТ-персонала и лучшему управлению нагрузкой\n  Мониторинг состояния ИТ-услуг в режиме реального времени; обучение членов команды методам быстрого и эффективного разрешения проблем.\n  Быстрое и эффективное восстановление работы ИТ-услуг.\n\n\nЗадачи\n\n  Эффективное оперативное управление услугой.\n  Проактивный и оперативный мониторинг состояния услуги.\n  Эффективное и быстрое предоставление помощи при пользовании услугой.\n  Восстановление работоспособности услуги в случае необходимости.\n\n\nSMF-функции\n\nЭксплуатация\n\n\n  Идентификация и описание работ, необходимых для успешной эксплуатации ИТ-услуг\n  Экономия времени за счет уменьшения объема работ реактивного характера, выполняемые  сотрудниками, ответственными за операционные процедуры\n  Минимизация нарушений и простоев в обслуживании\n  Эффективное и рациональное выполнение текущих эксплуатационных задач\n\n\nРезультат\n\nРуководство по эксплуатации\n\n\n  Повышение эффективности ИТ-персонала\n  Улучшение доступности ИТ-услуги\n  Улучшенная работа новых и измененных ИТ-услуг\n  Сокращение объема работ реактивного характера\n\n\nМониторинг и контроль услуг\n\nЦель\n\n\n  Мониторинг состояния ИТ-услуг\n  Принятие мер для минимизации влияния инцидентов и внутрисистемных событий\n\n\nРезультат\n\nданные мониторинга состояния ИТ-услуг\n\n\n  Улучшение общей доступности услуг\n  Сокращение количества нарушений соглашений SLA и OLA\n  Улучшенное понимание инфраструктурных компонентов, отвечаю¬щих за предоставление услуги\n  Повышение уровня удовлетворенности пользователей\n  Более эффективное и оперативное реагирование на события услуг\n\n\nОбслуживание пользователей\n\nЦель\n\n\n  Создание удобных условий для пользова-телей услуги\n  Обработка жалоб и проблемных ситуаций\n\n\nРезультат\n\nЭффективная поддержка пользователей услуги\n\n\n  Заданный уровень бизнес-продуктивности\n  Увеличение значимости ИТ-услуги\n  Повышение функцио-нальности, конкуренто-способности и эффек¬тивности бизнеса\n\n\nУправление проблемами\n\nЦель\n\n\n  Анализ ключевых причин для идентификации проблем\n  Прогнозирование проблем\n\n\nРезультат\n\nЭффективное разрешение проблем\n\n\n  Уменьшение количества инцидентов и проблем, а также их воздействия\n  Расширение перечня обходных и постоянных решений для выявленных проблем\n  Большинство проблем устраняется на ранних стадиях либо свое¬временно предотвращается\n\n\nУправление\n\nУровень «Управление» включает принятие решений, управление рисками и управление изменениями на всех этапах жизненного цикла ИТ-услуги. Кроме того, он охватывает процессы, связанные с определением ответственности и соответствующих ролей.\n\nУровень «Управление» — это фундамент для всех этапов жизненного цикла. Он обеспечивает согласованное планирование и предоставление ИТ-услуг, а также создает базу для разработки и эксплуатации устойчивой ИТ-среды.\n\nОсновная цель уровня «Управление» — интегрированный подход к управлению ИТ-услугами. Такой подход помогает координировать процессы на каждом из трех этапов жизненного цикла («Планирование», «Предоставление» и «Эксплуатация»).\n\nКоординация улучшается за счет следующих факторов:\n\n  Разработка процессов принятия решений.\n  Использование методов управления рисками и соответствующих средств контроля в составе всех процессов.\n  Контролируемые изменения и конфигурации.\n  Разделение работ на четкие и непересекающиеся сферы ответственности.\n\n\nКонкретные инструкции предназначены для повышения вероятности достижения следующих преимуществ:\n\n  Инвестиции в ИТ приводят к реализации ожидаемой коммерческой ценности.\n  Решения о распределении инвестиций и ресурсов принимаются соответствующими ролями.\n  Приемлемый уровень риска.\n  Используются контролируемые и документированные процессы.\n  Известны сферы ответственности и их владельцы.\n  Эффективные и надежные политики и внутренние меры контроля.\n\n\nДостижению этих целей способствуют следующие факторы:\n\n  Четкие структуры и процессы управления ИТ.\n  ИТ-отдел и бизнес-подразделения компании исповедуют единый подход к управлению рисками.\n  Регулярный, плановый управленческий анализ политик и внутренних мер контроля.\n\n\nSMF-функции\n\nУправление, риск и соответствие нормативным требованиям\n\nКонечный результат\n\nДостигнуты цели ИТ, изменения и риски контролируются и документируются. ИТ-услуги идеально соотносятся с бизнес-стратегией и целями.\n\nЦель\n\nПоддержка, укрепление и развитие организации с управлением рисками и ограничениями\n\nИзменение и конфигурация\n\nКонечный результат\n\nИзвестные конфигурации и прогнозируемая адаптивность. Прогнозируемые, надежные и заслуживающие доверия ИТ-услуги\n\nЦель\n\nИзменения планируются, число незапланированных изменений минимально, ИТ-услуги надежны\n\nКоманда\n\nКонечный результат\n\nЧеткие сферы ответственности, роли и назначение работ.\n\nИТ-решения предоставляются с соблюдением установленных ограничений, без незапланиро¬ванного ухудшения качества услуг. Надежное предоставление услуг бизнесу.\n\nЦель\n\nДинамичные, гибкие и масштабируемые рабочие группы.\n\n",
      "url": "/pages/it/mof/"
    },{
      
      "title": "Посадка на Луну",
      "description": "Моделирование процесса мягкой посадки на Луну космического аппарата в среде Python\n",
      "content": "Алгоритм посадки\n\nПредположим, что КА находится на опорной круговой орбите вокруг Луны высотой \\(h_0\\). Посадка КА выполняется в четыре этапа:\n\n  двухимпульсный переход с опорной круговой орбиты на круговую посадочную орбиту или орбиту ожидания с которой будет выполнятся спуск;\n  спуск (гравитационный разворот) с посадочной орбиты до некоторой небольшой высоты начала вертикального участка мягкой посадки (~100 м) – третье включение двигателя;\n  вертикальное движение КА c выключенным двигателем (свободное падение);\n  гашение вертикальной скорости и касание поверхности (четвёртое включение двигателя).\n\n\nНа первом этапе выполняется переход с начальной опорной круговой орбиты \\(h_0\\) на посадочную круговую орбиту \\(h_1\\), с которой будет выполнятся переход на траекторию спуска. Переход на посадочную орбиту выполняется по гомановской траектории.\n\n\n\nВторой этап (от \\(t_1\\) до \\(t_2\\) ) – это этап спуска с посадочной круговой орбиты до достижения заданной высоты \\(h_2\\) и скорости \\(v_2\\). На этом этапе двигатель КА создает постоянную тягу \\(F\\), направленную против вектора скорости. При такой схеме торможения обеспечивается расход топлива близкий к минимальному. Эта схема посадки использовалось КА Сервейер.\n\nДвигатель выключается на заданной высоте \\(h_2\\) при достижении скорости снижения значения \\(v_2\\) (например, \\(h_2 = 100\\) м и \\(v_2 = -1\\) м/с соответственно). Для выполнения этого условия должна быть определена высота круговой орбиты \\(h_1\\), с которой начинается спуск. Это высота может быть определена методом “пристрелки” путем интегрирования дифференциальных уравнений движения КА на втором этапе при различных значениях начальной высоты \\(h_1\\) до достижения условия\n\n[h(t_2) = h_2, \\quad v(t_2) = v_2]\n\n\n\nПосле достижения высоты \\(h_2\\) двигатель КА выключается. Далее в течение некоторого времени (третий этап) КА свободно падает до высоты запуска двигателя \\(h_3\\). Работа двигателя на четвертом участке обеспечивает касание поверхности Луны с нулевой вертикальной скоростью.\n\nВремя запуска двигателя для мягкой посадки может быть определено из уравнений вертикального движения КА в однородном гравитационном поле как материальной точки переменной массы\n\n[v_2 - g(t_{3e}+t_{23}) - I_s \\ln \\frac{m_2-bt_{3e}}{m_2} = 0]\n\n[h_2+v_2(t_{3e}+t_{23})-\\frac{g}{2}(t_{3e}+t_{23})^2-I_s\\left{\\left[t_{3e}-\\frac{m_2}{b}\\right]\\left[\\ln(1-\\frac{b}{m_2}t_{3e})-1\\right]-\\frac{m_2}{b}\\right}=0]\n\nгде \\(t_{23} = t_3 - t_2\\) – продолжительность пассивного вертикального участка, \\(t_{3e} = t_e - t_3\\) – продолжительность работы двигателя.\n\nУравнения движения\n\nУравнение движения посадочного модуля, как материальной точки переменной массы в центральном гравитационном поле Луны имеет вид:\n\n[\\ddot{\\vec{r}} = - \\mu \\frac{\\vec r}{r^3} - \\vec{e}_v \\frac{F}{m}, \\quad \\dot m = - \\frac{F}{I_s}]\n\nгде \\(\\mu\\) – гравитационный параметр Луны, \\(F\\) – сила тяги двигателя, \\(I_s\\) – удельный импульс, \\(\\vec r\\) – радиус-вектор посадочного модуля относительно центра Луны, \\(\\vec{e}_v\\) вектор направления скорости посадочного модуля:\n\n\n  \n    \n      [\\vec{e}_v = \\frac{\\dot{\\vec r}}{\n      \\dot{\\vec r}\n      }.]\n    \n  \n\n\nПроинтегрируем эти уравнения численно в среде Python.\n\nМодель посадки в среде Python\n\nПодключим необходимые библиотеки\n\n# Численные методы\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize  import fsolve\n# Класс для хранения данных\nfrom dataclasses import dataclass\nfrom typing import Callable\n# Графики\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\n\n\nПараметры рассматриваемой системы будем хранить в объекте типа dataclass.\n\n@dataclass\nclass Data:\n    # Гравитационный параметр Луны\n    mu : float = 4890.0e9;\n    # Радиус Луны\n    Rm : float = 0.5*3476e3;\n    # Начальная масса \n    m : float =  1500    \n    # Зависимость тяги двигателя \n    # посадочного модуля от времени \n    F : Callable[[float], float] = lambda t: 0\n    # Максимальная тяга\n    Fmax : float = 10e3\n    # Удельный импульс\n    Isp : float = 3500\n\n\nСоздаем экземпляр класса Data (объект)\n\np = Data()\n\n\nОбъявим функцию правых частей дифференциальных уравнений движения посадочного модуля. Первый аргумент функции – время, второй – вектор состояния системы на момент времени \\(t\\), третий аргумент – структура с данными системы. Вектор состояния системы это массив из 7 элементов:\n\n[q = [x, y, z, v_x, v_y, v_z, m_f]]\n\nгде \\(x, y, z\\) – координаты центра масс модуля в луноцентрической системе координат OXYZ, \\(v_x, v_y, v_z\\) – проекции скорости посадочного модуля в системе координат OXYZ,  \\(m_f\\) – масса израсходованного топлива.\n\ndef dqdt(t, q, p):  \n    r  = q[0:3]\n    v  = q[3:6]\n    # Израсходовано топлива\n    mf = q[6]\n    # Модуль скорости\n    vnorm = np.linalg.norm(v)\n    # Направление вектора скорости\n    ev = v/vnorm\n    # Текущая масса модуля\n    mass = p.m - mf\n    # Ускорение\n    a = - p.mu*r/(np.linalg.norm(r)**3) - ev*p.F(t)/mass\n    # Секундный расход\n    dm = np.abs(p.F(t))/p.Isp\n    return np.hstack([v,a,dm])\n\n\nОбъявим функцию, контролирующую достижение заданной радиальной скорости\n\n\n  \n    \n      [v_r = \\frac{\\vec r}{\n      \\vec r\n      } \\cdot \\dot{\\vec r}]\n    \n  \n\n\nЭта функция будет использоваться для остановки процесса интегрирования при достижении заданной радиальной (вертикальной) скорости vk. Аргументы функции: время t, вектор состояния на момент t, параметры системы p и контролируемое значение скорости vk:\n\ndef event_hv(t, q, p, vk):      \n    r = np.linalg.norm(q[0:3])\n    h = r - p.Rm\n    er = q[0:3]/r\n    vr = np.dot(q[3:6],er);\n    return vr-vk\n\n\nФункция будет возвращать ноль при равенстве вертикальной скорости заданному значению.\n\nОбъявим функцию, которая определяет высоту, при которой достигается заданная вертикальная скорость в конце второго этапа движения (торможения) \\(v_2\\) при движении с начальной круговой орбиты высотой \\(h_1\\). В функции производится интегрирование уравнений движения посадочного модуля до достижения условия \\(v_r = v_2\\):\n\ndef get_he_v_eq_0(h1, p, v2):\n    # Начальные условия\n    R0  = p.Rm+h1;\n    V0  = np.sqrt(p.mu/R0)\n    # Вектор начальных условий\n    q0  = np.array([R0,0,0,  0,V0,0,  0.0])    \n    # Уточняем функцию \"событий\"\n    ev = lambda t,q: event_hv(t,q,p,v2)\n    # Останавливаем процесс интегрирования\n    ev.terminal  = True    \n    # если функция event_hv (ее возвращаемое значение -- \n    # разность скоростей) пересекает ноль при возрастании\n    ev.direction = 1\n    # Запускаем процесс численного интегрирования    \n    sol = solve_ivp(lambda t,q: dqdt(t,q,p), [0,500], q0, method='RK45', events = [ev,], rtol = 1e-8)\n    # Определяем и возвращаем конечную высоту: \n    # высота на которой скорость стала равна vk\n    he   = np.sqrt(np.sum(sol.y[0:3]**2,axis=0))-p.Rm    \n    return he[-1]\n\n\nНачальные условия интегрирования соответствуют движению КА по круговой орбите:\n\n[\\mathbf r(0) = [ R_m + h_1,0,0]^T, \\quad \\mathbf v(0) = [0,\\sqrt{\\mu/(R_m+h_1)},0]^T]\n\nЗадавая различные значения начальной высоты h1, мы можем получить значения высоты, при которой достигается заданная вертикальная скорость v2.\n\n“Включаем” постоянную тягу\n\np.F = lambda t: p.Fmax\n\n\nПри помощи функции scipy.optimize.fsolve находим высоту посадочной круговой орбиты: включив двигатель на этой высоте и поддерживая направление силы тяги против вектора скорости, посадочный модуль достигнет высоты \\(h_2\\) = 100 м с вертикальной скоростью \\(v_2 = -1\\) м/с.\n\nh2 = +100.0\nv2 = -1.0\nh1 = fsolve(lambda x: get_he_v_eq_0(x[0], p, v2)-h2, [10000.0])[0]\n\n\nФункция scipy.optimize.fsolve численным методом находит решение нелинейного уравнения\n\n[f(\\vec x) = 0]\n\nВ рассматриваемом случае искомым аргументом этой функции является высота посадочной  орбиты \\(h_1\\). Получим численное решение для найденной начальной высоты \\(h_1\\):\n\nR0  = p.Rm+h1\nV0  = np.sqrt(p.mu/R0)\nq0  = np.array([R0,0,0, 0,V0,0.0, 0.0])\nev = lambda t,q: event_hv(t,q,p,-1.0)\nev.direction = 1\nev.terminal  = True    \nsol = solve_ivp(lambda t,q: dqdt(t,q,p), [0,500], q0, method='RK45', events = [ev,], rtol = 1e-8)  \n\n\nПостроим графики изменения высоты и вертикальной скорости посадочного модуля\n\n# Модуль радиус-вектора\nr          = np.sqrt(np.sum(sol.y[0:3]**2,0))\n# Высота\nheight     = r-p.Rm\n# Модуль скорости\nvelocity   = np.sqrt(np.sum(sol.y[3:6]**2,0))\n# Единичный вектор местной вертикали\ner         = sol.y[0:3].transpose()/np.repeat(np.sqrt(np.sum(sol.y[0:3].transpose()**2,axis=1)),3).reshape(-1,3)\n# Вертикальная скорость\nvelocity_r = np.sum(er*sol.y[3:6].transpose(),axis=1)\n\nplt.figure(figsize=[14,4])\nplt.subplot(1,2,1)\nplt.plot(sol.t,height)\nplt.xlabel('t, c')\nplt.ylabel('h, м')\nplt.grid(ls=':')\nplt.title('Высота');\n\nplt.subplot(1,2,2)\nplt.plot(sol.t,velocity_r)\nplt.xlabel('t, c')\nplt.ylabel('$v_r$, м/c')\nplt.grid(ls=':')\nplt.title('Вертикальная скорость');\n\n\n\n\nОпределим высоту начала пассивного участка, зададим скорость посадки (0) и вычислим секундны расход топлива:\n\n# Высота начала вертикального участка\nh2 = (np.sqrt(np.sum(sol.y[0:3]**2,0))-p.Rm)[-1];\n# Скорость посадки\nVe = 0;\n# Секундный расход топлива\nb  = abs(p.Fmax)/p.Isp;\n# Ускорение свободного падения (постоянное)\ng  = p.mu/p.Rm**2;\n\n\nЗададим массу посадочного модуля на момент \\(t_2\\)\n\nm2 = p.m-sol.y[6][-1]\n\n\nРешим систему уравнений для определения продолжительности свободного падения (\\(t_3 - t_2\\)) и продолжительности работы двигателя (\\(t_e - t_3\\))\n\nf1 = lambda tp,ta: v2-g*(ta+tp)-p.Isp*np.log((m2-b*ta)/m2)-Ve\nf2 = lambda tp,ta: h2+v2*(ta+tp)-g/2*(ta+tp)**2-p.Isp*((ta-m2/b)*(np.log(1-b/m2*ta)-1)-m2/b);\nf  = lambda x: (f1(x[0],x[1]), f2(x[0],x[1]));\n\nt23e = fsolve(f,[1,1])\n\nprint('Начальная высота                     {:3.1f} м'.format(h2))\nprint('Продолжительность свободного падения {:3.1f} c'.format(t23e[0]))\nprint('Продолжительность торможения         {:3.1f} c'.format(t23e[1]))\n\n\nНачальная высота                     100.0 м\nПродолжительность свободного падения 9.7 c\nПродолжительность торможения         1.8 c\n\n\nС начальными условиями, соответствующими моменту \\(t_2\\)\n\nt0  = sol.t[-1];\nq0  = sol.y[:,-1];\n\n\nПроинтегрируем уравнения движение посадочного модуля на интервале \\(t_e - t_2\\) с учетом того, что двигатель запускается через \\(t_3 - t_2\\) после начала движения\n\n# Конечное время \nte  = t23e[0]+t23e[1];           \n# Закон изменения тяги\np.F = lambda t: (t&gt;t0+t23e[0])*p.Fmax\n# Интегрируем...\nsol2 = solve_ivp(lambda t,q: dqdt(t,q,p), [t0,t0+te], q0, method='BDF', rtol = 1e-8)\n\n\nПостроим графики изменения высоты и скорости посадочного модуля на третьем и четвертом  этапах движения:\n\n# Модуль радиус-вектора\nr  = np.sqrt(np.sum(sol2.y[0:3]**2,0))\n# Высота\nh  = r-p.Rm\n# Модуль скорости\nv  = np.sqrt(np.sum(sol2.y[3:6]**2,0))\n# Единичный вектор местной вертикали\ner = sol2.y[0:3].transpose()/np.repeat(r,3).reshape(-1,3)\n# Радиальная скорость \nvr = np.sum(er*sol2.y[3:6].transpose(),axis=1)\n\nplt.figure(figsize=[14,5])\nplt.subplot(1,2,1)\nplt.plot(sol2.t,h,lw=3)\nplt.xlabel('t, c')\nplt.ylabel('h, м')\nplt.grid(True, lw=0.5, zorder=0,ls=':')\nplt.title('Высота');\n\nplt.subplot(1,2,2)\nplt.plot(sol2.t,vr,lw=3)\nplt.xlabel('t, с')\nplt.ylabel('$v_r$, м/с')\nplt.grid(True, lw=0.5, zorder=0,ls=':')\nplt.title('Вертикальная скорость');\n\n\n\n\nВ свободном падении с высоты 100 м с начальной скоростью минус 1 м/с посадочный модуль до запуска двигателя достигает скорости снижения более 15 м/с, а затем в течение 1,8 секунд гасит вертикальную скорость до момента касания поверхности Луны. Суммарный расход топлива без учета затрат на гомановский переход с опорной орбиты на посадочную орбиту составляет около 584 кг:\n\nsol2.y[6,-1]\n\n583.89\n\n",
      "url": "/pages/mechanics-in-space/moon-lander/"
    },{
      
      "title": "Численные методы",
      
      "content": "\n  Интерполяция\n  Сплайн-интерполяции\n  Решение систем линейных уравнений\n  Линейное программирование\n  Решение нелинейных уравнений\n  Решение систем нелинейных уравнений\n  Минимум функции одной переменной\n  Минимум функции нескольких переменных\n  Интегрирование\n\n\nИнтерполяция\n\nВ практике часто возникает необходимость аппроксимации некоторой табличной функции, заданной массивом аргументов \\(x_1, x_2, n_3 \\ldots, x_n\\) и массивом значений функции в этих точках \\(y(x_1), y(x_2), y(x_3), \\ldots, y(x_n)\\). Под аппроксимацией понимается подбор некоторой просто вычисляемой функции, которая приближала бы значения заданной табличной функции.\n\nИзвестны значения некоторой функции \\(y(x)\\) в точках \\(x_0, x_1, x_2, \\ldots, x_n\\):\n\n[y_0, y_1, y_2, \\ldots, y_n.]\n\nНеобходимо построить интерполирующий многочлен \\(L_{n}(x)\\), совпадающий со значениями табличной функции в точках \\(x_0, x_1, x_2, \\ldots, x_n\\) и приближающий функцию \\(y(x)\\) на интервале \\([x_0,x_n]\\).\n\nДля определения коэффициентов интерполяционного полинома, проходящего через заданные точки с координатами \\(x_1, f(x_1)\\), \\(x_2, f(x_2)\\), … \\(x_n, f(x_n)\\) используется функция polyfit:\n\n\n\nПервый аргумент функции массив значений \\(x\\), второй – массив значений функции.\n\n&gt;&gt; x = [ 1  2  3  4 ];\n&gt;&gt; y = [ 0  0.6931  1.0986  1.3863 ];\n&gt;&gt; p = polyfit(x, y, 3)\n\np =\n    0.0283   -0.3137    1.4362   -1.1507\n\n\nРезультат работы функции polyfit – коэффициенты полинома, расположенные в порядке убывания степени аргумента, при которых эти множители стоят:\n\n[P_3(x) = 0.0283 x^3 - 0.3137 x^2 + 1.4362 x - 1.1507]\n\nДля вычисления значения полинома используется функция polyval. Первый аргумент функции polyval – массив коэффициентов полинома, полученный при помощи функции polyfit, второй – одно или несколько значений аргумента \\(x\\), для которых необходимо вычислить значение полиномиальной функции:\n\n&gt;&gt; x0 = 0.1;\n&gt;&gt; polyval(p,x0)\n\nans =\n   -1.0100\n\n\n% График табличной функции (точки)\nplot(x, y, 'ro', 'LineWidth', 2);\nxlabel('x');\nylabel('y');\nhold on;\n% График полинома\nfplot(@(xa) polyval(p,xa),[x(1), x(end)],'LineWidth',2);\nhold off;\n\n\nЕсли степень многочлена, которая передается в функцию polyfit меньше, чем уменьшенное на 1 количество точек табличной функции, то коэффициенты полинома вычисляются по методу наименьших квадратов.\n\n% Столбец значений аргумента: 50 точек равномерно расположенных в интервале от 0 до 5  \nx  = linspace(0,5,50)';\n\n\nКвадрат аргумента с “шумом”: к каждому вычисленному значению добавляется случайное число от 0 до 5\n\ny  = x.^2 + rand(50,1)*5;\n\n\nОпределяем коэффициенты аппроксимирующего многочлена первого и второго порядка, которые уже, очевидно, не будут проходить через все точки табличной функции\n\np1 = polyfit(x, y, 1);\np2 = polyfit(x, y, 2);\n\n\nТочками строим график табличной функции\n\nplot(x,y,'bo')\n\n\nУдерживая (не стирая) первый график (hold on) рисуем на этом же рисунке графики аппроксимирующих многочленов при помощи функции fplot, первым аргументом которой является анонимная функция от x, вызывающая функцию polyval:\n\nhold on;\nfplot(@(x) polyval(p2,x), [0 5], 'r', 'LineWidth', 2)\nfplot(@(x) polyval(p1,x), [0 5], 'g', 'LineWidth', 2)\nhold off;\nxlabel('x'); ylabel('y');\n\n\n\n\nСплайн-интерполяции\n\nИнтерполяция кубическими сплайнами является частным случаем кусочно-полиномиальной интерполяцией. В этом специальном случае между любыми двумя соседними узлами функция интерполируется кубическим полиномом. его коэффициенты на каждом интервале определяются из условий сопряжения в узлах.\n\nДля сплайн интерполяции используется функция spline. Первый аргумент функции – строка или столбец значений аргумента, второй – строка или столбец со значениями функции, соответствующими значениям x. Третий аргумент – значения x, для которых необходимо вычислить значения функции, используя кубическую интерполяцию\n\nx  = [0 1 2 3];\ny  = exp(x);\n\nxq = linspace(0,3,10);\nyq = spline(x,y,xq)\n\nplot(x,y,'ro');\nhold on;\nplot(xq,yq,'b-');\nhold off;\nlegend('Табличная функция','Сплайн');\n\n\n\n\nДля линейно интерполяции используется функция interp1 с такой же структурой аргументов, что и функция spline. Отличие в том, что известные точки соединяются прямой линией, т.е. для определения промежуточных значений используется линейная интерполяция\n\nx  = [0 1 2 3];\ny  = exp(x);\n\nxq = linspace(0,3,10);\nyq = interp1(x,y,xq)\n\nplot(x,y,'ro');\nhold on;\nplot(xq,yq,'b-');\nhold off;\nlegend('Табличная функция','Линейная интерполяция');\n\n\n\n\nРешение систем линейных уравнений\n\nДля решения системы линейных уравнений, например\n\n[\\left{\n\\begin{aligned}\n    2 x_1 + 3 x_2 + x_3 = 5\n    x_1 + 7 x_2 + 2 x_3 = 1\n    3 x_1 + 2 x_2 + x_3 = 2\n\\end{aligned}\n\\right.]\n\nнеобходимо представить её в матричном виде\n\n[\\boldsymbol{A} \\cdot \\boldsymbol x = \\boldsymbol B]\n\nгде\n\n[\\boldsymbol A = \\begin{bmatrix} 2 &amp; 3 &amp; 1 \\ 1 &amp; 7 &amp; 2 \\ 3 &amp; 2 &amp; 1\\end{bmatrix}, \\quad\n    \\boldsymbol B = \\begin{bmatrix} 5 \\ 1 \\ 2 \\end{bmatrix}, \\quad\n    \\boldsymbol x = \\begin{bmatrix} x_1 \\ x_2 \\ x_3 \\end{bmatrix}, \\quad]\n\nДля определения столбца неизвестных \\(\\boldsymbol x\\) используется оператор \\\n\n&gt;&gt; A = [2 3 1; 1 7 2; 3 2 1];\n&gt;&gt; B = [5;1;2];\n&gt;&gt; x = A\\B\n\nx =\n    6.0000\n    9.0000\n  -34.0000\n\n\nЛинейное программирование\n\nЛинейное программирование — это математический численный метод для оптимизации моделей, в которых целевые функции\n\n[f(x_1,x_2,\\ldots,x_n) \\rightarrow min]\n\nи ограничения, например\n\n[g(x_1,x_2,\\ldots,x_n) &gt; 0]\n\nявляются уравнениями линейной алгебры.\n\nРассмотрим следующий пример. Предположим, что есть 4 типа продукта, для производства которых необходимо 3 типа сырья. В таблице приведены затраты сырья на производство каждого продукта, запасы сырья на складе и прибыль, получаемая от продажи единицы продукта.\n\n\n  \n    \n      Вид сырья\n      Продукт 1\n      Продукт 2\n      Продукт 3\n      Продукт 4\n      Запасы сырья\n    \n  \n  \n    \n      Сырьё 1\n      4 кг\n      2 кг\n      1 кг\n      8 кг\n      \\(\\leq 1200\\) кг\n    \n    \n      Сырьё 2\n      2 кг\n      10 кг\n      6 кг\n      0 кг\n      \\(\\leq 600\\) кг\n    \n    \n      Сырьё 3\n      3 кг\n      0 кг\n      6 кг\n      1 кг\n      \\(\\leq 1500\\) кг\n    \n    \n      Прибыль\n      15 р\n      6 р\n      12 p\n      24 p\n      максимум\n    \n  \n\n\nНеобходимо составить план производства, который бы привёл к максимальной прибыли с учетом имеющихся запасов на складе.\n\nПрибыль (целевая функция)\n\n[S = x_1 s_1 + x_2 s_2 + x_3 s_3 + x_4 s_4 \\rightarrow max]\n\nОграничения\n\n[x_1 a_{11} + x_2 a_{12} + x_3 a_{13} + x_4 a_{14} \\leq 1200]\n\n[x_1 a_{21} + x_2 a_{22} + x_3 a_{23} + x_4 a_{24} \\leq 600]\n\n[x_1 a_{31} + x_2 a_{32} + x_3 a_{33} + x_4 a_{34} \\leq 1500]\n\nВ MATLAB для решения этой задачи используется функция linprog\n\nx = linprog(f,Ane,Bne,Ae,Be,lb,ub)\n\n\n[\\min_{x} \\boldsymbol{f}^T x]\n\nПри условиях равенствах\n\n[\\boldsymbol{A}_e \\boldsymbol{x} = \\boldsymbol{B_e}]\n\nПри условиях неравенствах\n\n[\\boldsymbol{A}{ne} \\boldsymbol{x} \\leq \\boldsymbol{B{ne}}]\n\nПри условии\n\n[\\boldsymbol{L} \\leq \\boldsymbol{x} \\leq \\boldsymbol{U}]\n\nВ рассматриваемой задаче есть целевая функция и ограничения – неравенства. Функция  linprog ищет минимум функции, поэтому для максимизации прибили у коэффициентов рассматриваемой целевой функции нужно поменять знак.\n\n&gt;&gt; f = -[15 6 12 24];\n\n\nУсловия-неравенства (запасы сырья на складе) описываются матрицей коэффициентов Ane и матрицей запасов Bne\n\n&gt;&gt; Ane = [4 2 1 8; 2 10 6 0; 3 0 6 1];\n&gt;&gt; Bne = [1200; 600; 1500];\n\n\nВызываем функцию linprog\n\n&gt;&gt; x = linprog(f,Ane,Bne,[],[],[0 0 0 0],[])\n\nOptimal solution found.\n\nx =\n\n         0\n         0\n  100.0000\n  137.5000\n\n\nТаким образом, оптимальным планом будет производство 100 ед продукта 3 и 137 ед продукта 4.\n\nРешение нелинейных уравнений\n\nДля решения уравнений вида\n\n[f(x) = 0]\n\nиспользуется функция fzero, первым аргументом которой является ссылка на функцию \\(f(x)\\), вторым – начальное приближение для искомого значения решения уравнения или интервал внутри которого находится решение:\n\n&gt;&gt; fzero( @(x) cos(x) - x, 1)\n\nans =\n    0.7391\n\n\nРешение систем нелинейных уравнений\n\nДля решения системы нелинейных уравнений используется функция fsolve. Например, для решения системы\n\n[\\left{\n\t\\begin{aligned}\n\tx^2 + y^2 + z^2 - 1 &amp; = 0 \\ \n\t2x^2 + y^2 - 4z  &amp; = 0 \\ \n\t3x^2 - 4y + z^2  &amp; = 0 \n\t\\end{aligned}\n\t\\right.]\n\nнеобходимо написать m-файл с функцией\n\n% Файл f.m\nfunction y = f(x)\n    y = [x(1)^2+x(2)^2+x(3)^2-1;\n         2*x(1)^2+x(2)^2-4*x(3);\n         3*x(1)^2-4*x(2)+x(3)^2];\n\n\nДля поиска решения необходимо вызвать функцию fsolve, передав ей ссылку на функцию и вектор начального приближения \\([x_0, y_0, z_0]\\)\n\n&gt;&gt; fsolve(@y,[1;1;1])\n\nans =\n    0.7852\n    0.4966\n    0.3699\n\n\nМинимум функции одной переменной\n\nПоиск минимума функции \\(f(x)\\) на интервале \\([x_1, x_2]\\)\n\n&gt;&gt; fun = @(x) x^2 - 0.3*x^3 + 3 + cos(4*x)^2;\n&gt;&gt; fplot(fun,[-1 3]);\n&gt;&gt; fminbnd(fun,-1,3)\n\nans = \n    0.372\n\n\n\n\nМинимум функции нескольких переменных\n\nНайти минимум функции нескольких переменных\n\n[\\min_{\\boldsymbol x} f(\\boldsymbol x), \\quad \\boldsymbol{x} = [x_1,x_2,\\ldots,x_n]]\n\nПример:\n\n[f(x)=100(x_2 − x_1^2)^2+(1−x_1)^2]\n\nиспользуется функция fminsearch. Первый аргумент функции – ссылка на вектор-функцию от векторного аргумента, второй – начальное приближение\n\n&gt;&gt; fun = @(x1,x2) 100*(x2-x1.^2).^2+(1-x1).^2;\n&gt;&gt; x1 = linspace(0,3,100);\n&gt;&gt; x2 = linspace(0,3,100);\n&gt;&gt; [X1,X2] = meshgrid(x1,x2);\n&gt;&gt; f = fun(X1,X2);\n&gt;&gt; contour(X1,X2,f,200);\n&gt;&gt; fminsearch(@(x) fun(x(1),x(2)),[0, 0.5])\n\nans =\n    1.0000    1.0000\n\n\n\n\nИнтегрирование\n\nДля функции, заданной таблично, интеграл можно вычислить используя формулу трапеций, используя функцию trapz:\n\n&gt;&gt; x = 1.0:0.1:2.0;\n&gt;&gt; y = log(x);\n&gt;&gt; trapz(x, y)\n\nans =\n    0.3859\n\n\nТочное значение интеграла равно \\(\\log 4 - 1 \\approx 0.386294361119891\\).\n\nДля известной подинтегральной функции более точный результат дает использование функции quad, в которую нужно передать ссылку на подинтегральную функцию и пределы интегрирования\n\n[F = \\int_1^2 \\ln(x) dx]\n\n&gt;&gt; format long\n&gt;&gt; quad(@log, 1, 2)\n\nans =\n   0.386294334336416\n\n\nТретьим аргументом функции quad является желаемая точность результата (по умолчанию – \\(10^{-6}\\) )\n\n&gt;&gt; f = @(x) sin(x).*log(x).^2;\n&gt;&gt; quad(f, 1, 2, 1e-8)\n\nans =\n   0.1822\n\n",
      "url": "/pages/matlab/numeric/"
    },{
      
      "title": "Лабиринт",
      
      "content": "\n  Задана прямоугольная область \\(n \\times m\\) клеток\n  Каждая клетка может быть пустой или занята препятствием\n  Построить алгоритм определения пути для перемещения  из точки с координатами \\(x_0\\), \\(y_0\\) в точку с координатами \\(x_k\\), \\(y_k\\).\n  Перемещаемая точка может двигаться в произвольном направлении по клеткам, не занятым препятствиями.\n  Программа должна генерировать прямоугольную область с препятсвиями, выводить на экран поле и найденный маршрут.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/obstacles/"
    },{
      
      "title": "Управление процессом численного интегрирования (триггеры/события)",
      
      "content": "Рассмотрим движение материальной точки, положение которой определяется двумя координатами \\(x\\) и \\(y\\) в вертикальной плоскости в ограниченном пространстве:\n\n[x_{min} \\leq x \\leq x_{max}, \\quad y_{min} \\leq y \\leq y_{max}.]\n\nПредположим, что точка движется под действием силы тяжести и ее уравнения движения имеют вид:\n\n[\\left{\n    \\begin{aligned}\n    \\dot x  &amp; = &amp; V_x \n    \\dot y  &amp; = &amp; V_y \n    \\dot{V}_x &amp; = &amp; 0 \n    \\dot{V}_y &amp; = &amp; -g \n    \\end{aligned}\n\\right.]\n\n\n\nПусть при достижении правой или левой границы происходит отскок материальной точки от стенки (границы) с потерей энергии, так что:\n\n[V_x^+ = - k V_x^-, \\quad V_y^+ = \\cdot V_y^-,]\n\nгде \\(V_x^-\\), \\(V_x^+\\) – проекции скорости точки на ось x до и после удара соответственно, \\(V_y^-\\), \\(V_y^+\\) – проекции скорости точки на ось y до и после удара. \\(0 &lt; k \\leq 1\\) – коэффициент восстановления.\n\nТакже, при ударе точки о верхнюю  \\(y = y_{max}, \\, V_y&gt;0\\) или нижнюю границы \\(y = y_{min}, \\, V_y&lt;0\\):\n\n[V_x^+ = V_x^-, \\quad V_y^+ = -k \\cdot V_y^-,]\n\nПри моделировании движения такой механической системы в MATLAB необходимо останавливать процесс численного интегрирования при достижении любой из границ и запускать следующий процесс численного интегрирования с новыми начальными условиями (скоростями точки).\n\nСоздадим файл-скрипт и объявим в нем параметры системы при помощи структуры p, функцию правых частей дифференциальных уравнений pool_dqdt и начальные условия движения материальной точки:\n\nclc; clear all;\n\np.xmin = -2;\np.xmax = +5;\np.ymin = -2;\np.ymax = +2;\np.g    = 9.807;\np.vmin = 0.1;\n\n% Функция правых частей\npool_dqdt = @(t,q,p) [q(3:4);0;-p.g];\n\n% Начальные условия\nx0  = 0;  \ny0  = 0;\nvx0 = 10*cos(45*pi/180); \nvy0 = 10*sin(45*pi/180);\nq0  = [x0;y0;vx0;vy0];\n\n\nСоздадим еще один файл – файл-функцию pool_event_function, аргументами которой является время t, соответствующий этому времени координатный столбец вектора состояния системы \\([x,y,V_x,V_y]\\) и структура с параметрами системы.\n\nВ функции определяется вектор функция value, состоящая из 4 элементов. При пересечении границ поля точкой один элементов этого вектора становится равным нулю. Переменная direction определяет направление изменения компонентов вектор-функции, объявленной в переменной value, которые контролируется. Например, если значение x-p.xmin (первый элемент массива  value) пересечёт ноль при убывании x direction(1)=-1, то процесс интегрирования необходимо остановить isterminal(1)=1. Вторые элементы массивов value, direction, isterminal отвечают за контроль условия\n\n[x(t) - x_{max} = 0, \\quad \\dot x(t) &gt; 0]\n\nПоследний пятый элемент “следит” за уменьшением скорости движения материальной точки. Если эта скорость падает (direction(5)=-1) до значений меньше (по модулю) p.vmin, то процесс интегрирования также останавливается.\n\nfunction [value,isterminal,direction] = pool_event_function(t, q, p)\n  x = q(1);      \n  y = q(2);\n  % Скорость точки (модуль)  \n  v = norm(q(3:4));\n  % Контрольные функции\n  value      =  [x-p.xmin x-p.xmax y-p.ymin y-p.ymax v-p.vmin]; \n  % Направление изменений функций при пересечении нуля  \n  direction  = [-1 +1 -1 +1 -1]; \n  % Остановить процесс интегрирования [1 - да, 0 - нет], \n  isterminal =  [1 1 1 1 1]; \nend\n\n\nВернемся в главный файл-скрипт. При помощи функции odeset создадим структуру параметров интегрирования opt, указав, что в процессе интегрирования необходимо контролировать события, определенные в функции pool_event_function:\n\nopt = odeset('Events', @(t,q) pool_event_function(t,q,p));\n\n\nДалее зададим интервал интегрирования и объявим пока пустые массивы для хранения результатов интегрирования:\n\nt0 = 0 ; dt = 20;\nt = []; q = [];\n\n\nИнтегрирование производится интервалами по dt = 20 секунд (от t0 до t0+dt). Первый запуск процесса численного интегрирования выполняется для интервала от 0 до 20 секунд с начальными условиями q0. При “срабатывании” любого из пяти событий, определенных в функции  события pool_event_function, процесс интегрирования останавливается, при этом в переменную te записывается время наступления события, в переменную qe вектор состояния системы (строка: \\([ x,y,V_x,V_y ]\\) ) в этом момент, в переменную ie – номер сработавшего события или номера событий, если “сработало” несколько условий сразу. При помощи конструкции switch, case определяется номер события и в соответствии с ним изменяются начальные условия – меняются значения скоростей с учетом коэффициента восстановления. Для пятого события определяется, не находится ли точка, скорость которой уменьшилась до уровня менее p.vmin, ниже уровня p.ymin+0.01. Если да, то в переменную stop  записывается значение true. На выходе из блока switch Задается новое значение начала интервала интегрирования и результаты интегрирования присоединяются к массивам t и q.\n\nstop = false;\nfor i=1:100\n    [ti,qi,te,qe,ie] = ode45(@(t,q) pool_dqdt(t,q,p), [t0:0.1:t0+dt], q0, opt); \n    switch ie\n        case 1\n            q0 = qe'.*[1; 1; -0.9; 1]; \n        case 2            \n            q0 = qe'.*[1; 1; -0.9; 1]; \n        case 3\n            q0 = qe'.*[1; 1;  1.0 ;-0.9]; \n        case 4\n            q0 = qe'.*[1; 1;  1.0 ;-0.9]; \n        case 5            \n            if qe(2) &lt; p.ymin+0.01\n                stop = true;\n            end\n            q0 = qe'; \n    end\n    t0 = te;   \n    q = [q;qi]; \n    t = [t;ti];\n    if stop\n        break;\n    end\nend\n\n\nВ следующем блоке кода главного файл-скрипта из массива решения удаляются строки с одинаковыми значениями времени при помощи функции unique. Это необходимо сделать для того, чтобы можно было выполнять интерполирование по таблице полученного решения. Функция интерполирования требует монотонного роста таблицы аргумента (времени) интерполируемой табличной функции.\n\n[t, iu] = unique(t);\nq = q(iu,:);\n\n\nДалее создается видеофайл, в который записываются кадры движения материальной точки. Весь интервал времени от 0 до max(t) разбивается на 800 точек равномерно при помощи функции linspace. При помощи функции интерполяции interp1 определяется положение точки в каждый момент времени ti (от 0 до max(t)).\n\nv = VideoWriter('pool.avi');\nopen(v);\nfor ti = linspace(0,max(t),800)\n    r = interp1(t,q(:,1:2),[(ti-0.5)*(ti&gt;0.5):0.02:ti]); \n\n    plot(r(:,1),r(:,2),'*-','LineWidth',1);\n    daspect([1,1,1]);\n    xlim([p.xmin,p.xmax]);\n    ylim([p.ymin,p.ymax]);\n    frame = getframe(gcf);\n    writeVideo(v,frame);\nend\nclose(v);\n\n\n\n",
      "url": "/pages/matlab/ode-event/"
    },{
      
      "title": "Интегрирование уравнений движения эллиптического мятника в MATLAB",
      
      "content": "Рассмотрим задачу численного интегрирования уравнений движения эллиптического маятника, схема которого показана на рисунке 1. Эллиптический маятник состоит из поступательно движущейся платформы 1 и груза 2, подвешенного на невесомом стержне, который шарнирно закрепляется на платформе в точке А. Известны масса платформы \\(m_1\\), масса груза \\(m_2\\) и длина подвеса \\(l = AB\\).\n\n\n\nРисунок 1 - Эллиптический маятник\n\nПоложение системы определяется перемещением платформы относительно некоторой точки O на горизонтальной прямой (обобщенная координата \\(x\\)), и углом отклонения подвеса от вертикальной прямой (\\(\\varphi\\)). Движение системы происходит в поле силы тяжести. Ускорение свободного падения направлено вдоль оси \\(y_0\\).\n\nУравнения движения эллиптического маятника имеют вид:\n\n[\\left{\n\\begin{aligned} \n  &amp; \\ddot x \\cos \\varphi + \\ddot \\varphi l = -g \\sin \\varphi \n  &amp; \\ddot x (m_1+m_2) + \\ddot \\varphi l m_2 \\cos \\varphi = l m_2 \\dot{\\varphi}^2 \\sin \\varphi \n\\end{aligned}\n\\right.]\n\nДля численного интегрирования этой системы дифференциальных уравнений в MATLAB необходимо:\n\n\n  преобразовать её к системе дифференциальных уравнений первого порядка, введя дополнительные переменные: \\(v = \\dot x\\)  - линейная скорость платформы; \\(\\omega = \\dot \\varphi\\)  - угловая скорость поворота подвеса,\n  привести систему к форме Коши, выразив производные вектора состояния системы \\((x, \\varphi, v, \\omega)\\):\n\n\n[\\left{\n\\begin{aligned} \n  &amp; \\dot x = v, \n  &amp; \\dot \\varphi = \\omega, \n  &amp; \\dot v = f_v(t, x, \\varphi, v, \\omega), \n  &amp; \\dot \\omega = f_\\omega(t, x, \\varphi, v, \\omega). \n\\end{aligned}\n\\right.]\n\nПравые части последних двух уравнений системы могут быть получены из исходной системы двух дифференциальных уравнений второго порядка, которые представляют собой систему линейных уравнения относительно вторых производных:\n\n[\\left{\n\\begin{aligned} \n  &amp; a_{11} \\ddot x  + a_{12} \\ddot \\varphi = b_1 \n  &amp; a_{21} \\ddot x  + a_{22} \\ddot \\varphi = b_2\n\\end{aligned}\n\\right.]\n\nили в матричной форме\n\n[\\begin{bmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{22} \\end{bmatrix} \n\\begin{bmatrix} \\ddot x \\ \\ddot \\varphi \\end{bmatrix}\n=\n\\begin{bmatrix} b_1 \\ b_2 \\end{bmatrix}]\n\nгде\n\n[\\begin{aligned}\n&amp; a_{11} &amp; = &amp; \\cos \\varphi \\ \n&amp; a_{12} &amp; = &amp; l \n&amp; a_{21} &amp; = &amp; m_1 + m_2 \n&amp; a_{22} &amp; = &amp; l m_2 \\cos \\varphi \n&amp; b_{1}  &amp; = &amp; - g \\sin \\varphi \\ \n&amp; b_{2}  &amp; = &amp; l m_2 \\dot{\\varphi}^2 \\sin \\varphi \n\\end{aligned}]\n\nВ результате решения этой системы линейных уравнений находятся значения \\(\\ddot x, \\ddot \\varphi\\)\n\n[\\ddot x = \\dot v = f_v(t, x, \\varphi, v, \\omega)]\n\nи\n\n[\\ddot \\varphi = \\dot \\omega = f_\\omega(t, x, \\varphi, v, \\omega)]\n\nВ рассматриваемом случае необходимо решить систему двух линейных уравнений, что можно сделать аналитически и полученные выражения \\(f_v(t, x, \\varphi, v, \\omega)\\) и \\(f_\\omega(t, x, \\varphi, v, \\omega)\\) использовать при разработке файл-функции правых частей дифференциальных уравнений.\n\nДля систем с большим числом степеней свободы аналитическое решение системы линейных относительно вторых производных обобщенных координат может быть очень громоздким, поэтому целесообразно решать эту систему численно в файл-функции правых частей.\n\nФайл-функция правых частей\n\nСоздадим файл-функцию правых частей dq_elliptic(t, q, p), которая принимает в качестве аргументов текущее время, вектор состояния системы (столбец) и структуру с её параметрами. Примем следующий порядок обобщенных координат и скоростей в векторе q: \\(x\\), \\(\\varphi\\), \\(v\\), \\(\\omega\\).\n\nfunction dq = dq_elliptic(t, q, p)\n    % Даем имена элементам q для удобства чтения кода \n    x   = q(1);\n    phi = q(2);\n    v   = q(3);\n    w   = q(4);\n\n    % Формируем матрицу коэффициентов aij (построчно)\n    A = [cos(phi), p.l; p.m1+p.m2, p.m2*p.l*cos(phi)];\n    % Формируем матрицу-столбец B\n    B = [-p.g*sin(phi); p.l*p.m2*w*w*sin(phi)];\n\n    % Решаем систему линейных уравнений \n    % относительно вторых производных \n    % обобщенных координат\n    accel = A\\B;\n\n    % Извлекаем из решения\n    % ускорение платформы \n    ax = accel(1);\n    % и угловое ускорение поворота стержня\n    dw = accel(2);\n\n    % формируем результат работы функции -- производную вектора состояния\n    dq = [v; w; ax; dw];\n\n\n\nГлавный файл-скрипт\n\n% Параметры системы\np.l  = 1;\np.m1 = 5;\np.m2 = 2;\np.g  = 9.807;\n\n% Начальные условия\nx0   = 0;\nphi0 = 60*pi/180;\nv0   = 0;\nw0   = 0; \n\nq0 = [x0; phi0; v0; w0];\n\n% Интервал интегрирования\n% Получить решение на интервале от 0 до 5 секунд с шагом 0.01 с \nts = 0:0.01:5;\n\n% Запускаем процесс интегрирования\n[t, q] = ode45(@(t,q) dq_elliptic(t, q, p), ts, q0);\n\n% Графики перемещения платформы и угла поворота от времени \nsubplot(2,1, 1);\nplot(t, q(:,1));\nxlabel('t, c');\nylabel('x, м');\n\nsubplot(2,1, 2);\nplot(t, q(:,2));\nxlabel('t, c');\nylabel('\\phi, градус');\n\n\n\n\n\nМатрица масс\n\nЗадачу разрешения уравнений относительно старших производных (решение системы линейных уравнений относительно производных) можно делегировать MATLAB-у исключив её из кода файл-функции правых частей. Для этого необходимо создать отдельную файл-функцию, которая вычисляет (возвращает) матрицу коэффициентов при производных системы дифференциальных уравнений.\n\nДля рассматриваемого примера систему дифференциальных уравнений первого порядка в матричной форме можно записать в виде:\n\n[\\begin{bmatrix}\n1 &amp; 0 &amp; 0 &amp; 0 \n0 &amp; 1 &amp; 0 &amp; 0 \n0 &amp; 0 &amp; a_{11} &amp; a_{12} \n0 &amp; 0 &amp; a_{21} &amp; a_{22} \n\\end{bmatrix}\n\\begin{bmatrix}\n\\dot x \n\\dot \\varphi \n\\dot v \n\\dot \\omega \n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv \n\\omega \nb_1 \nb_2 \n\\end{bmatrix}]\n\nМатрица коэффициентов при производных имеет размерность \\(4 \\times 4\\). Создадим файл-функцию mass.m, которая вычисляет эту матрицу для заданного момента времени и вектора состояния системы. Третьим аргументом также будем передавать  в эту функцию структуру с параметрами системы:\n\nfunction m = mass(t, q, p)\n    phi = q(1);    \n    m = [1,  0,  0,   0;\n         0,  1,  0,   0;\n         0,  0,  p.l, cos(phi); \n         0,  0,  p.l*p.m2*cos(phi), (p.m1+p.m2)];    \nend\n\n\nФайл-функция правых частей (right_side.m) будет возвращать только матрицу-столбец правой части системы:\n\n[\\begin{bmatrix}\nv \n\\omega \nb_1 \nb_2 \n\\end{bmatrix}]\n\n% Функция правых частей\nfunction dq = right_side(t,q,p)\n    phi = q(1);\n    w   = q(3);            \n    dq = [q(3); q(4); -p.g*sin(phi); p.l*p.m2*w*w*sin(phi)];\nend\n\n\nВ главном файл-скрипте перед запуском процесса интегрирования необходимо сформировать структуру с дополнительными параметрами для интегратора при помощи функции odeset.\n\nАтрибуту ‘Mass’ необходимо присвоить ссылку на файл-функцию, вычисляющую “матрицу масс” (это должна быть функция двух переменных, поэтому используем анонимную функцию-“обертку”).\n\nПри вызове функции ode45 первым аргументом будет ссылка на функцию, вычисляющую правую часть системы дифференциальных уравнений – right_side. Последним аргументом передается структура opt с параметрами интегрирования:\n\n...\n...\n\n% Сообщаем численному методу дополнительные параметры, в \n% том числе ссылку на функцию, вычисляющую матрицу коэффициентов \n% при производных mass(...)\nopt = odeset('Mass', @(t,q) mass(t,q,p), 'RelTol', 1e-5);\n\n% Запускаем процесс интегрирования\n[t, q] = ode45(@(t,q) right_side(t, q, p), ts, q0, opt);\n\n...\n...\n\n\n\n",
      "url": "/pages/matlab/ode_elliptic/"
    },{
      
      "title": "Интегрирование дифференциального уравнения в MATLAB",
      
      "content": "\n  Модель\n  Функция правых частей\n  Запуск процесса численного интегрирования\n  Передача в функцию правых частей дополнительных параметров\n  Управления точностью численного интегрирования\n\n\nМодель\n\nРассмотрим простейшее дифференциальное уравнение математического маятника\n\n[\\ddot{\\varphi} = - \\frac{g}{l} \\sin \\varphi]\n\nгде \\(g\\) - ускорение свободного падения, \\(l\\) - длина подвеса материальной точки, \\(\\varphi\\) – угол отклонения маятника от вертикали.\n\n\n\nНеобходимо численно проинтегрировать это уравнение для следующих начальных условий:\n\n[\\varphi(0) = 60^{\\circ}, \\quad \\dot{\\varphi}(0) = 0.]\n\nДля того, чтобы в MATLAB численно проинтегрировать дифференциальное уравнения второго порядка, это уравнение необходимо привести к системе двух дифференциальных уравнений первого порядка. Для этого введём новую переменную – угловую скорость \\(\\omega = \\dot{\\varphi}\\), и запишем следующую эквивалентную систему дифференциальных уравнений:\n\n[\\begin{cases}\n\\dot{\\varphi} = \\omega, \n\\dot{\\omega} = - \\frac{g}{l} \\sin \\varphi.\n\\end{cases}]\n\nФункция правых частей\n\nПолученную систему дифференциальных уравнений можно представить в матричной форме:\n\n[\\dot{\\mathbf{q}} = \\mathbf{f}(t, \\mathbf{q})]\n\nгде \\(\\mathbf{q}\\) – вектор состояния системы (матрица-столбец):\n\n[\\mathbf{q} = \\begin{bmatrix} \\varphi \\ \\omega \\end{bmatrix}]\n\n\\(\\mathbf{f}\\) – векторная функция векторного аргумента и, может быть, времени. Эту функцию далее будем называть функцию правых частей системы дифференциальных уравнений:\n\n[\\mathbf{f}(t, \\mathbf{q}) = \\begin{bmatrix} \\omega \\ - \\frac{g}{l} \\sin \\varphi \\end{bmatrix} = \\begin{bmatrix} q_2 \\ - \\frac{g}{l} \\sin q_1 \\end{bmatrix}]\n\nДля интегрирования системы уравнений в MATLAB необходимо создать файл-функцию двух аргументов: времени и вектора состояния. Для рассматриваемого примера системы дифференциальных уравнений файл-функция правых частей может иметь такой вид:\n\nfunction dq = f(t, q)\n    % Для наглядности дадим элементам вектора состояния\n    % более понятные имена,  \n    phi = q(1); %  1 элемент q - угол\n    w   = q(2); %  2 элемент q - угловая скорость\n\n    g   = 9.807; % ускорение свободного падения\n    l   = 1.0;   % длина подвеса груза\n\n    % Первое уравнение системы диф. уравнений\n    % Производная фи = угловая скорость\n    dphi  = w;\n    % Второе уравнение системы\n    % Производная угловой скорости = угловое ускорение\n    dw    = -g*sin(phi)/l;\n\n    % Результат работы функции -- производная вектора состояния\n    dq    = [dphi; dw];\n\n\nЗапуск процесса численного интегрирования\n\nДля запуска процесса численного интегрирования MATLAB предлагает несколько функций, отличающихся методом используемого численного интегрирования (ode45, ode113, ode23, …). Например, для интегрирования методом Рунге-Кутты 4-го и 5-го порядков с автоматическим выбором шага интегрирования в зависимости от заданной точности используется функция ode45.\n\nСоздадим и запустим файл-скрипт main.m со следующим кодом:\n\n% Вектор-столбец начальных условия [угол; угловая скорость]\nq0 = [60*pi/180; 0];\n\n% Интервал интегрирования от 0 до 2 с\nts = [0, 2];\n\n% Запускаем процесс интегрирования:\n% Вызываем функцию ode45, передавая ей ссылку на функцию правых частей\n% интервал интегрирования и вектор-столбец начальных условий\n[t, q] = ode45(@f, ts, q0);\n\n\n\nВектор начальных условий q0 содержит начальный угол поворота маятника (первый элемент) и угловую скорость (второй элемент). Этот же порядок следования переменных состояния ожидается в функции правых частей.\n\nФункция ode45 в этом примере записывает результат своей работы в столбец t и прямоугольную матрицу q. В столбце t содержатся моменты времени, для которых  получены решения. Первый элемент в этом столбце равен 0 с, последний  2 c. Количество промежуточных значений алгоритм численного интегрирования определяет автоматически, исходя из требований точности интегрирования.\n\nМатрица q содержит результаты интегрирования. Число строк этой матрицы равно числу строк столбца t, а в каждой строке матрицы q(k,:) содержится вектор-строка состояния системы, соответствующий моменту времени t(k).\n\nДалее в файл-скрипте main.m можно построить график зависимости от времени угла отклонения маятника:\n\nplot(t, q(:,1)*180/pi);\nxlabel('t, c');\nylabel('\\phi, градус');\n\n\nПередача в функцию правых частей дополнительных параметров\n\nВ написанной выше функции правых частей параметры рассматриваемой механической системы \\(g\\) и  \\(l\\) были заданы непосредственно в коде функции, что нельзя назвать хорошей практикой программирования, поскольку смешивается код и данные модели. Отделим код модели от её данных, для этого перенесем определение всех параметров системы в главный файл-скрипт main.m, а сами параметры будем передавать в функцию правых частей третьим аргументом. Новое определение функции будет иметь следующий вид:\n\nfunction dq = f(t, q, p)\n    % Для наглядности дадим элементам вектора состояния \n    % более понятные имена\n    phi = q(1); %  1 элемент вектора q - угол\n    w   = q(2); %  2 элемент вектора q - угловая скорость\n\n    % Для сокращения записи уравнений движения\n    % перепишем значения полей структуры \n    % в новые локальные переменные\n    g = p.g;\n    l = p.l;\n\n    % Первое уравнение системы\n    dphi  = w;\n    % Второе уравнение системы\n    dw    = -g*sin(phi)/l;\n\n    % Результат работы функции -- производная вектора состояния\n    dq    = [dphi; dw];\n\n\nВ функцию правых частей третьим аргументом передаётся структура p, с атрибутами (полями) p.l и p.g, значения которых используются в коде функции. Структуру необходимо создать в главном файл-скрипте main.m:\n\n% Параметры системы\np.g = 9.807; % ускорение свободного падения\np.l = 1.0;   % длина подвеса\n\n% Начальные условия\nq0 = [60*pi/180; 0];\n% Интервал интегрирования\nts = [0, 2];\n\n\nФункция ode45 ожидает, что первым аргументов будет ссылкой (@) на функцию двух переменных (время и вектор состояния),  но новая функция правых частей это функция трех переменных – f(t,q,p). Для адаптации новой функции f используем анонимную функцию-обёртку двух переменных (t, q), которая будет вызывать функцию f, передавая в нее t и q, а также структуру с параметрами системы.\n\nf2 = @(t, q) f(t,q,p);\n[t, q] = ode45(@f2, ts, q0);\n\n\nили в одну строчку\n\n[t, q] = ode45(@(t, q) f(t,q,p), ts, q0);\n\n\nУправления точностью численного интегрирования\n\nДля управления точностью интегрирования в функцию ode45 необходимо передать дополнительный параметр (структуру), которая создается при помощи специальной функции odeset. Например, для того чтобы задать относительную погрешность равную \\(1 \\cdot 10^{-8}\\), а абсолютную погрешность \\(1 \\cdot 10^{-10}\\) необходимо вызвать функцию со следующими аргументами:\n\noptions = odeset('RelTol', 1e-8, 'AbsTol', 1e-10);\n\n\nПри численном интегрировании MATLAB будет пытаться выполнить условия\n\n[\\varepsilon_i \\leq \\max(\\text{RelTol} \\cdot \\max(\\text{abs}(q)), \\text{AbsTol}),]\n\nдля всех переменных состояния, самостоятельно изменяя шаг интегрирования, где \\(\\varepsilon_i\\) – относительна погрешность вычисления \\(i\\)-ой переменной состояния.\n\nТочность можно задать для каждой переменной отдельно:\n\noptions = odeset('RelTol',[1e-7, 1e-9],'AbsTol', [1e-9, 1e-8]);\n\n\nЗдесь мы задали относительную погрешность \\(10^{-7}\\) для угла и \\(10^{-9}\\) для угловой скорости, и абсолютную погрешность \\(10^{-9}\\) для угла и \\(10^{-8}\\) для угловой скорости. В этом случае для каждой \\(i\\)-ой переменной состояния будет выполнятся условие:\n\n[\\varepsilon_i \\leq \\max(\\text{RelTol}_i \\cdot \\text{abs}(q_i)), \\text{AbsTol}_i)]\n\nДля запуска численного интегрирования с заданной точностью необходимо передать структуру options в функцию ode45 последним аргументом:\n\n[t, q] = ode45(@(t, q) f(t,q,p), ts, q0, options);\n\n\n",
      "url": "/pages/matlab/ode_simple/"
    },{
      
      "title": "Кинематические уравнения.",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "\n  Задание 1\n  Задание 2\n  Задание 3\n  Задание 4\n  Пример решения    \n      Координатный столбец вектора абсолютной скорости точки Е в базисе 0.        \n          Пример кода на языке MATLAB\n        \n      \n      Координатный столбец абсолютной угловой скорости звена 4 в базисе 4.        \n          Пример кода на языке MATLAB\n        \n      \n    \n  \n\n\nЗадание 1\n\nРазработайте функцию определения производной координат кватерниона по заданным координатам кватерниона (первый аргумент функции – столбец 4x1) и проекциям угловой скорости тела на связанные оси (второй аргумент функции – столбец 3x1):\n\nfunction dquat = kinematic_Quat(quat, w)\n    ...\nend\n\n\nЗадание 2\n\nРазработайте функцию определения производной элементов матрицы направляющих косинусов по заданной матрице направляющих косинусов (первый аргумент функции – матрица 3x3) и проекциям угловой скорости тела на связанные оси (второй аргумент функции – столбец 3x1):\nfunction dA = kinematic_Matrix(A, w)\n    ...\nend\n\n\nЗадание 3\n\nУгловое положение системы координат, связанной с твердым телом в начальный момент времени (\\(t = 0\\)) определяется тремя углами \\(\\alpha_1 = 10^o\\), \\(\\alpha_2 = 30^o\\) и \\(\\alpha_3 = 60^o\\) (пассивная точка зрения). Последовательность поворотов определяется из таблицы:\n\n\n  \n    \n      Вариант\n      Последовательность\n    \n  \n  \n    \n      1\n      313\n    \n    \n      2\n      121\n    \n    \n      3\n      232\n    \n    \n      4\n      323\n    \n    \n      5\n      131\n    \n    \n      6\n      212\n    \n    \n      7\n      123\n    \n    \n      8\n      231\n    \n    \n      9\n      132\n    \n    \n      10\n      312\n    \n    \n      11\n      321\n    \n    \n      12\n      213\n    \n  \n\n\nНомер варианта = 1 + (NNNNN mod 12), где NNNNN – номер зачетной книжки.\n\nПроекции угловой скорости тела на связанные оси изменяются по закону:\n\n[\\omega_x = t \\text{ рад/с}, \\quad \\omega_y = \\cos (t/6) \\text{ рад/с}, \\quad  \\omega_z = \\cos(t/5) \\text{ рад/с}]\n\nПостройте графики изменения углов на интервале от 0 до 10 с.\n\nЗадание 4\n\nРобот манипулятор состоит из трех звеньев, соединенных тремя шарнирами. Первый шарнир соединяет неподвижную опору и звено 1, второй шарнир звено 1 и звено 2 и третий шарнир звено 2 и звено 3. Каждый шарнир имеет одну степень свободы.\n\n\nВариант 1\n\n\nВариант 2\n\n\nВариант 3\n\n\nВариант 4\n\n\n  Записать в матричном виде выражение для скорости точки С манипулятора.\n  Вычислить координатный столбец скорости точки С манипулятора в момент времени когда:\n\n\n[\\varphi_1 = 30\\,^\\circ, \\quad \\varphi_2 = 60\\,^\\circ, \\quad \\varphi_3 = 30\\,^\\circ]\n\n[\\dot{\\varphi}_1 = 5+(\\text{NNNNN}\\mod 5)\\,^\\circ/c, \\quad \\dot{\\varphi}_2 = 10+(\\text{NNNNN} \\mod 10)\\,^\\circ/c, \\quad \\dot{\\varphi}_3 = 15\\,^\\circ/c]\n\nНомер варианта определяется формулой: ВАРИАНТ =  1 + NNNNN mod 4. Длины всех звеньев равны 1 м:\n\n[OA = AB = BC = 1\\text{ м}.]\n\nПример решения\n\nНа рисунке показан механизм, состоящий из четырёх звеньев, соединённых цилиндрическими шарнирами. Механизм имеет четыре степени свободы и его положение определяется четырьмя углами: \\(\\varphi_1\\), \\(\\varphi_2\\), \\(\\varphi_3\\), \\(\\varphi_4\\):\n\n  угол \\(\\varphi_1\\) определяет вращение звена 1 вокруг оси \\(C_0 z_0\\) неподвижной системы координат \\(C_0x_0y_0z_0\\), совпадающей по направлению с осью \\(C_1 z_1\\) системы координат \\(C_1x_1y_1z_1\\);\n  звено 2 вращается вокруг оси \\(С_1 y_1\\) системы координат \\(C_1x_1y_1z_1\\), совпадающей по направлению с осью \\(C_2 y_2\\) системы координат \\(C_2x_2y_2z_2\\);\n  звено 3 вращается вокруг оси \\(x_2\\) системы координат \\(C_2x_2y_2z_2\\), совпадающей по направлению с осью \\(C_3 x_3\\) системы координат \\(C_3x_3y_3z_3\\);\n  звено 4 вращается вокруг оси \\(z_3\\) системы координат \\(C_3x_3y_3z_3\\), совпадающей по направлению с осью \\(C_4 z_4\\) системы координат \\(C_4x_4y_4z_4\\).\n\n\n\nСхема механизма\n\nПри \\(\\varphi_1=\\varphi_2=\\varphi_3=\\varphi_4\\) все системы координат, связанные со звеньями, совпадают с системой координат \\(C_0x_0y_0z_0\\).\n\n\n  Найти координатный столбец вектора абсолютной скорости точки Е в базисе 0.\n  Найти координатный столбец абсолютной угловой скорости звена 4 в базисе 4.\n\n\nКоординатный столбец вектора абсолютной скорости точки Е в базисе 0.\n\nВведем следующие обозначения для радиус-векторов:\n\n[{\\vec{\\rho}}_1=\\vec{AB},\\ \\ {\\vec{\\rho}}_2=\\vec{BC},\\ \\ {\\vec{\\rho}}_3=\\vec{CD},\\ \\ {\\vec{\\rho}}_4=\\vec{DE}.]\n\nРадиус-вектор точки Е относительно начала неподвижной системы координат \\(C_0x_0y_0z_0\\) определяется выражением:\n\n[{\\vec{r}}_E={\\vec{\\rho}}_1+{\\vec{\\rho}}_2+{\\vec{\\rho}}_3+{\\vec{\\rho}}_4.]\n\nКоординатный столбец вектора \\({\\vec{r}}_E\\) в базисе \\(C_0x_0y_0z_0\\):\n\n[r_E^{(0)}=\\rho_1^{(0)}+\\rho_2^{(0)}+\\rho_3^{(0)}+\\rho_4^{(0)}=A^{01}\\left(\\rho_1^{\\left(0\\right)}+A^{12}\\left(\\rho_2^{\\left(2\\right)}+A^{23}\\left(\\rho_3^{\\left(3\\right)}+A^{34}\\rho_4^{\\left(4\\right)}\\right)\\right)\\right)]\n\nПроизводная координатного столбца \\(r_E^{(0)}\\) по времени представляет собой координатный столбец скорости точки \\(Е\\) в базисе 0:\n\n[\\frac{dr_E^{\\left(0\\right)}}{dt}=V_E^{(0)}={\\dot{A}}^{01}\\left(\\rho_1^{\\left(1\\right)}+A^{12}\\left(\\rho_2^{\\left(2\\right)}+A^{23}\\left(\\rho_3^{\\left(3\\right)}+A^{34}\\rho_4^{\\left(4\\right)}\\right)\\right)\\right)+A^{01}\\left({\\dot{A}}^{12}\\left(\\rho_2^{\\left(2\\right)}+A^{23}\\left(\\rho_3^{\\left(3\\right)}+A^{34}\\rho_4^{\\left(4\\right)}\\right)\\right)+A^{12}\\left({\\dot{A}}^{23}\\left(\\rho_3^{\\left(3\\right)}+A^{34}\\rho_4^{\\left(4\\right)}\\right)+A^{23}\\left({\\dot{A}}^{34}\\rho_4^{\\left(4\\right)}\\right)\\right)\\right).]\n\nПроизводные координатных столбцов \\(\\rho_1^{(1)}\\), \\(\\rho_2^{(2)}\\), \\(\\rho_3^{(3)}\\), \\(\\rho_4^{(4)}\\) равны нулю поскольку вектора, соответствующие этим координатным столбцам, движутся вместе с соответствующими базисами. Например, вектор \\(\\vec{\\rho}_1\\) вместе с базисом \\(C_1 x_1 y_1 z_1\\) вращается вокруг оси \\(C_1 z_1\\) и координаты вектора \\(\\vec{\\rho}_1\\) в этом базисе не меняются. Аналогично, вектор \\(\\vec{\\rho}_2\\) вращается вместе с базисом \\(C_2 x_2 y_2 z_2\\) вокруг оси \\(C_2 y_1\\) и координаты вектора \\(\\vec{\\rho}_2\\) в этом базисе не изменяются.\n\nВведя обозначения\n\n[\\rho_{24}^{(2)}=\\rho_2^{(2)}+A^{23} \\rho_{34}^{(3)}, \\quad\n  \\rho_{34}^{(3)}=\\rho_3^{\\left(3\\right)}+A^{34}\\rho_4^{\\left(4\\right)},]\n\nвыражение для скорости точки Е можно упростить:\n\n[V_E^{(0)}={\\dot{A}}^{01}\\left(\\rho_1^{\\left(1\\right)}+A^{12}\\rho_{24}^{(2)}\\right)+A^{01}\\left({\\dot{A}}^{12}\\rho_{24}^{(2)}+A^{12}\\left({\\dot{A}}^{23}\\rho_{34}^{(3)}+A^{23}\\left({\\dot{A}}^{34}\\rho_4^{\\left(4\\right)}\\right)\\right)\\right).]\n\nС учетом выражений для производных матриц поворота:\n\n[\\dot{A}^{01} = A^{01} \\widetilde{\\Omega}_1^{(1)},\\quad \\dot{A}^{12} = A^{12} \\widetilde{\\Omega}_2^{(2)},]\n\n[\\dot{A}^{23}=A^{23} \\widetilde{\\Omega}_3^{(3)},\\quad \\dot{A}^{34}=A^{34} \\widetilde{\\Omega}_4^{(4)}.]\n\nМатрица \\(\\widetilde{\\Omega}_1^{(1)}\\) – кососимметрическая матрица угловой скорости звена 1 относительно неподвижной системы координат, составленная из компонент координатного столбца вектора угловой скорости звена 1 относительно неподвижной системы координат:\n\n[\\Omega_1^{(1)}=\\begin{bmatrix} \\Omega_{1x} \\ \\Omega_{1y} \\ \\Omega_{1z} \\end{bmatrix}]\n\nКососимметрическая матрица \\(\\widetilde{\\Omega}_1^{(1)}\\) имеет вид:\n\n[\\widetilde{\\Omega}1^{(1)}=\\begin{bmatrix} 0 &amp; -\\Omega{1z} &amp; \\Omega_{1y} \\ \\Omega_{1z} &amp; 0 &amp;-\\Omega_{1x} \\ -\\Omega_{1y} &amp; \\Omega_{1x} &amp; 0 \\end{bmatrix}]\n\nУчитывая, что звено 1 вращается вокруг оси \\(z_1\\) системы координат \\(C_1x_1y_1z_1\\):\n\n[\\widetilde{\\Omega}1^{(1)}=\n\\begin{bmatrix} 0 &amp; -\\Omega{1z} &amp; 0 \n\\Omega_{1z} &amp; 0 &amp; 0 \n0 &amp; 0 &amp; 0 \\end{bmatrix} \n= \\begin{bmatrix}\n0 &amp; -\\dot{\\varphi}_1 &amp; 0 \\ \n\\dot{\\varphi}_1 &amp; 0 &amp; 0 \\ \n0 &amp; 0 &amp; 0 \n\\end{bmatrix}]\n\nМатрица преобразования координат из базиса 1 в базис 0 при повороте вокруг оси \\(z_0\\ (z_1)\\):\n\n[A^{01}=\\begin{bmatrix}\\cos{\\varphi_1}&amp;-\\sin{\\varphi_1}&amp;0\\\\sin{\\varphi_1}&amp;\\cos{\\varphi_1}&amp;0\\0&amp;0&amp;1\\\\end{bmatrix}.]\n\nМатрица \\({\\widetilde{\\Omega}}_2^{(2)}\\) – кососимметрическая матрица угловой скорости звена 2 относительно звена 1, которая с учётом того, что звено 2 вращается вокруг оси \\(C_1 y_1\\) системы координат \\(C_1x_1y_1z_1\\) (совпадающей по направлению с осью \\(C_2 y_2\\)) определяется выражением:\n\n[\\widetilde{\\Omega}_2^{(2)}=\n\\begin{bmatrix}\n0 &amp; 0 &amp; {\\dot{\\varphi}}_2 \n0 &amp; 0 &amp; 0\n-{\\dot{\\varphi}}_2 &amp; 0 &amp; 0\n\\end{bmatrix}.]\n\nМатрица преобразования координат из базиса 2 в базис 1 при повороте вокруг оси \\(C_1 y_1\\ (C_2 y_2)\\):\n\n[A^{12}=\n\\begin{bmatrix}\n\\cos{\\varphi_2} &amp; 1 &amp; \\sin{\\varphi_2}\n0 &amp; 1 &amp; 0\n-\\sin{\\varphi_2} &amp; 0 &amp; \\cos{\\varphi_2} \n\\end{bmatrix}.]\n\nМатрица \\(\\widetilde{\\Omega}_3^{(3)}\\) – кососимметрическая матрица угловой скорости звена 3 относительно звена 2, которая с учётом того, что звено 3 вращается вокруг оси \\(C_3 x_3\\) системы координат \\(C_3x_3y_3z_3\\) (совпадающей по направлению с осью \\(C_2 x_2\\)) определяется выражением:\n\n[\\widetilde{\\Omega}_3^{(3)}=\n\\begin{bmatrix}\n0 &amp; 0 &amp; 0 \n0 &amp; 0 &amp; -\\dot{\\varphi}_3 \n0 &amp; \\dot{\\varphi}_3 &amp; 0 \n\\end{bmatrix}.]\n\nМатрица преобразования координат из базиса 3 в базис 2 при повороте вокруг оси \\(C_2 x_2\\ (C_3 x_3)\\):\n\n[A^{32}=\n\\begin{bmatrix}\n1 &amp; 0 &amp; 0 \n0 &amp; \\cos{\\varphi_3} &amp; -\\sin{\\varphi_3} \\ \n0 &amp; \\sin{\\varphi_3} &amp; \\cos{\\varphi_3} \n\\end{bmatrix}.]\n\nМатрица \\(\\widetilde{\\Omega}_4^{(4)}\\) – кососимметрическая матрица угловой скорости звена 4 относительно звена 3, которая с учётом того, что звено 4 вращается вокруг оси \\({C_4z}_4\\) системы координат \\(C_4x_4y_4z_4\\) (совпадающей по направлению с осью \\(C_3z_3\\)) определяется выражением:\n\n[\\widetilde{\\Omega}_4^{(4)} = \n\\begin{bmatrix}\n0 &amp; -{\\dot{\\varphi}}_4 &amp; 0 \n\\dot{\\varphi}_4 &amp; 0 &amp; 0 \n0 &amp; 0 &amp; 0\n\\end{bmatrix}.]\n\nМатрица преобразования координат из базиса 4 в базис 3 при повороте вокруг оси \\(C_4 z_4\\):\n\n[A^{34}=\\begin{bmatrix}\n\\cos{\\varphi_4}&amp;-\\sin{\\varphi_4}&amp;0\n\\sin{\\varphi_4}&amp;\\cos{\\varphi_4}&amp;0\n0&amp;0&amp;1\n\\end{bmatrix}.]\n\nПример кода на языке MATLAB\n\n\n% Оператор тильда\ntilde = @(w) [0 -w(3) w(2); w(3) 0 -w(1); -w(2) w(1) 0];\n\n% Матрица поворота вокруг оси x\nAx =  @(a) [1 0 0; 0 cos(a) -sin(a); 0 sin(a) cos(a)];\n\n% Матрица поворота вокруг оси y\nAy =  @(a) [cos(a) 0 sin(a); 0 1 0; -sin(a) 0 cos(a)];\n\n% Матрица поворота вокруг оси z\nAz =  @(a) [cos(a) -sin(a) 0; sin(a) cos(a) 0; 0 0 1];\n\n% Исходные данные. Угол, производная угла \nphi_1 = 1.0; dphi_1 = 1.0;\nphi_2 = 1.5; dphi_2 = 1.5;\nphi_3 = 0.5; dphi_3 = 0.5;\nphi_4 = 1.0; dphi_4 = 1.0;\n\n% Относительные угловые скорости \nOmega1_in_1 = [0;0;dphi_1];\nOmega2_in_2 = [0;dphi_2;0];\nOmega3_in_3 = [dphi_3;0;0];\nOmega4_in_4 = [0;0;dphi_4];\n\n% Матрицы поворота\nA01 = Az(phi_1);\nA12 = Ay(phi_2);\nA23 = Ax(phi_3);\nA34 = Az(phi_4);\n\n% Производные матриц поворота\ndA01 = A01*tilde(Omega1_in_1);\ndA12 = A12*tilde(Omega2_in_2);\ndA23 = A23*tilde(Omega3_in_3);\ndA34 = A34*tilde(Omega4_in_4);\n\n% Координатные столбцы AB, BC, CD, DE \n% в базисах 1, 2, 3 и 4 соответственно\nAB = [0;0;1];\nBC = [0;1;0];\nCD = [0;1;0];\nDE = [0;1;0];\n\n% \nCE_in_3 = CD + A34*DE;\nBE_in_2 = BC + A23*CE_in_3;\n\n% Абсолютная скорость точки Е в СК CoXoYoZo\nVE = dA01*(AB+A12*BE_in_2) + A01*(dA12*BE_in_2+A12*(dA23*CE_in_3+A23*dA34*DE));\n\n\n\nКоординатный столбец абсолютной угловой скорости звена 4 в базисе 4.\n\nАбсолютная угловая скорость звена DE определяется следующим образом:\n\n[{\\vec{\\omega}}_{DE}={\\vec{\\omega}}_4={\\vec{\\Omega}}_1+{\\vec{\\Omega}}_2+{\\vec{\\Omega}}_3+{\\vec{\\Omega}}_4.]\n\nКоординатный столбец вектора \\({\\vec{\\omega}}_4\\) в базисе \\(C_4x_4y_4z_4\\) будет определяться выражением\n\n[\\omega_4^{\\left(4\\right)}=\\left(A^{34}\\right)^T\\left(A^{23}\\right)^T\\left(A^{12}\\right)^T\\Omega_1^{\\left(1\\right)}+\\left(A^{34}\\right)^T\\left(A^{23}\\right)^T\\Omega_2^{\\left(2\\right)}+\\left(A^{34}\\right)^T\\ \\Omega_3^{\\left(3\\right)}+\\Omega_4^{\\left(4\\right)}]\n\nПример кода на языке MATLAB\n\n\nw4_in_4 = A34'*(A23'*(A12'*Omega1_in_1+Omega2_in_2)+Omega3_in_3)+Omega4_in_4;\n\n\n\n",
      "url": "/pages/mbs/omega/"
    },{
      
      "title": "Орбитальное движение.",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Разработать программу численного интегрирования движения материальной\nточки в центральном гравитационном поле Земли в геоцентрической инерциальной системе координат \\(O X_0 Y_0 Z_0\\).\n\nРазработать функцию преобразования четырёх элементов орбиты спутника (\\(\\Omega, i, \\omega, \\vartheta\\)) в декартовы координаты геоцентрической инерциальной системы координат \\(O X_0 Y_0 Z_0\\).\n\nРазработать функцию вычисления матрицы преобразования координат из перигейной системы координат \\(p x_p y_p z_p\\) в геоцентрическую инерциальную систему \\(O X_0 Y_0 Z_0\\).\n\nОсь \\(x_p\\) перигейной системы направлена из центра Земли в точку перигея орбиты, ось \\(y_p\\) лежит в плоскости орбиты и направлена в сторону орбитального движения КА, ось \\(z_p\\) дополняет систему до правой (перпендикулярная плоскости орбиты).\n\n\n\nПроинтегрировать движение спутника для следующих начальных условий:\n\n  Высота перигея, \\(h_p\\) = 200 км;\n  Высота апогея,  \\(h_a\\) = 200 + 50*(NNNNN mod 5) км;\n  Долгота восходящего узла, \\(\\Omega\\) = 10*(NNNNN mod 35) градус;\n  Наклонение, \\(i\\) = 10 + (NNNNN mod 80) градус;\n  Аргумент перицентра, \\(\\omega\\) = 5 + 10*(NNNNN mod 35) градус;\n  Угол истинной аномалии, \\(\\vartheta\\) = 0 (спутник находится в точке перицентра).\n\n\nгде NNNNN – последние пять цифр зачетной книжки, a mod b - остаток от деления a на b. Например, для зачетной книжки 2017-00521 начальные условия буду вычисляться следующим образом:\n\n\n  \\(h_p\\) = 200 км;\n  \\(h_a\\) = 200 + 50(521 mod 5) = 200 + 50(1) = 250 км;\n  \\(\\Omega\\) = 10(521 mod 35) = 10(31) = 310 градусов;\n  \\(i\\) = 10 (521 mod 80) = 10 + 41 = 51 градус;\n  \\(\\omega\\) = 5 + 10 (521 mod 35) = 5 + 10*31 = 315 градус.\n\n\nВысота перигея и апогея позволят вычислить модуль начальной скорости спутника (в точке апоцентра). Остальные параметры орбиты позволят определить направление вектора начальной скорости.\n\nРешение найти на интервале двух орбитальных периодов (T). Таблица решения должна содержать 240 точек на интервале от 0 до 2*Т.\n\nВ точке перицентра от спутника №1 отделяется спутник №2 с относительной скоростью 2 м/с в направлении орбитальной скорости. Найти решение для второго спутника. Найти численное решение на интервале двух орбитальных периодов спутника №1. Таблица решения должна содержать 240 точек на интервале от 0 до 2*Т.\n\nПостроить траекторию движения спутника №2 относительно спутника №1 в орбитальной системе координат спутника №1 в плоскости его орбиты.\n\nНачало орбитальной подвижной системы координат совпадает с центром масс спутника. Ось \\(S x_h\\) орбитальной подвижной системы координат направлена из центра масс спутника от Земли параллельно радиус-вектору спутника относительно центра Земли, ось \\(S y_h\\) лежит в плоскости орбиты и направлена в сторону орбитального движения спутника, ось \\(z_h\\) дополняет систему до правой (перпендикулярная плоскости орбиты).\n\nМетодические указания\n\nЭксцентрисистет орбиты (характеризует “вытянутость” орбиты):\n\n[e = \\frac{r_a-r_p}{r_p+r_a}]\n\nгде \\(r_p = R_e + h_p\\) - расстояние от центра Земли до точки перигея, \\(r_a = R_e + h_a\\) - расстояние от центра Земли до точки апогея, \\(R_e\\) - средний радиус Земли.\n\nФокальный параметр орбиты\n\n[p = \\frac{r_p+r_a}{2} (1-e^2)]\n\nСкорость спутника в перигее\n\n[V_p = \\sqrt{\\frac{\\mu}{p}}(1+e)]\n\nСкорость спутника в апогее\n\n[V_p = \\sqrt{\\frac{\\mu}{p}}(1-e)]\n\nгде \\(\\mu\\) - гравитационный параметр Земли, равный произведению её массы на гравитационную постоянную: \\(\\mu = 398600.433\\cdot 10^9\\) м\\(^3\\)/c\\(^2\\).\n\nПример функция правых частей\n\nfunction dq = dqdt(t,q,p)    \n    % Координатный столбец радиус-вектора спутника\n    r  = q(1:3);    \n    % Координатный столбец скорости \n    v  = q(4:6);    \n    % Гравитационный параметр\n    mu = p.mu;\n    % Координатный столбец ускорения спутника \n    a  = - mu*r/norm(r)^3;    \n    dq = [v; a];\nend\n\n\nФайл-скрипт, запускающий процесс интегрирования\n\np.mu    = ...\n\nha      = ...;\nhp      = ...;\n\n% Долгота восходящего узла\nRAAN    = ...; \n% Аргумент перигея\nap      = ...;\n\n% Координатный столбец вектора начального положения и скорости спутника\nr0      = ...\nv0      = ...\n\n% Период обращения\nT       = ...  \ntspan   = linspace(0,T,240);\n\nq0      = [r0;v0];\n\nopt     = odeset('RelTol', 1e-8);\n\n[t, q]  = ode113(@(t,q,p), tspan, q0, opt);\n\n...\n\n\n",
      "url": "/pages/mbs/orbital-motion/"
    },{
      
      "title": "Статьи",
      
      "content": "2024\n\n\n  \n    Трушляков В. И., Юдинцев В. В.  “Демпфирование колебаний вращающейся космической тросовой системы для увода космического мусора.” ИТ &amp; ТРАНСПОРТ (2024), C. 55-65.\n  \n  \n    V. Trushlyakov, V. Urbansky, V. Yudintsev, Theoretical and experimental studies of gas preparation system for pressurization and reactive control system of launch vehicle, Chinese Journal of Aeronautics (2024), doi: https://doi.org/10.1016/j.cja.2024.04.024\n  \n\n\n2023\n\n\n  \n    Результаты проведения демонстрационного эксперимента по спуску с орбиты второй ступени «Космос-3М» с использованием вращающейся тросовой системы / А. В. Владимиров, С. В. Кузнецов, С. Ю. Онищук,  Положенцев А.Е., Трушляков В.И., Урбанский В.А., Шатров Я.Т., Юдинцев В.В. // Космонавтика и ракетостроение. – 2023. – № 4(133). – С. 142-154.\n  \n  \n    Трушляков, В. И., Юдинцев, В. В., Урбанский, В. А., Онищук, С. Ю., Кленин, Д. А. Исследование проектно-конструкторского облика декартовой двигательной установки автономного стыковочного модуля для захвата мишени. Омский научный вестник. Серия «Авиационно-ракетное и энергетическое машиностроение», 7(3), 2023, 70–81. doi: 10.25206/2588-0373-2023-7-3-70-81.\n  \n  \n    Valeriy Trushlyakov, Vadim Yudintsev, Sergei Onishchuk Study of a rotating tethered system for capturing large-sized space debris on intersecting courses // Journal of Space Safety Engineering. 10, 2023 pp. 544–551.\n  \n  \n    В. И. Трушляков, В. А. Урбанский, Я. Т. Шатров, В. В. Юдинцев Подготовка газа системы наддува баков и рабочего тела для реактивной системы управления спасаемых ступеней ракет-носителей // Космонавтика и ракетостроение. - 2023. - № 1(130). - С. 111-122.\n  \n  \n    Á. Romero, V. Urbansky, V. Yudintsev, H. Schaub and V. Trushlyakov, Novel strategies for liquid rocket engine restart in microgravity, Acta Astronautica. V. 202, January 2023, pp. 214-228. doi: 10.1016/j.actaastro.2022.10.012.\n  \n\n\n2022\n\n\n  \n    В. И. Трушляков, В. А. Урбанский, Я. Т. Шатров, В. В. Юдинцев, Комбинированная система наддува с реактивной системой управления для возвращаемой ступени ракеты-носителя // Космонавтика и ракетостроение. - 2022. - № 6(129). - С. 110-121.\n  \n  \n    В. И. Трушляков, В. В. Юдинцев, В. А. Урбанский, С. Ю. Онищук Анализ состояния разработок средств очистки орбит в околоземном космическом пространстве от объектов крупногабаритного космического мусора // Омский научный вестник. Серия “Авиационно-ракетное и энергетическое машиностроение”. 2022. №4.\n  \n  \n    Valeriy I. Trushlyakov, Vadim V. Yudintsev, Sergei Yu. Onishchuk, Risks of docking and nulling of the kinetic moment of an uncooperative large-sized space debris, Journal of Space Safety Engineering, 2022. doi: 10.1016/j.jsse.2022.08.005\n  \n  \n    Valeriy Trushlyakov, Vadim Yudintsev, Dynamics of rotating tethered system for active debris removal, Acta Astronautica. Volume 195, June 2022, Pages 405-415. doi: https://doi.org/10.1016/j.actaastro.2022.03.023.\n  \n  \n    Á. Romero Calvo, V. Urbanskiy, V. Yudintsev, H. Schaub and V. Trushlyakov, Microgravity Restart of Liquid Rocket Engine With Low Propellant Residuals, AAS Guidance and Control Conference, Breckenridge, CO, Feb. 3-9, 2022.\n  \n\n\n2021\n\n\n  \n    Valeriy I. Trushlyakov, Vadim V. Yudintsev, Sergey Yu. Onishchuk “Risks of docking and nulling of the kinetic moment of an uncooperative large-sized space debris. 11th IAASS Conference, Virtual conference ‐ 19‐21 October 2021. Paper id: 2021 IAASS ES‐04/4.\n  \n  \n    Valeriy I. Trushlyakov, and Vadim V. Yudintsev “Control of the Rotating Tethered System for Orbital Debris Removal”. Global Space Exploration Conference (GLEX2021),St Petersburg, Russian Federation, 14-18 June 2021. Paper id: GLEX-2021,7,5,6,x62094.\n  \n  \n    Valeriy I. Trushlyakov, Vladislav A. Urbansky, and Vadim V. Yudintsev “Investigation of liquid oxygen pressurization system with cold gas helium and hydrogen peroxide”. Global Space Exploration Conference (GLEX2021),St Petersburg, Russian Federation, 14-18 June 2021. Paper id: GLEX-2021,6,2,2,x61696.\n  \n  \n    Трушляков В. И., Урбанский В. А., Шатров Я. Т., Юдинцев В. В. Оценка энергетических характеристик активной бортовой системы спуска при аварийном выключении жидкостного ракетного двигателя ракеты-носителя. Космонавтика и ракетостроение. №2 (119), 2021 г., с. 141-150.\n  \n  \n    Трушляков В. И., Урбанский В. А., Шатров Я. Т., Юдинцев В. В. Сценарии управления полётом ракеты-носителя при аварийном выключении жидкостного ракетного двигателя. Космонавтика и ракетостроение. №1 (118), 2021 г., с. 119-130.\n  \n\n\n2020\n\n\n  \n    Valeriy I. Trushlyakov, Vladislav A. Urbansky, and Vadim V. Yudintsev “Reducing Environmental Damage After Emergency Engine Cutoff of the Launch Vehicle” Journal of Spacecraft and Rockets, Published Online:14 Dec 2020. https://doi.org/10.2514/1.A34912.\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. “Rotary Space Tether System for Active Debris Removal,” Journal of Guidance, Control, and Dynamics. Vol. 43, No. 2, February 2020. doi: https://doi.org/10.2514/1.G004615\n  \n  \n    Апарин М.П., Юдинцев В.В. Использование аэродинамического торможения при движении возвращаемой первой ступени ракеты-носителя // Вестник молодых ученых и специалистов Самарского университета. — 2020. — № 1 (16). — С. 6-12\n  \n\n\n2019\n\n\n  \n    V. I. Trushlyakov, V. V. Yudintsev. “Method of Active Debris Removal Using Rotating Space Tether System,” First Int’l. Orbital Debris Conf. (2019).\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. (2019). Dynamic similitude for small-scale re-entry experiment. Phys.: Conf. Ser. 1210, 12148.\n  \n  \n    Апарин М. П., Юдинцев В. В. Мягкая посадка возвращаемой первой ступени ракеты-носителя. Международная молодёжная научная конференция «XV Королёвские чтения», посвящённая 100-летию со дня рождения Д.И. Козлова: тезисы докладов 8-10 октября 2019 года.\n  \n  \n    V. I. Trushlyakov, V. V. Yudintsev. (2019). Rotating tethered system for active space debris removal. J. Phys.: Conf. Ser. 1260 112032.\n  \n  \n    V. S. Aslanov, V. V. Yudintsev, Chaos in tethered tug-debris system induced by attitude oscillations of debris. Journal of Guidance, Control, and Dynamics. Vol. 42, No. 7, July 2019.\n  \n\n\n2018\n\n\n  \n    Юдинцев В. В. Динамика захвата сетью вращающегося объекта – космического мусора // Вестник Московского авиационного института. 2018. Т. 25. № 4. С. 28-39.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev  Motion Control of Space Tug During Debris Removal by a Coulomb Force. Journal of Guidance, Control, and Dynamics, 2018, March 22, 2018. doi:10.2514/1.G003251\n  \n  \n    Асланов В.С., Юдинцев В.В. Выбор параметров системы увода космического мусора с упругими элементами посредством тросовой буксировки. Вестник Московского авиационного института. 2018. Т. 25. № 1. С. 7-17.\n  \n  \n    V.I. Trushlyakov, V.V. Yudintsev, R.S. Pikalov Dynamic control of tug-debris tethered system after the capturing of the debris. Journal of Physics: Conference Series 1050 (2018) 012092. doi:10.1088/1742-6596/1050/1/012092\n  \n  \n    Асланов В. С., Юдинцев В. В. Классическая механика в технологиях увода космического мусора с орбиты. Сборник научно-методических статей. Теоретическая механика Вып. 30. / Под редакцией профессора В. А. Самсонова - М.: Издательство Московского университета, 2018. - 253 с.\n  \n  \n    Асланов В. С., Юдинцев В. В. Стыковка с объектом космического мусора при помощи разворачиваемой упругой балки-ленты. Вестник Московского авиационного института. - 2018. - Т. 25. - № 2. - С. 16-24.\n  \n\n\n2017\n\n\n  \n    Как убрать космический мусор с рабочих орбит? О работе 7-й Европейской конференции по космическому мусору.\n  \n  \n    V.I. Trushlyakov V.V. Yudintsev Systems engineering design and optimization of an active debris removal mission of a spent rocket body using piggyback autonomous module. 3rd IAA Conf. Dyn. Control Sp. Syst. (DYCOSS 2017) 30 May - 1st June 2017 (Moscow) pp 667-681.\n  \n  \n    V.S. Aslanov, A.K. Misra, V. V. Yudintsev, Chaotic attitude motion of a low-thrust tug-debris tethered system in a Keplerian orbit, Acta Astronaut. 139 (2017) 419-427. doi:10.1016/j.actaastro.2017.07.008.\n  \n  \n    V.V. Yudintsev, V.S. Aslanov, Detumbling Space Debris Using Modified Yo-Yo Mechanism, J. Guid. Control. Dyn. 40 (2017) 714–721. doi:10.2514/1.G000686.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Docking of a space tug with upper stage debris object using deployable flexible beam // Proceedings of the International Astronautical Congress, IAC. — 2017. — Vol. 11. — P. 7084-7090\n  \n  \n    O.G. Lagno, T.I. Lipatnikova, Y.N. Makarov, T.V. Mironova, V.I. Trushlyakov, Y.Y. Shatrov and V.V. Yudintsev Parameters design of autonomous docking module and the choice of suitable target and primary payload for ADR. Proc. 7th Eur. Conf. Sp. Debris ESOC 18 - 21 April 2017 (Darmstadt, Germany)\n  \n  \n    Асланов В. С., Юдинцев В. В.  Тросовая буксировка объекта космического мусора с полостью, заполненной жидкостью. Труды МАИ. 2017. № 97.\n  \n  \n    Юдинцев В. В. Модель пространственного движения механизма Йо-Йо. Труды МАИ. 2017. № 95.\n  \n\n\n2016\n\n\n  V.S. Aslanov, A.K. Misra, V.V. Yudintsev, Chaotic motions of tethered satellites with low thrust, in: 67th Int. Astronaut. Congr. IAC 2016; Guadalajara; Mex. 26 Sept. 2016 through 30 Sept. 2016, International Astronautical Federation, IAF, 2016.\n\n\n2015\n\n\n  \n    Юдинцев В.В. Динамика отделения наноспутника формата кубсат от транспортно-пускового контейнера // Всероссийский научно-технический журнал «Полёт», 8-9 2015, с. 10-15\n  \n  \n    В. Д. Еленев, Б. А. Титов, Е. И. Давыдов, И. Е. Давыдов, А. Г. Кочян, В. В. Юдинцев Исследование динамики малого космического аппарата с учётом воздействия упругих колебаний конструкции присоединённых панелей солнечных батарей и аэродинамического момента // Вестник СГАУ. Том 14, № 1 (2015) С. 25-35.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, The motion of tethered tug-debris system with fuel residuals, Adv. Sp. Res. 56 (2015) 1493–1501. doi:10.1016/j.asr.2015.06.032.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics, analytical solutions and choice of parameters for towed space debris with flexible appendages, Adv. Sp. Res. 55 (2015) 660–667. doi:10.1016/j.asr.2014.10.034.\n  \n\n\n2014\n\n\n  \n    V.S. Aslanov, V.V. Yudintsev, Behavior of tethered debris with flexible appendages, Acta Astronaut. 104 (2014) 91–98. doi:10.1016/j.actaastro.2014.07.028.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics, Analytical Solutions and Choice of Parameters for Towed Space Debris with Flexible Appendages, Adv. Sp. Res. 55 (2014) 660–667. doi:10.1016/j.asr.2014.10.034.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Behaviour of tethered debris with flexible appendages, Acta Astronaut. 104 (2014) 91–98. doi:10.1016/j.actaastro.2014.07.028.\n  \n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics and chaos control of asymmetric gyrostat satellites, Cosm. Res. 52 (2014) 216–228. doi:10.1134/S0010952514030010.\n  \n  \n    D. S. Zaretskiy , E. Kosmodemyanskii, A. Romanov, M. Sivov , M. Trusov, V. Yudintsev 1U-3U+ Cubesat Deployer by JSC SRC “Progress”. 1st Latin American IAA CubeSat WorkShop. Brasília, Brasil. December 8th - 11th, 2014.\n  \n  \n    Круглов Г. Е., Юдинцев В. В.  Синтез процессов группового отделения малых космических аппаратов от блока выведения для разных конструктивно-компоновочных схем. Международная конференция «Научные и технологические эксперименты на автоматических космических аппаратах и малых спутниках» (SPEXP 2014), 9-11 сентября 2014 г, Самара , Россия. 2014 (с. 224-227)\n  \n\n\n2013\n\n\n  \n    V.S. Aslanov, V.V. Yudintsev, Dynamics and control of dual-spin gyrostat spacecraft with changing structure, Celest. Mech. Dyn. Astron. 115 (2013) 91–105. doi:10.1007/s10569-012-9453-8.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика буксировки твердого тела на упругом тросе в безгравитационном пространстве. Вестник СамГУ - Естественнонаучная серия, №3 (104). 2013, с. 58-66.\n  \n  \n    В.В. Андреев, С.Р. Бурназян, Г.Е. Круглов, В.В. Юдинцев, О влиянии упругих свойств конструкции разделяемых тел на их кинематические параметры после отделения, in: Сборник Трудов III Всероссийской Научно-Технической Конференции «Актуальные Проблемы Ракетно-Космической Техники» (Козловские Чтения), 2013: pp. 114–122.\n  \n  \n    B.C. Асланов, B.B. Юдинцев, Динамика буксировки твердого тела на упругом тросе в безгравитационном пространстве, Вестник СамГУ. 3 (2013) 58–66.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics of large space debris removal using tethered space tug, Acta Astronaut. 91 (2013) 149–156. doi:10.1016/j.actaastro.2013.05.020.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика и управление хаосом асимметричных спутников-гиростатов. Космические исследования, том 52, № 3, с. 229-241.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics of Large Debris Connected to Space Tug by a Tether, J. Guid. Control. Dyn. 36 (2013) 1654–1660. doi:10.2514/1.60976.\n  \n  \n    V.S. Aslanov, V. V. Yudintsev, Dynamics and control of dual-spin gyrostat spacecraft with changing structure, Celest. Mech. Dyn. Astron. 115 (2013) 91–105. doi:10.1007/s10569-012-9453-8.\n  \n\n\n2012\n\n\n  \n    V. Aslanov, V. Yudintsev, Dynamics and chaos control of gyrostat satellite, Chaos, Solitons and Fractals. 45 (2012) 1100–1107. doi:10.1016/j.chaos.2012.06.008.\n  \n  \n    Асланов В. С., Юдинцев В. В. Динамика буксировки космического аппарата на тросе в центральном поле Вестник Самарского государственного аэрокосмического университета имени академика С. П. Королёва (национальный исследовательский университет). №2 (33). 2012. С. 9-16.\n  \n  \n    Юдинцев В. В. Моделирование процессов раскрытия многоэлементных конструкций космических аппаратов. Всероссийский научно-технический журнал “Полет”, №5. 2012 с. 28 - 33\n  \n\n\n2011\n\n\n  Седельников А. В., Юдинцев В. В. Оценка влияния температурных деформаций упругих элементов космической лаборатории на поле микроускорений ее внутренней среды // Известия СНЦ РАН. 2011. Т. 13 № 1(2). С. 344-346. ISSN 0579-2975.\n\n\n2010\n\n\n  \n    V. Aslanov, G. Kruglov, V. Yudintsev, NewtonEuler equations of multibody systems with changing structures for space applications, Acta Astronaut. 68 (2011) 2080–2087. doi:10.1016/j.actaastro.2010.11.013.\n  \n  \n    И.В. Белоконов, Г.E. Круглов, В.И. Трушляков, B.B. Юдинцев, Оценка возможности управляемого схода с орбиты верхней ступени РН “Союз” за счёт использования остатков топлива в баках, Вестник СГАУ. 2 (2010) 105–111.\n  \n  \n    Андреев В. В., Круглов Г. Е., Юдинцев В. В. Моделирование подвижных элементов конструкции космического аппарата. Решетневские чтения: Материалы XIV международной научной конференции, посвященной памяти конструктора ракетно-космических систем академика М .Ф. Решетнёва  (10-12 ноября, 2010 г., г. Красноярск): в 2х частях, под. ред. Ю. Ю. Логинова; Сибирский государственный аэрокосмический университет, 2010 г., ч. II, стр. 370-371.\n  \n\n\n2009\n\n\n  \n    Воронин В. В., Юдинцев В. В. Моделирование системы раскрытия створок солнечных батарей с механизмом синхронизации. Тезисы докладов XXXV Самарской областной студ. науч. конференции, Самара. 2009, с. 214.\n  \n  \n    Юдинцев В. В. Моделирование процесса отделения боковых блоков РН “Союз” в системе MSC/ADAMS. Стр. 631-638: C56 Современные информационные технологии и ИТ-образование. Сборник докладов научно-практической конференции. Под ред. Проф. В. А. Сухомлина. - М.: ИНТУИТ.РУ, 2009.-848с.\n  \n\n\n2008\n\n\n  \n    Юдинцев В. В. Использование пакета MSC/ADAMS для моделирования механических систем ракетно-космической техники, Сборник трудов IX международной научно-технической конференции «Компьютерное моделирование 2008», г. Санкт-Петербург, С. 269-272.\n  \n  \n    Юдинцев В. В. Параметризация матрицы масс уравнений движения систем твердых тел РКТ, Общероссийский научно-технический журнал «Полет», №9, 20-24, 2008\n  \n\n\n2006\n\n\n  \n    Асланов В. С., Круглов Г. Е., Юдинцев В. В. Матричная форма уравнений движения систем РКТ Общероссийский научно-технический журнал «Полет», №4, 2006.\n  \n  \n    Аншаков Г. П., Асланов В. С., Балакин В. Л., Дорошин А. В., Квашин А. С., Круглов Г. Е. Юдинцев В. В. Динамические процессы в ракетно-космических системах. Вестник Самарского государственного аэрокосмического университета им. академика С. П. Королева, №1(3), 2003 (3/1)\n  \n\n\n2002\n\n\n  \n    Кобзев Ю. Н., Круглов Г. Е., Петров Н. К., Щиблев Ю. Н. Юдинцев В. В. Разработка, научно-техническое обоснование и внедрение мероприятий по повышению скоростного напора при отделении боковых блоков ракеты носителя “Союз” с целью повышения её грузоподъемности. Материалы конференции. “Первые Уткинские чтения”, Балтийский государственный технический университет “Военмех”, СпБ, 2002. (4/1)\n  \n  \n    Юдинцев В. В. Уравнения движения системы связанных твердых тел с переменной структурой, Сборник трудов XII Всероссийского научно-технического семинара по управлению движением и навигации летательных аппаратов. Самарский гос. аэрокосм. университет. Самара, 2002.\n  \n\n\n2001\n\n\n  Асланов В. С., Балакин В. Л., Дмитриев В. В., Дорошин А. В., Круглов Г. Е. Юдинцев В. В. Научные исследования высшей школы по приоритетным направлениям науки и техники. Тезисы докладов отчетной конференции-выставки подпрограммы 205 “Транспорт” научно-технической программы Министерства образования РФ. М.: Изд-во МАИ, 2001 г.Транспортные ракетно-космические системы для глобального мониторинга, навигации и связи.\n\n\n2000\n\n\n  Асланов В. С., Круглов Г. Е., Юдинцев В. В. Синтез процесса раскрытия солнечных батарей КА, Сборник трудов X Всероссийского научно-технического семинара по управлению движением и навигации летательных аппаратов. Самарский гос. аэрокосм. университет. Самара, 2000 г.\n\n\n1999\n\n\n  Асланов В. С., Круглов Г. Е., Юдинцев В. В. “Параметрический синтез процесса отделения боковых блоков ракеты-носителя “Союз””, Вестник Академии космонавтики, стр. 31, Самара, 1999 г.\n\n",
      "url": "/pages/papers/"
    },{
      
      "title": "Патенты",
      
      "content": "\n  \n    Способ сброса жидких остатков топлива из бака отделившейся части ступени ракеты-носителя в окружающую среду и устройство для его реализации [Текст] : заявка.: 2023122118 от 25.08.2023 / Трушляков В. И., Урбанский В. А., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 15.02.2024 Бюл. № 5.\n  \n  \n    Способ подготовки газа для системы наддува топливных баков и для реактивной системы управления многоразовой ракеты-носителя и устройство для его реализации [Текст] : заявка.: 2802109 от 30.12.2022 / Трушляков В. И., Урбанский В. А., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 22.08.2023.\n  \n  \n    Способ спасения створки головного обтекателя ракеты-носителя и устройство для его реализации [Текст] : заявка.: 2022131650 от 05.12.2022 / Трушляков В. И., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 22.03.2023 Бюл. No 09.\n  \n  \n    Способ увода объектов крупногабаритного космического мусора и устройство для его реализации [Текст] : заявка.: 2021139051 от 27.12.2021: B64G 1/64 (2006.01) / Трушляков В. И., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; опубл. 28.06.2022 Бюл. No 08.\n  \n  \n    Способ увода объектов крупногабаритного космического мусора и устройство для его реализации [Текст] : пат.: 038352 от 12.08.2021: B64G 1/10 (2006.01), B64G 1/62 (2006.01), B64G 1/64 (2006.01) / Трушляков В. И., Юдинцев В. В.; заявитель и патентообладатель Федеральное государственное бюджетное образовательное учреждение высшего образования “Омский государственный технический университет”; заявл. 26.07.2019 Бюл. No 01; опубл. 29.01.2021 Бюл. No 08.\n  \n  \n    Способ отделения полезных нагрузок от орбитальной ступени ракеты-носителя с жидкостным ракетным двигателем [Текст] : заявка 2020122848 от 10.07.2020. Опубликовано: 19.05.2021 Бюл. No 14 : МПК7 B 64 G 1/26, B 64 С 15/14 / Трушляков В. И., Юдинцев В. В.\n  \n  \n    Способ спуска ускорителя ступени ракеты-носителя при аварийном выключении ЖРД и устройство для его реализации [Текст] : заявка 2020115740 от 13.05.2020. Опубликовано: 14.04.2021 Бюл. No 11 : МПК7 B 64 G 1/26, B 64 С 15/14 / Трушляков В. И., Юдинцев В. В., Урбанский В. А.\n  \n  \n    Способ очистки орбит от объектов космического мусора [Текст] : пат. 267368 Рос. Федерация : МПК7 B 64 G 1/56, B 64 G 1/64 / Трушляков В. И., Юдинцев В. В., Макаров Ю. Н., Шатров Я. Т.; заявитель и патентообладатель Госкорпорация “Роскосмос”. заявл. 09.02.18 ; опубл. 28.12.18, Бюл. № 1.\n  \n  \n    Универсальный транспортно-пусковой контейнер // Патент России № 2658401. 2018. Бюл. № 18. / Сивов М.Е., Юдинцев В.В.\n  \n  \n    Способ проведения лётно-конструкторских испытаний автономного стыковочного модуля для очистки орбит от космического мусора Трушляков В.И., Юдинцев В.В., Макаров Ю.Н., Шатров Я.Т. Патент на изобретение RUS 2643020 06.09.2016. Патент отмечен дипломом ФИПС и Роспатента - «100 лучших изобретений России-2018».\n  \n  \n    Узел крышки транспортно-пускового контейнера Сивов М. Е., Юдинцев В. В., Трусов М. Г., Кирсанов А. А., Зарецкий Д. С. RU 2 620 630 C1, 18.02.2016\n  \n  \n    Транспортно-пусковой контейнер Сивов М. Е., Юдинцев В. В., Трусов М. Г., Кирсанов А. А., Зарецкий Д. С. RU 2 631 360 C1, 19.08.2016.\n  \n  \n    Стенд для раскрытия батареи солнечной Сороколетов В. И., Плетнева Н. А., Богданов Н. А., Юдинцев В. В., Афанасьев А. П. RU 2 567 678 C1, 03.07.2014.\n  \n  \n    Устройство отделения хвостового отсека ракетного блока Божко А. В., Бурназян С. Р., Круглов Г. Е., Солунин В. С., Юдинцев В. В. RU 2 497 732 C1, 06.06.2012.\n  \n\n\n",
      "url": "/pages/patents/"
    },{
      
      "title": "План занятий 2023-2024 учебный год",
      
      "content": "Осенний семестр\n\nГруппа 2128-030401D\n\n\n  02.09 Ортогональные матрицы\n  16.09 Углы Эйлера\n  16.09 Кватернионы\n  30.09 Интегрирование ОДУ в MATLAB\n  14.10 Кинематические уравнения\n  28.10 Основы динамики твердого тела\n  11.11 Движение орбитальной ступени\n  25.11 Случай Эйлера\n  09.12 Случай Лагранжа\n  16.12 Случай Лагранжа в MATLAB\n  23.12 Зачет\n\n\nГруппа 1135-030401D\n\n\n  13.09 Ортогональные матрицы.\n  27.09 Углы Эйлера.\n  27.09 Кватернионы.\n  11.10 Кинематические уравнения.\n  25.10 Основы динамики твердого тела\n  08.11 Движение орбитальной ступени\n  22.11 Случай Эйлера\n  06.12 Случай Лагранжа\n  20.12 Зачет\n\n\n",
      "url": "/pages/mbs/plan2023/"
    },{
      
      "title": "Уравнения движения с кинематическими связями",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Материальная точка массы \\(m\\) падает на гладкую цилиндрическую поверхность радиуса R в однородном гравитационном поле. В начальный момент времени \\(x(0) = x_0 &gt; 0\\), \\(y(0) = h_0 &gt; R\\). Взаимодействие при контакте материальной точки с поверхностью в момент времени \\(t_c\\) абсолютно неупругое. Изменение скорости в момент контакта происходит мгновенно. После удара точка начинает скользить по поверхности.\n\n\n  Определить проекции скорости точки на оси системы координат \\(Ox_oy_o\\) в момент начала скольжения (\\(t_c\\)), используя теорию абсолютно неупругого удара.\n  Записать уравнения движения материальной точки по поверхности в декартовой системе координат \\(Ox_oy_o\\) с уравнением связи (в координатах: x и y).\n  Записать уравнение связи при движении точки по поверхности.\n  Численно проинтегрировать уравнения движения и найти  угол \\(\\varphi_s\\), при котором точка отрывается от поверхности.\n  Записать условие отрыва точки от поверхности (функция от скорости и положения точки).\n  Построить график изменения силы реакции взаимодействия точки с поверхностью в зависимости от времени на интервале \\([t_c; t_s]\\).\n  Построить график изменения силы реакции взаимодействия точки с поверхностью в зависимости от угла \\(\\varphi\\).\n  Зависит ли угол отрыва \\(\\varphi_s\\) от массы точки?\n  При какой минимальной начальной высоте \\(h_0\\) точка после соударения с поверхностью продолжит движение, не касаясь поверхности?\n\n\nИсходные данные: \\(h_0 = 1.1\\) м, \\(R = 1\\) м, \\(x_0 = 0.1\\) м, \\(\\varphi = 10^o\\).\n\n\n",
      "url": "/pages/mbs/point_on_roof/"
    },{
      
      "title": "Многоугольник и точка",
      "description": "Задание для курсовой работы\n",
      "content": "\n  \n    Многоугольник задан координатами своих \\(N\\) вершин в порядке обхода их по контуру по часовой стрелке.\n  \n  \n    Для точки с координатами \\((x,y)\\) определить, принадлежит ли она стороне многоугольника или лежит внутри или вне его.\n  \n  \n    Программа должна показать на экране многоугольник и точку и вывести на этом же рисунке информацию о взаимном положении точки и многоугольника:\n  \n\n\n\n  координаты ближайшей точки многоугольника\n  расстояние от заданной точки до ближайшей: положительное, если заданная точка лежит вне многоугольника, отрицательное, если точка лежит внутри многоугольника.\n\n\n\n  Результат работы программы должны выводиться на экран и сохраняться в графический файл формата png.\n\n\n\n",
      "url": "/pages/python/course_works/point_polygon/"
    },{
      
      "title": "Интегрирование системы дифференциальных уравнений движения системы точек в среде Python",
      "description": "Пример программы интегрирования уравнений движения цепи материальных точек, связанных невесомыми пружинами.\n",
      "content": "Вдоль горизонтальной прямой движутся n материальных точек с массами \\(m_k\\) (\\(k=1,\\ldots,n\\)), связанные пружинами с заданными жесткостями \\(c_k\\)  и свободными длинами \\(L_k\\).\n\n\n\nУравнения движения\n\nДифференциальное уравнение движение первого тела:\n\n[m_1 \\ddot{x}1 = - c_1 (x{1}-L_1) + c_2 (x_{2}-x_{1}-L_{2})]\n\nДифференциальное уравнение движение \\(k\\)-го тела (\\(2 \\leq k \\leq n-1\\)):\n\n[m_k \\ddot{x}k = - c_k (x{k}-x_{k-1}-L_k) + c_{k+1} (x_{k+1}-x_{k}-L_{k+1}), \\quad k=2,\\ldots,n-1]\n\nДифференциальное уравнение движение \\(n\\)-го тела:\n\n[m_n \\ddot{x}n = - c_n (x{n}-x_{n-1}-L_n)]\n\nУравнения движения в форме Коши:\n\n[\\left{\n\\begin{aligned}\n    &amp; \\dot{x}1 = V_1 \n    &amp; \\dot{V}_1 = \\frac{1}{m_k} \\left[- c_1 (x{1}-L_1) + c_2 (x_{2}-x_{1}-L_{2}) \\right] \n    &amp; \\dot{x}k = V_k \\quad k=2,\\ldots,n-1 \n    &amp; \\dot{V}_k = \\frac{1}{m_k} \\left[  - c_k (x{k}-x_{k-1}-L_k) + c_{k+1} (x_{k+1}-x_{k}-L_{k+1}), \\right] \\quad k=2,\\ldots,n-1 \n    &amp; \\dot{x}n = V_n \n    &amp; \\dot{V}_n = - \\frac{1}{m_n} c_n (x{n}-x_{n-1}-L_n) \n\\end{aligned}  \n\\right.]\n\nПрограмма\n\nПодключаем библиотеки\n\n# Массивы и матрицы\nimport numpy as np\n# Функция численного интегрирования\nfrom scipy.integrate import odeint\n# Структура с параметрами системы\nfrom collections import namedtuple\n# Графики\nimport matplotlib.pylab as plt\n\n\nФункция правых частей дифференциальных уравнений\n\ndef dqdt(q,t,p):\n    # Делим массив q (1,2n) на две части \n    # xv[0] = n координат x1,x2,...,xn \n    # xv[1] = n скоростей v1,v2,...,vn\n    xv = np.hsplit(q,2)    \n    x  = xv[0]\n    # Массив расстояний между точками\n    # Для первой точки - расстояние до начала координат\n    dx = np.diff(np.append(np.array([0]),x))\n    # Вычисляем силы растяжения пружин. Добавляем к этому списку справа 0 \n    # для сохранения структуры уравнений движения последней точки, \n    # на которую действует сила только от одой пружины\n    F  = np.append((dx - p.L0)*p.c,0)\n    # Массив сумм сил, действующих на каждую материальную точку\n    Fi = np.array([ -F[i]+F[i+1] for i in range(F.size-1) ])\n    # результат [массив скоростей, массив ускорений]\n    a  = np.hstack((xv[1],Fi/p.m))    \n    return a\n\n\nПараметры системы\n\np = namedtuple(\"p\", \"n c L0 m\")\n# Количество тел\np.n  = 5\n# Массив жесткостей пружин\np.c  = np.ones(p.n)*20\n# Свободная длина пружин\np.L0 = 1.0\n# Массы точек\np.m  = np.ones(p.n)*1.0\n\n\nИнтегрирование уравнений движения\n\n# Интервал интегрирования от 0 до 10 с шагом 0,01 с\nti = np.arange(0, 10.0, 0.01)\n# Начальная скорость точек\nv0 = np.zeros(p.n)\n# Начальное положение точек\nx0 = (np.random.rand(p.n)-0.5)*2*0.2+np.arange(5)+1.0\n# Начальный вектор состояния \nq0 = np.hstack((x0,v0))\n# Запускаем процесс численного интегрирования              \nq = odeint(lambda q,t: dqdt(q,t,p), q0, ti)\n\n\nГрафики изменения координат точек\n\nplt.figure(figsize=[11,11])\nfor i in range(1,6):\n    plt.subplot(3,2,i)\n    plt.plot(ti,q[:,i-1]); \n    plt.grid(ls=':')\n    plt.xlabel('t, c')\n    plt.ylabel('$x_{:}, м$'.format(i))\n\nplt.tight_layout()\nplt.savefig('npoints_q.png',dpi=150)    \n\n\n\n",
      "url": "/pages/python/points_springs/"
    },{
      
      "title": "Пересечение многоугольников",
      
      "content": "\n  Найти пересечение и объединение двух выпуклых многоугольников.\n  Многоугольники задаются координатами вершин в порядке обхода по контуру.\n  Координаты вершин заданы в текстовом файле.\n  Программа должна изобразить на экране исходные многоугольники и многоугольник – результат пересечения (объединения).\n\n\nИсточник: http://algolist.manual.ru/olimp/geo_prb.php\n\nСписок заданий\n",
      "url": "/pages/python/course_works/polygons/"
    },{
      
      "title": "Ломаная линия",
      
      "content": "В текстовом файле заданы координаты точек ломаной линии в виде:\n\nx1,y1\nx2,y2\nx3,y3\n...\nxn,yn\n\n\n\n  Нарисовать ломаную линию на экране.\n  Проверить является ли эта ломаная линия самопересекающейся.\n  Найти точки пересечения и обозначить эти точки на экране.\n  Записать координаты точек пересечения в текстовый файл.\n  Результат работы должен выводиться на экран и сохраняться в файле формата png.\n\n",
      "url": "/pages/python/course_works/polyline/"
    },{
      
      "title": "Презентации",
      "description": "Презентации к дисциплине “Динамика твёрдого тела и систем твёрдых тел”\n",
      "content": "Кинематика твёрдого тела\n\n\n  Ортогональные матрицы\n  Углы Эйлера\n  Кватернионы\n  Кинематические уравнения\n\n\nДинамика твёрдого тела\n\n\n  Основы динамики твёрдого тела\n  Случай Эйлера\n  Случай Лагранжа\n\n\nДинамика систем твёрдых тел\n\n\n  Уравнения связей. Двойной маятник\n  Матричные уравнения связей в декартовых координатах: связь “точка-плоскость” и связь, ограничивающая относительное вращение\n  Структура механической системы\n  Метод Виттенбурга. Сферические шарниры)\n  Метод Виттенбурга. Цилиндрические шарниры)\n  Метод Верещагина\n  Метод Кейна\n\n\n",
      "url": "/pages/mbs/presentations/"
    },{
      
      "title": "Основы Python",
      "description": "Презентации к дисциплине “Технологии и языки программирования” для студентов первого курса Института ракетно-космической техники Самарского университета.\n",
      "content": "Семестр 1\n\n\n  Введение\n  Основы Python 1. Синтаксис\n  Основы Python 2. Списки, кортежи, множества\n  Основы Python 3. Словари\n  Функции\n  Элементы функционального программирования\n  Модули и пакеты\n  Ввод и вывод\n\n\nСеместр 2\n\n\n  Обработка ошибок\n  Основы ООП 1.\n  Основы ООП 2.\n  Библиотека numpy\n  Библиотека scipy\n  Машинная арифметика\n  Библиотека matplotlib\n\n\n",
      "url": "/pages/python/presentations/"
    },{
      
      "title": "Компьютерная графика",
      "description": "Презентации к дисциплине “Компьютерная графика” для студентов второго курса Института ракетно-космической техники Самарского университета.\n",
      "content": "\n  Введение. Основы работы в Inkscape\n  Python и библиотека matplotlib\n  Основы Gnuplot\n  Преобразование поворота\n  Анимация в Mathematica\n  imagemagic и ffmpeg\n\n\n",
      "url": "/pages/graphics/presentations/"
    },{
      
      "title": "Презентации к курсу \"Базы данных\"",
      
      "content": "\n  Лекция 1. Информационная система. Базы данных. Модели данных. Система управления базами данных: функции и структура.\n  Лекция 2. Модель сущность-связь.\n  Лекция 3. Реляционная модель данных. Реляционная алгебра. Нормализация: четыре нормальные формы.\n  Лекция 4 Основы SQL. Типы данных. Создание таблиц. Индексы. Обеспечение целостности данных.\n  Лекция 5. Основы SQL. Манипулирование данными.\n  Лекция 6. Основы SQL. Изменение данных (INSERT, UPDATE, DELETE). Процедуры и триггеры.\n  Лекция 7. Основы NoSQL.\n\n",
      "url": "/pages/databases/presentations/"
    },{
      
      "title": "Презентации",
      
      "content": "Учебные презентации\n\n\n  Динамика твёрдого тела и систем тел\n  Основы Python\n  Основы MATLAB\n  Компьютерный практикум по механике\n  Компьютерная графика\n  Базы данных\n  Управление ИТ-сервисом и контентом\n\n\nПрезентации для конференций и семинаров\n\n\n  \n    Valeriy I. Trushlyakov, and Vadim V. Yudintsev “Control of the Rotating Tethered System for Orbital Debris Removal”. Global Space Exploration Conference (GLEX2021),St Petersburg, Russian Federation, 14-18 June 2021. Paper id: GLEX-2021,7,5,6,x62094.\n  \n  \n    V. Trushlyakov, V. Yudintsev Method of Active Debris Removal Using Rotating Space Tether System. The First International Orbital Debris Conference (IOC) \nDecember 9-12, 2019, Sugar Land, Texas.\n  \n  \n    Трушляков В. И., Юдинцев В. В. Вращающаяся тросовая система для увода космического мусора. III International scientific conference “Mechanical Science and Technology Update” (MSTU-2019). 23-24 April, 2019 (Omsk, Russia).\n  \n  \n    Трушляков В.И., Юдинцев В. В. Космический буксир на базе ТГК “Прогресс” для активного увода космического мусора. Презентация для Девятого Международного Аэрокосмического Конгресса. МГУ им. М.В. Ломоносова, 28-31 августа 2018 г.\n  \n  \n    V. Yudintsev The problems of nanosatellite cluster launching and the deployers for nanosatellites separation. Presentation for the XIV International Summer Space School “Future Space Technologies and Experiments in Space”, Samara University, Samara, Russia, 20 Aug - 1 Sep, 2018.\n  \n  \n    V. Trushlyakov, V. Yudintsev Progress-M spacecraft as the basis for the space tug for adr missions. Presentation for 5th European Workshop on Space Debris Modeling and Remediation - CNES HQ - Paris, June 25-27, 2018.\n  \n  \n    Проблема космического мусора: современные направления исследований обзор работ 7-ой Европейской конференции по космическому мусору (офис центра управления полетами ЕКА, Дармштадт, Германия, 18-21 апреля 2017 г.)\n  \n  \n    Модификация механизма Йо-Йо: гашение угловой скорости орбитальной ступени при помощи механизма Йо-Йо без образования космического мусора. Презентация подготовлена для семинара кафедры теоретической механики по материалам статьи “Detumbling Space Debris Using Modified Yo-Yo Mechanism” Journal of Guidance, Control, and Dynamics, Vol. 40, No. 3 (2017), pp. 714-721.\n  \n  \n    Асланов В. С., Юдинцев В. В. Стыковка с объёктом космического мусора с использованием упругой разворачиваемой штанги. Presentation for 68th International Astronautical Congress (IAC), Adelaide, Australia, 25-29 September 2017.\n  \n  \n    Vladimir S. Aslanov, Arun K. Misra, Vadim V. Yudintsev Chaotic motions of tethered satellites with low thrust. Presentation for 67th International Astronautical Congress (IAC), Guadalajara, Mexico, 26-30 September 2016.\n  \n  \n    The Removal of Large Space Debris Using Tethered Space Tug. Presentation for the 5th Eucass - European Conference for Aerospace Sciences - Munich, Germany, 1-4 July 2013.\n  \n  \n    Dynamics of towed non-functional satellite by tether\n  \n\n\n",
      "url": "/pages/presentations/"
    },{
      
      "title": "Презентации к курсу \"Методы вычислений\"",
      
      "content": "\n  Метод Гаусса\n  СЛАУ специального вида\n  Итерационные методы решения СЛАУ\n  Методы решения нелинейных уравнений и систем\n  Решение задач на собственные значения\n  Многошаговые методы решения ОДУ\n  Многочлены наилучших приближений\n\n\n",
      "url": "/pages/numerical_methods/presentations/"
    },{
      
      "title": "Задача Прима-Краскала",
      
      "content": "Дана плоская страна и в ней n городов. Нужно соединить все города телефонной связью так, чтобы общая длина телефонных линий была минимальной.\nВ декартовой системе координат положение \\(i\\)-го города, \\(i = 1,...,n\\), задано парой координат \\((x[i],y[i])\\). \\(d[i,j]\\) - декартово расстояние между i-ым городом и j-ым городом , \\(j=1,...,n\\). В задаче речь идет о телефонной связи, т. е. подразумевается транзитивность связи: если i-й город связан с j-ым, а j-ый с k-ым, то i-й связан с k-ым.\n\nИсточник: http://pkgn.ru/do/TRPP/TrppKurs.pdf\nАлгоритм Краскала\n\nСписок заданий\n",
      "url": "/pages/python/course_works/prima/"
    },{
      
      "title": "Проект 2024.1",
      
      "content": "Рассматривается движение возвращаемой ступени двухступенчатой ракеты-носителя сверхлегкого класса на интервале от момента её отделения от второй ступени и до момента подхвата вертолетом при движении на парашюте (или до момента приводнения). Предполагается, что для возвращения ступени используется схема аэродинамического торможения с использованием парашютов без повторного запуска двигателя.\n\nПосле отделения от второй ступени выполняется разворот возвращаемой ступени на 180 градусов по углу атаки при помощи газореактивных сопел. После завершения разворота и входа в плотные слои атмосферы выполняется раскрытие стабилизирующего парашюта для обеспечения устойчивого движения возвращаемой ступени при движении в плотных слоях атмосферы в процессе аэродинамического торможения. При приближении к поверхности земли вводится основной парашют (или последовательно несколько парашютов) для снижения скорости к моменту прохождения высоты подхвата ступени вертолетом.\n\nМодели\n\nМодель движения материальной точки в атмосфере\nДвижение возвращаемой ступени как материальной точки в атмосфере под действием аэродинамической силы и силы притяжения Земли. Определения параметров по траектории спуска (скорость, высота, скоростной напор), для формирования алгоритмов управления и определения условий ввода стабилизирующего и основного парашютов.\n\nУравнения движения есть в книжке “Вход в атмосферу космических летательных аппаратов”.\n\nМодель разворота\nАнализ движения возвращаемой ступени как твердого тела в атмосфере под действием возмущающего воздействия аэродинамических сил и управляющих моментов газореактивных сопел. Оптимальное управление  разворотом ступени по углу атаки с учетом движения центра масс.\n\nВ книжке “Алгоритмы управления космическим аппаратом при входе в атмосферу” в разделах 5.2 и 5.3 приведены однопараметрическая и двухпараметрические схемы управления угловым движением и стабилизации при действии возмущающего момента.\n\nМодель движения твердого тела на парашюте в атмосфере\n\nАнализ движения возвращаемой ступени как твердого тела в атмосфере под действием возмущающего воздействия аэродинамических сил и силы натяжения троса стабилизирующего парашюта. Анализ движения системы ступень - трос - парашют. Формирование требований к стабилизирующему парашюту.\n\nМодель спуска на парашюте\n\nФормирование требований к основной парашютной системе (количество и площадь парашютов, условия ввода парашюта). Определение условий подхвата (время, высота).\n\nЛитература\n\n\n  Охоцимский Д. Е., Голубев Ю. Ф., Сихарулидзе Ю. Г. Алгоритмы управления космическим аппаратом при входе в атмосферу. М.: Наука, 1975..\n  Ярошевский В.А. Вход в атмосферу космических летательных аппаратов. М.: Наука, 1988.\n  Лобанов Н.А. Основы расчета и конструирования парашютов. 1965.\n  Стасевич Р. А. Основы проектирования и расчета грузовых парашютных систем: Учебное пособие / Р. А. Стасевич. - Ленинград: 1969.\n\n",
      "url": "/pages/thesis/projects/project-2024/"
    },{
      
      "title": "Движение спускаемого аппарата в атмосфере",
      "description": "Простейшая плоская модель движения СА в атмосфере (Nguyen X. Vinh, Adolf Busemann, Robert D. Culp Hypersonic and planetary entry flight mechanics) The Unevrsity of Michigan Press\n",
      "content": "Спускаемый аппарат, рассматриваемый как материальная точка с заданной массой,  коэффициентом лобового аэродинамического сопротивления \\(C_d\\) и коэффициентом подъемной силы \\(C_l\\) начинает движение на круговой орбите высотой 100 км. Уравнения движения СА имеют вид:\n\n[\\frac{dV}{dt} = - \\frac{C_d S_m q}{m} - g \\sin \\theta,]\n\n[V \\frac{d \\theta}{dt} = \\frac{C_l S_m q}{m} - \\left(g-\\frac{V^2}{r}\\right) \\cos \\theta,]\n\n[\\frac{dr}{dt} = V \\sin \\theta]\n\nгде \\(V\\) - скорость СА; \\(\\vartheta\\) – угол наклона траектории (угол между вектором скорости и линией местного горизонта); \\(r\\) – расстояние от центра Земли до центра масс СА; \\(g\\) – ускорение свободного падения на высоте \\(h\\); \\(m\\) – масса СА; \\(S_m\\) – характерная площадь (площадь Миделя); \\(C_d\\) – аэродинамический коэффициент лобового сопротивления; \\(C_l\\) – аэродинамический коэффициент подъёмной силы; \\(q\\) – скоростной напор, зависящий от плотности воздуха и скорости движения СА:\n\n[q = \\frac{\\rho V^2}{2}]\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса СА, кг\n      1000\n    \n    \n      \\(C_d\\)\n      1.2\n    \n    \n      \\(C_l\\)\n      0.0\n    \n    \n      \\(S_m\\), м\\(^2\\)\n      5\n    \n  \n\n\nКод на языке Python\n\nПодключение необходимых библиотек\n\nfrom collections import namedtuple\nimport scipy\nfrom scipy.integrate import solve_ivp\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\nМодель изменения плотности воздуха в диапазоне от 0 до 100 км с погрешностью 1,5% (В. А. ЯРОШЕВСКИЙ “АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ” Ученые записки ЦАГИ, т. XL, №3, 2009.)\n\na  = np.array([-6.3759,-7.3012,-1.1817])\nb  = np.array([-0.4754,-0.0096,-0.0068,-0.0120,0.0042]);\nc  = np.array([ 0.1803, 0.0872,-0.0153, 0.0145,0     ]);\n\ndef rho(h):\n  # Функция вычисления плотности воздуха \n  # высота h задаётся в километрах\n  # результат -- плотность кг/м3\n  x = h/50.0-1\n  sa = a[0] + a[1]*x + a[2]*x*x\n  sbc= sum( (b[i]*np.cos((i+1)*np.pi*x) + c[i]*np.sin((i+1)*np.pi*x) for i in range(5)) ) \n  return np.exp(sa + sbc)\n\n\nКонстанты\n\n# Гравитационный параметр Земли\nmu = 398600.4415e9\n# Радиус Земли\nRe = 6371000.0\n\n\nФункция вычисления ускорения свободного падения м/с\\(^2\\) на высоте h (в метрах)\n\ndef g_acc(h):\n  # \n  return mu/(Re+h)**2\n\n\nФункция правых частей\n\nФункция правых частей дифференциальных уравнений: вычисление правых частей дифференциальных уравнений для\nмомента времени t и вектора состояния y = [r(t), v(t), theta(t)]:\n\ndef dydt(t, y, p):  \n\n  # Радиус-вектор точки в момент времени t\n  r     = y[0]\n  # Скорость  в момент времени t \n  v     = y[1]\n  # Угол наклона траекториии  в момент времени t  \n  theta = y[2]\n    \n  # Высота (км)\n  h     = (r - Re)*0.001\n  # Скоростной напор Н/м^2\n  q     = rho(h)*v*v/2  \n  # Ускорение свободного падения\n  g     = g_acc(r - Re)\n    \n  # dv/dt =   \n  dv    = - q*p.CD*p.Sm/p.mass - g*np.sin(theta) \n  # dtheta/dt =   \n  dtheta= (q*p.CL*p.Sm/p.mass - (g - v*v/r)*np.cos(theta))/v\n  # dr/dt =    \n  dr    = v*np.sin(theta) \n  # ds/dt\n  ds    = (Re/r)*v*np.cos(theta)\n  \n  return (dr,dv,dtheta,ds)\n\n\nФункция для остановки процесса интегрирования при достижении нулевой высоты\n\ndef event_h_eq_0(t, y):\n  # Функция-\"детектор\", передаваемая в интегратор (параметр events), \n  # для определения времени достижения нулевой высоты и \n  # остановки процесса интегрирования  \n  \n  return y[0]-Re  \n\n# функция определяется условие h = 0 при движении \"вниз\"\nevent_h_eq_0.direction = -1\n# функция-детектор активна\nevent_h_eq_0.terminal  = True  \n# функция возвращает высоту  \n\n\nПараметры системы\n\nparams = namedtuple(\"params\", \"CD CL mass\")\n# Масса тела\nparams.mass = 60000.0 \n# Аэродинамические коэфиициенты, \n# которые в общем случае зависят от числа Маха, \n# угла атаки\nparams.CD   = 1.4    # Коэффицент лобового сопротивления \nparams.CL   = 0.0    # Коэффицент подъёмной силы\n# Площадь миделя\nparams.Sm   = np.pi*3**2/4     \n\n\nНачальные условия\n\n# Начальные условия\nh0     = 120e3 # Начальная высота [м]\nv0     = 2800 # Начальная скорость [м/c]\ntheta0 = np.deg2rad(30.0)  # начальный угол наклона траектории [радиан]\n\n\nЗапуск процесса интегрирования\n\nsol = solve_ivp(lambda t,y: dydt(t,y,params), [0, 1000.0], [Re+h0, v0, theta0, 0], method='LSODA', events = [event_h_eq_0], rtol = 1e-9)\n\n\nРезультаты\n\nГрафик изменения высоты от времени\n\nplt.plot(sol.t,(sol.y[0]-Re)*0.001);\nplt.xlabel('t, c');plt.ylabel('h, км');\n\n\nЗависимость скоростного напора от высоты\n\nplt.plot((sol.y[0]-Re)*0.001,0.001*rho((sol.y[0]-Re)*0.001)*sol.y[1]*sol.y[1]/2.0);\nplt.xlabel('h, км');plt.ylabel('q, кН/м$^2$');\n\n\nПример кода на языке Python (в Google Colab)\n",
      "url": "/pages/python/python-reentry/"
    },{
      
      "title": "Кватернины.",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел\n",
      "content": "Алгебра кватернионов\n\nПроизведение кватернионов\n\nfunction AB = Q_multiple(A, B)    \n    if size(A,2) == size(B,2)\n        AB = [A(1,:).*B(1,:)-dot(A(2:4,:),B(2:4,:)); \n              repmat(A(1,:),3,1).*B(2:4,:)+...\n              repmat(B(1,:),3,1).*A(2:4,:)+cross(A(2:4,:),B(2:4,:))];\n    else\n        error('A и B должны иметь одинаковый размер 4xN, N&gt;=1.');\n    end\nend\n\n\nСопряжённый кватернион\n\nfunction QA = Q_conjugate(A)\n    QA = [A(1,:); -A(2:4,:)];\nend\n\n\nОртогональные преобразования\n\nКватернион ортогонального преобразования\n\nФункция возвращает массив 4x1 координат кватерниона\n\n[\\mathbf \\Lambda = \\cos \\frac{\\varphi}{2} + \\mathbf{e} \\sin \\frac{\\varphi}{2}]\n\nопределяющего поворот вокруг оси, определяемой единичным вектором \\(\\mathbf e\\) на угол \\(\\varphi\\):\n\nfunction A = Q_rotation(e, phi)\n    A  = [cos(phi/2); e.*repmat(sin(phi/2),3,1)];\nend\n\n\nЕдиничный вектор \\(\\mathbf e\\) передается в функцию quat_rotation первым аргументом и может быть задан столбцом 3x1 или строкой 1x3.\n\nОртогональное преобразование\n\n[\\mathbf R’ = \\mathbf \\Lambda \\circ \\mathbf R \\circ \\hat{\\mathbf \\Lambda}]\n\nfunction Rp = quat_rotate(A, R)\n    Rp = quat_multiply(quat_multiply(A, [0 reshape(R,1,3)]),quat_conjugate(R));\nend\n\n",
      "url": "/pages/mbs/quat-example/"
    },{
      
      "title": "Кватернионы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "\n\nОриентация системы координат \\(C x_c y_c z_x\\), связанной с космическим аппаратом по отношению к орбитальной системе координат определяется углом рыскания, углом тангажа и углом крена в указанной последовательности. Первый разворот на угол рыскания \\(\\psi\\) выполняется вокруг оси \\(C x_c\\), второй разворот на угол на угол тангажа \\(\\vartheta\\) вокруг оси \\(C z_c\\), третий поворот на угол собственного вращения \\(\\varphi\\) вокруг оси \\(C y_c\\). При нулевых значениях углов система координат, связанная с космическим аппаратом, совпадает с орбитальной системой координат.\n\nОриентация космического аппарата определяется углами:\n\n[\\psi = 90^o]\n\n[\\vartheta = 5 + (\\text{NNNNN}\\mod 5) \\; ^o]\n\n[\\varphi = 10 + (\\text{NNNNN}\\mod 5) \\; ^o]\n\nгде NNNNN - последние пять цифр зачётной книжки.\n\n\n  \n    Запишите кватернионы элементарных поворотов.\n  \n  \n    Напишите функцию MATLAB, вычисляющую произведение кватернионов.\n  \n\n\nfunction res = quat_multiple(q1, q2)\n% quat_multiple - вычисление произведения кватернионов\n% Аргументы:\n% q1 - координаты кватерниона [4x1]\n% q2 - координаты кватерниона [4x1] \n% Результат\n% res = q1*q2 [4x1] \n...\n...\n...\nres = ... ;\n\n\n\n  Вычислите кватернион \\(\\Lambda\\) преобразования координат из орбитальной системы координат в систему, связанную с КА:\n\n\n[R^{(c)} = \\Lambda \\circ R^{(0)} \\circ \\bar{\\Lambda}]\n\n\n  По координатам кватерниона \\(\\Lambda\\) вычислите матрицу преобразования координат  и сравните полученный результат с матрицей, построенной в лабораторной работе 1.\n\n",
      "url": "/pages/mbs/quat/"
    },{
      
      "title": "Вопросы теста",
      
      "content": "\n  Как определяет понятие “Информационные технологии” ГОСТ 34.003-90?\n  Как определяет понятие “Информационные технологии” ISO/IEC 38500:2008?\n  Что такое опорные технологии?\n  Какая цель ИТ-менеджмента?\n  Что такое WCMS?\n  Что является объектом ИТ-менеджемента?\n  Что является целью ИТ-менеджмента?\n  Параметры ИТ-сервиса.\n  Что такое надежность ИТ-сервиса?\n  Направления деятельности ИТ-службы.\n  Кто может предоставлять ИТ-сервис предприятию?\n  Ключевые характеристики процесса (при процессном подходе к организации работы ИТ-службы).\n  Кто  непосредственно отвечает за качество ИТ-процесса?\n  Кто осуществляет оперативное управление процессом?\n  Какой внутренний документ компании, определяющий зоны ответственности подразделений при взаимодействии в процессе формирования некой внешней услуги?\n  Как “расшифровывается” аббревиатура RFC в контексте ITIL?\n  Что такое проактивное изменение (Управление изменениями)?\n  Где фиксируются информация об изменении в рамках процесса управления изменениями?\n  Кто утверждает изменения (Управление изменениями)?\n  Может ли изменение утверждаться без процедуры возврата к исходному состоянию?\n  Чем определяется ожидаемый простой услуги при планировании затрагивающем её изменения?\n  Оцениваются ли затраты на изменение в рамках процесса по управлению изменениями?\n  Если запланированное изменение требует значительных затрат на его реализацию, то ему присваивается\n  Может ли помочь процесс управления конфигурациями снизить объем использования нелицензионного программного обеспечения в организации?\n  Программные продукты (коммерческие или свободные), которые можно использовать для управления конфигурациями (CMDB).\n  В рамках какого процесса производится лицензионный контроль программного обеспечения?\n  Цель процесса управления проблемами.\n  Цель процесса управления инцидентами.\n  Кто является владельцем процесса управления инцидентами?\n  Сотрудниками какого уровня поддержки определяются и документируются временные решения для обхода часто возникающих инцидентов.\n  Что такое срочность инцидента?\n  В рамках какого процесса управляются проекты по устранению ошибок?\n  Чем определяется приоритет инцидента?\n  К какому разделу библиотеки ITIL относится “Управление проблемами”.\n  Какие образом осуществляется взаимодействие службы поддержки Сервис-деск и пользователей.\n  Может ли в SLA включаться требование о предоставлении сведений о мерах, которые принимает исполнитель некоторой услуги для улучшения показателей её качества?\n  Что такое Изменение в терминологии ITIL?\n\n\n",
      "url": "/pages/it/questions/"
    },{
      
      "title": "Темы рефератов курса \"Управление IT-сервисом и контентом\"",
      
      "content": "Реферат оформляется в соответствии с “СТО 02068410-004-2018 Общие требования к учебным текстовым документам” и представляется в виде презентации (не более 10 минут) на одной из лабораторных работ.\n\n\n  Лицензирование программного обеспечения: свободные, несвободные, условно-бесплатные, коммерческие, BSD, MIT, и другие лицензии и их сравнение.\n  Практика использования свободных лицензий на предприятиях.\n  Криптографические методы защиты информации: история, алгоритмы, программное обеспечение, правовое регулирование в области криптографии в России и других странах.\n  Электронная цифровая подпись: история, алгоритмы, программное обеспечение, правовое регулирование электронной цифровой подписи в России и других странах.\n  Сравнение нескольких решений Service Desk.\n  Обзор систем управления базами данных конфигурациями (CMDB): открытые и коммерческие.\n  Облачные технологии в бизнесе.\n  Обзор систем видеоконференцсвязи.\n  Обзор корпоративных мессенджеров (чатов).\n  Обзор систем управления веб-контентом.\n  Обзор программного обеспечения мониторинга ИТ-инфраструктуры.\n  Обзор программных систем электронного документооборота.\n  Системы управления контентом предприятия (Enterprise Content Management).\n  Корпоративный VPN (назначение, виды, решения).\n  Реклама в Интернет: виды, особенности, эффективность.\n\n\n",
      "url": "/pages/it/referats/"
    },{
      
      "title": "Однофакторная и многофакторная линейные регрессии",
      
      "content": "Найти параметры \\(a\\) и \\(b\\) уравнения прямой\n\n[y = a + b x,]\n\nкоторая при этих значениях наилучшим образом приближает зависимость одной переменной от другой.\n\n\n\nДля определения коэффициентов a и b используется метод наименьших квадратов, при котором минимизируется сумма квадратов отклонений предсказанного значения \\(\\hat y_i = y(x_i)\\) от соответствующего значения зависимой переменной \\(y_i\\) (Sum of Squared Errors - SSE):\n\n[\\text{SSE}(a,b)=\\text{SS}{res[iduals]}=\\sum{i=1}^N{\\text{отклонение}i}^2=\\sum{i=1}^N(y_i-f(x_i))^2=\\sum_{i=1}^N(y_i-a-b\\cdot x_i)^2]\n\nРешается задача\n\n[\\min_{a, b} \\text{SSE}(a,b)]\n\nПример. Рассмотрим зависимость объема продаж от затрат на рекламу по телевидению, не учитывая других факторов. Построим график статистической зависимости объема продаж в зависимости от затрат на ТВ рекламу.\n\nПодключаем необходимые библиотеки:\n\nimport pandas as pd\nimport numpy as np\nimport scipy.stats \n\nimport io\nimport requests\n\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nsns.set(font_scale=1.2, palette='Set2')\n\n\nЗагружаем данные:\n\nurl=\"https://classmech.ru/assets/files/advertising.csv\"\ns=requests.get(url).content\nadvert=pd.read_csv(io.StringIO(s.decode('utf-8')))\nadvert.head()\n\n\nВид таблицы с данными (первые пять строк):\n\n\tTV\tRadio\tNewspaper\tSales\n0\t230.1\t37.8\t69.2\t22.1\n1\t44.5\t39.3\t45.1\t10.4\n2\t17.2\t45.9\t69.3\t12.0\n3\t151.5\t41.3\t58.5\t16.5\n4\t180.8\t10.8\t58.4\t17.9\n\n\nПостроим диаграмму рассеяния:\n\nplt.scatter(advert['TV'], advert['Sales'])\n\n\n\n\nОпределим параметры линейной функции, аппроксимирующей статистические данные при помощи scipy.stats.linregress:\n\nresult = scipy.stats.linregress(advert['TV'], advert['Sales'])\n\n\nАтрибуты результата (results):\n\n  result.slope = b - наклон прямой или коэффициент регрессии (Regression Coefficient)\n  result.intercept = a - начальное значение a = y(0)\n  result.rvalue = r коэффициент корреляции. \\(R = r^2\\) - коэффиицент детерминации, который показывает, в какой степени изменчивость одной переменной (y) обусловлена (детерминирована) влиянием другой переменной (x). Величина коэффициента детерминации равна 1, означает что функция идеально ложится на все точки — данные идеально скоррелированны.\n  result.pvalue - p-значение для проверки нулевой гипотезы о равенстве нулю наклона прямой \\(H_0: b = 0\\). По умолчанию альтернативной гипотезой является \\(H_1: b \\neq 0\\).\n  result.stderr - стандартная ошибка наклона прямой b\n  result.intercept_stderr - стандартная ошибка начального значения a\n\n\nplt.scatter(advert['TV'], advert['Sales'])\n\nTV_x = np.linspace(min(advert['TV']),max(advert['TV']),100)\nsales_predicted = result.intercept+result.slope*TV_x \n\nplt.plot(TV_x, sales_predicted, 'r--', lw = 3)\nplt.show()\n\n\n\n\nНайденное p-значение практически равно нулю\n\nresult.pvalue\n\n&gt;&gt; 7.927911625322733e-74\n\n\nпоэтому нулевая гипотеза отвергается, следовательно между рекламой на ТВ и продажами есть статистическая связь.\n\nСтандартные ошибки a и b позволяют оценить доверительный интервал для этих параметров\n\\(a = \\hat a \\pm t_\\alpha SE_a\\)\n\n[b = \\hat b \\pm t_\\alpha SE_b]\n\nгде \\(\\hat a\\), \\(\\hat b\\) – точечные оценки \\(a\\) и \\(b\\), \\(SE_a\\), \\(SE_b\\) - стандартные ошибки \\(a\\) и \\(b\\), \\(t_{1-\\alpha/2}\\) - квантиль распределения Стьюдента уровня \\(\\alpha\\) (двухсторонний) с n−2 степенями свободы.\n\n# Используем распределение Стьюдента для оценки доверительных интервалов\n# p - вероятность, df - число степеней свободы\ntinv = lambda p, df: abs(scipy.stats.t.ppf(p/2, df))\n\n\nts = tinv(0.05, len(advert['Sales'])-2)\nprint('С уровнем доверия 95 %:')\nprint('a принадлежит интервалу от {:.3f} до {:.3f}'.format(result.intercept-ts*result.intercept_stderr, result.intercept+ts*result.intercept_stderr))\nprint('b принадлежит интервалу от {:.3f} до {:.3f}'.format(result.slope-ts*result.stderr, result.slope+ts*result.stderr))\n\n\nРезультат:\n\nС уровнем доверия 95 %:\na принадлежит интервалу от 6.339 до 7.611\nb принадлежит интервалу от 0.052 до 0.059\n\n\nПосле построения доверительного интервала коэффициента корреляции, делается\nпроверка на попадание нуля в этот интервал.\n\nЕсли ноль попадет в доверительный интервал, с высокой вероятностью можно\nсчитать, что в генеральной совокупности связь между переменными отсутствует. В\nэтом случае коэффициент корреляции является статистически незначимым.\n\nЕсли ноль не попал в доверительный интервал, то с высокой вероятностью в\nгенеральной совокупности не может быть нулевого значения коэффициента\nкорреляции, что означает: связь между переменными существует. В таком случае\nкоэффициент корреляции является статистически значимым.\n\nМультилинейная регрессия\n\nМножественной или мультилинейной называют линейную регрессию, в модели которой число независимых переменных две или более. Уравнение множественной линейной регрессии имеет вид:\n\n[y = a_0 + b_1 x_1 + b_2 x_2 + \\ldots + b_n x_n]\n\nДля определения параметров этой функции будем использовать библиотеку sklearn.\n\nimport sklearn \nimport sklearn.model_selection\nimport sklearn.linear_model \nimport sklearn.metrics\n\n\nРазобъем выборку на две части при помощи функции train_test_split:\n\n  выборка для определения коэффициентов модели (обучающая)\n  выборка для оценки работы модели (тестовая)\n\n\ntrain, test = sklearn.model_selection.train_test_split(advert, test_size=0.2)\n# Размер выборки для \"обучения\" модели \n# (определения коэффициентов мультилинейной регрессии)\nprint(train.shape)\n# Размер выборки для последующего тестирования модели \nprint(test.shape)\n\n\n(160, 4)\n(40, 4)\n\n\n# Столбцы со свободными переменными - признаками\nvariables = ['TV', 'Radio', 'Newspaper']   \n# Столбец со значениями функции - целевой признак\ntarget    = 'Sales'  \n\n\n# Значения независимых переменных обучающей выборки\nX_train = train[variables]\n# Значения независимых переменных тестовой выборки\nX_test  = test[variables]\n\n\nДля обзора данных построим отношения между парами переменных:\n\n  На диагоналях - плотности распределения\n  Выше диагонали - диаграммы рассеяния\n  Ниже диагонали - совместные плотности распределения\n\n\ng = sns.PairGrid(advert[['TV',  'Radio', 'Newspaper', 'Sales']], diag_sharey=False, height=2)\ng.map_lower(sns.kdeplot, alpha=0.5) \ng.map_upper(plt.scatter, alpha=0.5) \ng.map_diag(sns.kdeplot, lw=2, alpha=0.9, common_norm=True) \ng.add_legend()\nplt.show()\n\n\n\n\nСоздаем модель\n\nmodel = sklearn.linear_model.LinearRegression(fit_intercept=True)  \n\n\n“Тренируем” ее на обучающей выборке (определяем коэффициенты)\n\nmodel.fit(X_train, train[target])  \n\n\nСвободный член мультилинейной функции\n\nmodel.intercept_\n\n&gt;&gt; 5.0293435246287075\n\n\nЗначения коэффициентов\n\nmodel.coef_\n\n&gt;&gt; array([ 0.05269666,  0.10909234, -0.00382442])\n\n\nОценим значения Y при помощи модели для значений независимых переменных тестового набора данных и сравним результаты с соответсвующими значениями тестовой набора\n\ncompareData  = pd.DataFrame({'Tested': test[target],'Predicted': model.predict(X_test)})\ncompareData = pd.concat([X_test, compareData],axis = 1)\n# Добавим столбец с относительной погрешностью\ncompareData['Rel. error'] = np.round((compareData['Tested'] - compareData['Predicted'])*100/compareData['Tested'],1)\ncompareData.head()\n\n\nTV\tRadio\tNewspaper\tTested\tPredicted\tRel. error\n155\t4.1\t    11.6\t    5.7\t    3.2\t        6.489072\t-102.8\n115\t75.1\t35.0\t    52.7\t12.6\t    12.603548\t-0.0\n173\t168.4\t7.1\t        12.8\t16.7\t    14.629065\t12.4\n80\t76.4\t26.7\t    22.3\t11.8\t    11.882850\t-0.7\n60\t53.5\t2.0\t        21.4\t8.1\t        7.984957\t1.4\n\n\nДля оценки качества модели библиотека sklearn предлагает несколько метрик для оценки погрешностей построенной модели\n\n\n  Среднеквадратичная ошибка\n\n\n[MSE = \\frac{1}{N} \\sum_{i=1}^{N} (y_i - y(x_i))^2]\n\nsklearn.metrics.mean_squared_error(test[target], model.predict(X_test))\n\n&gt;&gt; 3.0153747854144215\n\n\n\n  Коэффициент детерминации\n\n\nsklearn.metrics.r2_score(test[target], model.predict(X_test))  \n\n&gt;&gt; 0.9068127798062458\n\n\nКоэффициент детерминации может быть определен, используя метод модели score\n\nmodel.score(X_test,test[target])\n\n&gt;&gt; 0.9068127798062458\n\n\n\n  Абсолютная средняя ошибка\n\n\n\n  \n    \n      [\\text{MAE}(y, \\hat{y}) = \\frac{1}{n_{\\text{samples}}} \\sum_{i=0}^{n_{\\text{samples}}-1} \\left\n      y_i - \\hat{y}_i \\right\n      .]\n    \n  \n\n\nsklearn.metrics.mean_absolute_error(test[target], model.predict(X_test))\n\n&gt;&gt; 1.0890322497403002\n\n\n\n  Cредняя абсолютная процентная ошибка\n\n\n\n  \n    \n      [\\text{MAPE}(y, \\hat{y}) = \\frac{1}{n_{\\text{samples}}} \\sum_{i=0}^{n_{\\text{samples}}-1} \\frac{\\left\n      y_i - \\hat{y}_i \\right\n      }{\\max(\\epsilon, \\left\n      y_i \\right\n      )}]\n    \n  \n\n\nsklearn.metrics.mean_absolute_percentage_error(test[target], model.predict(X_test))\n\n&gt;&gt; 0.2162503623522544\n\n\n\n  Максимальная по модулю ошибка:\n\n\n\n  \n    \n      [\\text{Max Error}(y, y(x_i)) = \\max(\n      y_i - y(x_i)\n      )]\n    \n  \n\n\nsklearn.metrics.max_error(test[target], model.predict(X_test))\n\n&gt;&gt; 7.753015549113567\n\n\n\n  Средняя по модулю ошибка\n\n\n\n  \n    \n      [\\text{MAE}(y, \\hat{y}) = \\frac{1}{n_{\\text{samples}}} \\sum_{i=0}^{n_{\\text{samples}}-1} \\left\n      y_i - \\hat{y}_i \\right\n      .]\n    \n  \n\n",
      "url": "/pages/bigdata/regression/"
    },{
      
      "title": "Относительное орбитальное движение",
      
      "content": "\n  \n    От носителя (орбитальной ступени) одновременно отделяются три малых космических аппарата с одинаковыми скоростями \\(V_1 = V_2 = V_3 = 1\\) м/с.\n  \n  \n    Векторы приращений скоростей малых КА относительно орбитальной ступени лежат в плоскости орбиты, как показано на рисунке.\n  \n  \n    Носитель движется по круговой орбите высотой 400 км.\n  \n\n\n\n\n\n  \n    Используя уравнения относительного орбитального движения, определите наилучший угол отделения КА - \\(\\alpha\\), при котором минимальное расстояние между любыми КА и между любым КА и носителем (при сближении) в течение двух орбитальных периодов носителя было бы максимальным.\n  \n  \n    Постройте траектории движения КА относительно носителя (на одном рисунке).Постройте графики изменения расстояний между КА и носителем и между каждой парой КА (на одном рисунке).\n  \n  \n    Сравните результаты с решением, полученным при интегрировании уравнений абсолютного движения КА в центральном гравитационном поле Земли: постройте на одном рисунке траекторию движения одного КА относительно носителя (в орбитальной подвижной системе координат), и траекторию этого же КА, построенную на основе результатов интегрирования движения КА и носителя в центральном поле.\n  \n\n\nПример построения траекторий относительного орбитального движения (линейная модель)\n\n% Гравитационная постоянная \nmu = 398600.4415e9;\n\n% Высота орбиты носителя\nh0 = 300e3;\n\n% Угловая скорость орбитального движения носителя по круговой орбите\nw0 = sqrt(mu/(6371000+h0)^3);\n\n% Орбитальный период носителя\nTorb = 2*pi/w0;\n\n% Уравнения относительного орбитального движения КА, отделившегося от \n% носителя со скоростью v0 (координатный столбец), \n% заданной  орбитальной подвижной системе координат носителя\nr = @(t,w0,v0) [v0(1)/w0*sin(w0*t)-2*v0(2)/w0*cos(w0*t)+2*v0(2)/w0;\n                2*v0(1)/w0*(cos(w0*t)-1)+4*v0(2)/w0*sin(w0*t)-3*v0(2)*t;\n                v0(3)/w0*sin(w0*t)];\n\n\n% Решение определяется на 2х орбитальных периодах\ntlist = 0:1:2*Torb;\n\n% Угол отделения КА\nphi = 9*pi/180;\n\n% Скорости отделения 3х КА \nv10 = [cos(phi);sin(phi);0]*0.5;\nv20 = [cos(phi+120*pi/180);sin(phi+120*pi/180);0]*0.5;\nv30 = [cos(phi+240*pi/180);sin(phi+240*pi/180);0]*0.5;\n\n% Траектории [Nx3]\ns1 = r(tlist,w0,v10)'; \ns2 = r(tlist,w0,v20)'; \ns3 = r(tlist,w0,v30)';\n\n% Расстояния от КА до носителя\nd1 = sqrt(sum((s1).^2,2)); \nd2 = sqrt(sum((s2).^2,2));\nd3 = sqrt(sum((s3).^2,2));\n\n% Расстояния между парами КА\nd12 = sqrt(sum((s1-s2).^2,2)); \nd13 = sqrt(sum((s1-s3).^2,2));\nd23 = sqrt(sum((s2-s3).^2,2));\n\n% Траектории\nsubplot(2,1,1)\nplot(s1(:,2)*1e-3,s1(:,1)*1e-3,'LineWidth',2)\nhold on;\nplot(s2(:,2)*1e-3,s2(:,1)*1e-3,'LineWidth',2)\nplot(s3(:,2)*1e-3,s3(:,1)*1e-3,'LineWidth',2)\nhold off\ngrid; xlabel('y_0, км'); ylabel('x_0, км');\nlegend('КА1','КА2','КА3');\n\n% Расстояния\nsubplot(2,1,2);\nplot(tlist/3600,d12*1e-3);\nhold on;\nplot(tlist/3600,d13*1e-3);\nplot(tlist/3600,d23*1e-3);\nplot(tlist/3600,d1*1e-3,'--');\nplot(tlist/3600,d2*1e-3,'--');\nplot(tlist/3600,d3*1e-3,'--');\n\n% Отрезки убывания функции\ndecr_d1 = diff(d1)&lt;0;\nplot(tlist(decr_d1)/3600,d1(decr_d1)*1e-3,'r.');\nhold off; grid;\nxlabel('t, ч'); ylabel('км');\nlegend('d_{12}','d_{13}','d_{23}','d_1','d_2','d_3','\\Delta d_1 / \\Delta t &lt; 0');\n\n\n\n",
      "url": "/pages/mechanics-in-space/relative-orbital-motion/"
    },{
      
      "title": "Относительное орбитальное движение",
      
      "content": "Задание\n\nНаноспутник отделяется от космической станции в плоскости её орбиты под углом \\(\\alpha\\) к орбитальной скорости c заданной скоростью.\n\nСтанция движется по круговой орбите высотой h.\n\nВысота орбиты станции, скорость и направление отделения задаются в текстовом файле.\n\nПостроить траекторию движения наноспутника относительно станции в течение первых трёх орбитальных периодов станции для заданных значений скорости отделения спутника и угла \\(\\alpha\\).\n\nСкорость отделения (м/с) и угол отделения (градус) задаются пользователем в диалоговом режиме. Угол отсчитывается от направления орбитальной скорости станции против часовой стрелки.\n\nМетодические указания\n\nСписок заданий\n",
      "url": "/pages/python/course_works/relative_orbital_motion/"
    },{
      
      "title": "Продольные колебания стержня",
      
      "content": "Стержень, как система материальных точек, связанных пружинами\n\nПредставим однородный стержень постоянного сечения \\(A\\) массы \\(M\\) в виде системы \\(n\\) материальных точек, соединенных невесомыми линейно-упругими элементами – пружинами. Масса материальных точек:\n\n[m_i = M/n]\n\nЖесткость пружин:\n\n[c_i = n \\cdot \\frac{EA}{L}]\n\nгде \\(E\\) – модуль Юнга, \\(L\\) – длина стержня.\n\nУравнение движения массы \\(i\\) имеет вид (в проекции на горизонтальную ось \\(x\\) )\n\n[m_i \\ddot{x}i = -F_i + F{i+1}, \\quad i = 1, \\ldots, n-1]\n\nДля последней массы (\\(i=n\\))\n\n[m_n \\ddot{x}_n = -F_n]\n\nСилы, действующие на массы вычисляются следующим образом\n\n[F_k = c_k (x_k - x_{k-1} - l_0), \\quad k=2,\\ldots,n]\n\nДля первой точки\n\n[F_1 = c_1 (x_1 - l_0)]\n\nгде \\(l_0\\) - свободная длина пружины\n\n[l_0 = \\frac{L}{n}]\n\n\n\nПрограмма (файл-скрипт)\n\n% Модуль Юнга Н/м2\nE  = 1000000;\n% Площадь поперечного сечения стержня м2\nA  = 0.001;\n% Погонная масса кг/м\nmu = 10.0;\n% Длина стержня м\nL  = 1.0;\n% Масса стержня\nM   = L*mu;\n% Количество материальных точек, на которые разбивается стержень\nN   = 30;\n% Начальное расстояние между точками (l0)\np.L = L/N;\n% Масса материальной точки\np.m = M/N;\n% Жесткость пружин\np.c = N*E*A/L;\n%\n% Начальное положение точек\nx0  = (1:N)'/N*(L+0.1);\n% Начальная скорость\nvx0 = zeros(N,1);\n% Вектор состояния\nq0  = [x0;vx0];\n\n% Интегрирование\n[t, q] = ode113(@(t,q) dqdt(t,q,p),0:0.002:2,q0,odeset('RelTol',1e-8));\n\n% Вектор деформаций пружин\ndx = [q(:,1)-p.L (q(:,2:N) - q(:,1:N-1))-p.L];\n% Максимальная деформация\ndx_max = max(max(dx));\n% Минимальная деформация\ndx_min = -dx_max;\n% Открываем файл для записи видео\nv = VideoWriter('rod_d.avi');\nopen(v);\n% Фигура\nfigure('Position',[100 100 1920 1080]);\naxis([0 L*1.3,-0.5, 0.5]);\nset(gca,'FontSize',20);\ngrid on; hold on;\n% Палитра\ncolormap('jet');\n% Для каждого момента времени из таблицы результатов интегрирования\nfor i=1:size(t,1)\n    % Очищаем рисунок\n    cla;\n    % Массив деформаций пружин\n    dydx = ([q(i,1) diff(q(i,1:N))] - repmat(p.L,1,N));\n    % Вершины прямоугольников, изображающих пружины\n    % Каждый столбец содержит 4-ку координат для прямоугольника\n    % Координаты x   \n    vertex_x  = [0 q(i,1) q(i,1) 0; q(i,1:N-1)' q(i,2:N)' q(i,2:N)' q(i,1:N-1)'];\n    % Координаты y\n    vertex_y  = repmat([0.1 0.1 -0.1 -0.1],N,1);     \n    % Рисуем все прямоугольники сразу\n    % Третий аргумент - деформация каждой пружины для раскраски прямоугольника\n    patch(vertex_x', vertex_y', dydx,'FaceColor','flat');\n    % Приведение диапазона деформаций к диапазону цветов\n    caxis([dx_min dx_max]);\n    colorbar;\n    text(0.1,0.45,sprintf('T=%5.3f c. Длина стержня L=%5.3f м',t(i),q(i,N)),'FontSize',20);   \n    % График деформаций\n    fplot(@(x) interp1([0 q(i,1:N)],[0 dydx]*0.1/dx_max,x,'next'),[0 q(i,N)],'k-','LineWidth',1);\n    frame = getframe(gcf);\n    writeVideo(v,frame);\nend\nclose(v);\n\n\nФайл-функция правых частей дифференциальных уравнений движения системы материальных точек\n\nfunction dq = dqdt(t, q, p)\n\nn  = size(q,1)/2;\nx  = q(1:n);\n\n% Расстояние между точками для определения деформаций пружин\n% x1 (x2-x1) (x3-x2) (x4-x3) ... (xn - x_n-1)\nxdif = [x(1);diff(x)];\n\n% Из расстояний между точками вычитается свободная длина пружины\n% определяется деформация\n% x1-l0 (x2-x1)-l0 (x3-x2)-l0 (x4-x3)-l0 ... (xn - x_n-1)-l0\ndx   = xdif - repmat(p.L,n,1);\n\n% По деформации определяется сила\n% F = [-(x1-l0)*c -(x2-x1-l0)*c ...]\nF    = -dx*p.c;\n% На все точки, кроме последей, действуют еще силы со стороны соседней пружины справа\n% с противоположным знаком. На последнюю точку действует только одна пружина,\n% поэтому к действующей на нее силе добавляется ноль\nF    = F - [F(2:end); 0];\n\n% Ускорения точек\na    = F/p.m;\n% Результат работы функции -- скорости и ускорения точек\ndq   = [q(n+1:end);a];\n\nend\n\n\n\n\nСтержень, как распределённая система\n\nБабаков И.М. Теория колебаний. 4-е изд., испр. - М.: Дрофа, 2004. - 591 с\n\nУпругие свободные колебания однородного стержня постоянного сечения описываются линейным уравнением в частных производных с постоянными коэффициентами\n\n[\\frac{\\partial^2 y}{\\partial t^2} - c^2  \\frac{\\partial^2 y}{\\partial x^2} = 0]\n\nгде велчиина \\(c\\) представляет собой скорость распространения звука в материале стержня, зависящая от модуля упругости \\(E\\) материала и его плотности:\n\n[c^2 = \\frac{E \\cdot A}{\\mu}]\n\nВ последней формуле плотность материала стержня определяется отношением погонной массы \\(\\mu\\) к площади поперечного сечения \\(A\\).\n\nСложные малые колебания рассматриваемой системы с бесконечным числом степеней свободы представляются в виде суммы гармонических колебаний с частотами \\(p_i\\) и формами колебаний \\(d_i(x)\\), определяющих распределение деформаций по длине стержня\n\n[y_i(x,t) = d_i(x) \\sin (p_i \\cdot t + \\alpha_i)]\n\nгде \\(d_i(x)\\) – \\(i\\)-я форма главного колебания  – амлитудное значение деформации, как функция положения точки на стержне.\n\nПодстановка \\(y(x,t) = d(x) \\sin (p \\cdot t + \\alpha)\\) в уравнение движения приводит к уравнению собственных форм колебаний:\n\n[d’‘(x) + a^2 d(x) = 0]\n\nгде\n\n[a^2 = \\frac{p^2 \\mu}{EA}]\n\nРешение полученного однородного дифференциального уравнения второго порядка  имеет следующий вид:\n\n[d_i(x) = B \\cos a_i x + C \\sin a_i x]\n\nПостоянные \\(B\\) и \\(C\\) определяются из граничных условий – условий закрепления стержня. Например для закрпеленного с одной стороны стержня граничные условия будут иметь вид:\n\n[d(0) = 0]\n\n[d’(L) = 0]\n\nПодставляя эти граничные условия в решение, получим\n\n[B = 0]\n\nи\n\n[C a_i \\cos a_i L = 0]\n\nНетривиальное решение этого уравнения имеет вид:\n\n[\\cos a_i L  = 0 \\quad a_i = \\frac{1+2k}{2 L} \\pi, \\quad k=0,1,2,\\ldots,\\infty]\n\nТаким образом, ряд сообственных частот продольных колебаний стержня c закреплённым (\\(x=0\\)) будет определяться следующим образом:\n\n[p_k = \\sqrt{\\frac{EA}{\\mu}} \\frac{1+2k}{2 L} \\pi, \\quad k=0,1,2,\\ldots,\\infty]\n\nОбщее решение имеет следующий вид\n\n[y(x, t) = \\sum_{i=1}^{\\infty} d_i(x) (M_i \\cos p_i t + N_i \\sin p_i t)]\n\nПостоянные \\(M_i\\), \\(N_i\\) определяются из начальных условий – распределения начальной деформации по длиней стержня:\n\n[y(x,0) = f(x)]\n\nи распределением начальных скоростей:\n\n[\\dot{y}(x,0) = \\gamma(x)]\n\nВ общем случае константы \\(M_i\\), \\(N_i\\) определяются следующим образом:\n\n[M_i = \\int_0^L d_i(x) f(x) dx]\n\n[N_i = \\frac{1}{p_i} \\int_0^L d_i(x)\\gamma(x) dx]\n\n% Модуль Юнга Н/м2\nE  = 1000000;\n% Площадь поперечного сечения м2\nA  = 0.001;\n% Погонная масса kg/м\nmu = 10.0;\n% Длина стержная м\nL  = 1.0;\n% Количество учитываемых собственных форм\nk  = 1:10;\na  = (2*k-1)*pi*0.5/L;\n% Массив частот\np  = a*sqrt(E*A/mu); % рад/с\n% Начальная деформация\n% К концу стержня приложена растягивающая сила F\nF  = 100; % Н\ny0 = @(xx) interp1(linspace(0,L,10),F*linspace(0,L,10)/(E*A),xx);\n% Постоянные, определяемые по начальным условиям (для частоты i)\nM  = @(i)  (2/L)*integral(@(xx) y0(xx).*sin(a(i).*xx),0, L);\nM  = @(i)  (2*F/(L*E*A))*sin(a(i)*L)/(a(i)^2.0);\n% Начальная скорость деформаций равна нулю, поэтому (для частоты i)\nN  = @(i) 0;\n% Слагаемые общего решения\nyk = @(i,t,x) (M(i)*cos(p(i)*t)+N(i)*sin(p(i)*t))*sin((2*i-1)*pi*x*0.5/L);\n% Слагаемые деформации\nek = @(i,t,x) (M(i)*cos(p(i)*t)+N(i)*sin(p(i)*t))*cos((2*i-1)*pi*x*0.5/L)*(2*i-1)*pi*0.5/L;\n% Общее решение y(t,x)\ny   = @(t,x) sum(arrayfun(@(i) yk(i,t,x),k));\n% Деформация\neks = @(t,x) sum(arrayfun(@(i) ek(i,t,x),k));\n% ------------------------------------------------------------------------\n% Рисуем\n% ------------------------------------------------------------------------\n% Видео\nv = VideoWriter('rod_c.avi');\nopen(v);\n\n% Разделяем балку на 30 частей (для раскраски)\nx = linspace(0,L,30);\nfigure('Position',[100 100 900 600]);\naxis([0 1.3 -0.5 0.5]);\nhold on;\n% Цветовая палитра JET\ncmap = colormap(jet(128));\n% Максимальная деформация\nmaxd =  0.2;\nmind = -0.2;\ndef2index = @(d) floor((d-mind)/((maxd-mind)/size(cmap,1)));\nfor t=0:0.002:2\n    cla;\n    yx = arrayfun(@(xx) y(t,xx),x);    \n    pos = x + yx;    \n    defx = arrayfun(@(xx) eks(t,xx),x);\n    for j = 1:size(x,2)\n        col = cmap( def2index(defx(j)),:);\n        prev_point = 0;\n        if j ~= 1\n            prev_point = pos(j-1);\n        end\n        patch([prev_point pos(j) pos(j) prev_point],...\n              [0.1 0.1 -0.1 -0.1],col,'EdgeColor','none');            \n    end\n    plot(pos, arrayfun(@(xx) eks(t,xx),x));\n    xlabel('x, м');ylabel('y, м');box('on');\n\n    text(0.1,0.45,sprintf('T=%5.3f c. Длина стержня L=%5.3f м',t,yx(end)+L));    \n    text(0.1,0.35,sprintf('Частоты (Гц): '));    \n    text(0.1,0.31,sprintf('%3.1f | ',(2*pi./p).^-1));    \n\n    frame = getframe;    \n    writeVideo(v,frame);    \nend\nclose(v);\n\n\n\n",
      "url": "/pages/matlab/rod/"
    },{
      
      "title": "Исследование безударности относительного орбитального движения группы космических аппаратов после отделения от носителя",
      "description": "Задание для выпускной квалификационной работы.\n",
      "content": "Исходные данные\n\nОт носителя (орбитальной ступени) одновременно отделяется два малых космических аппарата (МКА) под углом \\(\\gamma = 5^o\\) градусов к продольной оси носителя. Заданы: ориентация носителя в орбитальной подвижной системе координат, параметры орбиты носителя, энергия пружинных толкателей отделения и её возможная погрешность, массы космических аппаратов. Масса МКА (600±20) кг, масса орбитальной ступени 4000±400 кг, суммарная работа толкателей отделения каждого МКА (50±5) Дж.\n\n\n\nЗадание\n\n\n  \n    Исследовать движение МКА друг относительно друга и относительно орбитальной ступени в течение 3 орбитальных периодов используя нелинейные уравнения относительного орбитального движения и линеаризованные уравнения относительного орбитального движения при различных угловых ориентациях станции относительно её орбитальной подвижной системы координат.\n  \n  \n    Используя метод Монте-Карло, оценить вероятность сближения КА друг с другом и с носителем на расстояние меньше заданного. Рассматривать массу МКА, массу орбитальной ступени и работу суммарную работу пружинных толкателей как случайные величины, нормальной распределенные с заданными статистическими характеристиками.\n  \n  \n    Сформулировать требования к ориентации орбитальной ступени на момент отделения МКА, обеспечивающий минимизацию вероятности сближения изделий в течение трех витков.\n  \n\n\nПлан-проспект пояснительной записки\n\nВведение\n\nОтделение нескольких КА. Проблема безударного отделения.\n\nПостановка задачи.\n\n…\n\nМодель относительного орбитального движения КА\n\nУравнения движения\n\nУравнения движения материальной точки в центральном поле. Нелинейные уравнения относительного орбитального движения для эллиптической орбиты станции. Уравнения относительного движения орбитального движения для круговой орбиты станции.\n\nНачальные условия\n\nСкорость отделения КА от носителя по энергетическим характеристикам толкателей отделения. Определение проекций скоростей отделения КА  на оси орбитальной системы координат носителя в зависимости от его ориентации.\n\nПроекции скоростей КА на оси системы координат носителя\n\n[V_1^{c} = V_1 \\begin{bmatrix} \\cos \\gamma \\ \\sin \\gamma \\ 0 \\end{bmatrix}, \\quad V_2^{c} = V_2 \\begin{bmatrix} \\cos \\gamma \\ -\\sin \\gamma \\ 0 \\end{bmatrix}]\n\nгде \\(V_1, V_2\\) – приращения скоростей КА 1 и 2 в результате работы средств отделения.\n\nОриентация связанной системы координат носителя \\(С x_с y_c z_c\\) относительно орбитальной подвижной системы координат задается углами рыскания \\(\\psi\\) (поворот вокруг оси y), тангажа \\(\\vartheta\\) (поворот вокруг оси z) и крена \\(\\varphi\\)  (поворот вокруг оси x).\n\n\n\nПри нулевых углах ось \\(Сx_с\\)  связанной системы координат носителя совпадает с осью \\(O y_o\\), \\(Сy_с\\)  с осью \\(O x_o\\), ось \\(C z_c\\) направлена в противоположном направлении оси \\(O z_o\\). С учётом этого матрица преобразования координат из системы, связанной с носителем, в орбитальную подвижную систему координат определяется матрицей поворота:\n\n[\\mathbf A = \\mathbf A_z(-\\pi/2) \\mathbf A_y(\\pi) \\mathbf A_y(\\psi) \\mathbf A_z(\\theta) \\mathbf A_x(\\phi)]\n\nПроекции приращений скоростей КА на оси орбитальной системы координат будут определяться выражением:\n\n[V_i^{(o)} = \\mathbf A \\begin{bmatrix} \\cos \\gamma \\ \\sin \\gamma \\ 0 \\end{bmatrix} V_i, \\quad i=1,2.]\n\nБезударность относительного орбитального движения\n\nГрафики изменения расстояния между КА и между каждым КА и носителем. Функция для оценки безударности относительного движения. Метод Монте-Карло.\n\n% Для заданной ориентации носителя\n% Задать количество расчетов n\nfor i=1:n\n  % Вычислить скорость отделения КА 1 \n  % Вычислить скорость отделения КА 2\n  % Рассчитать траекторию движения КА 1 относительно носителя\n  % Рассчитать траекторию движения КА 2 относительно носителя  \n  % Найти и запомнить минимальное расстояние в течение 3х орбитальных периодов min(КА1-КА2, КА1-носитель, КА2-носитель)\nend;\n\n\nРезультаты\n\nВыводы\n\nЛитература и ссылки\n\n\n  Alfriend K.T. et al. Spacecraft formation flying: Dynamics, control and navigation // Spacecraft Formation Flying: Dynamics, control and navigation. 2009.\n  Уравнения относительного орбитального движения.\n  Презентация. Уравнения относительного орбитального движения\n  Относительное орбитальное движение 1.\n  Относительное орбитальное движение 2\n\n",
      "url": "/pages/thesis/2025/sats/safety-sats/"
    },{
      
      "title": "Управление ИТ-контентом и анализ больших данных",
      
      "content": "Группа 7251-380405D\n\n20.09.23\n\n\n  Управление ИТ-контентом (EMS, WCMS).\n  Большие данные.\n  Инструменты для анализа данных\n  Основы Python.\n\n\n04.10.23\n\n\n  Библиотеки numpy, matplotlib, pandas.\n  Статистический анализ. Оценка параметров. Доверительные интервалы\n  Регрессия\n\n\n18.10.23\n\n\n  Проверка статистических гипотез.\n\n\nЭкзамен\n\n\n  00.00.00 00:00 Консультации\n  00.00.00 00:00 Экзамен\n\n\nЛабораторные работы\n\n\n  Лабораторная работа: основы Python\n  Лабораторная работа: numpy\n  Лабораторная работа: статистические гипотезы 1\n  Лабораторная работа: статистические гипотезы 2\n  Лабораторная работа: регрессия\n\n\nДополнительные материалы\n\n  Использование библиотеки pandas\n\n",
      "url": "/pages/bigdata/schedule-7251-380405D-2023/"
    },{
      
      "title": "Базы данных.",
      
      "content": "План занятий на весенний семестр 2023 года\n\nГруппы 7150-380305D, 7151-380305D, 7152-380305D\n\n\n  \n    \n      №\n      Дата\n      Тема\n    \n  \n  \n    \n      1\n      22.02.2023\n      Базы данных. Проектирование\n    \n    \n      2\n      22.03.2023\n      SQL. DDL\n    \n    \n      3\n      05.04.2023\n      SQL. DML 1\n    \n    \n      4\n      19.04.2023\n      SQL. DML 2\n    \n    \n      5\n      03.05.2023\n      NoSQL\n    \n  \n\n\nТема 1. 22.02.2023\n\n",
      "url": "/pages/databases/schedule/"
    },{
      
      "title": "Пользовательские функции и файл-скрипты",
      
      "content": "Файл-скрипт\n\nЛюбую последовательность команд в MATLAB можно оформить в виде m-файла.\n\n\n\n\n  Файл-скрипт не имеет входных и выходных аргументов.\n  Файл-скрипт работает с данными из рабочей области.\n  Все переменные, объявленные в файл-скрипте, являются глобальными.\n\n\nСтруктура файл-скрипта\n\n% Файл-скрипт my_script.m\n% Комментарий,\n% который появляется при вызове команды\n% help my_script\n\nx = 0:0.1:0.1;\ny = sin(x);\n\nplot(x,y);\n\n\nЗапустить, или другими словами выполнить последовательность действий, записанных в файл-скрипте, можно несколькими способами\n\n  запустить скрипт из редактора, нажав F5 (MS Windows)\n  набрать в консоли (Command window) имя скрипта и нажать Enter.\n\n\nВо втором случае файл-скрипт должен находится в текущем (рабочем) каталоге\n\n\n\nили в списке каталогов, которые просматривает MATLAB. Этот список можно изменить нажав кнопку Set Path\nна ленте Home\n\n\n\nФайл-скрипт можно для удобства разделить на секции при помощи удвоенного знака процента %%. Код в каждой секции можно выполнить отдельно от остального кода, нажав F9 (MS Windows), когда курсор находится в нужной секции.\n\n\n\nФайл-функции\n\nСобственные функции можно создавать тремя основными способами, используя\n\n\n  inline функции\n  анонимные функции\n  файл-функции\n\n\nInline-функции\n\nInline-функция объявляется при следующим образом:\n\n&gt;&gt; f1 = inline('x1^2+x2^2', 'x1', 'x2');\n&gt;&gt; f1(4,2)\n\n\nт.е. вызывается функция inline, в которую первым аргументов передается строка - выражение от аргументов функции, которые передаются следующим аргументами также в виде строк. В выражениях inline-функций не могут использоваться имена переменных из рабочей среды, а только переменные – аргументы, объявленные в функции inline.\n\nВызывается объявленная inline, как и любая другая функция, например, для объявленной выше функции двух переменных:\n\n&gt;&gt; f1(4,2)\n\n\nАнонимные функции\n\nБолее практичны в сравнении с inline-функциями анонимные функции, которые могут содержать имена переменных из рабочей среды. Анонимные функции также можно использовать для объявления коротких однострочных функций, создание для которых отдельных m-файлов нецелесообразно.\n\nАнонимная функция объявляется при помощи символа @, за которым в круглых скобках следуют аргументы функции, а затем её выражение, например, для объявления функции\n\n[f(x_1, x_2) = x_1^2 + x_2^2]\n\nнеобходимо написать\n\n&gt;&gt; f = @(x1,x2) x1^2+x2^2;\n\n\nАнонимные функции удобно использовать внутри выражений, например для построения графика функции \\(x^2 + sin(x)\\) на интервале от 0 до 5 можно написать\n\n&gt;&gt; f = @(x) x.^2 + sin(x);\n&gt;&gt; fplot( f, 0, 5 );\n\n\nно проще использовать анонимную функцию прямо в функции fplot\n\n&gt;&gt; fplot( @(x) x.^2 + sin(x), 0, 5);\n\n\nФайл-функция\n\n\n  Файл-функция содержит определение одной или нескольких функций.\n  По-умолчанию все переменные, объявленные внутри файл-функции, являются локальными.\n  Файл-функция является самостоятельным программным модулем, который связан с другими модулями и головной программой через входные и выходные параметры.\n\n\nСоздание файл-функции: File -&gt; New -&gt; Function\n\n\n\n% Комментарий к функции\n% \nfunction [res1, res2] my_function(x1, x2)\n    res1 = x1^2 + x2^2;\n    res2 = x1 + x2;\n\n\nПо умолчанию все переменные внутри функции являются локальными. Для того, чтобы несколько функций использовали одну переменную, её необходимо объявить глобальной.\n\n% Комментарий к функции\n% \nfunction [res1, res2] my_function(x1, x2)\n    global g;\n    res1 = g + x1^2 + x2^2;\n    res2 = x1 + x2;\n\n\nИмя файла и имя объявленной в нем функции должны совпадать. Как и для файл-скриптов каталог, в котором содержатся вызываемые функции, должен быть текущим (рабочим) или добавлен в список просматриваемых MATLAB.\n\nФункция прекращает работу после выполнения последнего оператора. Принудительно завершить функцию можно директивой return.\n\nФайл-функция вместе с определением основной функции может содержать определения вспомогательных функций, доступных к вызову только из основной функции. Переменные, используемые во внутренних функциях локальные.\n\nfunction f = myfun(x)\n    f1 = infun(x);\n    f  = f1 + cos(x);\n\n% Внутренняя функция\nfunction res = infun(x)\n    a = 3;\n    res = sin(x*3);\n\n\n",
      "url": "/pages/matlab/scripts/"
    },{
      
      "title": "Отделение полезного груза от орбитальной ступени",
      
      "content": "От орбитальной ступени ракеты-носителя (РН) отделяется космический аппарат (КА) при помощи трех пружинных толкателей.  Отделение КА происходит после выведения орбитальной ступени РН с КА на заданную орбиту и завершения работы двигателя орбитальной ступени.\n\nКА с орбитальной ступенью соединен при помощи пирозамков [1], которые срабатывают по команде от системы управления РН. В результате срабатывания пирозамков нарушается жесткая механическая связь между КА и орбитальной ступенью РН и КА под действием пружинных толкателей отделяется (отталкивается) от орбитальной ступени. Для телеметрического контроля отделения КА в поперечном стыке устанавливают датчики, которые сигнализируют об расхождении стыков (рисунок 1).\n\n\nРисунок 1 - Схема отделения КА\n\nСила пружинного толкателя изменяется в зависимости от перемещения его штока по линейному закону, убывая при выдвижении штока (рисунок 2). Начальное усилие одного пружинного толкателя равно \\(P_2\\), конечное усилие \\(P_1\\), максимальное перемещение штока (при котором усилие равно \\(P_1\\)) равно \\(h_p\\).\n\n\nРисунок 2 - Изменение силы пружинного толкателя в зависимости от перемещения его штока\n\n\nРисунок 3 - Относительное движение КА и орбитальной ступени РН\n\nЗадание\n\n\n  Определить приращение скорости КА \\(\\Delta V_2\\) после окончания работы пружинных толкателей.\n  Определить приращение скорости орбитальной ступени \\(\\Delta V_1\\) после окончания работы пружинных толкателей.\n  Определить продолжительность работы толкателей (записать уравнения движения КА и орбитальной ступени относительно инерциальной системы координат \\(Ox_oy_o\\) (вдоль оси Oxo) под действием пружин толкателей,проинтегрировать получившееся линейное неоднородное дифференциальное уравнение относительно \\(x_{12}\\)).\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса КА\n      6 т\n    \n    \n      Масса орбитальной ступени\n      2 т\n    \n    \n      Начальное усилие толкателя \\(P_2\\)\n      3000 Н\n    \n    \n      Конечное усилие толкателя \\(P_1\\)\n      500 Н\n    \n    \n      Количество толкателей\n      3\n    \n    \n      Максимальное перемещение штока толкателя \\(h_p\\)\n      0,3 м\n    \n  \n\n\nСписок использованных источников\n\n\n  Колесников К. С., Кокушкин В. В., Борзых С. В., Панкова Н. В. Расчет и проектирование систем разделения ступеней ракет. М. МГТУ им. Баумана 2006г.\n  Суханов А. А. Астродинамика Учреждение Российской акад. наук Ин-т космических исследований РАН. - Москва : Ин-т космических исследований РАН, 2010\n  Аппазов Р. Ф., Сытин О. Г. Методы проектирования траекторий носителей и спутников Земли. М. Наука 1987г.\n\n\n",
      "url": "/pages/mechanics-in-space/separation/"
    },{
      
      "title": "Буксировка на тросовой связи",
      
      "content": "Исходные данные\n\nКосмическая тросовая система для буксировки объекта космического мусора состоит из орбитального буксира, и объекта космического мусора, соединенных упругим невесомым тросом, выполненным из кевлара.\n\n\n  \n    \n      Параметр\n      Обозначение\n      Значение\n    \n  \n  \n    \n      Масса буксира\n      \\(m_1\\)\n      2000 кг\n    \n    \n      Масса объекта космического мусора\n      \\(m_2\\)\n      4000 кг\n    \n    \n      Модуль упругости материала троса\n      \\(E\\)\n      120 ГПа\n    \n    \n      Предел прочности троса\n      \\(\\sigma_b\\)\n      2.5 ГПа\n    \n    \n      Диаметр троса\n      \\(d\\)\n      ? мм\n    \n    \n      Свободная длина нерастянутого троса\n      \\(l_0\\)\n      1500 м\n    \n    \n      Сила тяги буксира\n      \\(P\\)\n      10 кН\n    \n  \n\n\n\n\nОбъект космического мусора и буксир рассматриваются как материальные точки постоянного состава. Движение тросовой системы происходит в безгравитационном пространстве.\n\nЗадание\n\n\n  Записать и проинтегрировать уравнения продольных колебаний троса для начальных условий \\(x_1(0) = l_0\\), \\(x_2(0) = 0\\), \\(\\dot{x}_1(0) = \\dot{x}_2(0) = 0\\) (буксировка с запуском двигателя буксира начинается в момент когда расстояние между телами равно свободной длине троса).\n  Определить диаметр троса, достаточный для безопасной транспортировки с запасом прочности троса 1,5.\n  Определить максимальную деформацию и максимальную силу натяжения троса.\n  Определить период продольных колебаний троса.\n  Определить максимальную деформацию и максимальную силу натяжения троса в случае если двигатель буксира запускается при расстоянии между объектом космического мусора и буксира равном \\(l_0 - 30 м\\): \\(x_1(0) = l_0 - 30\\) м, \\(x_2(0) = 0\\), \\(\\dot{x}_1(0) = \\dot{x}_2(0) = 0\\). Уточнить, при необходимости, диаметр троса.\n\n\n",
      "url": "/pages/mechanics-in-space/simple-towing-model/"
    },{
      
      "title": "Динамика раскрытия солнечных батарей КА при наземной отработке",
      "description": "Задание для выпускной квалификационной работы (магистратура, 2024).\n",
      "content": "Исходные данные\n\n\n\nМасса створки 1 - 15 кг, масса створки 2 - 12 кг, масса створки 3 - 10 кг, размеры 1x1x0.02 м. Масса балки 1 - 5 кг, балок 2 и 3 - 3 кг.\n\nЗадание\n\n\n  Разработать модель раскрытия створок солнечной батареи, состоящей из трех створок: движение створок происходит в одной плоскости, створки – абсолютно-твердые тела.\n  Разработать модель раскрытия створок солнечной батареи, состоящей из трех створок в условиях наземной отработки с учетом движения шарнирно-связанных балок системы обезвешивания, соединенных со створками упругими тросами.\n  Сравнить результаты моделирования движения створок солнечной батареи в условиях полета и в условиях наземной отработки.\n  Разработать модель раскрытия створок солнечной батареи, состоящей из трех створок в условиях наземной отработки с учетом движения системы обезвешивания при активном управлении звеньями системы обезвешивания.\n  Сравнить результаты моделирования движения створок солнечной батареи в условиях полета и в условиях наземной отработки.\n\n\n",
      "url": "/pages/thesis/2024/solar-array-deployment/"
    },{
      
      "title": "Задание. Раскрытие солнечной батареи космического аппарата",
      
      "content": "Построить модель процесса раскрытия солнечной батареи КА, состоящей из двух створок. На рисунке 1 показано начальное положение створок солнечной батареи. На рисунке 2 показано конечное положение створок солнечной батареи.\n\nВыбрать параметры торсионов, обеспечивающие раскрытие каждой створки с угловой скоростью не более \\(150\\,^{\\circ}/c\\).\n\n\n\nРисунок 1 - Закрытое (исходное) положение солнечной батареи\n\n\n\nРисунок 2 - Раскрытое положение солнечной батареи\n\nМасса каждой створки \\(m_{1}=m_{2}=10\\) кг, момент инерции створки относительно центра масс \\(J_{1z}=J_{2z}=J_{3z}=0.5\\) кг⋅м². Минимальная жесткость торсиона 0.16 Н⋅м/рад.\n\nСтворки считать однородными тонкими стержнями длиной 700 мм (рисунок 3).\n\n\n\nРисунок 3 - Упрощенная модель солнечной батареи\n\n",
      "url": "/pages/mechanics-in-space/solar-array-open/"
    },{
      
      "title": "Вращающаяся тросовая система",
      
      "content": "Рассматривается движение вращающейся космической тросовой системы, образованной космическим буксиром и объектом космического мусора, соединённых тросом. Вращающаяся космическая тросовая система используется для увода объекта космического мусора на орбиту утилизации по толкающей схеме, при которой тяга буксира действуют вдоль линии троса в направлении его сжатия. Натяжение троса обеспечивается вращением системы.\n\nУравнения продольных колебаний троса\n\nПостроим модель продольных колебаний троса вращающейся тросовой системы. Космический буксир и объект космического мусора рассматриваются как материальные точки постоянного состава, соединенные упругим невесомым тросом. Движение системы рассматривается в безгравитационным пространстве.\n\n\n\nРассмотрим движение буксира относительно неинерциальной системы координат \\(Cx_cy_c\\), расположенной в центре масс системы двух тел (точка C), и вращающейся в месте с тросом.\n\n[m_1{\\ddot{l}}1=-T-P+\\Phi\\omega+\\Phi_p]\n\nВ правой части уравнения указаны сила натяжения троса \\(T\\), тяга буксира \\(P\\) и две силы инерции, вызванные движением  центра масс системы с ускорением (\\(\\Phi_p\\)) и вращением троса (\\(\\Phi_\\omega\\)). Сила натяжения троса \\(T\\) зависит от жесткости троса (\\(c=EA/l_0\\)) и демпфирующих свойств троса. Предполагаем, что сила натяжения троса пропорциональна деформации \\(\\delta=l-l_0\\) и скорости деформации \\(\\dot{\\delta}=\\dot{l}\\)\n\n[T=c\\delta+k_d\\ \\dot{l}]\n\nгде \\(E\\) - модуль Юнга материала троса, \\(A\\) - площадь поперечного сечения троса, \\(k_d\\) - коэффициент демпфирования.\n\n[\\Phi_\\omega=\\omega^2 l_1 m_1, \\quad \\Phi_p=\\frac{P}{m_1+m_2}m_1]\n\nРасстояние от центра масс системы до буксира может быть выражено через длину троса:\n\n[l_1=\\frac{m_2}{m_1+m_2} (l_0+\\delta)]\n\nПодставляя выражения для сил и расстояния \\(l_1\\) в уравнение движения, получим:\n\n[\\ddot{\\delta}=-\\frac{EA}{l_0 m_{12}}\\delta-\\frac{k_d}{m_{12}} \\dot{\\delta}+\\omega^2(l_0+\\delta)-\\frac{P}{m_1}]\n\nгде \\(m_{12}\\) приведенная масса системы\n\n[m_{12}=\\frac{m_1m_2}{m_1+m_2}]\n\nВведем обозначение для квадрата собственной частоты продольных колебаний троса:\n\n[k^2=\\frac{EA}{m_{12}l_0},]\n\nи коэффициента демпфирования\n\n[\\eta=\\frac{k_d}{m_{12}}]\n\nПредставим деформацию троса \\(\\delta\\) как произведение удельной деформации \\(\\varepsilon\\) и свободной длины троса \\(\\delta=\\varepsilon l_0\\). Уравнение продольных колебаний троса принимает вид:\n\n[\\ddot{\\varepsilon}+k^2\\varepsilon+2\\eta\\ \\dot{\\varepsilon}=\\omega^2\\left(1+\\varepsilon\\right)-\\frac{P}{m_1l_0}]\n\nЭто уравнение является нелинейным вследствие зависимости \\(\\omega\\) от деформации троса. Уравнение имеет стационарное решение (\\(\\dot \\varepsilon = \\dot\\varepsilon = 0\\))\n\n[\\varepsilon_s=\\frac{\\omega_s^2-\\frac{P}{m_1l_0}}{k^2-\\omega_s^2}]\n\nиз которого можно получить стационарную деформацию троса \\(\\varepsilon_s\\) для заданной стационарной угловой скорости \\(\\omega_s\\). Для выполнения условия \\(\\varepsilon_s&gt;0\\) верхнее значение тяги  буксира должно быть ограничено:\n\n[P&lt;\\omega_s^2 m_1 l_0, \\quad  \\omega_s&gt;\\sqrt{\\frac{P}{m_1l_0}}]\n\nЭто выражение может быть использовано для получения минимальной угловой скорости вращающейся тросовой системы для заданной тяги буксира.\n\nДля вращающейся тросовой системы в отсутствие внешних моментов сохраняется кинетический момент относительно её центра масс:\n\n[K_r=(l_1^2m_1+l_2^2m_2), \\quad \\omega=m_{12}l^2\\omega=\\text{const}]\n\nПредположим, что в момент формирования вращающейся тросовой системы длина троса была равна его свободной длине \\(l_0\\). В этом случае начальная угловая скорость системы будет определяться выражением\n\n[\\omega=\\frac{l_0^2}{l^2}\\omega_0=\\frac{1}{(1+\\varepsilon)^2}\\omega_0]\n\nПодставляя это выражение для угловой скорости в дифференциальное уравнение движения, получим:\n\n[\\ddot{\\varepsilon}+k^2\\varepsilon+2\\eta\\ \\dot{\\varepsilon}=\\frac{\\omega_0^2}{\\left(1+\\varepsilon\\right)^3}-\\frac{P}{m_1l_0}]\n\nДля \\(\\varepsilon \\ll 1\\) можно линеаризовать первое слагаемое в правой части\n\n[\\frac{1}{(1+\\varepsilon)^3}\\approx1-3\\varepsilon]\n\nи привести уравнение движения к линейному неоднородному дифференциальному уравнению:\n\n[\\ddot{\\varepsilon}+\\left(k^2+3\\omega_0^2\\right)\\varepsilon+2\\eta\\dot{\\varepsilon}=\\omega_0^2-\\frac{P}{m_1l_0}]\n\nРешение этого уравнения при \\(P = 0\\) и при отсутствии демпфирования с начальными условиями\n\n[\\varepsilon(0)=0, \\quad  \\dot{\\varepsilon}(0) = \\dot{\\varepsilon}_0]\n\nимеет вид:\n\n[\\varepsilon=\\varepsilon_s \\left(1-\\cos \\frac{\\omega_0}{\\sqrt{\\varepsilon_s}} t \\right)+\\frac{\\dot{\\varepsilon}_0}{\\omega_0} \\sqrt{\\varepsilon_s} \\sin \\frac{\\omega_0}{\\sqrt{\\varepsilon_s}} t]\n\nгде деформация \\(\\varepsilon_s\\) определяется стационарным решением:\n\n[\\varepsilon_s = \\frac{\\omega_0^2}{k^2+3\\omega_0^2}]\n\nИсходные данные\n\nКосмическая тросовая система состоит из орбитального буксира, и объекта космического мусора, соединенных упругим тросом.\n\n\n  \n    \n      Параметр\n      Обозначение\n      Значение\n    \n  \n  \n    \n      Масса буксира\n      \\(m_1\\)\n      1000 кг\n    \n    \n      Масса объекта космического мусора\n      \\(m_2\\)\n      4000 кг\n    \n    \n      Модуль упругости материала троса\n      \\(E\\)\n      83 ГПа\n    \n    \n      Диаметр троса\n      \\(d\\)\n      ? мм\n    \n    \n      Свободная длина нерастянутого троса\n      \\(l_0\\)\n      3000 м\n    \n  \n\n\nТросовая система начинает движение с начальной угловой скоростью \\(\\omega = 3\\,^\\circ/c\\) при свободной длине троса \\(l_0\\) и нулевой тяге буксира.\n\nЗадание\n\n\n  Определить минимальный диаметр троса, обеспечивающий его прочность с запасом 1,5.\n  Найти деформацию и силу натяжения троса.\n  Определить период продольных колебаний троса.\n  Сравнить аналитическое решение линейной системы с численным решением нелинейной системы: определить абсолютную погрешность определения максимальной деформации троса в метрах, сравнив решения линейной и нелинейной систем.\n\n\n\n\n",
      "url": "/pages/mechanics-in-space/spinning-tethered-system/"
    },{
      
      "title": "Лабораторная работа №4. DML, часть 1",
      
      "content": "Описание базы данных\n\nОписание БД\n\nЗадание\n\nПостройте SQL-запросы для получения следующей информации из базы данных.\n\nЧасть 1\n\n\n  Все записи таблицы customers\n  Все записи таблицы categories\n  Все записи таблицы manufacturers\n  Все записи таблицы stores\n  Все записи таблицы products\n  Все записи таблицы deliveries\n  Все записи таблицы price_change\n  Все записи таблицы purchase_items\n  Фамилии и имена покупателей, отсортированные по имени\n  Фамилии и имена покупателей, отсортированные по фамилии\n  Количество покупателей в базе\n  Количество товаров в базе\n  Количество имен производителей в базе\n  Список производителей, отсортированный по алфавиту\n  Количество товаров, поступивших до заданной даты\n  Количество товаров заданной категории\n  Количество товаров в каждой категории (таблица вида: категория, количество)\n  Количество товаров заданного производителя\n  Количество товаров по каждому производителю (таблица вида: имя производителя, количество)\n  Постройте запрос, возвращающий два столбца: наименование товара, категория\n  Постройте запрос, возвращающий два столбца: наименование товара, производитель\n  Постройте запрос, возвращающий два столбца: Дата покупки, фамилия покупателя\n  Постройте запрос, возвращающий два столбца: фамилия покупателя, общее количество покупок (не товаров)\n  Постройте запрос, возвращающий два столбца: дата покупки, фамилия покупателя, филиал\n  Список товаров, отсортированных по наименованию (по алфавиту)\n  Список всех покупок (purchases), отсортированных дате\n  Даты последних 5 покупок (purchases)\n  Даты первых 5 покупок (purchases)\n  Фамилии последних 5 покупателей\n  Фамилии первых 5 покупателей\n\n\n",
      "url": "/pages/databases/sql/"
    },{
      
      "title": "Лабораторная работа №5. DML, часть 2",
      
      "content": "Описание базы данных\n\nОписание БД\n\nЗадание\n\nПостройте SQL-запросы для получения следующей информации из базы данных.\n\n\n  Список первых 3 клиентов, купивших товаров на максимальную сумму в заданном диапазоне дат\n  Список первых 3 клиентов, купивших максимальное количество товара в заданном диапазоне дат\n  Товар, который покупали чаще всего в заданном диапазоне дат\n  Товар, который покупали чаще всего в заданном диапазоне дат по филиалам\n  Средний чек в диапазоне дат\n  Средний чек в диапазоне дат по филиалам\n  Суммарная стоимость проданных товаров каждого филиала в диапазоне дат\n  Суммарная стоимость проданных товаров в диапазоне дат\n  Список филиалов по убыванию объема продаж (суммарная стоимость) до заданной даты\n  Список филиалов по убыванию количества проданного товара до заданной даты\n  Список товаров с указанием проданного количества товара в каждом магазине до заданной даты\n  Список товаров, проданных в заданном филиале до заданной даты\n  Список клиентов, покупавших любой товар в заданном магазине до заданной даты\n  Список клиентов, покупавших любой товар в двух магазинах сети\n  Список клиентов, покупавших любой товар во всех магазинах сети\n  Количество товара каждой категории, проданных в филиале до заданной даты\n  Количество товара каждой категории, проданных во всех филиалах до заданной даты\n  Суммарная стоимость товаров по филиалам на заданную дату\n  Суммарная стоимость товаров во всех филиалах на заданную дату\n  Количество товаров в каждом филиале на заданную дату\n  Какого товара меньше всего осталось в каждом из филиалов на заданную дату?\n  Какого товара больше всего осталось в каждом из филиалов на заданную дату?\n  Количество товаров каждого наименования во всех филиалах на заданную дату\n  Остатки товаров каждого наименования в филиале на заданную дату\n  Список пяти самых дешевых товаров в филиале на заданную дату\n  Список пяти самых дорогих товаров в филиале на заданную дату\n  Дата, в которую поступило товара на максимальную сумму в заданный филиал\n  Суммарная стоимость поступивших товаров на каждую дату поступления в заданный филиал\n  Суммарная стоимость товаров каждого производителя в филиале на дату\n  Суммарное количество товаров каждого производителя в филиале на дату\n  Суммарное количество проданных товаров каждого производителя в филиале до заданной даты\n  Суммарная стоимость проданных товаров каждого производителя в филиале до заданной даты\n  Суммарная стоимость проданных товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество проданных товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество поступивших товаров каждого производителя во всех филиалах до заданной даты\n  Суммарное количество поступивших товаров каждого производителя в филиал до заданной даты\n  Суммарная стоимость поступивших товаров каждого производителя в филиал до заданной даты\n  Изменение суммарной стоимости товаров заданного производителя в филиале в диапазоне дат\n\n",
      "url": "/pages/databases/sql2/"
    },{
      
      "title": "Основы работы c SQLite",
      "description": "Работа в Google Colab с базой данных SQLite, расположенной на диске Google Drive\n",
      "content": "Google Colab позволяет выполнять программы, написанные на языке Python прямо в браузере без необходимости установки на компьютер дополнительного программного обеспечения.\n\nДля использования Google Colab необходимо иметь учетную запись Google. Если вы используете смартфон на платформе Android, то такая учетная запись у вас уже есть, однако для безопасности вашей основной учетной записи рекомендуется создать новую учетную запись на время выполнения лабораторных работ.\n\nАдрес Google Colab: https://colab.research.google.com.\n\nДоступ к Google Drive для хранения базы данных\n\nБаза данных может храниться локально, на том же компьютере, на котором запускается прикладное программное обеспечение для работы с базой данных или на удаленном компьютере.\n\nGoogle Colab (точнее Python, запускаемый в среде Google Colab) позволяет работать и с условно «локальной» базой данных и с базой данных на удаленном сервере. В первом случае может использоваться СУБД SQLite, которая будет хранится на облачном диске Google Drive. Для среды Google Colab это будет локальная БД.\n\nДля доступа к диску Google Drive сервису Google Colab необходимо дать разрешение на подключение к диску. К сожалению  Google Colab через каждые 12 часов «забывает» полученные ранее разрешения, поэтому через каждые 12 часов необходимо заново разрешать доступ Google Colab к вашему облачному диску. Данные (файл базы данных SQLite) в Google Colab конечно сохраняются.\n\nДля подключения и разрешения доступа Google Colab к диску Google Drive можно использовать следующий код:\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\n\n\nGoogle Colab предложит перейти по предложенной ссылке для разрешения доступа к диску\n\n\n\nПосле того, как вы разрешите доступ к диску Google Drive, появится окно с кодом, который нужно вставить в показанное выше поле “Enter your authorization code”:\n\n\n\nПосле ввода кода и нажатия Enter появится сообщение о том, что диск подключен “Mounted at /content/drive/”.\n\n\n\nПодключение к базе данных\n\nПодключаем модуль для работы с базой SQLite\n\nimport sqlite3\n\n\nСоздаем на диске Google каталог databases. Указываем путь к будущей (или уже существующей) базе данных.\n\n\n\npath = \"./drive/My Drive/databases/mydatabase.db\"\n\n\nПодключаемся к базе mydatabase.db. Если этого файла нет в каталоге, то он будет создан.\n\nconn = sqlite3.connect(path)\n\n\nСоздание таблицы\n\nСоздадим таблицу музыкальных альбомов (albums) с пятью столбцами:\n\n\n  \n    \n      title\n      artist\n      release_date\n      publisher\n      media_type\n    \n  \n  \n    \n      Наименование альбома\n      Исполнитель\n      Дата выхода\n      Издатель\n      Тип носителя\n    \n  \n\n\n# Создаем объект типа cursor для доступа к данным\ncursor = conn.cursor()\n# Создание простейшей таблицы, все поля (столбцы) которой имеют тип text\ncursor.execute(\"CREATE TABLE albums (title text, artist text, release_date text, publisher text, media_type text)\")\n# Подтверждаем изменения (обязательно)\nconn.commit()\n# Закрываем курсор\ncursor.close()\n# Закрываем соединение (рекомендуется)\nconn.close()\n\n\nДобавление записей в таблицу\n\nДобавление в таблицу двух строк:\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"INSERT INTO albums VALUES (?, ?, ?, ?, ?)\"\nval1 = (\"The Serpen't Egg\", \"Dead Can Dance\", \"1988\", \"4AD\", \"CD\")\nval2 = (\"Everyday Is Christmas\", \"SIA\", \"2017\", \"Atlantic\", \"CD\")\ncursor.execute(sql, val1)\ncursor.execute(sql, val2)\nconn.commit()\ncursor.close()\nconn.close()\n\n\nЗапрос данных из таблицы\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"SELECT artist, title, release_date from albums\"\ncursor.execute(sql)\n\nfor i in cursor:\n    print(i)\n\ncursor.close()\nconn.close()\n\n\nДля наглядного представления табличных данных можно использовать библиотеку pandas:\n\nimport pandas as pd\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"SELECT artist, title, release_date from albums\"\ncursor.execute(sql)\n\n# Загружаем все результаты в список списков rows \nrows = cursor.fetchall()\ncursor.close()\nconn.close()\n\n\nСоздаем объект DataFrame на основе списка rows, указывая наименования столбцов (columns=…):\n\npd.DataFrame( rows, columns=('Исполнитель', 'Альбом', 'Год') )\n\n\nРезультат будет выглядеть так:\n\n\n\n\n\nОсобенности хранения в SQLite значений дат\n\nПри работе с базой данных SQLite необходимо учитывать, что даты в таблицах SQLite хранятся в виде целого числа, которое представляет собой количество секунд прошедших с начала (по Гринвичу) первого января 1970 года – Unix-время (этот момент называют Unix-эпохой). Эту особенность представления даты и времени в SQLite следует учитывать при выводе (форматировании) и сравнении дат.\n\nНапример, следующий сценарий выводит таблицу имен покупателей с датами совершенных ими покупок до 20 января 2019 года.\n\nselect \n\tcustomers.customer_name, strftime(\"%d.%m.%Y\", purchase_date, 'unixepoch') as purchase_date_string\nfrom \n\tpurchases\nleft join \n\tcustomers on customers.customer_id  = purchases.customer_id \nwhere \n\tpurchase_date &lt; CAST(strftime('%s', '2019-01-20') AS INTEGER)\norder by \n\tpurchase_date;\n\n\nРезультат\n\ncustomer_name                |purchase_date_string|\n-----------------------------|--------------------|\nГусев Пров Дмитриевич        |06.01.2019          |\nБорисова Евдокcия Григорьевна|06.01.2019          |\nДорофеев Митофан Демидович   |10.01.2019          |\n\n\nВ этом сценарии для преобразования из внутреннего Unix-времени в “читаемый” текстовый формат даты ГГГГ.ММ.ДД  используется функция strftime, которая преобразует числовое значение даны в строку в соответствии с заданным форматом, который передается первым аргументом функции. Второй аргумент функции  strftime – столбец таблицы, который содержит дату, “закодированную” целым числом. Третий аргумент – формат хранения даты ‘unixepoch’.\n\nДля того, чтобы сравнить заданную текстовым представлением дату (в примере это ‘2019-01-20’) со значением в таблице, например, в условии WHERE, необходимо преобразовать строку в ГГГГ-ММ-ДД в строку, представляющую целое число секунд с Unix-эпохи, а затем преобразовать эту строку в целое число, которое и будет сравниваться со значениями в столбце purchase_date таблицы. Для преобразования из строки в целое число используется функция CAST(СТРОКА AS INTEGER), например результатом работы функции CAST(‘123’ AS INTEGER) будет целое число 123.\n\nПри работа с базой данных из среды Python, преобразование даты в формат Unix-времени и обратно можно выполнять в коде, используя метод объекта datetime – datetime.timestamp(), например:\n\nimport sqlite3\nimport datetime\nfrom tabulate import tabulate \n\npath = \"./drive/My Drive/databases/goods.db\"\n\nconn = sqlite3.connect(path)\ncursor = conn.cursor()\n\nsql  = \"\"\"\nSELECT \n  customers.customer_name, purchases.purchase_id, COUNT(purchase_items.product_id)\nFROM\n  purchase_items \nLEFT JOIN \n  purchases on purchase_items.purchase_id = purchases.purchase_id\nLEFT JOIN \n  customers on customers.customer_id = purchases.customer_id\nWHERE \n  purchases.purchase_date BETWEEN ? AND ? \nGROUP BY \n  purchases.purchase_id\nORDER BY \n  customer_name\n\"\"\"\n\ncursor.execute(sql,(datetime.datetime(2019,8,1).timestamp(),  \n                    datetime.datetime(2020,1,1).timestamp() ))\n\nrows = cursor.fetchall()\nprint(tabulate(rows))\n\ncursor.close()\nconn.close()\n\n\n\n",
      "url": "/pages/databases/sqlite_start/"
    },{
      
      "title": "Структуры",
      
      "content": "Структура это тип данных, который позволяет объединить группу связанных данных в рамках одного имени.\n\nСоздание структуры\n\n&gt;&gt; a.x = 1:5;\n&gt;&gt; a.y = sin(a.x);\n&gt;&gt; a\n\na = \n  struct with fields:\n    x: [1 2 3 4 5]\n    y: [0.8415 0.9093 0.1411 -0.7568 -0.9589]\n\n\nВ приведенном выше примере структура a имеет два поля (свойства, атрибута) x и y, в которых хранятся матрицы строки. Структура может хранить данные любых типов\n\n&gt;&gt; a.Description = 'Описание структуры'\n\na = \n  struct with fields:\n              x: [1 2 3 4 5]\n              y: [0.8415 0.9093 0.1411 -0.7568 -0.9589]\n    Description: 'Описание структуры'\n\n\nДля создания структуры может использоваться функция struct\n\nСоздание пустой структуры\n\ns = struct\n\ns = \n  struct with no fields.\n\n\nСоздание структуры парами имя поля  – значение. Имена полей задаются строковыми константами\n\n&gt;&gt; s = struct('x',[1 2 3],'y',[10 20 30])\n\ns = \n  struct with fields:\n    x: [1 2 3]\n    y: [10 20 30]\n\n",
      "url": "/pages/matlab/struct/"
    },{
      
      "title": "Структурное программирование",
      
      "content": "Оператор ветвления\n\nОператор ветвления выполняет фрагмент кода только при выполнении некоторого условия. В самом простом виде оператор ветвления в MATLAB записывается следующим образом:\n\nif a &lt; 10\n    x = 1;\nend\n\n\nПеременной x будет присвоено значение 1, если значение переменной a будет меньше 10. Если необходимо выполнить определенный код в случае невыполнения условия, то оператор if можно записать в следующем виде\n\nif a &lt; 10\n    x = 1;\n    z = 5;\nelse\n    x = 2;\n    z = 10*x;\nend\n\n\nПри наличии нескольких условий и нескольких фрагментов кода, исполняемых при выполнении этих условий, используется следующая структура оператора ветвления\n\nif a &lt; 10 \n    x = 1;\nelseif a &gt; 20\n    x = 2;\nelse \n    x = 3;\nend\n\n\nВ результате выполнения этого кода переменная x будет равна 1 если a меньше 10, 3 – если a больше 20 и 2 если а будет принадлежать интервалу от 10 до 20.\n\n\n  \n    \n      В выражениях-условиях могут применятся логические операторы И (&amp;&amp;), ИЛИ (\n       \n      ), НЕ (~):\n    \n  \n\n\nif a &gt;= 10 &amp;&amp; a &lt;= 20 \n    x = 3;\nelseif a &gt; 20\n    x = 2;\nelse \n    x = 1;\nend\n\n\nЦикл for\n\nЦикл for позволяет заданное количество раз выполнить фрагмент кода. В  MATLAB  цикл for определяется при помощи ключевого слова for, обозначающего заголовок цикла и end, обозначающего окончание выполняемого в цикле блока кода.\n\nСледующий код\n\nfor i = 1:10\n    fprintf('%i - %3.1f', i, cos(i/2.0))\nend\n\n\nвыведет на таблицу значений аргумента и функции \\(\\cos i/2\\) для \\(i\\) изменяющегося в диапазоне от 1 до 10 с шагом 1 (1:10), как указано в заголовке цикла\n\n  1   0.9\n  2   0.5\n  3   0.1\n  4  -0.4\n  5  -0.8\n  6  -1.0\n  7  -0.9\n  8  -0.7\n  9  -0.2\n 10   0.3\n\n\nПеременная \\(i\\) в приведённом примере называется переменной-интератором. Эта переменная принимает значения в соответствии с заданной последовательностью (от 1 до 10).\n\nВ заголовке цикла в качестве ‘источника’ значений для переменной-итератора может быть матрица строка. Например, результат работы следующего примера будет точно таким же, как и у предыдущего\n\na = 1:10;\nfor i = a\n    fprintf('%i - %3.1f', i, cos(i/2.0))\nend\n\n\nЕсли в качестве источника используется матрица, то переменная-итератор будет принимать значений столбцов этой матрицы. В результате работы следующего кода\n\na = [1 2 3; 4 5 6];\nfor i = a\n    i\nend\n\n\nцикл выполнится 3 раза и переменна \\(i\\) будет принимать значения [1; 4], [2; 5] и [3; 6].\n\nВ MATLAB следует избегать использования циклов. Использование циклов приводит к снижению скорости выполнения кода. Где это возможно, циклы следует заменять матричными операциями.\n\nРассмотрим для примера код, который вычисляет количество четных чисел в случайно последовательности\n\na = round(rand(1,10)*20);\n\n\nВ цикле for переменная el последовательно принимает значения элементов из матрицы-строки a. В теле цикла определяется остаток от деления элемента последовательности на 2, и если этот остаток равен 0 (число четное), то этот элемент добавляется к переменной-сумматору s. После выхода из цикла переменная s будет содержать сумму чётных элементов матрицы строки a.\n\ns = 0;\n% перебираем все значения из массива a\n% следующая строка читается как \"ДЛЯ каждого элемента el из a\"\nfor el = a\n    %  ЕСЛИ остаток деления на 2 равен нулю, то el это \n    %  чётное число и его добавляем в сумматор\n    if mod(el,2) == 0\n       s = s + el;\n    end\nend\ns\n\n\nЭтот код можно заменить одной строкой\n\ns = sum(a(mod(a,2)==0))\n\n\nРезультатом работы выражения mod(a,2)==0 является логическая матрица-строка, равная по форме исходной матрице-строке a, в логической матрице на местах четных элементов матрицы a стоят 1 (ИСТИНА), на местах остальных элементов нули\n\n&gt;&gt; mod(a,2)==0\n\nans =\n  1×10 logical array\n   1   1   0   0   1   1   0   0   1   1\n\n\nэтот результат используется в качестве индекса оператора () для извлечения четных элементов из матрицы a\n\n&gt;&gt; a(mod(a,2)==0)\n\nans =\n     6    14     2    10    12     4\n\n\nдалее определяется сумма всех извлеченных элементов при помощи функции sum.\n\nЦикл while (пока)\n\nЦикл while используется при необходимости выполнения фрагмента кода (тела цикла), пока выполняется некоторое условие. Предположим, что необходимо вычислить сумму первой последовательной цепочки четных чисел заданной матрицы-строки\n\n% Последовательность\na = [2 4 8 3 2 5 6 7];\n% Сумматор\ns = 0;\n% Начальное значение индекса числа в массиве a\ni = 1;\n% Если i-ое число четное И (&amp;&amp;) его номер не больше 8 (количество элементов в массиве а)\nwhile mod(a(i),2)==0 &amp;&amp; i &lt;= numel(a)\n    % ТО добавляем это число в сумматор\n    s = s + a(i);\n    % переходим к следующему индексу (увеличиваем на 1)\n    % иначе цикл станет бесконечным\n    i = i + 1;\nend\n\n\nПосле ключевого слова while в заголовке цикла указывается логическое выражение. Цикл будет выполнятся до тех пор, пока результатом этого выражения будет ИСТИНА. Цикл while может не выполниться ни одного раза, если при входе в цикл результатом логического выражения будет ЛОЖЬ.\n\n",
      "url": "/pages/matlab/structural/"
    },{
      
      "title": "Таблицы",
      
      "content": "Объект table для представления данных в табличном виде, но в отличие от обычной матрицы таблица может содержать данные разных типов.\n\nПример таблицы, которая в первом столбце содержит строковые данные, а во втором столбце – числовые:\n\n&gt;&gt; T1 = table( {'AA'; 'AB'; 'BA'}, (1:3)' )\n\nT1 =\n  3×2 table\n    Var1    Var2\n    ____    ____\n    'AA'     1  \n    'AB'     2  \n    'BA'     3  \n\n\nСледует обратить внимание, что были переданы матрица-столбец ячеек и числовая матрица-столбец. Если передать строки, то результатом будет таблица, содержащая одну строку с матрицей ячеек в первом столбце и матрицей-строкой во втором\n\n&gt;&gt; T1 = table( {'AA', 'AB', 'BA'}, (1:3) )\n\nT1 =\n  1×2 table\n            Var1               Var2    \n    ____________________    ___________\n    'AA'    'AB'    'BA'    1    2    3\n\n\nСтолбцам таблицы были автоматически присвоены имена ‘Var1’ и ‘Var2’. Эти имена можно использовать для обращения к столбцам\n\n&gt;&gt; T1.Var1\n\nans =\n  3×1 cell array\n    {'AA'}\n    {'AB'}\n    {'BA'}\n\n&gt;&gt; T1.Var2\n\nans =\n     1\n     2\n     3\n\n\nПри создании таблицы можно задать имена столбцов при помощи свойства VariableNames\n\n&gt;&gt; T1 = table( {'AA'; 'AB'; 'BA'}, (1:3)', 'VariableNames', {'Variant', 'Value'} )\n\nT1 =\n  3×2 table\n    Variant    Value\n    _______    _____\n     'AA'        1  \n     'AB'        2  \n     'BA'        3  \n\n\nМожно создать пустую таблицу заданных размеров, при этом необходимо указать тип данных для каждого столбца\n\n&gt;&gt; T = table('Size',[5 3],'VariableTypes',{'string','double','datetime'})\n\nT =\n  5×3 table\n      Var1       Var2    Var3\n    _________    ____    ____\n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n    &lt;missing&gt;     0      NaT \n\n\nЗаполняем первую строку таблицы\n\n&gt;&gt; T.Var1(1) = 'Вариант 1';\n&gt;&gt; T.Var2(1) = 5;\n&gt;&gt; T.Var3(1) = datetime(2020,5,20);\n&gt;&gt; T\n\nT =\n  5×3 table\n       Var1        Var2       Var3    \n    ___________    ____    ___________\n    \"Вариант 1\"     5      20-May-2020\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n    &lt;missing&gt;       0              NaT\n\n\nПри создании таблицы можно задать имена строк\n\n&gt;&gt; T = table('Size',[3 3],'VariableTypes',{'string','double','datetime'}, 'RowNames', {'Иванов', 'Петров', 'Сидоров'});\n\nT =\n  3×3 table\n                 Var1       Var2    Var3\n               _________    ____    ____\n    Иванов     &lt;missing&gt;     0      NaT \n    Петров     &lt;missing&gt;     0      NaT \n    Сидоров    &lt;missing&gt;     0      NaT \n\n\nИмя строки может использоваться для доступа к элементу таблицы\n\n&gt;&gt; T({'Иванов'},1) = {'Хорошо'}\n\nT =\n  3×3 table\n                 Var1       Var2    Var3\n               _________    ____    ____\n    Иванов     \"Хорошо\"      0      NaT \n    Петров     &lt;missing&gt;     0      NaT \n    Сидоров    &lt;missing&gt;     0      NaT \n\n\nЭтот же элемент таблицы можно изменить, используя имя столбца и номер строки\n\n&gt;&gt; T.Var1{1} = 'Удовлетворительно'\n\nT =\n  3×3 table\n                      Var1            Var2    Var3\n               ___________________    ____    ____\n    Иванов     \"Удовлетворительно\"     0      NaT \n    Петров     &lt;missing&gt;               0      NaT \n    Сидоров    &lt;missing&gt;               0      NaT \n\n\n",
      "url": "/pages/matlab/table/"
    },{
      
      "title": "Компьютерные и экспериментальные методы в механике",
      
      "content": "Основы регрессионного анализа, полный факторный эксперимент\n\nМ. Ю. Черняк, М. С. Эльберг Планирование и организация эксперимента. Практикум. стр. 27.\n\nЗадания 1 - 4\n\nДля изучения зависимости некоторой величины от воздействующих факторов были поставлены эксперименты по плану ПФЭ \\(2^3\\). В качестве факторов (\\(X_1\\), \\(X_2\\), \\(X_2\\)), влияющих на отклик, были выбраны следующие:\n\n\n  \n    \n      Уровни факторов\n      \\(X_1\\)\n      \\(X_2\\)\n      \\(X_3\\)\n    \n  \n  \n    \n      Нижний\n      6\n      40\n      0.22\n    \n    \n      Основной\n      10\n      80\n      0.40\n    \n    \n      Верхний\n      14\n      120\n      0.31\n    \n  \n\n\nНа основании экспериментальных данных вывести математическую модель (линейную и нелинейную) в кодированных и натуральных значениях факторов.\n\nВариант 1\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      0.11\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.22\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.16\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.10\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.22\n      0.20\n      0.18\n    \n  \n\n\nВариант 2\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      1.10\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.18\n      0.20\n    \n    \n      0.18\n      0.16\n      0.16\n      0.16\n    \n    \n      0.14\n      0.12\n      0.12\n      0.16\n    \n    \n      0.11\n      0.12\n      0.12\n      0.10\n    \n    \n      0.24\n      0.23\n      0.23\n      0.21\n    \n    \n      0.20\n      0.22\n      0.22\n      0.18\n    \n  \n\n\nВариант 3\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.12\n      0.11\n      0.12\n    \n    \n      0.06\n      0.07\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.21\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.17\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.11\n      0.10\n    \n    \n      0.24\n      0.23\n      0.22\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nВариант 4\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.12\n      0.12\n      0.12\n    \n    \n      0.06\n      0.07\n      0.08\n      0.08\n    \n    \n      0.20\n      0.18\n      0.20\n      0.20\n    \n    \n      0.18\n      0.16\n      0.17\n      0.17\n    \n    \n      0.14\n      0.12\n      0.13\n      0.16\n    \n    \n      0.11\n      0.12\n      0.11\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nЗадания 5 - 6\n\nДля изучения зависимости некоторой величины от воздействующих факторов были поставлены эксперименты по плану ПФЭ \\(2^3\\). В качестве факторов (\\(X_1\\), \\(X_2\\), \\(X_2\\)), влияющих на отклик, были выбраны следующие:\n\n\n  \n    \n      Уровни факторов\n      \\(X_1\\)\n      \\(X_2\\)\n      \\(X_3\\)\n    \n  \n  \n    \n      Нижний\n      3\n      11\n      0.2\n    \n    \n      Основной\n      7\n      26\n      0.25\n    \n    \n      Верхний\n      11\n      41\n      0.3\n    \n  \n\n\nНа основании экспериментальных данных вывести математическую модель (линейную и нелинейную) в кодированных и натуральных значениях факторов.\n\nВариант 5\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      0.11\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.22\n      0.20\n    \n    \n      0.18\n      0.16\n      0.18\n      0.16\n    \n    \n      0.14\n      0.12\n      0.14\n      0.16\n    \n    \n      0.11\n      0.12\n      0.10\n      0.10\n    \n    \n      0.24\n      0.23\n      0.24\n      0.21\n    \n    \n      0.20\n      0.21\n      0.20\n      0.18\n    \n  \n\n\nВариант 6\n\n\n  \n    \n      \\(Y_1\\)\n      \\(Y_2\\)\n      \\(Y_3\\)\n      \\(Y_4\\)\n    \n  \n  \n    \n      0.12\n      1.10\n      1.10\n      0.12\n    \n    \n      0.06\n      0.06\n      0.06\n      0.08\n    \n    \n      0.20\n      0.18\n      0.18\n      0.20\n    \n    \n      0.18\n      0.16\n      0.16\n      0.16\n    \n    \n      0.14\n      0.12\n      0.12\n      0.16\n    \n    \n      0.11\n      0.12\n      0.12\n      0.10\n    \n    \n      0.24\n      0.23\n      0.23\n      0.21\n    \n    \n      0.20\n      0.21\n      0.22\n      0.18\n    \n  \n\n\n",
      "url": "/pages/stat/task1/"
    },{
      
      "title": "Космическая тросовая система",
      
      "content": "Используя пример программы моделирования движения груза на тросовой связи в однородном поле силы тяжести, разработать модель движения троса, прикрепленного к космическому аппарату, движущемуся по круговой орбите высотой \\(h = 400\\) км.\n\n\n\nДвижение троса рассмотреть течение двух орбитальных периодов КА в плоскости орбиты относительно неинерциальной системы координат (орбитальной подвижной), движущейся вместе с космическим аппаратом \\(C x_o y_o\\). Ось \\(C x_o\\) орбитальной подвижной системы координат направлена вдоль КА направлена вдоль радиус-вектора КА относительно центра Земли в сторону “от Земли”, ось \\(C y_o\\) совпадает с вектором орбитальной скорости движения КА по круговой орбите.\n\nНа каждый узел троса в неинерциальной орбитальной подвижной системе координат \\(C x_o y_o\\) кроме сил упругости действуют сила, определяемая  координатным столбцом в \\(C x_o y_o\\):\n\n[\\Phi_i = \n    \\begin{bmatrix}\n        3 \\omega_0^2 x_i + 2 \\omega_0 \\dot y_i \n        - 2 \\omega_0 \\dot x_i \n    \\end{bmatrix} m_i]\n\nгде \\(\\omega_0\\) – угловая скорость орбитального движения космического аппарата (среднее движение), определяемая высотой круговой орбиты КА:\n\n[\\omega_0 = \\sqrt{\\frac{\\mu}{(R_e+h)^3}},]\n\nгде \\(\\mu\\) – гравитационный параметр Земли, \\(R_e\\) – средний радиус Земли, \\(h\\) –  высота орбиты КА.\n\nКА рассматривать материальной точкой, движущейся по круговой орбите. Длина троса 5 км, материал троса имеет плотность 1,4 тонн на кубический метр, модуль упругости материала троса - 90 МПа, диаметр троса - 2 мм. Масса капсулы равна 30 кг. В начальный момент времени трос вытянут в прямую линию и его начальная длина равна свободной длине. Начальный угол \\(\\varphi\\) между осью минус \\(C x_o\\) орбитальной системы координат и тросом равен 45 градусам. Начальная скорость точек троса равна нулю.\n\n\n\n",
      "url": "/pages/mechanics-in-space/tether-relative-orbital/"
    },{
      
      "title": "Динамика отделения от орбитального блока двух малых космических аппаратов, связанных тросом.",
      "description": "Задание для выпускной квалификационной работы (магистратура, 2025).\n",
      "content": "Задание\n\nОт орбитального блока одновременно отделяется два космических аппарата (КА), связанных тросом. МКА установлены под углом 10 градусов к продольно оси орбитального блока. Масса каждого МКА 300 кг, расстояние от точки крепления до центра масс КА 1,5 метра. Момент инерции КА относительно поперечной оси равен 200 кг·м². МКА отделяются от носителя с приращением скорости 0,5 м/с.\n\n\n\n\n  Разработать модель плоского движения МКА, связанных упругим невесомым тросом переменной длины, рассматривая МКА как материальные точки.\n  Используя модель, разработанную в п. 1, проанализировать движение космической тросовой системы (КТС) в зависимости от ориентации носителя на момент отделения МКА.\n    \n      Проработать возможность формирования гравитационно-стабилизированной КТС (ориентированной вдоль радиус-вектора центра масс КТС). Сформулировать требования к ориентации орбитального блока на момент отделения МКА для этого.\n      Проработать возможность формирования вращающейся космической тросовой системы (в плоскости орбиты). Сформулировать требования к ориентации орбитального блока на момент отделения МКА для этого.\n    \n  \n  Разработать модель плоского движения МКА, связанных упругим невесомым тросом переменной длины, рассматривая МКА как твердые тела постоянного состава.\n  Используя модель, разработанную в п. 1, проанализировать движение космической тросовой системы (КТС) в зависимости от ориентации носителя на момент отделения МКА.\n\n\nЛитература\n\nModeling, Dynamics and Control of Space Tethered System as Distributed Radar Array\n",
      "url": "/pages/thesis/2025/tethered-separation/"
    },{
      
      "title": "Анализ текста",
      
      "content": "Написать программу, которая для загруженного текста из файла определяет:\n\n  количество знаков с пробелами;\n  количество знаков без пробелов;\n  количество знаков препинания;\n  количество слов;\n  максимальную длину слова;\n  среднюю длину слова;\n  количество предложений;\n  максимальную длину предложений (в словах);\n  среднюю длину предложений (в словах).\n\n\nВ отдельный текстовый файл программа должна вывести частотный словарь, каждая строка которого содержит слово и частоту его употребления.\n\nДля демонстрации работы программы использовать тексты из библиотеки http://lib.ru/\n\nСписок заданий\n",
      "url": "/pages/python/course_works/text/"
    },{
      
      "title": "Временные ряды",
      
      "content": "timeseries\nСправка MathWorks\n\nОбъект timeseries предназначен для представления изменяющихся в дискретном времени данных. Для создания временного ряда используется функция timeseries\n\n&gt;&gt; ts1 = timeseries((1:5)','Name','MyTimeSeries')\n  timeseries\n\n  Common Properties:\n            Name: 'MyTimeSeries'\n            Time: [5x1 double]\n        TimeInfo: [1x1 tsdata.timemetadata]\n            Data: [5x1 double]\n        DataInfo: [1x1 tsdata.datametadata]\n\n  More properties, Methods\n\n\nПри создании временного ряда ts первым аргументом был передан массив значений ряда от 1 до 5 с шагом 1 . Вторым аргументом задано имя временного ряда (свойство ‘Name’). Значения времени переданы не были, поэтому MATLAB задает эти значения автоматически, считая, что первая точка данных (1) соответствует моменту времени 0, последняя 4. Это некоторые абстрактные значения, не привязанные к конкретным единицам времени. Значения времени содержаться в атрибуте (свойстве) объекта Time\n\n&gt;&gt; ts1.Time\n\nans =\n     0\n     1\n     2\n     3\n     4\n\n\nДля того, чтобы задать и массив значений времени и массив значений исследуемой функции используется следующий способ вызова функции timeseries\n\n&gt;&gt; ts1 = timeseries([1 3 2 5 7]',[0 10 20 30 40],'Name',' Ряд 1');\n\n\nПервый аргумент (1:5)’ это значения функции (данные), второй – соответствующие этим значениям временные метки. В примере это массив [0 10 20 30 40].\n\nВременными метками могут быть конкретные значения даты и времени, которые могут быть переданы в функцию timeseries в виде массива строк. Для того чтобы преобразовать массив дат в массив текстового представления этих дат используется функция datestr\n\n&gt;&gt; datestr(datetime(2020,04,1:5,12,0,0))\n\nans =\n  5×20 char array\n    '01-Apr-2020 12:00:00'\n    '02-Apr-2020 12:00:00'\n    '03-Apr-2020 12:00:00'\n    '04-Apr-2020 12:00:00'\n    '05-Apr-2020 12:00:00'\n\n\nТогда\n\n&gt;&gt; date_string_array  = datestr(datetime(2020,04,1:5,12,0,0));\n&gt;&gt; ts1 = timeseries([1 3 2 5 7]', date_string_array, 'Name', ' Ряд 1');\n\n\nОчень просто построить график временного ряда. Достаточно передать в функцию plot имя объекта timeseries\n\n&gt;&gt; plot(ts1);\n\n\nЧтобы метки дат на оси x отображались в нужном формате используем функцию datetick\n\n&gt;&gt; datetick('x','dd.mm.yy');\n\n\n\n\nНекоторые функции для работы с timeseries\n\nresample\n\nФункция пересчитывает значения временного ряда для новых значений времени, передаваемых в функцию вторым аргументом. Результатом работы функции  resample является новый временной ряд\n\n&gt;&gt; ts2 = resample(ts1,[3 12 25 31 39]);\n&gt;&gt; ts2.Data\n\nans =\n    1.6000\n    2.8000\n    3.5000\n    5.2000\n    6.8000\n\n\nДля сравнения двух временных рядов построим их графики на одном рисунке\n\n&gt;&gt; plot(ts1,'ro-');\n&gt;&gt; hold on;\n&gt;&gt; plot(ts2,'g^--');\n&gt;&gt; hold off;\n\n\n\n\nКак видно из результата, по умолчанию для пересчета значений используется линейная интерполяция. Способ интерполяции значений временного ряда задаётся функцией setinterpmethod\n\nts3 = setinterpmethod(ts2,'zoh');\n\n\nФункция возвращает новый временной ряд. Первый аргумент – преобразуемый временной ряд, второй – способ интерполяции значений. Возможны два варианта ‘zoh’ и ‘linear’. ‘zoh’ – интерполяция нулевого порядка, которая представляет временной ряд в виде кусочно-постоянной функции\n\nplot(ts3)\n\n\n\n\nФункция detrend\n\nФункция detrend удаляет из временного ряда постоянное число, равное среднему значению ряда, или линейную составляющую, вычисленную по методу наименьших квадратов.\n\nСоздадим временной ряд для интервала времени от 0 до 10 с шагом 0.2. Функция представляет собой сумму периодической функции с линейной функцией.\n\n&gt;&gt; t = 0:0.2:10\n&gt;&gt; y = sin(5*t)+3*t;\n&gt;&gt; ts1 = timeseries(y,t);\n\n\nСоздадим два новых временных ряда на основе исходного, применив функцию detrend\n\n&gt;&gt; ts2 = detrend(ts1,'constant');\n&gt;&gt; ts3 = detrend(ts1,'linear');\n\n\n\n\n",
      "url": "/pages/matlab/timeseries/"
    },{
      
      "title": "Хронологические таблицы",
      
      "content": "Объект типа timetable предназначен для хранения представления и обработки табличных данных, предполагая, что каждая строка таблицы связана с меткой времени. Тип timetable объединяет функционал типов timeseries и table.\n\nСоздание timetable\n\n&gt;&gt; date_array = datetime(2020,4,1:2:6)';\n&gt;&gt; timetable(date_array, [1;2;3], [5;6;7], [8;9;10])\n\nans =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5        8 \n    03-Apr-2020     2       6        9 \n    05-Apr-2020     3       7       10 \n\n\nИспользуя свойство VariableNames можно задать имена столбцов таблицы\n\n&gt;&gt; T1.Properties.VariableNames = {'C1', 'C2', 'C3'};\n&gt;&gt; T1\n\nT1 =\n  3×3 timetable\n    date_array     C1    C2    C3\n    ___________    __    __    __\n    01-Apr-2020    1     5      8\n    02-Apr-2020    2     6      9\n    03-Apr-2020    3     7     10\n\n\nСвойство Variables позволяет получить матрицу данных таблицы. Для созданной выше таблицы T1 это будет\n\n&gt;&gt; T1.Variables\n\nans =\n     1     5     8\n     2     6     9\n     3     7    10\n\n\nОбъект timetable может содержать столбцы любого типа\n\n&gt;&gt; T2 = timetable(date_array, [1;2;3], [5;6;7], {'A';'B';'C'})\n\nT2 =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5      'A' \n    03-Apr-2020     2       6      'B' \n    05-Apr-2020     3       7      'C' \n\n\nИзвлечение данных при помощи свойства Variables из такой таблицы приведёт к ошибке\n\n...\nUnable to concatenate the table variables 'Var1' and 'Var3', because their types are double and cell.\n\n\nОбъект timetable можно создать на основе объекта table\n\n&gt;&gt; SBER_table = readtable('SBRCY.csv');\n&gt;&gt; table2timetable(SBER_table);\n\n\nВ таблице должен быть хотя бы один столбец, имеющий тип DateTime. Первый столбец в таблице, который имеет тип DateTime, используется для меток времени\n\nt0 = table((1:5)',(10:10:50)',(hours(0):hours(1):hours(4))')\nt1 = table2timetable(t0)\n\n\nФункции timetable\n\nretime\n\nФункция retime используется для пересчета значений timetable в новой шкале времени.\n\nНапример, рассмотрим таблицу, содержащую 3 строки, соответствующие трём датам: 1, 3 и 5 апреля 2020 года:\n\n&gt;&gt; date_array = datetime(2020,4,1:2:6)';\n&gt;&gt; T1 = timetable(date_array, [1;2;3], [5;6;7], [10;15;8])\n\nT1 =\n  3×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020     1       5       10 \n    03-Apr-2020     2       6       15 \n    05-Apr-2020     3       7        8 \n\n\nНа основе этой таблицы создадим таблицу TR с шагом по времени 1 день. Для этого можно вторым аргументом явно указать в функции retime новый массив дат\n\n&gt;&gt; TR = retime(T1,datetime(2020,4,1:1:6)')\n\nTR =\n  6×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020      1       5      10 \n    02-Apr-2020    NaN     NaN     NaN \n    03-Apr-2020      2       6      15 \n    04-Apr-2020    NaN     NaN     NaN \n    05-Apr-2020      3       7       8 \n    06-Apr-2020    NaN     NaN     NaN \n\n\nКак видно, для новых значений времени, которых не было в исходной таблице, данных не появилось. Чтобы новая таблица содержала значения в столбцах для новых дат, необходимо третим аргументом указать тип интерполяции, например, линейная (‘linear’), сплайн (‘spline’), следующее значение (‘next’):\n\n&gt;&gt; T2 = retime(T1,datetime(2020,4,1:1:6)','linear')\n\nT2 =\n  6×3 timetable\n    date_array     Var1    Var2    Var3\n    ___________    ____    ____    ____\n    01-Apr-2020      1       5       10\n    02-Apr-2020    1.5     5.5     12.5\n    03-Apr-2020      2       6       15\n    04-Apr-2020    2.5     6.5     11.5\n    05-Apr-2020      3       7        8\n    06-Apr-2020    3.5     7.5      4.5\n\n\nЕсли новый массив времени содержит меньшее количество точек, то вместо интерполяции используются агрегатные функции (среднее, минимум, максимум).\n\nx = linspace(0,5,50);\nVAR1 = 2*x + sin(x);\nVAR2 = cos(x);\n\nT1 = timetable(seconds(x)',VAR1',VAR2');\n\nplot(T1.Time,T1.Var1,'-', T1.Time,T1.Var2, '--');\n\nhold on;\n\nx2 = linspace(0,5,10);\nT2 = retime(T1,seconds(x2)','nearest');\nplot(T2.Time,T2.Var1,'o', T2.Time,T2.Var2, '^');\n\nhold off;\n\nlegend('Var1','Var2','retime Var1','retime Var2');\n\n\n\n",
      "url": "/pages/matlab/timetable/"
    },{
      
      "title": "TLE",
      
      "content": "\n  Написать модуль, содержащий функции, которые в заданном текстовом файле (текстовом блоке) выявляют двухстрочные элементы орбиты и возвращает в виде списка строк результаты анализа (расшифровку) двухстрочных элементов, найденных в файле. Тектовый файл может содержать произвольный текст с включенными в него двухстрочными элементами орбиты.\n  Написать программу, которая демонстрирует использование разработанного модуля.\n\n\nСписок заданий\n",
      "url": "/pages/python/course_works/tle/"
    },{
      
      "title": "Буксировка на тросовой связи",
      
      "content": "Исходные данные\n\nКосмическая тросовая система для буксировки объекта космического мусора состоит из орбитального буксира, и объекта космического мусора, соединенных упругим тросом, выполненным из кевлара.\n\n\n  \n    \n      Параметр\n      Обозначение\n      Значение\n    \n  \n  \n    \n      Масса буксира\n      \\(m_1\\)\n      2000 кг\n    \n    \n      Масса объекта космического мусора\n      \\(m_2\\)\n      4000 кг\n    \n    \n      Модуль упругости материала троса\n      \\(E\\)\n      120 ГПа\n    \n    \n      Предел прочности троса\n      \\(\\sigma_b\\)\n      2.5 ГПа\n    \n    \n      Диаметр троса\n      \\(d\\)\n      ? мм\n    \n    \n      Плотность материала троса\n      \\(\\rho\\)\n      1.44 г/см\\(^2\\)\n    \n    \n      Свободная длина нерастянутого троса\n      \\(l_0\\)\n      1500 м\n    \n    \n      Сила тяги буксира\n      \\(P\\)\n      10 кН\n    \n  \n\n\n\n\nОбъект космического мусора и буксир рассматриваются как материальные точки постоянного состава. Моделируется системой материальных точек, связанных невесомыми пружинами. Движение тросовой системы происходит в безгравитационном пространстве.\n\nЗадание\n\n\n  Используя упрощенную модель тросовой системы, определить диаметр троса при буксировке с начальными условиями \\(x_T(0) = l_0\\), \\(x_D(0) = 0\\), \\(\\dot{x}_D(0) = \\dot{x}_T(0) = 0\\) (буксировка с запуском двигателя буксира начинается в момент когда расстояние между телами равно свободной длине троса).\n  Записать и проинтегрировать уравнения продольных колебаний троса, рассматривая трос как систему материальных точек, соединенных невесомыми пружинами.\n  Определить максимальную деформацию и максимальную силу натяжения троса.\n  Сравнить результаты моделирования с результатами упрощенной модели: построить на одном рисунке графики изменения расстояния между буксиром и объектом космического мусора, полученные при помощи двух моделей.\n\n\n",
      "url": "/pages/mechanics-in-space/towing-model/"
    },{
      
      "title": "Город",
      
      "content": "Источник\n\nНеобходимо написать программу - помощник архитектора в рисовании очертания города. Город задается расположением зданий. Город рассматривается как двумерный и все здания в нем - прямоугольники, имеющие одинаковое основание (город построен на равнине). Здания задаются тройкой чисел\n\n(L[i],H[i],R[i])\n\nгде L[i]~ и R[i] есть координаты левой и правой стен здания i, а H[i] - высота этого здания. На рисунке здания описываются тройками\n\n(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22), (23,13,29),(24,4,28)\n\n\n\n\nКонтур, показанный на втором рисунке, задается последовательностью\n\n(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)\n\n\n\n\n\n  Ввод представляет собой последовательность троек, задающих дома.\n  Все координаты есть целые числа, меньшие 10000.\n  Во входном файле минимум одно и максимум 50 зданий.\n  Каждая тройка, обозначающая здание находится в отдельной строке во входном файле.\n  Все целые числа в тройке разделены одним или несколькими пробелами.\n  Тройки отсортированы по L[i], т.е. по левой х-координате здания, таким образом, здание с самой маленькой левой х-координатой является первым во входном файле.\n  Вывод будет состоять из вектора, описывающего очертание, как показано в примере выше.\n  В векторе очертания\n\n\n(v[1],v[2],v[3], ... , v[n-2],v[n-1],v[n]),\n\n\nv[i], когда i-четное число, означает горизонтальную линию (высоту). Когда i-нечетное, v[i]-означает вертикальную линию (х-координату). Последний элемент в векторе линии контура будет 0.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/town/"
    },{
      
      "title": "Команды среды разработки Турбо Паскаль",
      
      "content": "\n  \n    \n      Сочетание клавиш\n      Действие\n    \n  \n  \n    \n      F10\n      вход в меню\n    \n    \n      Ctrl+F9\n      запуск программы\n    \n    \n      Alt+F5\n      просмотр пользовательского экрана\n    \n    \n      F2\n      сохранение программы\n    \n    \n      F3\n      открытие сохраненной программы\n    \n    \n      Alt+F3\n      закрытие активного окна\n    \n    \n      Alt+X\n      выход из Турбо Паскаль\n    \n    \n      F1\n      контекстная помощь\n    \n    \n      Ctrl+F1\n      справка об операторе, на котором установлен курсор\n    \n    \n      Alt+Backspace\n      отмена последнего изменения\n    \n    \n      Ctrl+Y\n      удаление строки\n    \n    \n      Shift+стрелки\n      выделение блока текста\n    \n    \n      Ctrl+Insert\n      копирование выделенного блока в буфер\n    \n    \n      Shift+Insert\n      вставка из буфера\n    \n  \n\n\n",
      "url": "/pages/informatics/tp_cheat_sheet/"
    },{
      
      "title": "Пересечение треугольников",
      
      "content": "В тектовом файле заданы координаты верщин \\(n\\) треугольников:\n\nx11 y11 x12 y12 x13 y13\nx21 y21 x22 y22 x23 y23\nx31 y31 x32 y32 x33 y33\n...\nxn1 yn1 xn2 yn2 xn3 yn3\n\n\nОпределить точки пересечения сторон треугольников и сохранить координаты этих точек в текстовый файл, в котором указаны номера, пересекающихся треугольников и координаты точек пересечения:\n\n1-2 x1 y1\n2-3 x2 y2\n...\nn-k xm ym\n\n\nПрограмма должна показать на экране треугольники, точки пересечния и их координаты.\n\nРезультат работы программы выводится на экран и сохраняется в файл формата png.\n\nСписок заданий\n",
      "url": "/pages/python/course_works/triangles/"
    },{
      
      "title": "Метод отдельных тел",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Для изображенного на рисунке механизма с двумя степенями свободы, записать матрицы \\(S_1\\), \\(S_2\\), \\(C_1\\), \\(C_2\\), \\(w_1'\\) в выражении:\n\n[w_k = C_k \\cdot w_{k-1} + S_k \\cdot \\ddot{q}_k+w_k’, k = 1, 2]\n\n\n",
      "url": "/pages/mbs/two-dof-mech-mot/"
    },{
      
      "title": "Двухимпульсный перелет",
      
      "content": "Задана начальная масса \\(m_0\\) космического аппарата, находящегося на круговой орбите высотой \\(h_0\\). Задана высота конечной орбиты \\(h_k\\) и эффективность двигателя – удельный импульс 1500…3500 м/с. Указанные исходные данные загружаются из текстового файла\n\nm0\nh0\nIs\n\n\n\n  Определить затраты топлива, необходимые для двухимпульного перехода с одной орбиты на другую.\n  Определить продолжительность перелёта.\n  Определить приращение скорости и затраты топлива на первый и второй импульс.\n  Вывести на экран исходные данные и результаты расчёта. Сохранить результаты в тектовый файл\n\n\nНачальная масса КА          : m0 кг\nУдельный импульс            : Is м/c\nНачальная орбита (круговая) : h0 x h0 км\nКонечная  орбита (круговая) : hk x hk км\n\nСуммарные затраты топлива   : ms кг\nПродолжительность перелёта  : ts с\n...\n...\n\n\n\n  Построить график зависимостей затрат топлива в зависимости от высоты конечной орбиты при \\(h_0\\) = 200 км для нескольких значений удельных импульсов (1500, 2000, 2500, 3000 и 3500 м/с).\n\n\nСтр. 48 http://www.iki.rssi.ru/books/2010sukhanov.pdf\n\nСписок заданий\n",
      "url": "/pages/python/course_works/two_impulse_transfer/"
    },{
      
      "title": "Движение твердого тела под действием следящей силы. Пример программы.",
      "description": "Пример кода моделирования движения орбитальной ступени.\n",
      "content": "Построить модель движения орбитальной ступени ракеты-носителя после отделения полезного груза в течение 30 секунд. Принять допущение о том, что орбитальная ступень движется только под действием силы тяги сопла торможения относительно орбитальной подвижной системы координат, которая считается инерциальной (ИСК).\n\nОписание системы\n\nПример MATLAB-кода для углов Брайнта (123)\n\nГлавный файл-скрипт для запуска процесса интегрирования\n\n% Масса\nparams.m = 5000.0;\n% Матрица тензора инерции\nparams.J = [5000.0,     0,     0;\n            0     , 20000,     0;\n            0     , 0    , 20000];\n% Матрица обратная матрице тензора инерции\nparams.invJ = inv(params.J);\n\n% Функция силы от времени\n% Текущее значение силы интерполируется по таблице значений\n% при помощи функции interp1\nparams.sopForceTable = @(t) interp1([0 5 10 15 30 50],[1000 380 150 50 0 0],t);\n\n% Точка приложения силы в ССК                     \nparams.pFsop = [1.5; \n                1.0*sin(45*pi/180.0); \n                1.0*cos(45*pi/180.0)];  \n            \n% Единичный вектор направления силы в ССК\nparams.nFsop = [-cos(20*pi/180.0); \n                +sin(20*pi/180.0)*cos(55*pi/180.0);\n                -sin(20*pi/180.0)*cos(35*pi/180.0)];                    \n% Начальные условия\n% Положение центра масс\nr0 = [0;0;0];\n% Скорость центра масс\nv0 = [0;0;0];\n% Начальная ориентация (углы Брайнта 1-2-3)\na0 = [0;0;0];\n% Начальная угловая скорость\nw0 = [0;0;0];\n\n% Начальный вектор состояния\nq0 = [r0;a0;v0;w0];\n% Интервал интегрирования от 0 до 30 секунд с шагом 0.2 с\n% Другой вариант (с заданным количеством точек) linspace(0,30,100)\n% 100 точек в интервале от 0 до 30 с\ntspan = 0:0.2:30;\n\n% Относительная погрешность\noption = odeset('RelTol',1e-8);\n\n% Запуск процесса интегрирования дифференциальных уравнений\n[t, q] = ode45(@(t,q) dqdt_orbital_stage(t,q,params), tspan, q0, option);\n\n\nФайл-функция правых частей\n\nfunction dq = dqdt_orbital_stage(t,q,params)\n%dqdt_orbital_stage.m Файл-функция правых частей дифференциальных уравнений \n% движения орбитальной ступени\n\n  r = q(1:3);   % Положение центра масс\n  a = q(4:6);   % Углы Брайнта\n  v = q(7:9);   % Скорость центра масс\n  w = q(10:12); % Угловая скорость\n\n% Матрица преобразования координат из \n% связанной системы координат (ССК) \n% в орбитальную (ОСК)\nA = Axyz(a(1),a(2),a(3));\n\n% Модуль силы\nF = params.sopForceTable(t);\n\n% Вектор силы в ССК\n% Значение * единичный вектор направления\nFsop_b = F*params.nFsop;\n\n% Вектор момента этой силы относительно ССК\nMsop_b = cross(params.pFsop, Fsop_b);\n\n% Вектор силы в ИСК\nFsop_0 = A*Fsop_b;\n\n% Ускорение центра масс\ndv = Fsop_0/params.m;\n\n% Угловое ускорение \ndw = params.invJ*(Msop_b - cross(w,params.J*w));\n\n% Кинематические уравнения для углов Брайнта\n% (производные углов)\nda = kinematicEq123(a, w);\n\n% Собираем ответ \n% Значение правой части системы ДУ\ndq = [v; da; dv; dw];\n\nend\n\n\nФункция вычисления производных углов Брайнта (функция кинематических уравнений)\n\nfunction da = kinematicEq123(a, w)\n%kinematicEq123.m Кинематические уравнения для углов Брайнта\n% Последовательность XY'Z'' (пассивная точка зрения)\n% \n% Аргументы:\n%   a - строка или столбец углов Брайнта в радианах  \n%   w - строка или столбец угловых скоростей радиан/с\n% Результат:\n%   res - столбец производных углов Брайнта\n% \n     c3 = cos(a(3));\n     s3 = sin(a(3));\n     c2 = cos(a(2));\n     s2 = sin(a(2));\n     \n     da = [ w(1)*c3/c2 - w(2)*s3/c2;\n            w(1)*s3 + w(2)*c3;\n           -w(1)*c3*s2/c2 + w(2)*s3*s2/c2 + w(3)];\nend\n\n\nФайл-функция Axyz.m\n\nfunction A = Axyz(a1, a2, a3)\n  A = Ax(a1)*Ay(a2)*Az(a3);\nend\n\n\nfunction A = Ax(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [1,  0,  0;\n       0,  c, -s;\n       0,  s,  c];\nend\n\n\nfunction A = Ay(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c,  0,  s;\n       0,  1,  0;\n      -s,  0,  c];\nend\n\n\nfunction A = Az(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c, -s,  0;\n       s,  c,  0;\n       0,  0,  1];\nend\n\n\nПример кода на языке Python для углов Брайнта\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\nfrom dataclasses import dataclass\nfrom typing import Callable\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\n\n# Настройка свойств графиков \"по умолчанию\"\nparams = {'legend.fontsize': 12, 'figure.figsize': (9, 5), 'axes.labelsize': 12,\n         'axes.titlesize':12, 'xtick.labelsize':12,'ytick.labelsize':12}\npylab.rcParams.update(params)\n\n\nМатрицы элементарных поворотов\n\nAx = lambda a: np.matrix([[1.0,0,0],[0.0,np.cos(a),-np.sin(a)],[0,np.sin(a),np.cos(a)]])\nAy = lambda a: np.matrix([[np.cos(a),0,np.sin(a)],[0.0,1,0],[-np.sin(a),0,np.cos(a)]])\nAz = lambda a: np.matrix([[np.cos(a),-np.sin(a),0],[np.sin(a),np.cos(a),0],[0,0,1]])\n\n\nОбъявляем класс для хранения параметров системы (требуется Python 3.7)\n\n@dataclass\nclass Data:\n    # Масса\n    m = 5000\n    # Матрица тензора инерции в ССК\n    J = np.matrix(np.diag(np.array([5000.0,20000,20000])))\n    # Обратная матрица тензора инерции\n    invJ = np.linalg.inv(J)    \n    # Зависимость тяги от времени\n    F : Callable[[float], float] = lambda t: np.interp(t,[0.0,5,10,15,30,50],[1000.0,380,150,50,0,0])\n    # Точка приложения силы тяги в ССК\n    pFsop = np.matrix([1.5, \n                       1.0*np.sin(np.deg2rad(45)), \n                       1.0*np.cos(np.deg2rad(45))]).transpose()\n    # Направление силы тяги в ССК\n    nFsop = np.matrix([-np.cos(np.deg2rad(20)), \n                        np.sin(np.deg2rad(20))*np.cos(np.deg2rad(55)),\n                       -np.sin(np.deg2rad(20))*np.cos(np.deg2rad(35))]).transpose()\n\n# Создаем экземпляр класса Data (объект)\np = Data()\n\n\nНачальные условия\n\nr0 = np.array([0.0,0.0,0.0])\nv0 = np.array([0.0,0.0,0.0])\na0 = np.array([0.0,0.0,0.0])\nw0 = np.array([0.0,0.0,0.0])\n\nq0 = np.hstack([r0,a0,v0,w0])\n\n\nКинематические уравнения для последовательности углов 1-2-3\n\ndef kinematicEq123(a,w):\n    c3 = np.cos(a[2]);\n    s3 = np.sin(a[2]);\n    c2 = np.cos(a[1]);\n    s2 = np.sin(a[1]);    \n    return np.array([w[0]*c3/c2 - w[1]*s3/c2, \n                     w[0]*s3 + w[1]*c3, \n                    -w[0]*c3*s2/c2 + w[1]*s3*s2/c2 + w[2]])\n\n\nФункция правых частей\n\ndef dqdt(t, q, p):  \n    r = q[0:3]\n    a = q[3:6]\n    v = q[6:9]\n    # Координатный столбец угловой скорости\n    w = np.asmatrix(q[9:12]).T\n    # Матрица преобразования координат из ССК в ИСК\n    A = Ax(a[0])*Ay(a[1])*Az(a[2])    \n    # Координатный столбец вектора силы тяги сопла в связанных осях  \n    Fsop_b = p.F(t)*p.nFsop;\n    # Координатный столбец момента силы тяги сопла относительно центра масс \n    # в связанных осях\n    Msop_b = np.matrix(np.cross(p.pFsop.ravel(), Fsop_b.ravel())).T\n    # Координатный столбец вектора силы тяги сопла в ИСК  \n    Fsop_0 = A*Fsop_b\n    # Вектор ускорения центра масс\n    dv = Fsop_0/p.m\n    # Вектор углового ускорения\n    dw = p.invJ*(Msop_b - np.asmatrix(np.cross(np.ravel(w),np.ravel(p.J*w))).T)\n    # Производные углов\n    da = kinematicEq123(a,np.ravel(w))\n    # Собираем ответ\n    return np.hstack([np.ravel(v),da,np.ravel(dv),np.ravel(dw)])\n\n\nЗапуск процесса интегрирования\n\nsol = solve_ivp(dqdt, [0, 30], q0, args = (p,), method='LSODA', rtol = 1e-7)\n\n\nГрафики проекций угловых скороcтей на связанные оси ступени\n\nplt.plot(sol.t,sol.y[9,:],sol.t,sol.y[10,:],sol.t,sol.y[11,:])\nplt.xlabel('t, c')\nplt.ylabel('$\\omega$, 1/c')\nplt.grid(ls=':')\nplt.legend(['$\\omega_x$','$\\omega_y$','$\\omega_z$'])\n\n\n\n\n",
      "url": "/pages/mbs/upperstage-code/"
    },{
      "image": {"path":"/assets/img/mbs/Orbital_stage.png"},
      "title": "Движение твердого тела под действием следящей силы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "\n  Описание механической системы\n  Задание    \n      Часть 1\n      Часть 2\n      Часть 3\n    \n  \n\n\nПостроить модель движения орбитальной ступени ракеты-носителя после отделения полезного груза в течение 30 секунд. Принять допущение о том, что орбитальная ступень движется только под действием силы тяги сопла торможения относительно орбитальной подвижной системы координат, которая считается инерциальной (ИСК).\n\nОписание механической системы\n\n\n  Схема орбитальной ступени показана на рисунке 1.\n\n\n\nРисунок 1 – Схема ступени (все линейные размеры в миллиметрах)\n\n\n  Инерционно-массовые характеристики ступени\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса ступени\n      5000 кг\n    \n    \n      Положение центра масс, \\(x_c\\)\n      3 м\n    \n    \n      Момент инерции относительно продольной оси\n      5000 кг\\(\\cdot\\)м \\(^2\\)\n    \n    \n      Момент инерции относительно любой поперечной оси\n      20000 кг\\(\\cdot\\)м \\(^2\\)\n    \n  \n\n\n\n  Тяга реактивного сопла увода\n\n\n\nРисунок 2 – Закон изменения тяги реактивного сопла\n\nВ качестве параметров, определяющих угловое положение ступени – связанной со ступенью системы координат (ССК) – относительно ИСК, использовать:\n\n  направляющие косинусы;\n  углы Эйлера (пассивная точка зрения);\n  кватернионы.\n\n\nПоследовательность поворотов углов Эйлера выбирается из следующей таблицы:\n\n\n  \n    \n      Вариант\n      Последовательность\n    \n  \n  \n    \n      1\n      313\n    \n    \n      2\n      231\n    \n    \n      3\n      131\n    \n  \n\n\nНомер варианта определяется по формуле 1 + (NNNNN mod 3), где NNNNN - последние пять цифр номера зачетной книжки. В начальный момент времени координаты центра масс равны нулю, скорость ступени равна нулю (по отношению к орбитальной подвижной системы координат). Начальные углы поворота определяются выражением:\n\n[\\varphi_1 = 1 + (\\text{NNNNN} \\mod 5), \\; \\varphi_1 = 5 + (\\text{NNNNN} \\mod 10), \\; \\varphi_1 = 10 + (\\text{NNNNN} \\mod 5).]\n\nПроекция начальной угловой скорости ступени на ее продольную ось равна 1 градус в секунду, проекции угловой скорости на поперечные оси равны нулю.\n\nЗадание\n\nЧасть 1\n\n\n  Записать уравнения движения центра масс, вокруг центра масс и кинематические уравнения движения, используя в качестве параметров углы (313, 231 или 131), направляющие косинусы и кватернионы.\n  Разработать программу моделирования движения ступени на интервале работы сопла увода для трех вариантов уравнений движения (в среде MATLAB или Octave).\n  Построить графики изменения проекций угловой скорости ступени на связанные оси: \\(\\omega_x, \\omega_y, \\omega_z\\) (для одного варианта программы).\n  Построить графики изменения координат и проекций скорости центра масс ступени на оси орбитальной подвижной системы координат: \\(x,y,z\\), \\(V_x, V_y, V_z\\) для каждого варианта программы (результаты должны совпадать).\n  Построить графики изменения углов: \\(\\varphi_1, \\varphi_2, \\varphi_3\\).\n\n\nЧасть 2\n\n\n  Определить проекции единичного вектора направление вектора кинетического момента ступени после окончания работы реактивного сопла (через 30 секунд после начала движения) в системе координат \\(O x_0 y_0 z_0\\).\n  Определить угол нутации и угловую скорость прецессии орбитальной ступени после окончания работы реактивного сопла (через 30 секунд после начала движения).\n\n\nЧасть 3\n\n\n  Записать аналитические выражения для проекций угловой скорости ступени на собственные оси на интервале от 30 до 50 секунды (движение “по инерции”), определить законы изменения проекций угловой скорости, построить графики.\n  Сравнить численное решение на том же интервале с аналитическим (построить графики).\n\n\n",
      "url": "/pages/mbs/upperstage/"
    },{
      "image": {"path":"/assets/img/mbs/Orbital_stage.png"},
      "title": "Движение твердого тела под действием следящей силы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Построить модель движения орбитальной ступени ракеты-носителя после отделения полезного груза в течение 30 секунд. Принять допущение о том, что орбитальная ступень движется только под действием силы тяги сопла торможения относительно орбитальной подвижной системы координат, которая считается инерциальной.\n\nОписание механической системы\n\n\n  Схема орбитальной ступени показана на рисунке 1.\n\n\n\nРисунок 1 – Схема ступени (все линейные размеры в миллиметрах)\n\n\n  Инерционно-массовые характеристики ступени\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса ступени\n      5000 кг\n    \n    \n      Положение центра масс, \\(x_c\\)\n      3 м\n    \n    \n      Момент инерции относительно продольной оси\n      5000 кг\\(\\cdot\\)м \\(^2\\)\n    \n    \n      Момент инерции относительно любой поперечной оси\n      10000 кг\\(\\cdot\\)м \\(^2\\)\n    \n  \n\n\n\n  Тяга реактивного сопла увода\n\n\n\nРисунок 2 – Закон изменения тяги реактивного сопла\n\nВ качестве параметров, определяющих угловое положение ступени, использовать\n\n  направляющие косинусы;\n  углы Эйлера (пассивная точка зрения);\n  кватернионы\n\n\nПоследовательность поворотов углов Эйлера выбирается из следующей таблицы:\n\n\n  \n    \n      Вариант\n      Последовательность\n    \n  \n  \n    \n      1\n      313\n    \n    \n      2\n      231\n    \n    \n      3\n      131\n    \n  \n\n\nНомер варианта определяется по формуле 1 + (NNNNN mod 3), где NNNNN - последние пять цифр номера зачетной книжки. В начальный момент времени координаты центра масс равны нулю, скорость ступени равна нулю (по отношению к орбитальной подвижной системы координат). Начальные углы поворота определяются выражением:\n\n[\\varphi_1 = 1 + (\\text{NNNNN} \\mod 5), \\; \\varphi_1 = 5 + (\\text{NNNNN} \\mod 10), \\; \\varphi_1 = 10 + (\\text{NNNNN} \\mod 5).]\n\nПроекция начальной угловой скорости ступени на ее продольную ось равна 1 градусу в секунду, проекции угловой скорости на поперечные оси равны нулю.\n\nЗадание\n\n\n  Построить графики изменения проекций угловой скорости ступени на связанные оси: \\(\\omega_x, \\omega_y, \\omega_z\\).\n  Построить графики изменения координат и проекций скорости центра масс ступени на оси орбитальной подвижной системы координат: \\(x,y,z\\), \\(V_x, V_y, V_z\\).\n  Построить графики изменения углов: \\(\\varphi_1, \\varphi_2, \\varphi_3\\).\n  Определить проекции единичного вектора направление вектора кинетического момента ступени после окончания работы реактивного сопла (через 30 секунд после начала движения) в системе координат \\(O x_0 y_0 z_0\\).\n  Определить угол нутации и угловую скорость прецессии орбитальной ступени после окончания работы реактивного сопла (через 30 секунд после начала движения).\n\n\nМетодические указания\n\nПример MATLAB-кода для углов Брайнта (123)\n\nГлавный файл-скрипт для запуска процесса интегрирования\n\n% Масса\nparams.m = 5000.0;\n% Матрица тензора инерции\nparams.J = [5000.0,     0,     0;\n            0     , 20000,     0;\n            0     , 0    , 20000];\n% Матрица обратная матрице тензора инерции\nparams.invJ = inv(params.J);\n\n% Функция силы от времени\n% Текущее значение силы интерполируется по таблице значений\n% при помощи функции interp1\nparams.sopForceTable = @(t) interp1([0 5 10 15 30 50],[1000 380 150 50 0 0],t);\n\n% Точка приложения силы в ССК                     \nparams.pFsop = [1.5; \n                1.0*sin(45*pi/180.0); \n                1.0*cos(45*pi/180.0)];  \n            \n% Единичный вектор направления силы в ССК\nparams.nFsop = [-cos(20*pi/180.0); \n                +sin(20*pi/180.0)*cos(55*pi/180.0);\n                -sin(20*pi/180.0)*cos(35*pi/180.0)];                    \n% Начальные условия\n% Положение центра масс\nr0 = [0;0;0];\n% Скорость центра масс\nv0 = [0;0;0];\n% Начальная ориентация (углы Брайнта 1-2-3)\na0 = [0;0;0];\n% Начальная угловая скорость\nw0 = [0;0;0];\n\n% Начальный вектор состояния\nq0 = [r0;a0;v0;w0];\n% Интервал интегрирования от 0 до 30 секунд с шагом 0.2 с\n% Другой вариант (с заданным количеством точек) linspace(0,30,100)\n% 100 точек в интервале от 0 до 30 с\ntspan = 0:0.2:30;\n\n% Относительная погрешность\noption = odeset('RelTol',1e-8);\n\n% Запуск процесса интегрирования дифференциальных уравнений\n[t, q] = ode45(@(t,q) dqdt_orbital_stage(t,q,params), tspan, q0, option);\n\n\nФайл-функция правых частей\n\nfunction dq = dqdt_orbital_stage(t,q,params)\n%dqdt_orbital_stage.m Файл-функция правых частей дифференциальных уравнений \n% движения орбитальной ступени\n\n  r = q(1:3);   % Положение центра масс\n  a = q(4:6);   % Углы Брайнта\n  v = q(7:9);   % Скорость центра масс\n  w = q(10:12); % Угловая скорость\n\n% Матрица преобразования координат из \n% связанной системы координат (ССК) \n% в орбитальную (ОСК)\nA = Axyz(a(1),a(2),a(3));\n\n% Модуль силы\nF = params.sopForceTable(t);\n\n% Вектор силы в ССК\n% Значение * единичный вектор направления\nFsop_b = F*params.nFsop;\n\n% Вектор момента этой силы относительно ССК\nMsop_b = cross(params.pFsop, Fsop_b);\n\n% Вектор силы в ИСК\nFsop_0 = A*Fsop_b;\n\n% Ускорение центра масс\ndv = Fsop_0/params.m;\n\n% Угловое ускорение \ndw = params.invJ*(Msop_b - cross(w,params.J*w));\n\n% Кинематические уравнения для углов Брайнта\n% (производные углов)\nda = kinematicEq123(a, w);\n\n% Собираем ответ \n% Значение правой части системы ДУ\ndq = [v; da; dv; dw];\n\nend\n\n\nФункция вычисления производных углов Брайнта (функция кинематических уравнений)\n\nfunction da = kinematicEq123(a, w)\n%kinematicEq123.m Кинематические уравнения для углов Брайнта\n% Последовательность XY'Z'' (пассивная точка зрения)\n% \n% Аргументы:\n%   a - строка или столбец углов Брайнта в радианах  \n%   w - строка или столбец угловых скоростей радиан/с\n% Результат:\n%   res - столбец производных углов Брайнта\n% \n     c3 = cos(a(3));\n     s3 = sin(a(3));\n     c2 = cos(a(2));\n     s2 = sin(a(2));\n     \n     da = [ w(1)*c3/c2 - w(2)*s3/c2;\n            w(1)*s3 + w(2)*c3;\n           -w(1)*c3*s2/c2 + w(2)*s3*s2/c2 + w(3)];\nend\n\n\nФайл-функция Axyz.m\n\nfunction A = Axyz(a1, a2, a3)\n  A = Ax(a1)*Ay(a2)*Az(a3);\nend\n\n\nfunction A = Ax(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [1,  0,  0;\n       0,  c, -s;\n       0,  s,  c];\nend\n\n\nfunction A = Ay(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c,  0,  s;\n       0,  1,  0;\n      -s,  0,  c];\nend\n\n\nfunction A = Az(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c, -s,  0;\n       s,  c,  0;\n       0,  0,  1];\nend\n\n",
      "url": "/pages/mbs/upperstage2/"
    },{
      "image": {"path":"/assets/img/mbs/Orbital_stage.png"},
      "title": "Движение твердого тела под действием следящей силы",
      "description": "Задание для лабораторной работы по курсу Динамика твёрдого тела и систем тел.\n",
      "content": "Построить модель движения орбитальной ступени ракеты-носителя после отделения полезного груза в течение 30 секунд. Принять допущение о том, что орбитальная ступень движется только под действием силы тяги сопла торможения относительно орбитальной подвижной системы координат, которая считается инерциальной.\n\nОписание механической системы\n\n\n  Схема орбитальной ступени показана на рисунке 1.\n\n\n\nРисунок 1 – Схема ступени (все линейные размеры в миллиметрах)\n\n\n  Инерционно-массовые характеристики ступени\n\n\n\n  \n    \n      Параметр\n      Значение\n    \n  \n  \n    \n      Масса ступени\n      5000 кг\n    \n    \n      Положение центра масс, \\(x_c\\)\n      3 м\n    \n    \n      Момент инерции относительно продольной оси\n      5000 кг\\(\\cdot\\)м \\(^2\\)\n    \n    \n      Момент инерции относительно любой поперечной оси\n      10000 кг\\(\\cdot\\)м \\(^2\\)\n    \n  \n\n\n\n  Тяга реактивного сопла увода\n\n\n\nРисунок 2 – Закон изменения тяги реактивного сопла\n\nВ качестве параметров, определяющих угловое положение ступени, использовать\n\n  направляющие косинусы;\n  углы Эйлера (пассивная точка зрения);\n  кватернионы\n\n\nПоследовательность поворотов углов Эйлера выбирается из следующей таблицы:\n\n\n  \n    \n      Вариант\n      Последовательность\n    \n  \n  \n    \n      1\n      313\n    \n    \n      2\n      231\n    \n    \n      3\n      131\n    \n  \n\n\nНомер варианта определяется по формуле 1 + (NNNNN mod 3), где NNNNN - последние пять цифр номера зачетной книжки. В начальный момент времени координаты центра масс равны нулю, скорость ступени равна нулю (по отношению к орбитальной подвижной системы координат). Начальные углы поворота определяются выражением:\n\n[\\varphi_1 = 1 + (\\text{NNNNN} \\mod 5), \\; \\varphi_1 = 5 + (\\text{NNNNN} \\mod 10), \\; \\varphi_1 = 10 + (\\text{NNNNN} \\mod 5).]\n\nПроекция начальной угловой скорости ступени на ее продольную ось равна 1 градусу в секунду, проекции угловой скорости на поперечные оси равны нулю.\n\nЗадание\n\nЧасть 1\n\n\n  Построить графики изменения проекций угловой скорости ступени на связанные оси: \\(\\omega_x, \\omega_y, \\omega_z\\).\n  Построить графики изменения координат и проекций скорости центра масс ступени на оси орбитальной подвижной системы координат: \\(x,y,z\\), \\(V_x, V_y, V_z\\).\n  Построить графики изменения углов: \\(\\varphi_1, \\varphi_2, \\varphi_3\\).\n  Определить проекции единичного вектора направление вектора кинетического момента ступени после окончания работы реактивного сопла (через 30 секунд после начала движения) в системе координат \\(O x_0 y_0 z_0\\).\n  Определить угол нутации и угловую скорость прецессии орбитальной ступени после окончания работы реактивного сопла (через 30 секунд после начала движения).\n\n\nЧасть 2\n\n\n  Модифицировать программу, добавив в число действующих сил и моментов силу притяжения Земли и гравитационный момент, исключив действие на ступень реактивной силы сопла увода. Интегрирование уравнений движения проводить с теми же начальными условиями.\n  Получить результат интегрирования на интервале двух орбитальных периодов, предполагая, что ступень движется по круговой орбите высотой 200 км.\n  Построить график изменения высоты ступени от времени для проверки корректности модели.\n  Построить графики изменения от времени проекций угловой скорости ступени на её связанные оси: \\(\\omega_x, \\omega_y, \\omega_z\\).\n  Построить график изменения угла между продольной осью ступени и направлением местной вертикали.\n\n\nМетодические указания\n\nПример MATLAB-кода для углов Брайнта (123)\n\nГлавный файл-скрипт для запуска процесса интегрирования\n\n% Масса\nparams.m = 5000.0;\n% Матрица тензора инерции\nparams.J = [5000.0,     0,     0;\n            0     , 20000,     0;\n            0     , 0    , 20000];\n% Матрица обратная матрице тензора инерции\nparams.invJ = inv(params.J);\n\n% Функция силы от времени\n% Текущее значение силы интерполируется по таблице значений\n% при помощи функции interp1\nparams.sopForceTable = @(t) interp1([0 5 10 15 30 50],[1000 380 150 50 0 0],t);\n\n% Точка приложения силы в ССК                     \nparams.pFsop = [1.5; \n                1.0*sin(45*pi/180.0); \n                1.0*cos(45*pi/180.0)];  \n            \n% Единичный вектор направления силы в ССК\nparams.nFsop = [-cos(20*pi/180.0); \n                +sin(20*pi/180.0)*cos(55*pi/180.0);\n                -sin(20*pi/180.0)*cos(35*pi/180.0)];                    \n% Начальные условия\n% Положение центра масс\nr0 = [0;0;0];\n% Скорость центра масс\nv0 = [0;0;0];\n% Начальная ориентация (углы Брайнта 1-2-3)\na0 = [0;0;0];\n% Начальная угловая скорость\nw0 = [0;0;0];\n\n% Начальный вектор состояния\nq0 = [r0;a0;v0;w0];\n% Интервал интегрирования от 0 до 30 секунд с шагом 0.2 с\n% Другой вариант (с заданным количеством точек) linspace(0,30,100)\n% 100 точек в интервале от 0 до 30 с\ntspan = 0:0.2:30;\n\n% Относительная погрешность\noption = odeset('RelTol',1e-8);\n\n% Запуск процесса интегрирования дифференциальных уравнений\n[t, q] = ode45(@(t,q) dqdt_orbital_stage(t,q,params), tspan, q0, option);\n\n\nФайл-функция правых частей\n\nfunction dq = dqdt_orbital_stage(t,q,params)\n%dqdt_orbital_stage.m Файл-функция правых частей дифференциальных уравнений \n% движения орбитальной ступени\n\n  r = q(1:3);   % Положение центра масс\n  a = q(4:6);   % Углы Брайнта\n  v = q(7:9);   % Скорость центра масс\n  w = q(10:12); % Угловая скорость\n\n% Матрица преобразования координат из \n% связанной системы координат (ССК) \n% в орбитальную (ОСК)\nA = Axyz(a(1),a(2),a(3));\n\n% Модуль силы\nF = params.sopForceTable(t);\n\n% Вектор силы в ССК\n% Значение * единичный вектор направления\nFsop_b = F*params.nFsop;\n\n% Вектор момента этой силы относительно ССК\nMsop_b = cross(params.pFsop, Fsop_b);\n\n% Вектор силы в ИСК\nFsop_0 = A*Fsop_b;\n\n% Ускорение центра масс\ndv = Fsop_0/params.m;\n\n% Угловое ускорение \ndw = params.invJ*(Msop_b - cross(w,params.J*w));\n\n% Кинематические уравнения для углов Брайнта\n% (производные углов)\nda = kinematicEq123(a, w);\n\n% Собираем ответ \n% Значение правой части системы ДУ\ndq = [v; da; dv; dw];\n\nend\n\n\nФункция вычисления производных углов Брайнта (функция кинематических уравнений)\n\nfunction da = kinematicEq123(a, w)\n%kinematicEq123.m Кинематические уравнения для углов Брайнта\n% Последовательность XY'Z'' (пассивная точка зрения)\n% \n% Аргументы:\n%   a - строка или столбец углов Брайнта в радианах  \n%   w - строка или столбец угловых скоростей радиан/с\n% Результат:\n%   res - столбец производных углов Брайнта\n% \n     c3 = cos(a(3));\n     s3 = sin(a(3));\n     c2 = cos(a(2));\n     s2 = sin(a(2));\n     \n     da = [ w(1)*c3/c2 - w(2)*s3/c2;\n            w(1)*s3 + w(2)*c3;\n           -w(1)*c3*s2/c2 + w(2)*s3*s2/c2 + w(3)];\nend\n\n\nФайл-функция Axyz.m\n\nfunction A = Axyz(a1, a2, a3)\n  A = Ax(a1)*Ay(a2)*Az(a3);\nend\n\n\nfunction A = Ax(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [1,  0,  0;\n       0,  c, -s;\n       0,  s,  c];\nend\n\n\nfunction A = Ay(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c,  0,  s;\n       0,  1,  0;\n      -s,  0,  c];\nend\n\n\nfunction A = Az(angle)\n  c = cos(angle);\n  s = sin(angle);\n  A = [c, -s,  0;\n       s,  c,  0;\n       0,  0,  1];\nend\n\n",
      "url": "/pages/mbs/upperstage3/"
    },{
      
      "title": "Видео",
      
      "content": "\n  YouTube\n  RuTube\n\n\n",
      "url": "/pages/videos/"
    },{
      
      "title": "Blog",
      
      "content": "\n",
      "url": "/blog/2/"
    },{
      
      "title": "Blog",
      
      "content": "\n",
      "url": "/blog/3/"
    },{
      
      "title": "Blog",
      
      "content": "\n",
      "url": "/blog/4/"
    },{
      
      "title": "Blog",
      
      "content": "\n",
      "url": "/blog/5/"
    }
  ], 
  "documents": [
    {
      
      "title": "Удалить историю git",
      "date": "2018-04-01 00:00:00 -0500",
      
      "content": "git checkout --orphan temp_branch\ngit add -A\ngit commit -am \"The first commit\"\n\n\ngit branch -D master\ngit branch -m master\ngit push -f origin master\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-04-01-git-clear-history/"
    },{
      
      "title": "Electrostatic Space Tug",
      "date": "2018-04-02 00:00:00 -0500",
      
      "content": "Вышла новая статья про уборку космического мусора в Journal of Guidance, Control, and Dynamics. В этот раз не про трос, а про “тяговый луч”.\n\nНа высоких орбитах, в частности на геостационарной орбите можно для буксировки пассивных объектов использовать электростатическое поле, зарядив сам буксир и буксируемый объект разными или одинаковыми по знаку зарядами. В зависимости от этого будет схема «тяни» или «толкай».\n\nВ первом случае, буксир создает силу тяги, направленную в сторону мусора, толкая его перед собой: медленно, но верно переводя на орбиту захоронения. Для геостационарной орбиты это орбиты, находящиеся на 200 км выше (спуск мусора к Земле получается слишком дорогим).\n\n\n\nЕсли электрические заряды буксира и мусора разные по знаку, то буксир будет притягивать мусор, поэтому сила тяги буксира должна быть направлена от космического мусора.\n\n\n\nИдея использование электростатического поля для буксировки мусора запатентована (https://patents.justia.com/patent/8210480), правда в патенте речь идет о противоположных зарядах.\n\nДля создания необходимого заряда космического мусора и самого буксира можно использовать электронные или ионные пушки, например электрореактивные двигатели — тяга в электрореактивных (ионных) двигателях как раз создается за счёт ионизированного газа, разгоняемого магнитным полем. Этот поток заряженных частиц можно исползовать для передачи заряда.\n\n«Тяга», создаваемая электрическим полем невелика (десятки миллиньютонов), но достаточна для изменения орбиты космического мусора на высоких орбитах.\n\nСтатья посвящена вопросу устойчивого управления буксиром в процессе орбитальной транспортировки.\n\nV. S. Aslanov, V. V. Yudintsev Motion Control of Space Tug During Debris Removal by a Coulomb Force. Journal of Guidance, Control, and Dynamics, 2018, March 22, 2018. doi:10.2514/1.G003251 \n",
      "categories": [],
      "tags": ["космонавтика","space debris","космический мусор"],
      
      "collection": "posts",
      "url": "/blog/2018-04-02-electrostatic-space-tug/"
    },{
      
      "title": "Net",
      "date": "2018-04-14 00:00:00 -0500",
      
      "content": "Экспериментирую с MATLAB-моделью сети (для захвата сетью космического мусора). В этой модели 257 тел. Сеть представлена 256 материальными точками-узлами, соединенными односторонними упругими связями. С объектом (шаром) взаимодействуют только узлы сети.\n\nНесмотря на все упрощения MATLAB-кода скорость интегрирования пока очень низкая: расчёт 5 секунд времени модели требует около 6,5 минут машинного времени (i5-2500 3.3Ghz x 4 / Linux). Что же будет при захвате более сложных вращающихся объектов?\n\n\n",
      "categories": ["mechancis"],
      "tags": ["debris"],
      
      "collection": "posts",
      "url": "/blog/mechancis/2018-04-14-net/"
    },{
      
      "title": "Использование утилиты ffmpeg",
      "date": "2018-05-13 00:00:00 -0500",
      
      "content": "Изменение размера изображения\n\nffmpeg −i input.avi −s 320x240 result.mp4\n\n\nИзвлечение фрагмента\n\nСохранить в файл result.wmv фрагмент видео из файла input.wmv начиная с 30 секунды (-ss) продолжительностью 10 секунд (-t).\n\nffmpeg −ss 00:00:30.0 −i input.wmv −c copy −t 00:00:10.0 result.wmv\n\n\nИзвлечение одного кадра\n\nСохранить один кадр на первой секунде и сохранить его в файл video_frame.png\n\nffmpeg -ss 00:00:01 -i video.avi -vframes 1 video_frame.png\n\n\nИзвлечение нескольких кадров\n\nИзвлечение кадра каждую секунду:\n\nffmpeg -i net_case_1.avi -vf fps=1 case_1_%3d.png\n\n\nВидеопрезентация из серии изображений\n\nСоздаётся видеофайл из изображений p01.png, p02.png, p03.png, …, которые сменяют друг-друга каждые 5 секунд (1/5). Частота кадров видеофайла 30 кадров/с.\nffmpeg -r 1/5 -i p%2d.png -c:v libx264 -r 30 -y -pix_fmt yuv420p slide_show.mp4\n\n\nДобавление аннотации\n\nffmpeg -i net.avi -vf \"drawtext=text='Net capture':fontcolor=black@0.6:fontsize=18:box=1:boxcolor=black@0.0:x=5:y=5\" -b:v 4M -y net_annotated.avi\n\n\nСоздание анимированного gif\n\nffmpeg −i video.avi video.gif\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-05-13-ffmpeg/"
    },{
      
      "title": "Истечение газа из ёмкости постоянного объёма",
      "date": "2019-01-02 00:00:00 -0600",
      
      "content": "Пример кода на языке Python (в Google Colab) решения задачи истечения газа через отверстие из ёмкости постоянного объёма.\n\nПо книге Е. В. Герц, Г. В. Крейнин Расчёт пневмоприводов Справочное пособие М.: Машиностроение, 1975.\n\nДана ёмкость с постоянным объемом \\(V_1\\) и начальным давлением \\(p_1\\), соединенная со средой с давлением \\(p_a\\). Из ёмкости через отверстие с эффективной площадью \\(f\\) начинает истекать газ. Процесс происходит без теплообмена с окружающей средой. Необходимо найти закон изменения давления в ёмкости.\n\nПодключение необходимых библиотек\n\nimport math\nimport scipy\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.pylab as pylab\n\n# Настройка свойств графиков \"по умолчанию\"\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\nКонстанты и начальные условия\n\n# Ускорение свободного падения\ng = 9.807\n# Газовая постоянная, \nR = 29.27\n# Температура, К\nT = 280.0\n# Показатель адиабаты\nk  = 1.4\n# Критическое соотношение давлений\nsk = (2/(k+1))**(k/(k-1))\n\n# Объём ёмкости м3\nV1 = 0.018\n# Начальное давление в ёмкости, кгс/м2\np1 = 5.0e4\n# Эффективная площадь отверстия м2\nf  = 0.7*1.76e-4\n# Давление среды, кгс/м2\npa = 1.0e4\n\n\nВесовой расход газа\n\nВесовой расход газа \\(G_m\\) зависит от режима истечения газа, определяемого соотношением давлений \\(\\sigma\\).\n\n[\\sigma = \\frac{p_2}{p_1}]\n\nПри \\(\\sigma &lt; \\sigma^*\\) (надкритический расход)\n\n[G_m = \\sqrt{\\frac{2 k g}{k-1}} \\frac{fp_1 \\varphi(\\sigma^*)}{\\sqrt{RT}}]\n\nДля \\(\\sigma &gt; \\sigma^*\\) (подкритический расход)\n\n[G_m = \\sqrt{\\frac{2 k g}{k-1}} \\frac{fp_1 \\varphi(\\sigma)}{\\sqrt{RT}}]\n\nгде\n\n[\\sigma = \\frac{p_2}{p_1}, \\quad \\sigma^* = \\left(\\frac{2}{k+1}\\right)^{k/(k-1)},\\quad \\varphi(\\sigma) = \\sqrt{\\sigma^{2/k}-\\sigma^{(k+1)/k}}]\n\n\ndef Gm(p1, p2, f):\n  '''\n  Функция вычисляет весовой расход газа (кгс/с)\n  при истечении из емкости с давлением p1 (кгс/м2)\n  в ёмкость c давлением p2 (кгс/м2) (p2 &lt; p1) \n  через отверстие с эффективной площадью f (м2)  \n  '''  \n  # Соотношение давлений (куда/откуда)\n  s   = p2/p1\n  phi = lambda x: math.sqrt(x**(2.0/k)-x**((k+1.0)/k)) \n  \n  if s &lt; sk:\n    # Надкритический расход (истечение со скоростью звука)\n    # Вместе с вычисленным расходом возвращаем признак 1 \n    res = [1, math.sqrt(2*k*g/(k-1))*f*p1*phi(sk)/math.sqrt(R*T)]\n  else:\n    # Подкритический расход\n    # Вместе с вычисленным расходом возвращаем признак 0\n    res = [0, math.sqrt(2*k*g/(k-1))*f*p1*phi(s)/math.sqrt(R*T) ]\n    \n  return res \n\n\nДифференциальное уравнение изменения давления в ёмкости\n\n[\\frac{dp_1}{dt} = - \\frac{G_m k R T}{V_1}]\n\ndef dp1dt(t, q):  \n  '''\n  Функция правой части дифференциального уравнения dp1/dt = ...\n  '''\n  p1 = q[0]  \n  gm = -Gm(p1, pa, f)[1]  \n  return gm*k*R*T/V1\n\n\nИнтегрирование\n\nsol = scipy.integrate.solve_ivp(dp1dt, [0, 1], [p1], method='LSODA', rtol = 1e-10)\n# Извлекаем давление из результатов интегрирования\npt  = sol.y.flatten()\n# Вычисляем расход по полученным результатам интегрирования\nGt  = np.array([ Gm(x, pa, f) for x in pt ])\n\n\nРезультаты\n\nГрафик изменения давления в ёмкости\n\nplt.plot(sol.t[Gt[:,0]&gt;0],pt[Gt[:,0]&gt;0]/1e4,'r',sol.t[Gt[:,0]&lt;1],pt[Gt[:,0]&lt;1]/1e4,'g');\nplt.legend(['Надкритический режим','Подкритический режим'])\nplt.xlim([0,1]);plt.xlabel('t, c');plt.ylabel('p, кгс/см$^2$');\n\n\nГрафик весового расхода газа\n\nplt.plot(sol.t[Gt[:,0]&gt;0],Gt[Gt[:,0]&gt;0,1],'r',sol.t[Gt[:,0]&lt;1],Gt[Gt[:,0]&lt;1,1],'g');\nplt.legend(['Надкритический режим','Подкритический режим'])\nplt.xlim([0,0.9]);plt.xlabel('t, c');plt.ylabel('Весовой расход, кгс/c');\n\n\nКод в Google CoLab.\n",
      "categories": ["mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-01-02-discharge-constant-volume-python/"
    },{
      
      "title": "Движение спускаемого аппарата в атмосфере",
      "date": "2019-01-05 00:00:00 -0600",
      
      "content": "Пример кода на языке Python (в Google Colab) для моделирования движения спускаемого аппарата (СА) в атмосфере Земли. Рассматривается простейшая плоская модель движения СА, как материальной точки с постоянными коэффициентами лобового сопротивления и подъёмной силы. Показано использование параметра events интегратора для остановки процесса интегрирования при достижении СА поверхности Земли.\n\nПодключаем необходимые библиотеки\n\n\nfrom collections import namedtuple\nimport scipy\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n\n\nОбъявляем функцию, для вычисления плотности воздуха и ускорения свободного падения на заданной высоте.\n\n# Модель атмосферы в диапазоне от 0 до 100 км с погрешностью 1,5%\n# В. А. ЯРОШЕВСКИЙ \"АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ\"\n# Ученые записки ЦАГИ, т. XL, №3, 2009.\na  = np.array([-6.3759,-7.3012,-1.1817])\nb  = np.array([-0.4754,-0.0096,-0.0068,-0.0120,0.0042]);\nc  = np.array([ 0.1803, 0.0872,-0.0153, 0.0145,0     ]);\n\ndef rho(h):\n  # Функция вычисления плотности воздуха\n  # высота h задаётся в километрах\n  # результат -- плотность кг/м3\n  x = h/50.0-1\n  sa = a[0] + a[1]*x + a[2]*x*x\n  sbc= np.sum( (b[i]*np.cos((i+1)*np.pi*x) + c[i]*np.sin((i+1)*np.pi*x) for i in range(5)) )\n  return np.exp(sa + sbc)\n\n# Гравитационный параметр Земли\nmu = 398600.4415e9\n# Радиус Земли\nRe = 6371000.0\n\ndef g_acc(h):\n  # Вычисление ускорения свободного падения м/с^2 на высоте h (в метрах)\n  return mu/(Re+h)**2\n\n\nУравнения движения имеют следующий вид:\n\n[\\frac{dV}{dt} = - \\frac{C_d S_m q}{m} - g \\sin \\theta,\\quad V \\frac{d \\theta}{dt} = \\frac{C_l S_m q}{m} - \\left(g-\\frac{V^2}{r}\\right) \\cos \\theta, \\quad \\frac{dr}{dt} = V \\sin \\theta]\n\nгде \\(V\\) - скорость СА; \\(\\vartheta\\) – угол наклона траектории (угол между вектором скорости и линией местного горизонта); \\(r\\) – расстояние от центра Земли до центра масс СА; \\(g\\) – ускорение свободного падения на высоте \\(h\\); \\(m\\) – масса СА; \\(S_m\\) – характерная площадь (площадь Миделя); \\(C_d\\) – аэродинамический коэффициент лобового сопротивления; \\(C_l\\) – аэродинамический коэффициент подъёмной силы; \\(q\\) – Скоростной напор:\n\n[q = \\frac{\\rho V^2}{2}]\n\nФункция правых частей дифференциальных уравнений:\n\ndef dydt(t, y, p):  \n  # Функция правых частей дифференциальных уравнений\n  # вычисление правых частей дифференциальных уравнений для\n  # момента времени t и вектора состояния y = [r(t), v(t), theta(t)]\n\n  # Радиус-вектор точки в момент времени t\n  r     = y[0]\n  # Скорость  в момент времени t\n  v     = y[1]\n  # Угол наклона траекториии  в момент времени t  \n  theta = y[2]\n\n  # Высота (км)\n  h     = (r - Re)*0.001\n  # Скоростной напор Н/м^2\n  q     = rho(h)*v*v/2  \n  # Ускорение свободного падения\n  g     = g_acc(r - Re)\n\n  # dv/dt =   \n  dv    = - q*p.CD*p.Sm/p.mass - g*np.sin(theta)\n  # dtheta/dt =   \n  dtheta= (q*p.CL*p.Sm/p.mass - (g - v*v/r)*np.cos(theta))/v\n  # dr/dt =    \n  dr    = v*np.sin(theta)\n\n  return (dr,dv,dtheta)\n\n\nСледующая функция используется для останова процесса интегрирования при достижении спускаемым аппаратом нулевой высоты. Функция возвращает высоту полета и устанавливает два атрибута, один из которых указывает на направление изменения контролируемой функции (высоты) при пересечении нулевого значения. В рассматриваемом случае атрибут direction равен минус 1, т.е. процесс интегрирования остановится только если высота пересечет ноль уменьшаясь. Второй атрибут – terminal предписывает остановить процесс интегрирования.\n\ndef event_h_eq_0(t, y):\n  # Функция-\"детектор\", передаваемая в интегратор (параметр events),\n  # для определения времени достижения нулевой высоты и\n  # остановки процесса интегрирования  \n  # функция возвращает высоту  \n  return y[0]-Re  \n\n# функция определяется условие h = 0 при движении \"вниз\"\nevent_h_eq_0.direction = -1\n# функция-детектор активна\nevent_h_eq_0.terminal  = True  \n\n\nПараметры спускаемого аппарата (масса, аэродинамические коэффициенты, площадь миделя) будут храниться в структуре params.\n\nparams = namedtuple(\"params\", \"CD CL mass\")\n# Масса тела\nparams.mass = 4000.0\n# Аэродинамические коэфиициенты,\n# которые в общем случае зависят от числа Маха,\n# угла атаки\nparams.CD   = 1.5    # Коэффицент лобового сопротивления\nparams.CL   = 0      # Коэффицент подъёмной силы\n# Площадь миделя\nparams.Sm   = 3      \n\n\nНачальные условия движения:\n\n# Начальные условия\nh0     = 100e3 # Начальная высота [м]\nv0     = 7800. # Начальная скорость [м/c]\ntheta0 = -0.1  # начальный угол наклона траектории [радиан]\n\n\nЗапускаем процесс интегрирования, передавая функции solve_ivp ссылку на функцию правых частей, интервал интегрирования, список начальных условий, используемый численный метод и ссылку на функцию для останова интегрирования. Функция правых частей должна иметь два аргумента: время и вектор состояния. Объявленная ранее функция dydt имеет три аргумента, включая ссылку на структуру с параметрами спускаемого аппарата, поэтому эту функция адаптируется к требованиям solve_ivp при помощи лямбда-функции.\n\nsol = scipy.integrate.solve_ivp(lambda t,y: dydt(t,y,params), [0, 1000], [Re+h0, v0, theta0], method='LSODA', events = event_h_eq_0, rtol = 1e-8)\n\n\nПостроение графиков\n\n# Зависимость высоты от времени\nplt.plot(sol.t,(sol.y[0]-Re)*0.001);\nplt.xlabel('t, c');plt.ylabel('h, км');\n\n",
      "categories": ["mechanics"],
      "tags": ["python","space"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-01-05-reentry-1/"
    },{
      
      "title": "Способ очистки орбит от объектов космического мусора",
      "date": "2019-02-22 00:00:00 -0600",
      
      "content": "Изобретение относится к методам и средствам очистки орбит от космического мусора, главным образом отработанных ступеней ракет-носителей. Способ включает выведение в область очистки космического аппарата-буксира и автономного стыковочного модуля на тросе. Автономный модуль стыкуется с орбитальной ступенью и гасит кинетический момент ступени своими управляющими двигателями. Кинетический момент связки гасится двигателями буксира и двигателями автономного модуля.\n\nОткрыть документ\n",
      "categories": ["mechanics"],
      "tags": ["space"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-02-22-patent/"
    },{
      
      "title": "Пример использования библиотеки sympy для поиска экстремума функции",
      "date": "2019-06-09 00:00:00 -0500",
      
      "content": "Рассмотрим алгоритм поиска экстремума функции одной переменной при помощи библиотеки sympy. Дана следующая функция от \\(x\\):\n\n[f(x)  = \\frac{\\sqrt{x^2+a^2} + k \\sqrt{b^2+(h-x)^2}}{v_1}]\n\nДля нахождения экстремума функции найдем ее производную по \\(x\\), используя библиотеку sympy, и решив уравнение\n\n[\\frac{df(x)}{dx} = 0,]\n\nнайдем значение x, которому соответсвует минимум или максимум функции.\n\nПоключаем библиотеки\n\n\n# numpy всегда пригодится\nimport numpy as np\n# Для построения графиков\nimport matplotlib.pyplot as plt\n# Научный питон  \nfrom scipy import optimize\n# Символьный питон\nfrom sympy import *\n\n\n\nОбъявляем используемые в функции символьные параметры\n\na, b, h, k, x, v1 = symbols('a, b, h, k, x, v1')\n\n\nОбъявляем функцию\n\nf  = (sqrt(x**2+a**2) + k*sqrt(b**2+(h-x)**2))/v1\n\n\nНайдем её производную при помощи функции библиотеки sympy diff. Первый аргумент функции diff – дифференцируемое выражение, второй – переменная, по которой необходимо найти производную:\n\ndf = diff(f, x)\n\n\nВ результате переменная df будет содержать следующее выражение\n\n&gt;&gt; df\n\n(k*(-h + x)/sqrt(b**2 + (h - x)**2) + x/sqrt(a**2 + x**2))/v1\n\n\nВ полученном выражении для производной заменим символы (параметры) a, b, h, k, v1 их значениями (a=10, b=10, h=10, k=5, v1=5). Для этого создаем словарь\n\nparams = {a:10, b:10, h:10.0, k:5, v1: 5}\n\n\nкоторый подставим в найденную производную, используя метод subs\n\ndf_par = df.subs(params)\n\n\nРезультатом будет выражение, которое зависит только от x:\n\n&gt;&gt; df_par\n\nx/(5*sqrt(x**2 + 100)) + (x - 10.0)/sqrt((-x + 10.0)**2 + 100)\n\n\nСоздадим на основе символьного вращения f_par лямбда-функцию от x\n\ndf_num = lambda xnum: df_par.subs( {x: xnum} ) \n\n\nЧисленным методом найдем значение x, при котором производная обращается в 0. Для этого используем функцию root модуля scipy.optimize, передав этой функции имя лямбда-функции и начальное приближение \\(x_0 = 5\\):\n\nsol = optimize.root(df_num, 5.0)\n\n\nРезультатом будет следующее значение \\(x\\):\n\n&gt;&gt; sol.x\n\narray([8.6777724])\n\n\n",
      "categories": ["programming","python","mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/programming/python/mechanics/2019-06-09-sympy/"
    },{
      
      "title": "Плоская модель сети",
      "date": "2019-06-30 00:00:00 -0500",
      
      "content": "Код простейшей модели взаимодействия сети с твердым телом, например, при улавливании створки головного обтекателя сетью, как это пытается делать компания SpaceX.\n\nМодель плоская. Cтворка описывается выпуклым многоугольником, а сеть представлена системой материальных точек, соединённых невесомыми пружинками с заданными коэффициентами жёсткости и демпфирования.\n\nИз выпускной квалификационной работы Савичевой А. С.\n\n\n",
      "categories": ["mechanics","programming"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/mechanics/programming/2019-06-30-net2D/"
    },{
      
      "title": "Модель движения наноспутника",
      "date": "2019-07-03 00:00:00 -0500",
      
      "content": "Пример использование языка программирования Python с библиотеками numpy, scipy, sympy, matplotlib для построения и интегрирования уравнений движения наноспутника формата кубсат внутри транспортно-пускового контейнера.\n\nСсылка на Jupyter-Notebook\n\n\n\n",
      "categories": ["programming","mechanics","python"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/programming/mechanics/python/2019-07-03-cubesat-python/"
    },{
      
      "title": "Движение механической системы с двумя степенями свободы",
      "date": "2019-07-29 00:00:00 -0500",
      
      "content": "Пример использование языка программирования Python с библиотеками numpy, scipy, sympy, matplotlib для построения и интегрирования уравнений движения механической системы с двумя степенями свободы.\n\nСсылка на Jupyter-Notebook\n\n",
      "categories": ["mechanics"],
      "tags": ["python"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2019-07-29-mech-python/"
    },{
      
      "title": "Модель физического маятника в Simulink",
      "date": "2019-08-01 00:00:00 -0500",
      
      "content": "Построение модели физического маятника в Simulink. Ссылка на Youtube видео\n\n",
      "categories": ["cae"],
      "tags": ["matlab","simulink"],
      
      "collection": "posts",
      "url": "/blog/cae/2019-08-01-simulink-pendulum/"
    },{
      
      "title": "Решение нестационарной задачи теплопроводности в MATLAB",
      "date": "2019-12-10 00:00:00 -0600",
      "description": "Использование модуля pde-toolbox для решения плоской нестационарной задачи теплопроводности.\n",
      "content": "Рассматривается нестационарная плоская задача теплопроводности. Пластина со сторонами \\(a = 0.4\\) м, \\(b+d=0.051\\) м нагревается в тонком слое толщиной \\(d=1\\) мм (на верхней грани) за счёт внутренних источников тепла. В слое в одну секунду генерируется 8 кДж тепла. Со всех граней пластины излучается тепло рассеивается по закону Стефана-Больцмана. Степень черноты материала пластины - 0.8.\n\n\n\nТемпература точек пластины \\(T(x,y,t)\\) есть функция времени и координат. Эта зависимость определяется дифференциальным уравнением в частных производных:\n\n[\\frac{\\partial T}{\\partial t} = k \\left( \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} \\right) + \\frac{q}{\\rho c_p}]\n\nгде\n\n  \\(k\\) – теплопроводность [Вт/(м\\(\\cdot\\)К)],\n  \\(\\rho\\) – плотность [кг/м\\(^3\\)],\n  \\(c_p\\) – удельная теплоёмкость [Дж/(кг\\(\\cdot\\)K)],\n  \\(q(x,y)\\) – функция внутренних источников тепла [Вт/(м\\(^3\\))].\n\n\nСоздаем модель, указывая тип задачи: нестационарная (transient) задача теплопроводности (thermal)\n\n% Нестационарная модель\nthermalModelT = createpde('thermal','transient');\n\n\n% Размеры пластины\na = 0.4;\nb = 0.05;\n% Толищина \"горячего\" слоя\nd = 0.001;\n\n% Описание геометрии: Прямоугольник\ng = decsg([3 4 -a/2 a/2 a/2 -a/2 0.00 0.00 b b;\n           3 4 -a/2 a/2 a/2 -a/2 b b b+d b+d]');\n\n% Модель\ngeometryFromEdges(thermalModelT,g);\n\n\nСвойства материала пластины\n\nk   = 50;   % теплопроводность\nrho = 7800; % плотность\ncp  = 468;  % удельная теплоёмкость\nthermalProperties(thermalModelT,'ThermalConductivity',k,'MassDensity',rho,'SpecificHeat',cp);\n\n\nГраничные условия\n\nДля корректного определения граничных условий необходимо увидеть геометрию тела с идентификаторами ребер (edges) и областей (faces).\n\npdegplot(thermalModelT,'EdgeLabels','on','SubdomainLabels','on');\naxis equal\n\n\n\n\nИдентификаторы ребер (E1, 2, 3, … 7) и областей (F1, F2) используются при задании граничных условий. Пластина излучает со всех своих ребер, степень черноты тела принята равной 0.8. Температура среды 4 К.\n\n% Постоянная Стефана-Больцмана\nthermalModelT.StefanBoltzmannConstant = 5.670373E-8; \n% Излучение со всех ребер\n% Степень черноты 0.8\n% Температура среды 4 К \nthermalBC(thermalModelT,'Edge',[1 2 4 5 6 7],'Emissivity',0.8,'AmbientTemperature', 4);\n\n\nВнутренний источник тепла в тонком слое на верхней границе тела (область F2). В этом слое генерируется \\(2 \\cdot 10^7 \\cdot 0.4 \\times 0.001 = 8\\) кДж в секунду. В общем случае, это может быть не число (\\(2 \\cdot 10^7\\)), а ссылка на функцию координат и времени.\n\ninternalHeatSource(thermalModelT,2e7,'Face',2);\n\n\nСоздание сетки\n\ngenerateMesh(thermalModelT,'Hmax',0.03);\npdeplot(thermalModelT); \naxis equal\ntitle 'Сетка'\n\n\n\n\nРасчёт\n\nЗапускаем расчёт на интервале от 0 до 3600 с с шагом 1 с.\n\ntfinal = 3600;\ntlist = 0:1:tfinal;\n\n% Начальная температура тела\nthermalIC(thermalModelT,273);\n\n% Вывести статистическую информацию решателя\nthermalModelT.SolverOptions.ReportStatistics  = 'on';\n\n% Решаем\nresult = solve(thermalModelT,tlist)\n\n\nРезультаты\n\nПосле выполнения функции solve в консоль MATLABа (Command Window) выводится следующая информация\n\n34 successful steps\n0 failed attempts\n49 function evaluations\n1 partial derivatives\n12 LU decompositions\n48 solutions of linear systems\n\n\nПостроим карту температуры пластины на момент времени t=3600 c. Решение получено в numel(tlist)) точках, поэтому распределение температуры в момент времени t=3600 c будет соответствовать самому последнему набору значений массива result.Temperature(:,sol_index), где sol_index будет равен numel(tlist) = 3601.\n\nsol_index = numel(tlist));\npdeplot(thermalModelT,'XYData',result.Temperature(:,sol_index),'Contour','on','ColorMap','hot'); \n% Покажем метки точек, для которых далее будут построены графики изменения температуры\nhold on;\n% Рисуем метки точек\nplot(0,0.000,'bo'); \nplot(0,0.051,'bo'); \n% Рисуем подписи точек\ntext(0,-0.010,'T2','FontSize',18);\ntext(0, 0.060,'T1','FontSize',18);\nhold off;\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nxlim([-0.25 0.25]);\nylim([-0.05 0.15]);\n\n\n\n\nГрафик изменения температуры на верхней и нижней грани пластины.\n\n% Генерируем матрицу размера numel(sol_index)x2 с температурами точек Т1 и Т2. \nprobeTemp = cell2mat(arrayfun(@(i) interpolateTemperature(result,[0.000 0.000],[0.051 0.000],i)',(1:length(tlist))','UniformOutput',false));\n% Первый график на интервале от 0 до 100 с\nsubplot(1,2,1);\nplot(tlist,probeTemp(:,1),'r-','LineWidth',2); hold on;\nplot(tlist,probeTemp(:,2),'b-','LineWidth',2); hold off;\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nlegend('T1','T2');\nxlabel('t, c');\nylabel('Температура, K');\nxlim([0,100]);\n% Второй график на всем интервале от 0 до 3600 с\nsubplot(1,2,2);\nplot(tlist,probeTemp(:,1),'r-','LineWidth',2); hold on;\nplot(tlist,probeTemp(:,2),'b-','LineWidth',2); hold off;\n%plot(tlist,probeTemp(:,2)-probeTemp(:,1),'b-','LineWidth',2);\nset(gca,'FontSize',14,'LineWidth',1);grid on;\nlegend('T1','T2');\nxlabel('t, c');\nylabel('Температура, K');\n\n\n\n\nНиже на видео показана динамика изменения температуры. Стрелками показаны направления тепловых потоков. Показана температура на верхней грани, нижней грани и разница температур. Для построения видео использовался следующий код\n\nv = VideoWriter('temperature.avi');\nopen(v);\n% Фигура\nfigure('Position',[100 100 1920 1080]);\nhold on;\n% Для каждого момента времени из таблицы результатов интегрирования\n[qTx,qTy] = evaluateHeatFlux(result);\nfor i=1:5:size(tlist,2)\n    % Очищаем рисунок\n    cla;\n    %[qTx,qTy] = evaluateHeatFlux(result,0.2,0.05,1:length(tlist));    \n    pdeplot(thermalModelT,'XYData',result.Temperature(:,i),'Contour','on', ...\n                     'FlowData',[qTx(:,i) qTy(:,i)], ...\n                     'ColorMap','hot','Levels',3);        \n    axis([-0.25 0.25,-0.05, 0.15]);    \n    % Определим температуру в двух точках [0,0] и [b+d, 0]\n    % координаты точек задаются двумя массивами координат x и y\n    % [x1, x2, x3, ...], [y1, y2, y3, ...]\n    Temp = interpolateTemperature(result,[0 0],[b+d 0],i);\n    text(0,-0.010,sprintf('%5.1f',Temp(2)),'FontSize',20);\n    text(0,+0.060,sprintf('%5.1f',Temp(1)),'FontSize',20);    \n    % Разница температур\n    text(0,-0.03,sprintf('dT = %5.1f',Temp(1)-Temp(2)),'FontSize',20);    \n    % Время\n    text(-0.2, 0.12,sprintf('t = %5.1f', tlist(i)),'FontSize',20);\n    % Шрифт для подписей осей\n    set(gca,'FontSize',20);\n    % Сетка\n    grid on;   \n    frame = getframe(gcf);    \n    writeVideo(v,frame);\nend\nclose(v);\n\n\n\n\n",
      "categories": ["cae"],
      "tags": ["matlab","термодинамика"],
      
      "collection": "posts",
      "url": "/blog/cae/2019-12-10-pde-thermal/"
    },{
      
      "title": "Модель отделения створки головного обтекателя",
      "date": "2020-03-10 00:00:00 -0500",
      "description": "Интегрирование уравнений движения совместно с уравнениями связей на примере модели движения створки головного обтекателя ракеты-носителя\n",
      "content": "Движение створки головного обтекателя ракеты-носителя\n\nГоловной обтекатель отделяется от ракеты-носителя после того, как ракета-носитель набрала высоту, на которой действие набегающего потока разреженного воздуха уже невелико, что позволяет сбросить “лишнюю” массу головного обтекателя, который до этого момента защищал выводимый на орбиту космический аппарат при движении ракеты-носителя в плотных слоях атмосферы. Существует несколько способов отделения головного обтекателя. Далее рассматривается способ отделения с разделением обтекателя  на две створки и последующим их разворотом [2,3].\n\nСхема системы\n\nДля отделения головного обтекателя производится его механическое разделение на две створки, при этом каждая створка остается шарнирно-закрепленной на ракете-носителе. После этого начинается разворот створок под действием толкателей (по два на створку), каждый из которых закреплен одним концом на створке, а другим – упирается в переходный отсек ракеты-носителя. Толкатели создают момент относительно оси вращения створки, разворачивая её относительно ракеты. При достижении некоторого угла (более 45 градусов) шарнирная связь между створкой и ракетой-носителем разрывается и створка продолжает свободное движение.\n\n\n\nСистемы координат\n\nПостроим модель отделения обтекателя с момента его разделения на две створки до свободного движения створок. Будем считать, что створка – это абсолютно-твердое тело с массой значительно меньшей массы ракеты-носителя, что позволять не учитывать влияние движения створки на движение ракеты-носителя. Будет рассматриваться плоское движение створки, полагая, что все силы действуют на створку в одной плоскости, перпендикулярной оси её вращения, проходящей через центр масс створки.\n\nПоскольку необходимо исследовать движение створки относительно ракеты, для записи уравнений движения удобней использовать неинерциальную систему координат \\(O x_0 y_0 z_0\\), которая связана с ракетной-носителем, движущейся с постоянным ускорением вдоль оси \\(O x_0\\). Также при записи уравнений движения будет использоваться система координат \\(C x_1 y_1 z_1\\), связанная со створкой.\n\n\n\nУравнения движения\n\nДля записи уравнений систем многих тел для получения компактных уравнений движения целесообразно использовать матричную форму записи, которую потом легко перевести на языки компьютерной алгебры. Рассматриваемая механическая система простая и имеет небольшое число степеней свободы. Так при плоском движении на первом этапе движения (этапе разворота) створка имеет одну степень свободы относительно ракеты-носителя, на втором этапе – этапе свободного движения – три степени свободы. Для записи уравнений движения можно использовать уравнения Лагранжа, чтобы получить минимальное количество уравнений движения, но здесь для записи уравнений будут использованы уравнения движения центра масс и уравнения движения вокруг центра масс с учетом действия на створку силы реакции в шарнире. Уравнения движения створки будут решаться совместно с уравнениями связей. Такой подход позволит на всех этапах движения системы  использовать один набор обобщенных координат: положение центра масс и поворот створки, а также определить в процессе интегрирования уравнений движения силы реакции связей в шарнире створки.\n\nУравнение движения центра масс створки\n\nВ системе координат \\(O x_0 y_0 z_0\\) движение центра масс створки описывается одним матричным уравнением, которому соответствует три скалярных уравнения\n\n[m \\ddot{\\boldsymbol{r}}^{(0)} = \\boldsymbol{P}^{(0)} + \\boldsymbol \\Phi^{(0)} + \\boldsymbol{R}^{(0)}]\n\nгде \\(\\boldsymbol{P}^{(0)}\\) – координатный столбец вектора силы толкателя, \\(\\boldsymbol \\Phi^{(0)}\\) – координатный столбец переносной силы инерции, \\(\\boldsymbol R^{(0)}\\) – координатный столбец силы реакции в шарнире. Верхним индексом в круглых скобках обозначается то, что координатные столбцы векторов в уравнении записаны в системе координат \\(O x_0 y_0 z_0\\). В неинерциальной системе координат к активным силам и силам реакции необходимо добавить переносную силу инерции, направленную вдоль продольно оси ракеты-носителя. Координатный столбец переносной силы инерции определяется следующим образом:\n\n[\\boldsymbol \\Phi^{(0)} = - \\begin{bmatrix} 1 \\ 0 \\ 0 \\end{bmatrix} m g n_x]\n\nгде \\(m\\) – масса створки, \\(g\\) – ускорение свободного падения, \\(n_x\\) – перегрузка, с которой движется ракета-носитель, которая определяет “действующую” на створку переносную силу инерции в неинерциальной системе координат \\(O x_0 y_0 z_0\\)\n\nСила толкателя, действующего на створку, пропорциональна расстоянию между точками \\(P_0\\) и \\(P_1\\) и направлена вдоль вектора \\(P_0 P_1\\). Обозначим это вектор буквой \\(d\\). В системе координат \\(O x_0 y_0 z_0\\) этот вектор определяется следующим образом\n\n[\\boldsymbol d^{(0)} = - r_{p0}^{(0)} + r^{(0)} + \\boldsymbol{A}1 \\boldsymbol{\\rho}{p1}^{(1)}]\n\nРассматривается плоское движение створки, поэтому действие двух толкателей на створку можно заменить действием одного толкателя с силой равной суммарной силе двух толкателей. Обозначим как \\(\\boldsymbol{e}_P\\) единичный вектор, вдоль которого действует сила толкателя P\n\n\n  \n    \n      [\\boldsymbol{e}_P^{(0)} = \\frac{\\boldsymbol d^{(0)}}{\n      \\boldsymbol d^{(0)}\n      },]\n    \n  \n\n\nтогда координатный столбец силы, действующей на створку, в системе координат \\(O x_0 y_0 z_0\\) будет иметь вид\n\n[\\boldsymbol{P}^{(0)} = \\boldsymbol{e}_P^{(0)} P(d),]\n\nгде \\(P(d)\\) зависимость силы толкателя от его длины (перемещения штока). Сила пружинного толкателя линейно зависит перемещения штока:\n\n[P(d) = P_0 + \\frac{P_0-P_K}{h} (d-d_0)]\n\nгде \\(P_0\\) - начальное усилие толкателя (двух толкателей в рассматриваемой плоской задачи), \\(P_K\\) - конечное усилие толкателя (это также суммарная сила от действия двух толкателей), \\(d_0\\) - начальная длина толкателя (расстояние от точки \\(p_0\\) до \\(p_1\\) ), \\(h\\) - ход толкателя.\n\n\n\nУравнение движения вокруг центра масс\n\nДвижение створки вокруг центра масс описывается динамическим уравнением Эйлера, которые в матричной форме в системе координат, связанной со своркой, имеют вид:\n\n[\\boldsymbol{J}^{(1)} \\dot{\\boldsymbol{\\omega}}^{(1)} + \\boldsymbol{\\omega}^{(1)} \\times \\boldsymbol{J}^{(1)} \\boldsymbol{\\omega}^{(1)} = \\boldsymbol{M}^{(1)}(P) + \\boldsymbol{M}^{(1)}(R)]\n\nВ правой части уравнений движения вокруг центра масс момент от силы толкателя и момент от силы реакции \\(\\boldsymbol{R}\\). Момент от силы толкателя в системе координат, связанной со створкой  записывается следующим образом:\n\n[\\boldsymbol{M}^{(1)}(P) = \\tilde{\\boldsymbol{r}}_{p1}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{P}^{(0)}]\n\nЗдесь и далее оператор тильда обозначает кососимметричную матрицу, записанную из компонент координатного столбца вектора\n\n[\\tilde{\\boldsymbol{a}} = \\begin{bmatrix} 0 &amp; - a_z &amp; a_y \\ a_z &amp; 0 &amp; - a_x \\ - a_y &amp; a_x &amp; 0 \\end{bmatrix}]\n\nКососимметричная матрица используется для матричной записи векторного произведения двух координатных столбцов векторов\n\n[\\boldsymbol{a} \\times \\boldsymbol{b} = \\tilde{\\boldsymbol{a}} \\boldsymbol{b} = - \\tilde{\\boldsymbol{b}} \\boldsymbol{a}]\n\nМомент от силы реакции относительно центра масс створки:\n\n[\\boldsymbol{M}^{(1)}(R) = \\tilde{\\boldsymbol{c}}_{11}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{R}^{(0)}]\n\nС учётом полученных выражений для моментов, уравнение движения вокруг центра масс принимает вид\n\n[\\boldsymbol{J}^{(1)} \\dot{\\boldsymbol{\\omega}}^{(1)} = \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{P}^{(0)} + \\tilde{\\boldsymbol{c}}{11}^{(1)} \\boldsymbol{A}_1^T \\boldsymbol{R}^{(0)} - \\boldsymbol{\\omega}^{(1)} \\times \\boldsymbol{J}^{(1)} \\boldsymbol{\\omega}^{(1)}]\n\nВ уравнения движения центра масс и движения вокруг центра масс входят неизвестные силы реакции, которые можно определить, дополнив полученные уравнения движения уравнениями связей.\n\nУравнения связей\n\nПоложение шарнирной точки, связанной со створкой, в системе координат \\(O x_0 y_0 z_0\\) определяется суммой вектора положения центра масс створки и положения шарнирной точки створки относительно центра масс \\(\\mathbf{r}_1^{(0)} + \\mathbf{A}_1 \\mathbf{c}_{11}^{(1)}\\). Матрица поворота или матрица преобразования координат используется в этом выражении для преобразования координат вектора \\(\\mathbf{c}_{11}^{(1)}\\) из системы координат, связанной со створкой в систему координат \\(O x_0 y_0 z_0\\). Система координат, связанная со створкой \\(C_1 x_1 y_1 z_1\\), повёрнута относительно системы координат \\(O x_0 y_0 z_0\\) на угол \\(\\varphi\\) вокруг оси \\(z_0\\), поэтому матрица поворота имеет простой вид\n\n[\\mathbf{A}_1 = \\begin{bmatrix} \\cos \\varphi &amp; -\\sin \\varphi &amp; 0 \\ \\sin \\varphi &amp; \\cos \\varphi &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}]\n\nШарнирная точка створки должна совпадать с соответствующей шарнирной точкой на ракете-носителе, положение которой относительно  \\(O x_0 y_0 z_0\\) определяется неизменным координатным столбцом \\(\\mathbf{c}_{01}^{(0)}\\), поэтому\n\n[\\mathbf{c}{01}^{(0)} = \\mathbf{r}_1^{(0)} + \\mathbf{A}_1 \\mathbf{c}{11}^{(1)}]\n\nПолученное уравнение представляет собой уравнение связи, которое говорит о том, что створка и ракета-носитель в процессе движения имеют одну общую точку – шарнирную точку. При развороте створки относительно шарнира ограничивается и угловое движение створки как твёрдого тела относительно двух других осей, перпендикулярных оси шарнира, однако если на створку действует плоская система сил, лежащая в плоскости \\(O x_0 y_0 z_0\\), в которой также находится и центр масс створки, то дополнительные уравнения связей можно не записывать.\n\nДля интегрирования дифференциальных уравнений движения совместно с алгебраическими уравнениями связей, обычно используют следующую технику решения, которая позволят использовать для интегрирования уравнений движения “стандартные” численные методы решения обыкновенных дифференциальных уравнений. Уравнения связей дважды дифференцируют для получения уравнений связей на  ускорения. Учитывая постоянство координатных столбцов \\(\\mathbf{c}_{11}^{(1)}\\) и \\(\\mathbf{c}_{01}^{(0)}\\), после первого дифференцирования уравнения связи получим:\n\n[\\mathbf{0} = \\mathbf{v}1^{(0)} + \\dot{\\mathbf{A}}_1 \\mathbf{c}{11}^{(1)}]\n\nПроизводная матрицы поворота определяется выражением [1]:\n\n[\\dot{\\mathbf{A}}_1 = \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)}]\n\nгде \\(\\tilde{\\mathbf{\\omega}}_1^{(1)}\\) – кососимметрическая матрица, составленная из компонент вектора угловой скорости створки в проекциях на оси системы координат, связанной со створкой\n\n[\\tilde{\\mathbf{\\omega}}_1^{(1)} = \\begin{bmatrix} 0 &amp; - \\omega_z^{(1)} &amp; \\omega_y^{(1)} \\ \\omega_z^{(1)} &amp; 0 &amp; - \\omega_x^{(1)} \\ - \\omega_y^{(1)} &amp; \\omega_x^{(1)} &amp; 0 \\end{bmatrix}]\n\nС учётом последнего выражения, матричное уравнение связи примет вид\n\n[\\mathbf{0} = \\mathbf{v}1^{(0)} + \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nЭто уравнение, в отличие исходного уравнения связи, уже говорит о том, что не положения, а скорости общих точек створки и ракеты-носителя должны совпадать. При условии того, что начальные условия будет удовлетворять исходному уравнению связи и при точном интегрировании уравнений движения исходное уравнение связи тоже будет выполняться, однако вследствие неизбежной погрешности численного интегрирования возможен так называемый “дрейф” связи – нарушение исходного уравнения связи и удаление шарнирных на створке и ракете-носителе друг от друга. В рассматриваемой задаче, учитывая небольшой интервал времени, на котором рассматривается движение системы, эта погрешность будет мала при разумном выборе точности интегрирования системы дифференциальных уравнений.\n\nПосле второго дифференцирования уравнение связи принимает вид\n\n[\\mathbf{0} = \\mathbf{a}1^{(0)} + \\mathbf{A}_1 \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)} + \\mathbf{A}1 \\tilde{\\boldsymbol{\\varepsilon}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nПолученное уравнение связи требует, чтобы ускорения общих точек створки и ракеты-носителя были одинаковы в процессе интегрирования уравнений движения. Начальные условия должны удовлетворять исходному уравнению связи и уравнению связи, записанному для скоростей точек.\n\nПерепишем уравнение связи, выделив матрицу коэффициентов перед ускорениями, используя тождество \\(\\tilde{\\mathbf a} \\mathbf b = - \\tilde{\\mathbf b} \\mathbf a\\)\n\n[\\mathbf{0} = \\mathbf{a}1^{(0)} + \\mathbf{A}_1 \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)} - \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} \\boldsymbol{\\varepsilon}_1^{(1)}]\n\nСобрав из линейных и угловых ускорений створки столбец \\(6 \\times 1\\), запишем это уравнение в блочном матричном виде\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; - \\mathbf{A}_1 \\tilde{\\mathbf{c}}{11}^{(1)} \n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \n    \\end{bmatrix}\n    = - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\boldsymbol{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}]\n\nСистема дифференциально-алгебраических уравнений в матричном виде\n\nЭтап 1\n\nОбъединив уравнения движения и уравнения связи в одно блочное матричное уравнение, получим для первого этапа движения (вращение створки)\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T\n        \n        \\mathbf{E}{3 \\times 3} &amp; - \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} &amp; \\mathbf{0}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}_1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nПоскольку\n\n[(\\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)})^T  = - \\tilde{\\mathbf{c}}_{11}^{(1)} \\mathbf{A}_1^T,]\n\nс точностью до знака полученная матрица коэффициентов является симметричной. Умножив уравнение связи на минус 1, получим симметричную матрицу коэффициентов\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T\n        \n        - \\mathbf{E}{3 \\times 3} &amp; \\mathbf{A}1 \\tilde{\\mathbf{c}}{11}^{(1)} &amp; \\mathbf{0}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}_1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nСтруктура этой системы дифференциально-алгебраических уравнений следующая\n\n[\\begin{bmatrix} \\boldsymbol{M} &amp; \\boldsymbol{Q}^T \n    \\boldsymbol{Q}^T &amp; \\boldsymbol{0} \n    \\end{bmatrix} \\begin{bmatrix} \\ddot{\\boldsymbol{X}} \\ \\boldsymbol{R} \\end{bmatrix}=\n    \\begin{bmatrix}\n    \\boldsymbol{L} \\ \\boldsymbol{B}\n    \\end{bmatrix}]\n\nЭту систему можно представить в виде двух матричных уравнений\n\n[\\begin{aligned}\n    \\boldsymbol{M} \\ddot{\\boldsymbol{X}} + \\boldsymbol{Q}^T \\boldsymbol{R} = \\boldsymbol{L} \n    \\boldsymbol{Q}^T \\ddot{\\boldsymbol{X}} = \\boldsymbol{B} \n    \\end{aligned}]\n\nВыразив из первого уравнения \\(\\ddot{\\boldsymbol{X}}\\)\n\n[\\ddot{\\boldsymbol{X}} = \\boldsymbol{M}^{-1} ( \\boldsymbol{L} - \\boldsymbol{Q}^T \\boldsymbol{R} )]\n\nи подставив во второе уравнение, получим систему линейный уравнений для определения сил реакций\n\n[(\\boldsymbol{Q}^T \\boldsymbol{M}^{-1} \\boldsymbol{Q}^T) \\boldsymbol{R}  = \\boldsymbol{Q}^T \\boldsymbol{M}^{-1}  \\boldsymbol{L} - \\boldsymbol{B},]\n\nчто позволяет найти столбец ускорений\n\n[\\ddot{\\boldsymbol{X}} = \\boldsymbol{M}^{-1} (\\boldsymbol{L} - \\boldsymbol{Q}^T  (\\boldsymbol{Q}^T \\boldsymbol{M}^{-1} \\boldsymbol{Q}^T)^{-1} (\\boldsymbol{Q}^T \\boldsymbol{M}^{-1}  \\boldsymbol{L} - \\boldsymbol{B}) )]\n\nЭтап 2\n\nНа втором этапе движения механическая связь между створкой и ракетной-носителем отсутствует. Для учёта этого уравнение связи можно заменить на матричное уравнение (три скалярных уравнения)\n\n[\\mathbf{R}^{(0)} = 0]\n\nтогда, система уравнений примет вид\n\n[\\begin{bmatrix}\n        \\mathbf{E}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3} &amp; - \\mathbf{E}{3 \\times 3}\n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{J}1 &amp; - \\tilde{\\mathbf{c}}{11}^{(1)} \\mathbf{A}1^T \n        \n        \\mathbf{0}{3 \\times 3} &amp; \\mathbf{0}{3 \\times 3}  &amp; \\mathbf{E}{3 \\times 3}\n    \\end{bmatrix}\n    \\begin{bmatrix}\n        \\mathbf{a}1^{(0)}  \\ \\boldsymbol{\\varepsilon}_1^{(1)} \\ \\mathbf{R}^{(0)} \n    \\end{bmatrix}\n    = \n    \\begin{bmatrix}\n    \\boldsymbol{P}^{(0)} + \\boldsymbol{F}^{(0)} \n    \\tilde{\\boldsymbol{r}}{p1}^{(1)} \\boldsymbol{A}1^T \\boldsymbol{P}^{(0)} \n    - \\mathbf{A}_1 \\tilde{\\mathbf{\\omega}}_1^{(1)} \\tilde{\\mathbf{\\omega}}_1^{(1)} \\mathbf{c}{11}^{(1)}\n    \\end{bmatrix}]\n\nКод\n\nПримеры кода на языках MATLAB и Python, реализующие описанный алгоритм.\n\nКод на языке MATLAB\n\nФайл-скрипт main.m\n\n\nclc; clear all;\n% Положение шарнирной точки отчносительно центра масс створки с ССК\np.c11 = [-4.0;  1.0; 0.0];\n% Положение точки закрепления толкателя на створке относительно центра масс\n% створки в ССК\np.rp1 = [-3.5; -0.8; 0.0];  \n% Положение точки закрепления толкателя на РН относительно БСК\np.rp0 = [ 0.0;  0.2; 0.0];  \n% Ускорение свободного падения\np.g   = 9.807;            \n% Начальное усиле толкателей\np.P0  = 30000;            \n% Конечное усилие толкателей\np.Pk  = 10000;            \n% Ход толкателя\np.h   = 0.4;   \n% Начальная длина толкателя\np.d0  = 0.5;\n% Масса створки\np.m   = 1000;  \n% Тензор инерции створки\np.J   = diag([10000,10000,10000]);            \n%\np.phimax   = 60;            \n\n% Начальные условия\nq0 = [4.0; 1.0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]; \n% Первый этап\np.Stage = 1;\nopt = odeset('Events', @(t,q) PhiEvent(t,q,p));\n[t1,q1] = ode45(@(t, q) dqdt(t, q, p), 0:0.02:2, q0, opt);\n% Второй этап\np.Stage = 2;\n[t2,q2] = ode45(@(t, q) dqdt(t, q, p), [t1(end):0.02:3], q1(end, :)');\n% Склейка результатов двух этапов\nt = [t1(1:end - 1); t2];\nq = [q1(1:end - 1, :); q2];  \n\n\nФайл-функция правых частей дифференциальных уравнений dqdt.m\n\nfunction [dq, R]= dqdt(t, q, p)\n% Извлекаем компоненты из вектора состояния\n% Координатный столбцец центра масс\nr   = q(1:3);     \n% Углы поворота створки\n% в плоской задаче испольуется только последний, а остальные принимаются\n% равными нулю\nphi = q(4:6); \n% Координатный столбец скорости центра масс створки в СК РН\nv   = q(7:9); \n% Координатный столбец угловой скорости\nw   = q(10:12);       \n% в плоской задаче испольуется только последнее значение - wz, а остальные принимаются\n% равными нулю\nwz  = w(3);\n\n% Этап движения \nStage = p.Stage;\n% Матрица поворота вокруг оси z\nA     = @(a) [cos(a), -sin(a) 0; sin(a), cos(a), 0;0 0 1];\n% Оператор тильда\ntilde = @(a) [0 -a(3) a(2); a(3) 0 -a(1); -a(2) a(1) 0];\n% Матрица поворота на угол phi вокруг оси z\nA1    = A(phi(3));\n\n% Матрица коэффиицентов при ускорениях в уравнениях связей, ограичивающих\n% перемещение шарнирной точки\nQ     = - A1*tilde(p.c11);\n% Матрица коэффициентов при реакциях в уравнении движения створки вокруг\n% центра масс\nQT    = - tilde(p.c11)*A1';\n\n% Вектор от точки закрепления толкателя на РН до точки закрепления\n% толкателя на створке\nd     = - p.rp0 + r + A1*p.rp1;\n% Модуль этого вектора\nnd    = norm(d);\n% Единичный вектор этого напарвления  \ned    = d/nd;\n\n% Если длина толкателя не больше его начальной длины и хода\n% вычисляем силу\nif nd &lt; p.d0 + p.h\n   Pin0 = ed*(p.P0 - (p.P0-p.Pk)*(nd-p.d0)/p.h );    \n% иначе, толкатель уже не работает\nelse\n   Pin0 = [0;0;0]; \nend\n% Координатный столбец силы в ССК створки\nPin1          = A1'*Pin0;\n% Координатный столбец силы инерции в СК РН (вдоль продольной оси)\nInertialForce = [-1;0;0]*p.m*p.g;\n\nE3 = eye(3);\nZ3 = zeros(3);\n\nif Stage == 1\n    % Матрица коэффициентов для первого этапа \n    M = [p.m*E3   Z3 -E3; \n             Z3  p.J -QT; \n             E3  Q    Z3];\nend\nif Stage == 2\n    % Матрица коэффициентов для второго этапа \n    % Реакции равны нулю\n    M = [p.m*E3   Z3  E3; \n             Z3  p.J -QT; \n             Z3   Z3  E3];\nend\n\n% Матрица-столбец правой части ДАУ\nB = [Pin0 + InertialForce; \n     tilde(p.rp1)*Pin1;\n     -A1*tilde(w)*tilde(w)*p.c11];\n\n% Находим ускорения и реакции  \nX = M\\B;                            \n\nR = X(7:9);\n\n% Кинематические уравнения для плоского движения \n% Производня последнего угла равна угловой скорости, остальные компоненты\n% равны нулю\ndphi = [0;0;wz];\n\n% Производня вектора состояния\ndq = [v; dphi; X(1:6)];                \n\nend\n\n\nФайл-функция событий системы дифференциальных уравнений dqdt.m\n\nФайл-функция событий передается в качестве параметра в функцию интегрирования дифференциальных уравнений и предназначена для остановки процесса интегрировании при заданном условии, которое задается функцией, изменяющей знак. В рассматриваемой задаче такой функцией будет угол поворота створки.\n\n\nfunction [Value, isterminal, direction] = PhiEvent(t, q,p)\n    \n    % Если угол поврота превышает phimax...\n    Value = q(6)-deg2rad(p.phimax);     \n    % при увеличении угла, \n    direction = 1;                       \n    % то остановить интегрирование\n    isterminal = 1;                     \n\nend\n\n\n\n\nКод на языке Python\n\nВес код программы можно разместить в одном файле. Удобно для решения подобных задач использовать Jupyter notebook\n\n\n# Массивы, матрицы\nimport numpy as np\n# Для численного интегрирования дифференциальных уранвений\nfrom scipy.integrate import solve_ivp\n\n# Для построения графиков\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n# Настройки графиков по умолчанию\nimport matplotlib.pylab as pylab\nparams = {'legend.fontsize': 14, 'figure.figsize': (10, 7), 'axes.labelsize': 14,\n         'axes.titlesize':14, 'xtick.labelsize':14,'ytick.labelsize':14}\npylab.rcParams.update(params)\n\n# Для передачи параметров в функцию объеденим их в структуру namedtuple\nfrom collections import namedtuple\n\n\n\n\n# Параметры системы\nParameters = namedtuple('Parameters' , 'm J c11 c01 rp0 rp1 d0 h P0 PK nx g phimax')\n\nparam1 = Parameters(m=1000.0, \n                    J=np.diag([5000,10000,10000.]), \n                    c11 = np.array([-4.0, 1.0, 0.0]),\n                    c01 = np.array([ 0.0, 2.0, 0.0]),                    \n                    rp0 = np.array([ 0.0, 0.4, 0.0]),\n                    rp1 = np.array([-3.5,-0.6, 0.0]),\n                    d0  = 0.5,\n                    h   = 0.4,\n                    P0  =  50000,\n                    PK  =  40000,\n                    nx  = 1.0,\n                    g   = 9.807,\n                    phimax = np.deg2rad(50))\n\n\nФункции матрицы поворота и оператор тильда\n\n\n# Матрица 0 3x3\nZ3 = np.zeros((3, 3))\n\n# Единичная матрица 3x3\nE3 = np.identity(3)\n\n# Матрица поворота  \ndef Az(a):  \n  return np.array([[np.cos(a), -np.sin(a), 0],[np.sin(a), np.cos(a), 0],[0, 0, 1.0]]);\n\n# Тильда\ndef tilde(a):  \n  return np.array([[     0, -a[2],  a[1] ], \n                   [  a[2],     0, -a[0] ],\n                   [ -a[1],  a[0],    0  ] ])\n\n\nФункция правых частей системы дифференциальных уравнений.\n\n\ndef dqdt(t,q,p):  \n  # координатный столбец центра масс  \n  r   = q[0:3]\n  # углы поворота створки\n  a   = q[3:6]\n  # в рассматриваемой плоской задаче \n  # используется только один - последний из трёх\n  phi = a[2]  \n  # координатный столбец скорости центра масс  \n  v   = q[6:9]\n  # координатный столбец угловой скорости створки  \n  w   = q[9:12]\n\n  # Вычисляем матрицу поворота для текущего значения угла\n  A1 = Az(phi)\n\n  # Коэффициенты при ускорениях в уравнениях связей\n  Q = np.dot(A1, tilde(p.c11))\n  \n  # Переносная сила инерции\n  F  = np.array([-1,0,0])*p.m*p.g*p.nx\n  \n  # Вектор p0p1\n  d  = -p.rp0 + r + np.dot(A1,p.rp1)\n  # Длина вектора\n  dn = np.sqrt(np.dot(d,d))\n  # Едичиный вектор направления силы в базисе x0y0z0\n  eP = d/dn\n  \n  # Сила толкателя  \n  P  = 0*eP\n\n  if dn&lt;p.d0+p.h:\n    P  = (p.P0 + (dn-p.d0)*(p.P0-p.PK)/p.h)*eP \n    \n\n  # Матрица коэффициентов\n  A = np.block([[E3*p.m,  Z3,             -E3],\n                [Z3    , p.J, np.transpose(Q)],\n                [-E3   ,   Q,              Z3]])\n\n  if STAGE == 2:\n    # Матрица коэффициентов\n    A = np.block([[E3*p.m,  Z3,             -E3],\n                  [Z3    , p.J, np.transpose(Q)],\n                  [Z3    ,   Z3,             E3]])\n  \n    # Матрица правой части\n  B = np.block([ F + P, \n                -np.cross(w,np.dot(p.J,w)) + np.cross(p.rp1, np.dot(np.transpose(A1),P)),\n                 np.dot(np.dot(A1,np.dot(tilde(w),tilde(w))),p.c11)])\n\n  X = np.linalg.solve(A,B)\n\n  dq = np.block([v,w,X[0:6]])\n  \n  return dq\n\n\n\nФункция-“детектор”, передаваемая в интегратор (параметр events), для определения времени перехода от этапа 1 к этапу 2 и остановки процесса интегрирования функция возвращает разницу между углом потери связи и текущим углом\n\n\ndef event_phi_eq_phimax(t, q):\n  return param1.phimax-q[5]\n\n# функция-детектор останавливает процесс интегрирование\nevent_phi_eq_phimax.terminal = True\n# при пересечении функции нуля при убывании\nevent_phi_eq_phimax.direction = -1.0\n\n\n\nЗапускаем процесс интегрирования\n\n\nq0 = [4, 1, 0,  0, 0, 0,  0, 0, 0, 0, 0, 0];\n\nSTAGE = 1\ns1 = solve_ivp(lambda t, y: dqdt(t, y, param1), [0, 1.5], q0,  \n               events = [event_phi_eq_phimax],  rtol = 1e-7, max_step=0.1)\n\n\nSTAGE = 2\n\nq1 = s1.y[:,-1]\ns2 = solve_ivp(lambda t, y: dqdt(t, y, param1), [s1.t[-1], 2], q1, rtol = 1e-6, max_step=0.1)\n\n\n\nГрафик изменения угла и угловой скорости створки\n\n\nplt.plot(s1.t,s1.y[5]*180/np.pi,'r-')\nplt.plot(s2.t,s2.y[5]*180/np.pi,'r--')\nplt.plot(s1.t,s1.y[11]*180/np.pi,'b-')\nplt.plot(s2.t,s2.y[11]*180/np.pi,'b--')\nplt.xlabel('t, c'), plt.ylabel('$\\\\varphi$, $\\\\omega$');\nplt.grid(ls='--'), plt.legend(['$\\\\varphi$ Этап 1','$\\\\varphi$ Этап 2']);\n\n\n\nИсточники\n\n\n  Маркеев А. П.  Теоретическая механика: Учебник для университетов. 3-е изд. — М.; Ижевск: РХД, 2007. — 592 с.\n  Колесников К.С., Кокушкин В.В., Борзых С.В., Панкова Н.В. Расчет и проектирование систем разделения ступеней ракет: учебное пособие. М.: МГТУ им. Н.Э. Баумана. 2006. 376 с.\n  Круглов Г. Е. Аналитическое проектирование механических систем [Электронный ресурс] : учеб. пособие. Самарский государственный аэрокосмический университет им. С. П. Королева. 2000.\n\n",
      "categories": ["mechanics"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2020-03-10-fairing/"
    },{
      
      "title": "Уравнения Лагранжа II рода в Wolfram Mathematica",
      "date": "2020-04-10 00:00:00 -0500",
      "description": "Пример построения и интегрирования уравнений движения механической системы с двумя степенями свободы\n",
      "content": "Открыть пример\n",
      "categories": [],
      "tags": ["Mathematica","Механика"],
      
      "collection": "posts",
      "url": "/blog/2020-04-10-Mathematica-mech/"
    },{
      
      "title": "Игра Жизнь на SQL",
      "date": "2020-05-09 00:00:00 -0500",
      "description": "Реализации игры Жизнь на языке SQL.\n",
      "content": "В процессе подготовки материалов для очередной лекции по Базам данных студентов Института экономики и управления Самарского университета возникла идея реализовать алгоритм игры “Жизнь” на SQL.\n\nБаза данных состоит из двух таблиц: таблица cells с координатами клеток колонии, вместе с номером поколения, которому эти клетки принадлежат, и “константная” таблица относительных координат смежных клеток (dxdy). Алгоритм смены поколений записан в процедуре NextGen. При помощи объединения (UNION) результатов двух SELECT выбираются клетки, переходящие в следующее поколение (клетки c 2 или 3 соседями), и определяются рождающиеся клетки (граничащие ровно с 3 соседями). Результат с номером нового поколения вставляется в таблицу cells.\n\nПодробности…\n",
      "categories": [],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/2020-05-09-Game-of-Life-SQL/"
    },{
      
      "title": "Простая функция определения плотности воздуха",
      "date": "2020-05-19 00:00:00 -0500",
      
      "content": "Простая функция аппроксимирующая плотность воздуха в диапазоне высот от 0 до 100 км\n\n% Модель атмосферы в диапазоне от 0 до 100 км с погрешностью 1,5%\n% В. А. ЯРОШЕВСКИЙ \"АППРОКСИМАЦИЯ МОДЕЛИ СТАНДАРТНОЙ АТМОСФЕРЫ\"\n% Ученые записки ЦАГИ, т. XL, №3, 2009.\n%\n% density = rho(h)\n% Atmospheric density\n%   h [meters]\n%   density [kg/m^3]\nfunction density = rho(h)\n\na  = [-6.3759,-7.3012,-1.1817];\nb  = [-0.4754,-0.0096,-0.0068,-0.0120,0.0042];\nc  = [ 0.1803, 0.0872,-0.0153, 0.0145,0     ];\n\n\nx = (h*0.001)/50.0-1; \nsa = a(1) + a(2)*x + a(3)*x*x;\n\n%rho = sum(arrayfun(@(i) b(i)*cos(i*pi*x) + c(i)*sin(i*pi*x), 1:5));\nrho = 0;\nfor i=1:5\n    rho = rho + b(i)*cos(i*pi*x) + c(i)*sin(i*pi*x);\nend\n\ndensity = exp(sa + rho);\n\nend\n\n",
      "categories": ["programming","cae"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/programming/cae/2020-05-19-atm-density-matlab/"
    },{
      
      "title": "Пример построения сложного запроса к базе данных",
      "date": "2020-05-20 00:00:00 -0500",
      
      "content": "Составить запрос к базе данных, формирующий список производителей товаров, проданных до заданной даны во всех филиалах (магазинах), с указанием суммарной стоимости проданных товаров для каждого производителя.\n\nНачнём с простого запроса к таблице покупок. Выведем номер (идентификатор) покупки, дату и идентификатор покупателя – вся эта информация есть в таблице purchases:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id \nFROM \n\tpurchases \nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\n\n\nРезультат выполнения запроса, из которого следует, что до 30 января 2019 года (некоторая произвольно заданная дата) было совершено 7 покупок:\n\npurchase_id|purchase_date|customer_id|\n-----------|-------------|-----------|\n         12|   2019-01-24|          9|\n         32|   2019-01-25|          2|\n         37|   2019-01-10|          1|\n         46|   2019-01-06|         10|\n         60|   2019-01-24|          4|\n         75|   2019-01-06|          6|\n         83|   2019-01-29|          8|\n\n\nВ полученном результате отсутствует информация о товарах, которые были куплены в каждой покупке. Эта информация есть в таблице purchase_items – “купленные товары”.\n\nВ таблице purchase_items есть поле (столбец) purchase_id, который представляет собой ссылку на идентификатор покупки в таблице покупок purchases, т.е. purchase_items.purchase_id является внешним ключом.\n\nЧтобы увидеть список товаров для каждой покупки необходимо для каждой строки полученного выше результата, т.е. каждой покупки, найти и вывести соответствующую строку из таблицы purchase_items: нужно найти строки у которых purchase_items.purchase_id = purchases.purchase_id. Такое соединение двух таблиц выполняется при помощи оператора LEFT JOIN:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n    purchase_items.product_id\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\n\n\nВнешнее соединение LEFT JOIN: означает, что помимо строк, для которых выполняется условие предиката (ON УСЛОВИЕ), в результирующий набор попадут все остальные строки из первой таблицы (левой). При этом отсутствующие значения полей из правой таблицы будут заполнены NULL-значениями.\n\nВ рассматриваемом случае покупка не может не содержать списка товаров, поэтому для записи из левой таблицы purchases всегда найдётся хотя бы одно соответствие (товар) в правой таблице purchase_items.\n\nРезультат запроса\n\npurchase_id|purchase_date|customer_id|product_id|\n-----------|-------------|-----------|----------|\n         12|2019-01-24   |          9|         3|\n         32|2019-01-25   |          2|        11|\n         32|2019-01-25   |          2|        46|\n         37|2019-01-10   |          1|        35|\n         37|2019-01-10   |          1|        43|\n         46|2019-01-06   |         10|        19|\n         46|2019-01-06   |         10|        28|\n         46|2019-01-06   |         10|        30|\n         60|2019-01-24   |          4|        28|\n         60|2019-01-24   |          4|        47|\n         75|2019-01-06   |          6|        48|\n         83|2019-01-29   |          8|        21|\n\n\nВ полученном новом результате больше строк, чем первом запросе, поскольку некоторым покупкам соответствует несколько проданных товаров. Например, запись о покупке с номером 32  повторяется два раза, следовательно в таблице purchase_items нашлось две записи с таким номером и это означает, что в этой покупке было куплено 2 товара с номерами 11 и 46.\n\nНомер покупки 46 повторяется три раза, т.е. в рамках этой покупки было куплено 3 товара с номерами 19, 28 и 30.\n\nВ полученном результате больше информации, но она не наглядна, поскольку вместо имен покупателей, наименований товаров, указаны их номера. Для того чтобы увидеть вместо номера товара его наименование необходимо найти в таблице товаров имя, которой соответствует номеру товара в последнем запросе. Это делается также при помощи внешнего соединения LEFT JOIN  таблицы products с условием ON products.product_id = purchase_items.product_id:\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n-- Вместо идентификатора продукта выведем его имя из присоединенной таблицы товаров --\n    products.product_name\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\t\n\n\nРезультат\n\npurchase_id|purchase_date|customer_id|product_name                                 |\n-----------|-------------|-----------|---------------------------------------------|\n         12|2019-01-24   |          9|Ноутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|\n         32|2019-01-25   |          2|Швейная машина, оверлок Pfaff Expression 150 |\n         32|2019-01-25   |          2|Электрочайник Winner WR-126                  |\n         37|2019-01-10   |          1|Мультиварка Marta MT-1981                    |\n         37|2019-01-10   |          1|Микроволновая печь Daewoo KOR-8A4R           |\n         46|2019-01-06   |         10|Пылесос Redmond RV-350                       |\n         46|2019-01-06   |         10|Электрочайник Vitesse VS-118                 |\n         46|2019-01-06   |         10|Весы Unit UBS-2156                           |\n         60|2019-01-24   |          4|Электрочайник Vitesse VS-118                 |\n         60|2019-01-24   |          4|Весы Energy EN-426                           |\n         75|2019-01-06   |          6|Монитор HP V214a                             |\n         83|2019-01-29   |          8|Ноутбук HP ProBook 470 G5 [470G5 2UB59EA]    |\n\n\nДобавим к результату столбец производителя, выполнив LEFT JOIN с таблицей manufacturers по условию manufacturers.manufacturer_id = products.manufacturer_id\n\nSELECT \n\tpurchases.purchase_id,\n\tDATE(purchases.purchase_date,'unixepoch') as purchase_date,\n\tpurchases.customer_id, \n    products.product_name,\n--  Добавим имя производителя и назо    вем его для краткости brand --    \n    manufacturers.manufacturer_name as brand     \nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\t\n\n\nРезультат запроса\n\npurchase_id|purchase_date|customer_id|product_name                                 |brand  |\n-----------|-------------|-----------|---------------------------------------------|-------|\n         12|2019-01-24   |          9|Ноутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|HP     |\n         32|2019-01-25   |          2|Швейная машина, оверлок Pfaff Expression 150 |Pfaff  |\n         32|2019-01-25   |          2|Электрочайник Winner WR-126                  |Winner |\n         37|2019-01-10   |          1|Мультиварка Marta MT-1981                    |Marta  |\n         37|2019-01-10   |          1|Микроволновая печь Daewoo KOR-8A4R           |Daewoo |\n         46|2019-01-06   |         10|Пылесос Redmond RV-350                       |Redmond|\n         46|2019-01-06   |         10|Электрочайник Vitesse VS-118                 |Vitesse|\n         46|2019-01-06   |         10|Весы Unit UBS-2156                           |Unit   |\n         60|2019-01-24   |          4|Электрочайник Vitesse VS-118                 |Vitesse|\n         60|2019-01-24   |          4|Весы Energy EN-426                           |Energy |\n         75|2019-01-06   |          6|Монитор HP V214a                             |HP     |\n         83|2019-01-29   |          8|Ноутбук HP ProBook 470 G5 [470G5 2UB59EA]    |HP     |\n\n\nВ соответствии с заданием необходимо получить суммарную стоимость проданных товаров каждого производителя до заданной даты. Учитывая это исключим из запроса лишние для решения поставленной задачи столбцы, кроме наименования товара (для ясности) и добавим столбцы с ценой товара и количества. Информация для двух новых столбцов есть в первой присоединенной таблице purchase_items:\n\nSELECT \n    products.product_name,    \n    manufacturers.manufacturer_name as brand,\n    purchase_items.product_price,\n    purchase_items.product_count \nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER);\t\n\n\nРезультат выполнения запроса\n\nproduct_name                                 |brand  |product_price|product_count|\n---------------------------------------------|-------|-------------|-------------|\nНоутбук HP ENVY 13-ad000 [13-AD008UR 1WS54EA]|HP     |        54890|            1|\nШвейная машина, оверлок Pfaff Expression 150 |Pfaff  |        91850|            1|\nЭлектрочайник Winner WR-126                  |Winner |        818.4|            1|\nМультиварка Marta MT-1981                    |Marta  |       2855.6|            1|\nМикроволновая печь Daewoo KOR-8A4R           |Daewoo |       5481.3|            2|\nПылесос Redmond RV-350                       |Redmond|       5377.9|            1|\nЭлектрочайник Vitesse VS-118                 |Vitesse|       5149.1|            2|\nВесы Unit UBS-2156                           |Unit   |        647.9|            2|\nЭлектрочайник Vitesse VS-118                 |Vitesse|       5149.1|            1|\nВесы Energy EN-426                           |Energy |        625.9|            1|\nМонитор HP V214a                             |HP     |      22544.5|            2|\nНоутбук HP ProBook 470 G5 [470G5 2UB59EA]    |HP     |        60159|            2|\n\n\nПолучен список товаров с наименованием производителя каждого товара, цены товара и его количества, проданных до 30 января 2019 года. Если теперь исключить из результата первый столбцец, то получим список производителей проданных товаров\n\nbrand  |product_price|product_count|\n-------|-------------|-------------|\nHP     |        54890|            1|\nPfaff  |        91850|            1|\nWinner |        818.4|            1|\nMarta  |       2855.6|            1|\nDaewoo |       5481.3|            2|\nRedmond|       5377.9|            1|\nVitesse|       5149.1|            2|\nUnit   |        647.9|            2|\nVitesse|       5149.1|            1|\nEnergy |        625.9|            1|\nHP     |      22544.5|            2|\nHP     |        60159|            2|\n\n\nЧтобы найти суммарную стоимость проданных товаров каждого производителя необходимо сложить стоимость всех товаров каждого производителя (с учетом количества в последнем столбце). Для этого необходимо сгруппировать значения первого столбца или, другими словами, объеденить одинаковые значения в первом столбце, используя оператор GROUP BY, а к объединямым произведениям цены на количество применить агрегатную функцию SUM:\n\nSELECT \n    manufacturers.manufacturer_name as brand,\n    SUM(purchase_items.product_price*purchase_items.product_count) as total\nFROM \n\tpurchases \n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN purchase_items\n    ON purchase_items.purchase_id = purchases.purchase_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ purchase_items --\nLEFT JOIN products\n    ON products.product_id = purchase_items.product_id\n-- ВНЕШНЕЕ СОЕДИНЕНИЕ ТИПА LEFT JOIN ТАБЛИЦЫ manufacturers --\nLEFT JOIN manufacturers\n\tON manufacturers.manufacturer_id = products.manufacturer_id\nWHERE \n\tpurchases.purchase_date &lt; CAST(strftime('%s', '2019-01-30') AS INTEGER)\nGROUP BY\n\tbrand;\n\n\nРезультат\n\nbrand  |total             |\n-------|------------------|\nDaewoo |           10962.6|\nEnergy |             625.9|\nHP     |            220297|\nMarta  |            2855.6|\nPfaff  |             91850|\nRedmond|            5377.9|\nUnit   |            1295.8|\nVitesse|15447.300000000001|\nWinner |             818.4|\n\n\nНайдена суммарная стоимость проданных товаров каждого производителя до 30 января 2019 года.\n\nВопрос: Как нужно изменить запрос, чтобы выводилась информация для всех производителей, которые есть в базе данных с указанием нулевой суммы для тех производителей, товары которых не были проданы до 30 января 2020 года?\n",
      "categories": ["programming"],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/programming/2020-05-20-select-sql/"
    },{
      
      "title": "Создание множества баз данных и пользователей в MySQL",
      "date": "2021-02-22 00:00:00 -0600",
      
      "content": "В рамках курса “Базы данных” на кафедре ММЭ для выполнения лабораторных работ понадобилось запустить MySQL сервер и создать для каждого студента свою учетную запись и базу данных на сервере.\n\nДля формирования SQL-сценария для создания баз данных и пользователей использовался  bash-скрипт. В первой bash-скрипта части читается тектовый файл students.txt, в котором в одну колонку записаны номера зачетных книжек студентов в формате YYYY-NNNNN. Для каждого номера зачетной книжки генерируется пароль pwgen. Результат (номер пароль) записывается в текстовый файл userpass.txt.\n\n#!/bin/bash\n\nBTICK='`'\n\ncat /dev/null &gt; 'userpass.txt'\n\nwhile IFS=\" \" read -r USERNAME remainder\ndo      \n    PASSWORD=`pwgen 12 1`\n    echo $USERNAME $PASSWORD &gt;&gt; 'userpass.txt'\ndone &lt; \"students.txt\"\n\n\nВо второй части из файла userpass.txt читаются номера зачетных книжек и пароли, формируются имя пользователя uYYYY_NNNNN и база данных db_YYYY_NNNNN. SQL-скрипт создания базы данных и пользователя записывается в файл create_user_script.sql.\n\ncat /dev/null &gt; 'create_user_script.sql'\n\nwhile IFS=\" \" read -r UNAME UPASS remainder\ndo\n    UNAME=${UNAME//-/_}  \n    DBNAME=\"db_$UNAME\"\n    UNAME=\"u$UNAME\"\n    \n    Q1=\"CREATE DATABASE IF NOT EXISTS $DBNAME;\"\n    Q2=\"GRANT ALL ON ${BTICK}$DBNAME${BTICK}.* TO '$UNAME'@'%' IDENTIFIED BY '$UPASS';\"\n    echo $Q1 &gt;&gt; 'create_user_script.sql'\n    echo $Q2 &gt;&gt; 'create_user_script.sql'\ndone &lt; \"userpass.txt\"\n\necho 'FLUSH PRIVILEGES;' &gt;&gt; 'create_user_script.sql'\n\n",
      "categories": ["programming"],
      "tags": ["database"],
      
      "collection": "posts",
      "url": "/blog/programming/2021-02-22-mysql-add-multiple-users/"
    },{
      
      "title": "Навык Алисы для доступа к CelesTrak",
      "date": "2021-03-14 00:00:00 -0600",
      
      "content": "Сделал на платформе Яндекс.Диалоги голосовой интерфейс к каталогу космических запусков CelesTrak. Пока поиск выполняется только по каталогу с пусками за последние 30 дней.\n\nВозможности:\n\n\n  Поиск по имени: “Найди объект по имени Прогресс”\n  Поиск по SATID: “Найди объект 47720”\n  Поиск по высоте орбиты: “Найди объект с минимальной высотой 300 километров”, “Найди объект на орбите 300 километров”, “Найди объект с максимальной высотой 700 км”\n  Найди последний объект в базе\n  Уточнение параметра после первого запроса: “Какое наклонение?”, “Какой аргумент перигея?”, “Какая долгота восходящего узла?”\n\n\nЧто предполагается сделать:\n\n\n  Контроль изменений элементов орбиты выбранного объекта.\n  Использование других каталогов с CelesTrak.\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-03-14-alice-celestrak/"
    },{
      
      "title": "GLEX-2021",
      "date": "2021-06-20 00:00:00 -0500",
      
      "content": "Наши работы, представленные на GLEX-2021.\n\nПервая работа посвящена многофункциональной системе наддува, которая кроме наддува баков РН обеспечивает рабочим телом (газифицируя остатки топлива) систему газореактивных сопел для стабилизации отделившейся первой ступени для сокращения площади района ее падения, если это одноразовая ступень, и, если это возвращаемая ступень, для обеспечения условий повторного запуска её двигателя.\n\nValeriy I. Trushlyakov, Vladislav A. Urbansky, and Vadim V. Yudintsev “Investigation of liquid oxygen pressurization system with cold gas helium and hydrogen peroxide”. Global Space Exploration Conference (GLEX2021), St Petersburg, Russian Federation, 14-18 June 2021. Paper id: GLEX-2021,6,2,2,x61696.\n\nВторая работа продолжает исследование нового способа увода космического мусора на вращающейся тросовой связи.\n\nValeriy I. Trushlyakov, and Vadim V. Yudintsev “Control of the Rotating Tethered System for Orbital Debris Removal”. Global Space Exploration Conference (GLEX2021), St Petersburg, Russian Federation, 14-18 June 2021. Paper id: GLEX-2021,7,5,6,x62094.\n\nПрезентация\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-06-20-glex/"
    },{
      
      "title": "Способ увода объектов крупногабаритного космического мусора",
      "date": "2021-09-04 00:00:00 -0500",
      
      "content": "Получен евразийский патент на способ увода объектов крупногабаритного космического мусора и устройство для его реализации, описывающий схему увода объекта космического мусора на вращающейся тросовой связи.\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-09-04-evraz-patent/"
    },{
      
      "title": "Дискретная модель троса в MATLAB",
      "date": "2021-10-29 00:00:00 -0500",
      "description": "Lumped mass tether model in MATLAB.\n",
      "content": "При исследовании движения протяженных космических тросовых систем часто используется простейшая дискретная модель троса, которая учитывает как упругие свойства троса так и его массу. Рассмотрим построение модели такой тросовой системы в MATLAB.\n\nТрос рассматривается как система материальных точек (узлов). Узлы соединяются между собой невесомыми пружинами, которые имитируют упругие свойства троса. Предположим, что масса троса \\(M\\) распределяется по длине троса равномерно. В этом случае при разбиении троса на узлы масса одного узла \\(m\\) будет определяться выражением:\n\n[m = \\frac{M}{n},]\n\nгде n – количество точек (узлов), на которые разбивается трос.\n\n\n\nДвижение троса рассматривается относительно неподвижной системы координат \\(Ox_0 y_0\\), находящейся в однородном поле силы тяжести. Ускорение свободного падения \\(g\\) направлено в противоположном направлении оси \\(Oy_0\\). Предположим, что один конец троса закреплен. Уравнение движения узла троса имеет вид:\n\n[m \\ddot{\\vec{r}}i = - \\vec{F}_i  + \\vec{F}{i+1} + \\vec{F}_{ie}, \\quad i  = 1,\\ldots,n-1.]\n\nгде \\(\\vec{F}_i\\), \\(\\vec{F}_{i+1}\\) – силы, действующие со стороны смежных узлов, вызванные растяжением троса, \\(\\vec{F}_{ie}\\) – внешняя сила, действующая на \\(i\\)-ый узел.\n\nНа последний узел действует только одна сила упругости со стороны предыдущего смежного узла, поэтому уравнение движения последнего узла имеет вид:\n\n[m \\ddot{\\vec{r}}n = - \\vec{F}_n + \\vec{F}{ne}.]\n\nсила  \\(\\vec{F}_k\\), действующая между узлом \\(k-1\\) и узлом \\(k\\) определяется выражением\n\n[\\vec{F}_ k = c (l_k - l_0) \\vec{e}_k, \\quad k =1, \\ldots, n]\n\nгде \\(c\\) – жесткость участка троса между двумя узлами, зависящая от свойств материала троса, его толщины и свободной длины участка троса, соединяющего два узла:\n\n[c = \\frac{EF}{l_0}]\n\nгде \\(EF\\) – произведение модуля упругости материала троса на площадь его поперечного сечения, \\(l_0\\) – свободная длина троса, соединяющего два узла. Если трос длиной \\(L_0\\), разбивается узлами на отрезки одинаковой длины, то значения \\(l_0\\) одинаковы для всех отрезков:\n\n[l_0 = \\frac{L_0}{n}]\n\nРасстояние между узлом \\(k-1\\) и узлом \\(k\\) – \\(l_k\\) определяется следующим образом:\n\n\n  \n    \n      [l_k =\n      \\vec{r}k - \\vec{r}{k-1}\n      , \\quad k=2,\\ldots,n]\n    \n  \n\n\nДлина первого участка троса, соединяющего неподвижную точку троса с первым узлом:\n\n\n  \n    \n      [l_1 =\n      \\vec{r}1 - \\vec{r}{0}\n      .]\n    \n  \n\n\nгде \\(r_0\\) – радиус вектор точки закрепления.\n\nЕсли длина \\(l_k\\) будет больше \\(l_0\\), то между узлами \\(k-1\\) и \\(k\\) будет действовать упругая сила \\(\\vec{F}_k\\). Единичный вектор \\(\\vec{e}_k\\), определяет положительное направление силы \\(\\vec{F}_k\\), действующей со стороны узла \\(k\\) на узел \\(k-1\\).\n\n[\\vec{e}k = \\frac{\\vec{r}_k - \\vec{r}{k-1}}{l_k}.]\n\nНа узел \\(k\\), действует та же по модулю сила противоположного направления.\n\nПри движении троса в поле силы тяжести, как показано на рисунке, на каждый узел будет действовать сила тяжести:\n\n[\\vec{F}_{ke} = - m g \\vec{e}_y]\n\nгде \\(\\vec{e}_y\\) – единичный вектор оси \\(O y_0\\).\n\nКод\n\nПрограмма моделирования движения троса будет состоять из двух файлов:\n\n  файл-функция правых частей дифференциальных уравнений dq_tether.m;\n  файл-скрипт для запуска процесса интегрирования main.m.\n\n\nФайл-функция правых частей.\n\nВ файл-функцию передается время \\(t\\), столбец состояния системы в момент \\(t\\), представляющей собой последовательность пар координат узлов и скоростей узлов:\n\n[q = [x_1, y_1, x_2, y_2, \\ldots, x_n, y_n, \\; \\dot{x}_1, \\dot{y}_1, \\dot{x}_2, \\dot{y}_2, \\ldots, \\dot{x}_n, \\dot{y}_n]^T,]\n\nи структуру с параметрами системы p, которая будет объявлена в главном файл-скрипте.\n\nfunction dq = dq_tether(t, q, p)    \n    % Количество точек (узлов)\n    n  = size(q,1)/4;        \n    % Формируем из q матрицу столбцов координат узлов 2xn [r1, r2, ..., rn]\n    r  = reshape(q(1:2*n),2,[]);    \n    % Добавим точку закрепления троса в начало матрицы r\n    r  = [[0;0] r];\n    % Матрица радиус-векторов, соединяющих смежные точки (от узла k к узлу k+1)\n    dr = diff(r, 1, 2);\n    % Расстояния между узлами\n    l  = sqrt(sum(dr.^2,1));    \n    % Удлинение участка троса\n    delta = l - p.L0;    \n    % Матрица единичных векторов направления от узла k к узлу k+1\n    e = dr./repmat(l,2,1);    \n    % Сила между узлами. Учитывается, что только растяжение \n    % вызывает возникновение упругой силы\n    F = delta*p.c.*(delta&gt;0);    \n    % Вектор силы\n    Fvec = repmat(F,2,1).*e;\n    % На каждый узел кроме последнего, действуют две силы    \n    % Одна со знаком минус, другая со знаком плюс \n    Fp = -Fvec + [Fvec(:, 2:n) [0;0]];    \n    % Ускорение    \n    ap = Fp./repmat(p.point_masses,2,1);    \n    % В направлении минус Y действует сила тяжести\n    ag = repmat([0; -p.g],1,n);    \n    % Суммарное ускорение точки (узла)\n    ap = ap + ag;\n    % Результат работы функции - производная вектора состояния\n    dq = [q(2*n+1:end);ap(:)];    \nend\n\n\nГлавный файл-скрипт\n\nclc;\n% Трос длиной 3 км \nL = 3000; \n% диаметром 3 мм, \nd = 0.003;\n% Площадь поперечного сечения\nF  = pi*d^2/4;\n% плотность материала троса г/см3 -&gt; кг/м3 (кевлар)\nrho = 1.44*(1e3); \nm   = rho*pi*d^2/4*L;\nfprintf('Масса троса %3.1f кг', m);\n% Количество точек\nn = 50;\n% Массы точек (узлов) троса - массив\np.point_masses = repmat(m/n,1,n);\n% На конце троса масса 10 кг\np.point_masses(n) = 10;\n% Модуль упругости 83 ГПа\nE   = 83e9;\n% Свободная длина троса\np.L0 = L/n;\n% Жесткость отрезка троса, соединяющего две точечные массы\np.c = E*F/p.L0;\n% Ускорение свободного падения\np.g = 9.807;\n% Формируем начальные условия\nx0 = (1:n)*p.L0;  \ny0 = zeros(1,n);\nr0 = [x0; y0];\nv0 = zeros(2,n);\n% Интегрируем методом Рунге-Кутты\n[t,q] = ode45(@(t,q) dq_tether(t,q,p), 0:0.5:100, [r0(:); v0(:)]);\n% Анимация\nfor i=1:size(t,1)\n    cla;\n    % Положения точек\n    r = [ [0;0], reshape(q(i,1:2*n),2,[])] ;\n    % Точки, соединенные отрезками \n    plot(r(1,:), r(2,:),'.-');    \n    % Включить сетку\n    grid on;\n    % Границы графика должны быть неизменны\n    xlim([-L,L]); ylim([-L,L*0.1]);    \n    % Масштаб по всем осям одинаков для исключения искажений    \n    daspect([1 1 1]);\n    % Сохранить кадр\n    getframe;\nend\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-10-29-point-tether/"
    },{
      
      "title": "Модель одноканальной системы ориентации в SIMULINK",
      "date": "2021-12-10 00:00:00 -0600",
      
      "content": "В раздел MATLAB добавлена лабораторная работа: Модель одноканальной системы ориентации в SIMULINK.\n",
      "categories": [],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-12-10-simulink/"
    },{
      
      "title": "Управление мягкой посадкой",
      "date": "2022-04-18 00:00:00 -0500",
      "description": "По материалам книги Battin R. H. An introduction to the mathematics and methods of astrodynamics. – AIAA, 1999.\n",
      "content": "Рассмотрим движение посадочного модуля, совершающего мягкую посадку на поверхность Луны. Модуль будем рассматривать как материальную точку, которая движется под действием силы тяжести и силы тяги двигателя. Необходимо построить закон управления, который приводит посадочный модуль из произвольного начального положения в точку, определяемую радиус-вектором \\(\\mathbf{r}_1\\) и скоростью \\(\\mathbf{v}_1\\) за заданное время. Будем считать, что направление и величина силы тяги при этом не ограничены.\n\n\n\nНайдем такое управление, которое минимизирует функционал:\n\n[J = \\int_{t_0}^{t_1} a^2(t) dt = \\int_{t_0}^{t_1} \\mathbf{a}^T(t) \\mathbf{a}(t) dt,]\n\nт. е. движение из исходного в конечное положение за заданное время \\((t_1-t_0)\\) нужно выполнить с минимальным среднеквадратическим ускорением, от которого будут зависеть затраты топлива.\n\nОбозначим вектором \\(\\mathbf a\\) полное ускорение посадочного модуля, тогда дифференциальные уравнения его движения в векторной форме будут иметь вид\n\n[\\frac{d \\mathbf r}{dt} = \\mathbf v, \\quad \\frac{d \\mathbf v}{dt} = \\mathbf a,]\n\nГраничные условия, которым должны удовлетворять решения дифференциальный уравнений:\n\n[\\mathbf{r}(t_0) = \\mathbf{r}_0, \\, \\mathbf{v}(t_0) = \\mathbf{v}_0, \\, \\mathbf{r}(t_1) = \\mathbf{r}_1, \\, \\mathbf{v}(t_1) = \\mathbf{v}_1]\n\nСуществует множество решений (траекторий), которые удовлетворяют этим уравнениям движения и граничным условиям. Каждой из этих траекторий может быть сопоставлено значение функционала \\(J\\). Среди этого множества траекторий  найдем такую траекторию, которая минимизирует функционал \\(J\\).\n\nОбозначим решение, минимизирующее функционал \\(\\mathbf{r}_m(t)\\), \\(\\mathbf{v}_m(t)\\). Введем векторы отклонений \\(\\mathbf{\\delta}(t)\\), \\(\\mathbf{\\nu}(t)\\), \\(\\mathbf{\\zeta}(t)\\), которые удовлетворяют уравнениям\n\n[\\frac{d \\mathbf{\\delta}}{dt} = \\mathbf \\nu, \\quad \\frac{d \\mathbf \\nu}{dt} = \\mathbf \\zeta,]\n\nи граничным условиям\n\n[\\delta(t_0) = \\mathbf{\\delta}(t_1) = 0, \\, \\mathbf{\\nu}(t_0) = \\mathbf{\\nu}(t_1) = 0, \\, \\mathbf{\\zeta}(t_0) = \\mathbf{\\zeta}(t_1) = 0,]\n\nСформируем однопараметрическое семейство функций\n\n[\\mathbf{r}(t,\\alpha) = \\mathbf{r}_m(t) + \\alpha \\mathbf{\\delta}(t),]\n\n[\\mathbf{v}(t,\\alpha) = \\mathbf{v}_m(t) + \\alpha \\mathbf{\\nu}(t),]\n\n[\\mathbf{a}(t,\\alpha) = \\mathbf{a}_m(t) + \\alpha \\mathbf{\\zeta}(t),]\n\nи перепишем функционал\n\n[J(\\alpha)=\\int_{t_0}^{t_1} \\mathbf{a}m^T \\mathbf{a}_m dt + 2 \\alpha \\int{t_0}^{t_1} \\mathbf{a}m^T \\zeta dt + \\int{t_0}^{t_1} \\zeta^T \\zeta dt]\n\nЗапишем необходимое условие минимума функционала по параметру \\(\\alpha\\)\n\n[\\frac{dJ}{d\\alpha} = 0 = 2 \\int_{t_0}^{t_1} \\mathbf{a}_m^T d \\mathbf{\\nu}]\n\nПравая часть этого выражения может быть проитегрирована по частям. С учётом того, что \\(\\mathbf{\\nu}(t_0) = \\mathbf{\\nu}(t_1) = 0\\), получим\n\n[\\int_{t_0}^{t_1} \\mathbf{a}m^T d \\mathbf{\\nu} = - \\int{t_0}^{t_1} \\frac{d \\mathbf{a}m^T}{ dt} \\mathbf{\\nu}(t) dt = - \\int{t_0}^{t_1} \\frac{d \\mathbf{a}_m^T}{ dt} \\frac{d \\mathbf{\\delta}}{dt} dt]\n\nНеобходимое условие минимума функционала принимает вид\n\n[\\frac{dJ}{d\\alpha} = \\int_{t_0}^{t_1} \\frac{d \\mathbf{a}_m^T}{ dt} \\frac{d \\mathbf{\\delta}}{dt} dt = 0]\n\nВ соответствии с основной леммой вариационного исчисления, если функция \\(g(x)\\) на интервале \\((a,b)\\) удовлетворяет условию\n\n[\\int_a^b g(x) h’(x) dx = 0]\n\nдля любой гладкой функции \\(h\\) на том же интервале, при этом \\(h(a)=h(b)=0\\) ,  то функция \\(g(x)\\) равна константе. В рассматриваемом случае, это будет означать, что ускорение \\(\\mathbf{a}_m\\) представляет собой линейную функцию\n\n[\\frac{d \\mathbf{a}_m}{ dt} = 0 \\Rightarrow \\mathbf{a}_m=\\mathbf{c}_1 t + \\mathbf{c}_2]\n\nПостоянные \\(c_1\\), \\(c_2\\) определяются из граничных условий, с учетом которых получим:\n\n[\\mathbf{a}m = \\frac{4}{t{go}} \\left( \\mathbf{v}1 - \\mathbf v(t) \\right) + \\frac{6}{t{go}^2} \\left( \\mathbf{r}1 - (\\mathbf{r}(t)+\\mathbf{v}_1 t{go}) \\right)]\n\nгде \\(t_{go} = t_1-t\\).\n\nНайдено полное ускорение, которое есть сумма ускорения, создаваемого двигателем, и ускорения силы тяжести. Ускорение, создаваемое двигателем будет равно\n\n[\\mathbf{a}c = \\frac{4}{t{go}} \\left( \\mathbf{v}1 - \\mathbf v(t) \\right) + \\frac{6}{t{go}^2} \\left( \\mathbf{r}1 - (\\mathbf{r}(t)+\\mathbf{v}_1 t{go}) \\right) - \\mathbf{g}(\\mathbf{r}(t))]\n\nУмножив \\(\\mathbf{a}_c\\) на массу посадочного модуля, получим необходимую силу тяги.\n\nВ задачах, представляющих практический интерес, вектор \\(\\mathbf g\\) не является неизменным, и  в этом случае критерий оптимальности уже не будет обеспечивать минимизацию расхода топлива. Однако полученное решение может рассматриваться как близкое к оптимальному. На основе этого метода разрабатывалась программа посадки на Луну посадочного модуля миссий Аполлон.\n\nВсе величины в законе управления могут быть либо измерены на борту посадочного модуля, либо рассчитаны. По мере приближения к конечному моменту времени \\(t_{go}\\), которая находится в знаменателе, будет стремится к нулю, что может привести к проблемам при вычислениях. Этих проблем можно избежать, например, сохраняя постоянной величину  \\(t_{go}\\), когда она станет меньше некоторой малой величины. Затем, когда  \\(t_{go}\\) достигнет нуля, можно “отдать команду” на отключение двигателя.\n\n",
      "categories": ["mechanics"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/2022-04-18-battin/"
    },{
      
      "title": "Наноспутники формата кубсат",
      "date": "2022-11-11 00:00:00 -0600",
      
      "content": "Презентация к лекции курса “Современные проблемы механики”.\n",
      "categories": ["mechanics"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/2022-11-11-cubesats/"
    },{
      "image": "/assets/img/blog/rst-rst.png",
      "title": "Модель движения вращающейся тросовой системы в SimInTech",
      "date": "2022-11-16 00:00:00 -0600",
      "description": "Пример построения в системе SimInTech модели продольных колебаний троса вращающейся тросовой системы для увода объектов космического мусора\n",
      "content": "\n  Вращающаяся тросовая система\n  Математическая модель продольных колебаний троса\n  Построение модели в SimInTech    \n      Прямое интегрирование уравнения движения\n      Интегрирование дифференциального уравнения используя блок-функцию правой части дифференциального уравнения\n      Построение модели, используя блоки библиотеки “Механика”\n    \n  \n\n\nНекоторые способы очистки околоземных орбит от крупногабаритных объектов космического мусора (ОКМ), таких как орбитальные ступени ракет или отработавшие спутники, предполагают использование космических тросовых систем. Трос можно использовать как буксировочное средство, соединяющее космический буксир с ОКМ. В этом случае связка буксира и ОКМ уводится на орбиту утилизации к границе атмосферы Земли, используя тянущую схему буксировки. Тросовая связь устанавливается при помощи гарпуна, сети, которыми можно “выстрелить” в ОКМ, или при помощи автономного стыковочного модуля, отделяемого от космического буксира.\n\n\n\nРисунок 1 - Тянущая схема буксировки на тросе\n\nТянущая схема буксировки требует нестандартной компоновки космического буксира. Действительно, поскольку в процессе буксировки ОКМ находится позади буксира, устройство развертывания и крепления троса на буксире, т.е. его полезная нагрузка, должна быть расположена в его кормовой части, там же, где должна располагаться двигательная установка. Это требование к компоновке не позволяет использовать в качестве буксиров орбитальные средства, разработанные на основе существующих разгонных блоков, таких как “Фрегат”, “Бриз”, БВ “Волга”). Кроме этого, при тянущей схеме буксировки есть риск повреждения троса факелом работающего двигателя буксира.\n\nДля существующих разгонных блоков или космических аппаратов, на основе которых может быть разработан космический буксир, естественной является толкающая схема буксировки, которая предполагает формирование между буксиром и ОКМ жесткой механической связи. При этом жесткая механическая связь должна быть сформирована с учетом возможности парирования системой управления буксиром возмущений, вызванных отклонением центра масс связки от линии действия силы тяги буксира.\n\n\n\nРисунок 2 - Толкающая схема буксировки\n\nВращающаяся тросовая система\n\nРассматриваемая здесь вращающаяся тросовая система (ВТС) позволяет использовать толкающую схему буксировки при нежесткой  механической связи между буксиром и ОКМ: вращение космической тросовой системы буксир-трос-ОКМ приводит к растяжению троса под действием так называемых “центробежных сил”, что то позволяет прикладывать силу тяги буксира вдоль троса в направлении его сжатия, используя толкающую схему буксировки.\n\n\n\nРисунок 3 - Вращающаяся тросовая система\n\nПосле формирования ВТС её увод на орбиту утилизации производится периодическими включениями двигателя буксира в те интервалы времени, когда проекция вектора силы тяги буксира на направление орбитальной скорости связки отрицательна.\n\n\n\nРисунок 4 - Движение ВТС под действием тяги буксира\n\nВ этой статье рассматриваются способы построения моделей продольных колебаний троса вращающейся тросовой системы в российской среде разработке моделей динамических систем SimInTech.\n\nМатематическая модель продольных колебаний троса\n\nРассмотрим движение вращающейся тросовой системы после ее формирования. Необходимое вращение системы может быть обеспечено за счет разности скоростей буксира и ОКМ в момент формирования тросовой связи. Например, перехват ОКМ с формированием ВТС может быть выполнен с внутренней по отношению к орбите ОКМ орбиты буксира.\n\n\n\nРисунок 5 - Формирование ВТС\n\nПри построении математической модели буксир и ОКМ рассматриваются как материальные точки постоянного состава. Предполагается, что движение ВТС происходит в безгравитационном пространстве (действие на ВТС гравитационного поля Земли не учитывается). Трос рассматривается как невесомая пружина.\n\nПредположим, что в момент времени t = 0 между двумя ОКМ и буксиром возникает тросовая связь. Пусть в этот момент времени длина троса равна его свободной длине \\(l_0\\) и скорости ОКМ и буксира параллельны друг другу. Начальная угловая скорость ВТС будет равна отношению разности скоростей буксира и ОКМ на расстояние между ними:\n\n[\\omega_0 = \\frac{\\Delta V}{l_0}]\n\nПосле формирования связки начнутся упругие колебания троса относительно некоторой стационарной деформации троса, определяемой его жесткостью, длиной и угловой скоростью ВТС. В отсутствии внешних моментов момент количества движения ВТС остается постоянным, поэтому при изменении длины троса будет изменяться его угловая скорость по следующему закону:\n\n[\\omega=\\frac{l_0^2}{l^2}\\omega_0]\n\nгде \\(l_0\\) – начальная длина троса, равная его свободной длине, \\(\\omega\\) – фактическая угловая скорость троса, \\(l\\) – фактическая длина троса, равная сумме его свободной длины и упругой деформации \\(\\delta\\):\n\n[l = l_0 + \\delta]\n\nРассмотрим движение буксира во вращающейся неинерциальной системе координат \\(Cx_cy_c\\), связанной с тросом, начало которой расположено в центре масс системы.\n\n\n\nРисунок 6 - Схема системы\n\nВдоль оси \\(Cx_c\\) на буксир действуют сила натяжения троса \\(T\\), зависящая от его деформации и \\(\\delta = l - l_0\\) и жесткости \\(c\\):\n\n[T = c(l-l_0) = c \\delta,]\n\nи сила тяги буксира \\(P\\). К активным силам добавляется сила инерции, обусловленная вращением системы координат \\(Cx_cy_c\\) с угловой скоростью \\(\\omega\\):\n\n[\\Phi_\\omega = \\omega^2 l_1 m_1 = \\omega^2 \\frac{m_2}{m_1+m_2} l m_1 = \\omega^2 l m_{12},]\n\nи сила инерции, вызванная движением центра масс ВТС под действием силы тяги \\(P\\):\n\n[\\Phi_P = \\frac{P}{m_1+m_2} m_1 = P \\frac{m_{12}}{m_2}]\n\nУравнение движения буксира в проекции на ось \\(C x_c\\) имеет вид:\n\n[m_1 \\ddot{l}1 = \\omega^2 l m{12} + P \\frac{m_{12}}{m_2} - с \\delta  - P]\n\nС учетом того, что\n\n[l_1 = \\frac{m_2}{m_1+m_2} l = \\frac{m_{12}}{m_1} (l_0+\\delta),]\n\nпосле небольших преобразований получим дифференциальное уравнение для деформации троса:\n\n[\\ddot{\\delta} - \\left(\\omega^2 - \\frac{c}{m_{12}}\\right) \\delta = \\omega^2 l_0 - \\frac{P}{m_1}]\n\nЭто уравнение нелинейное поскольку угловая скорость \\(\\omega\\) зависит от длины троса, однако при малых \\(\\delta \\ll l_0\\) это уравнение можно линеаризовать.\n\nПостроение модели в SimInTech\n\nПостроить модель рассматриваемой системы в SimInTech можно тремя способами:\n\n  непосредственно численно проинтегрировать дифференциальное уравнение движения, приведя его к системе дифференциальных уравнений первого порядка в форме Коши, используя встроенный язык программирования SimInTech;\n  создать блок с функцией правой части дифференциального уравнения (или системы дифференциальных уравнений), используя язык программирования или математические блоки, и проинтегрировать эту функцию, используя блоки-интеграторы;\n  построить модель, используя блоки библиотеки “Механика”.\n\n\nПрямое интегрирование уравнения движения\n\nРассмотрим движение ВТС при \\(P = 0\\). Самый простой способ получить решение – это проинтегрировать полученное выше дифференциальное уравнение, используя встроенный язык программирования SimInTech, похожий на Pascal.\n\nСоздадим новую модель (Файл → Новый проект → Схема модели общего вида) и поместим блок “Язык программирования” из раздела “Динамические”. Внутри блока запишем систему дифференциальных уравнений первого порядка:\n\n// Начальные условия\ninit delta=0, vdelta=0;\noutput delta, vdelta;\n// Текущая угловая скорость \nw = w0*L0^2/(L0+delta)^2;\n// Дифференциальные уравнения в форме Коши\ndelta'  = vdelta; \nvdelta' = (w^2-k2)*delta + w^2*L0;\n\n\nВ первой строке кода блока объявляются (init) переменные состояния и их начальные значения, которые также являются выходами блока (output). Далее записывается система дифференциальных уравнений первого порядка для объявленных переменных состояния.\n\nСледует отметить, что переменную w в блоке с системой дифференциальных уравнений необходимо объявлять без ключевого слова var, т.е. нельзя написать:\n\nvar w = w0*L0^2/(L0+delta)^2;\n\n\nВ противном случае значение w будет вычислено только один раз в момент запуска процесса интегрирования, т.е. для начального значения переменной состояния delta, что приведет к неверному результату. К сожалению, при разработке кода блока система не предупреждает о таком поведении.\n\nВ коде блока используются внешние переменные, например w0, L0. Объявить эти переменные и присвоить им значения можно в скрипте модели.\n\n\n\nРисунок 7 - Схема модели 1\n\nТекст скрипта инициализации:\n\ninitialization\n  // Масса буксира\n  var m1  = 1000;\n  // Масса космического мусора\t\t\n  var m2  = 3000;\n  // Начальная длина троса\t\t\n  var L0  = 2000;\n  // Модуль упругости на площадь поперечного сечения троса\n  var EA  = 124e9*pi*0.002^2/4;\n  // Приведенная масса\n  var m12 = m1*m2/(m1+m2);\n  // Отношение жёсткости троса к приведенной массе\n  var k2  = EA/(m12*L0);\n  // Начальная угловая скорость ВТС\n  var w0  = 3*pi/180;\nend;\n\n\nК выходным портам блока (деформация и скорость деформации) подключим блок “Временной график” из раздела “Вывод данных”. Запустив процесс моделирования (“Пуск”), получим решение: ниже на рисунке показан график изменения деформации троса.\n\n\n\nРисунок 8 - Изменение деформации троса\n\nМаксимальная деформация троса (40,95 м) близка к приближенной аналитической оценке максимальной деформации:\n\n[\\delta_{max} = \\frac{2 \\omega_0^2}{k^2+3\\omega_0^2} l_0 = 40.93\\text{ м}]\n\nИнтегрирование дифференциального уравнения используя блок-функцию правой части дифференциального уравнения\n\nПолучим решение вторым способом, сформировав функцию правой части дифференциального уравнения. Также для упрощения модели будем считать, что движение ВТС происходит при \\(P = 0\\). Создадим блок “Язык программирования” и напишем в нем код, который вычисляет \\(\\ddot \\delta\\) (выход блока), по заданным значениям \\(\\delta\\) и \\(\\dot{\\delta}\\), которые будут входами блока:\n\ninput delta, vdelta;\noutput d2delta;\n\nw = w0*L0^2/(L0+delta)^2;\n \nd2delta = (w^2-k2)*delta + w^2*L0;\n\n\nВыход блока \\(\\ddot \\delta\\)  подключим последовательно к двум блокам-интеграторам. Выходы первого (скорость деформации) и второго (деформация) интеграторов подключим к соответствующим входам созданного блока-функции правой части. Построенная модель будет иметь следующий вид:\n\n\n\nРисунок 9 - Схема модели 2\n\nВ отличие от первого рассмотренного способа построения модели, начальные условия движения системы будут задаваться в блоках-интеграторах. В первом блоке-интеграторе - начальная скорость деформации, во втором - начальная деформация.\n\n\n\nРисунок 10 - Начальные условия для скорости деформации троса, задаваемые в интеграторе\n\nЗапустив расчет, получим решение, которое не будет отличаться от решения, полученного первым способом.\n\nПостроение модели, используя блоки библиотеки “Механика”\n\nВ отличие от первых двух способов, при использовании библиотеки “Механика” для построения модели нет необходимости записи уравнений движения системы на языке программирования SimInTech. Однако, математическая модель (уравнение движения) необходима для правильного построения структуры модели.\n\nРазрабатываемая модель состоит из трех подсистем или субмоделей: подсистемы моделирования троса, подсистемы для расчета угловой скорости ВТС, основываясь на законе сохранения момента количества движения, и подсистемы управления силой тяги буксира для активного демпфирования продольных колебаний.\n\n\n\nРисунок 11 - Схема модели 3\n\nМодель тросовой систем состоит из поступательной пружины, имитирующей упругий невесомый трос, двух точечных масс (буксир, ОКМ). Каждая сила в модели представляется одним блоком типа “Идеальный источник силы поступательного движения”. Также в модель добавлен блок моделирования демпфирующих свойств троса (блок “Демпфер”), но коэффициент демпфирования принят равным 0 для возможности сравнения результатов моделирования с результатами, полученными с результатами предыдущих двух моделей.\n\n\n\nРисунок 12 - Схема субмодели “Модель тросовой системы”\n\nВ отличие от математических блоков, которые обычно имеют один вход и один выход, “механические” блоки соединяются двунаправленной связью, обозначаемой на схеме зеленой линией, в которой передаётся сила и скорость (или момент и угловая скорость, если блоки модулируют вращательное движение). Что из этих двух величин является входом, а что является выходом зависит от типа блока. Например, для блока “Инерция поступательного движения” входом (воздействием) является закон изменения силы, а выходом (реакцией) является скорость - результат однократного интегрирования уравнения поступательного движения материальной точки под действием силы с заданным в этом блоке начальным условием. Блок “Идеальный источник силы поступательного движения” (раздел “Механические источники силы” библиотеки блоков), которая используется в схеме для моделирования силы инерции, передает по двунаправленной связи только значение силы, полученное на математическом порту (черный цвет связи).\n\nСамый сложный блок в разрабатываемой схеме “Упругий невесомый трос”, который имеет тип “Пружина поступательного движения”. Этот блок имеет два входа, на которые поступает скорость левого и правого конца пружины. В блоке вычисляется разность скоростей, эта разность скоростей интегрируется с учетом заданного в блоке начального условия – начальной деформации пружины. В результате интегрирования получается удлинение пружины, которое умножается на её жесткость \\(с\\) и полученный результат – сила с учетом знака возвращается на первый и второй входы:\n\n[F_R = - с \\int_{0}^t (V_R - V_C) dt, \\quad F_C = + с \\int_{0}^t (V_R - V_C) dt,]\n\nВ рассматриваемой модели \\(V_R\\) это скорость буксира в проекции на ось \\(Cx_c\\) относительно центра масс системы, \\(V_C\\)  – это скорость ОКМ в проекции на ту же ось.\n\nНиже показано внутреннее устройство блока “Пружина поступательного движения”, реализующего эти формулы:\n\n\n\nРисунок 13 - Схема блока “Пружина поступательного движения”\n\nВ приведённой подсистеме также используется измеритель деформации и скорости деформации пружины. Как и пружина этот блок имеет два входа, на которые поступает скорость левого и правой точки пружины. В блоке вычисляется разность скоростей между двумя точками, эта разность скоростей интегрируется с учетом заданного в блоке начального условия – начального расстояния между точками. В результате интегрирования получается текущее деформация пружины, которая передается в выходной математический порт. Разность скоростей также передается в выходной математический порт.\n\nК выходам блока “Упругий невесомый трос” подключаются блоки “Инерция поступательного движения”, моделирующие массы буксира и ОКМ. Кроме силы упругости к буксиру приложены сила тяги и две силы инерции, вызванные вращение тросовой системы и движением ее центра масс с ускорением под действием силы тяги. В отличие от математических блоков, для сложения сил не используются блоки сумматоры: дополнительные силы просто подключаются к линии, ведущей к блоку типа “Инерция поступательного движения”.\n\nДля вычисления силы инерции действующей на буксир и вызванной вращением тросовой системы, угловая скорость ВТС возводится в квадрат, умножается на фактическую длину троса с учетом его упругой деформации. Результат умножается на приведенную массу системы:\n\n[\\Phi_\\omega = \\omega^2 (l_0+\\delta) m_{12},]\n\nНиже на рисунке показан фрагмент подсистемы, который реализует эту формулу. Сила инерции \\(\\Phi_\\omega\\), “действующая” на буксир в неинерциальной системе отсчета, связанной с тросом, направлена в положительном направлении оси \\(Cx_c\\), поэтому на математический порт блока “Сила инерции” (тип блока “Идеальный источник силы поступательного движения”) подаётся значение силы со знаком плюс. На математический порт силы инерции объекта космического мусора сила инерции подается со знаком минус, для чего используется блок “Усилитель” с коэффициентом усиления равным минус 1.\n\n\n\nРисунок 14 - Фрагмент субмодели “Модель тросовой системы” для вычисления силы инерции, обусловленной вращением тросовой системы\n\nСила тяги \\(P\\) действует непосредственно на буксир, а также на всю систему, вызывая движение её центра масс с ускорением:\n\n[a_{c} = \\frac{P}{m_1 + m_2}.]\n\nНиже на рисунке показан фрагмент модели, где сигнал с входного порта P (сила тяги буксира) умножается на минус 1 и добавляется к системе сил, действующей на буксир. Знак минус учитывает направление действия силы тяги в отрицательном направлении оси \\(Cx_c\\).\n\n\n\nРисунок 15 - Фрагмент субмодели “Модель тросовой системы” для вычисления силы инерции, обусловленной движением центра масс системы с ускорением\n\nДля определения силы инерции, вызванной движением начала координат с ускорением под действием силы \\(P\\), на этой же схеме значение силы делится на массу всей системы, а затем результат умножается на массу буксира и массу ОКМ, формируя выражения для блоков сил инерции буксира и ОКМ соответственно. Эти силы инерции и на буксир и на ОКМ действует в одном направлении.\n\nНа рассматриваемую вращающуюся тросовую систему в соответствии с принятыми допущениями не действуют внешние моменты, поэтому кинетический момент системы остается постоянным:\n\n[J_0 \\omega_0 = J \\omega]\n\nгде \\(J = m_{12} l^2\\) – момент инерции ВТС. В начальный момент времени \\(J_0 = m_{12} l_0^2\\).\n\nЕсли в начальный момент времени угловая скорость ВТС была равна \\(\\omega_0\\), а длина \\(l_0\\), то при длине троса \\(l\\) угловая скорость будет равна:\n\n[\\omega = \\frac{l_0^2}{l^2}\\omega_0]\n\nЭту формулу реализует подсистема “Закон сохранения момента количества движения ВТС”, схема которой приведена ниже.\n\n\n\nРисунок 16 - Схема субмодели “Закон сохранения момента количества движения ВТС”\n\nДля гашения продольных колебаний троса после формирования тросовой системы или после включения и выключения двигателя может быть использовано управление свободной длиной троса или управление тягой буксира. Рассмотрим второй способ демпфирования продольных колебаний. Логика работы активного демпфирования описана в субмодели “Модель изменения силы тяги”.\n\nКак было отмечено в начале статьи, для увода с орбиты ВТС производится периодические  включения двигателя буксира в те интервалы времени, когда проекция силы вектора тяги буксира (\\(P\\)) на направление орбитальной скорости связки (\\(V_c\\)) отрицательна:\n\n[\\cos \\psi &gt; cos \\psi_a]\n\n\n\nРисунок 17 - Активный режим ВСТ\n\nТаким образом: у ВТС есть два режима движения: активный, когда должен работать двигатель, и пассивный когда двигатель буксира должен быть выключен.\n\nПри выключенном двигателе стационарная деформация троса \\(\\delta_{s}\\) будет определяться выражением:\n\n[\\delta_{s} = \\frac{\\omega_0^2}{k^2+3\\omega_0^2} l_0.]\n\nВ активном режиме стационарная деформация троса \\(\\delta_{p}\\) будет меньше:\n\n[\\delta_{p} = \\frac{\\omega_0^2 - \\frac{P}{m_1 l_0}}{k^2+3\\omega_0^2} l_0.]\n\nПри переходе из одного режима в другой необходимо демпфировать возникающие колебания, минимизируя отклонение фактической деформации троса от стационарной. Предположим, что тяга двигателя буксира не может регулироваться плавно и работающий двигатель может создавать только постоянную тягу \\(P_{max}\\). Для гашения колебаний троса предлагается следующий релейный алгоритм управления.\n\nЕсли ВТС находится в пассивном режиме, то сила тяги определяется следующим образом:\n\n[P = \n  \\begin{cases}\n  P_{max}, &amp; \\delta &gt; \\delta_s + \\Delta \\delta \\, \\And \\dot \\delta &gt; \\Delta \\dot \\delta \n  0, &amp; \\text{ во всех других случаях}\n  \\end{cases}]\n\nРисунок 18 иллюстрирует это условие: если деформация троса отклоняется от стационарного значения, увеличиваясь более чем на \\(\\Delta \\delta\\) и продолжает расти \\(\\dot \\delta &gt; \\Delta \\dot \\delta\\), то даже в пассивном режиме ВТС запускается двигатель для уменьшения деформации троса.\n\n\n\nРисунок 18 - К алгоритму демпфирования колебаний в пассивном режиме работы ВТС\n\nЕсли ВТС находится в активном режиме (рисунок 19):\n\n[P = \n  \\begin{cases}\n  0, &amp; \\delta &lt; \\delta_p - \\Delta \\delta \\, \\And \\dot \\delta &lt; \\Delta \\dot \\delta \n  P_{max}, &amp; \\text{ во всех других случаях}\n  \\end{cases}]\n\nгде \\(\\Delta \\delta\\) - некоторое передельное отклонение деформации троса от стационарной деформации, определяющее зону нечувствительности системы управления, \\(\\Delta \\dot \\delta\\) – некоторое передельное отклонение скорости деформации троса от нуля.\n\n\n\nРисунок 19 - К алгоритму демпфирования колебаний в активном режиме работы ВТС\n\nНиже показана схема субмодели “Модель изменения тяги”, реализующей описанный алгоритм. На вход субмодели поступает информация о режиме работы двигателя (1 - активный режим, 0 - пассивный режим), деформация и скорость деформации троса.\n\n\n\nРисунок 20 - Схема субмодели “Модель изменения тяги”\n\nРежим работы моделируется при помощи блока “Меандр”, который формирует на выходе сигнал из равномерных прямоугольных импульсов с заданными временными и амплитудными параметрами. Параметры блока:\n\n\n\nРисунок 21 - Свойства блока Меандр\n\nВ течение первых 100 секунд после формирования ВСТ находится в пассивном режиме (на выходе блока 0), затем в течение следующих 100 секунд в активном режиме (на выходе блока 1).\n\nУсловия включения двигателя буксира формируются при помощи четырех блоков типа “Релейное неоднозначное (гистерезис)”. Блоки “Реле 1” и “Реле 2” реализуют логику работы двигателя в пассивном режиме. Блоки “Реле 3” и “Реле 4” реализуют логику работы двигателя в активном режиме. Например, “Реле 1” включается (на выходе “1”), если отклонение деформации троса от стационарной деформации при P=0 превышает заданное в скрипте модели предельное значение thr_d:\n\n\n\nРисунок 22 - Свойства блока “Реле 1”\n\n“Реле 2” включается, если отклонение скорости деформации троса от нуля превышает заданное в скрипте модели предельное значение thr_v. Сигналы с “Реле 1” и “Реле 2” перемножаются, реализуя конъюнкцию (логическое “И”). Результат передается на селектор режимов, реализованный при помощи блока “Ключ управляемый перекидной”. В зависимости от режима работы ВТС, в схеме используется сигнал с блоков “Реле 1” и “Реле 2” или с блоков реле “Реле 3” и “Реле 4”. Учитывая, что в активном режиме при выполнении условия\n\n[\\delta &lt; \\delta_p - \\Delta \\delta \\, \\And \\dot \\delta &lt; \\Delta \\dot \\delta,]\n\nреализуемого при помощи реле “Реле 3” и “Реле 4”, двигатель буксира выключается, то перед передачей сигнала на селектор производится его “обращение” при помощи блока “Оператор НЕ”.\n\nСигнал с выхода селектора режимов (“1” или “0”) умножается на максимальную тягу буксира. Для этого используется блок типа “Усилитель”.\n\nНиже показаны графики режима работы и график изменения тяги двигателя буксира и соответствующий график изменения деформации троса, иллюстрирующий работу представленного алгоритма.\n\n\n\nРисунок 23 - Режим работы и изменение тяги двигателя буксира\n\n\n\nРисунок 24 - Изменение деформации троса\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2022-11-16-simintech-rsts/"
    },{
      "image": "/assets/img/blog/jan-simintech-object.png",
      "title": "Эффект Джанибекова в SimInTech",
      "date": "2022-12-04 00:00:00 -0600",
      "description": "Модель и визуализация движения в SimInTech гайки-барашка при её вращении вокруг оси с промежуточным моментом инерции, известного как “Эффект Джанибекова”.\n",
      "content": "\n  Эффект Джанибекова\n  Анализ устойчивости    \n      Вращение вокруг оси с максимальным значением момента инерции\n      Вращение вокруг оси с промежуточным значением момента инерции\n    \n  \n  Модель    \n      Блок динамических уравнений\n      Блок кинематических уравнений\n      Переход от углов последовательности 131 к углам последовательности 232\n      Скрипт модели\n    \n  \n  Ссылки\n\n\nСреда динамического моделирования SimInTech предлагает простой набор функций для визуализации движения моделируемых объектов. В этой статье рассматривается построение модели и визуализации движения гайки-барашка при ее свободном вращении вокруг собственной оси с “промежуточным” моментом инерции. Это движение известно как “Эффект Джанибекова”.\n\nЭффект Джанибекова\n\nЭффектом Джанибекова называют необычное движение вращающейся вокруг одной из своих осей гайки-барашка, выражающееся в её периодическом быстром перевороте на 180 градусов. Этой яркое явление наблюдал космонавт Владимир Александрович Джанибеков на борту орбитальной стации Салют-7 в 1985 году. На рисунке 1 показано движение гайки-барашка, построенное при помощи описываемой далее модели в среде динамического моделирования SimInTech.\n\n\n\nРисунок 1 - Неустойчивое движение гайки-барашка\n\nВокруг этого явления возникло множество различных безумных теорий, например, встречалось объяснение этого эффекта “на основании философии Дуализма Диалектики Абсолютного Парадокса” (все буквы, конечно, заглавные), однако этот эффект описывается в рамках классической механики. Вращение гайки-барашка вокруг оси с промежуточным или средним моментом инерции, например вокруг собственной оси Y, если значения главных моментов инерции удовлетворяют условиям \\(J_z &lt; J_y &lt; J_x\\),  является неустойчивым, что и приводит к наблюдаемому перевороту гайки. Некоторой аналогией движения гайки является поведение физического маятника,  выведенного небольшим возмущением из неустойчивого (верхнего) положения равновесия.\n\n\n\nРисунок 2 - Движение физического маятника\n\nМятник будет совершать размашистые колебания с амплитудой чуть меньше 180 градусов, подходя к точке неустойчивого равновесия то слева то справа, надолго “зависая” в этом положении. Нижнее устойчивое положение маятник будет проходить с большой скоростью. Подобным же образом ведет себя гайка, но гайка, в отличие от маятника, имеет устойчивые и неустойчивые движения, а не положения, поэтому у гайки длительные движения в окрестности неустойчивоой оси Y сменяются быстрыми переворотами на 180 градусов.\n\nАнализ устойчивости\n\nРассмотрим движение твердого тела, которое имеет три различных главных момента инерции, при этом обозначения главных центральных осей тела выбраны так, чтобы выполнялись условия \\(J_z \\leq  J_y \\leq  J_x\\).\n\n\n\nРисунок 3 - Система координат, связанная с гайкой\n\nВращение вокруг оси с максимальным значением момента инерции\n\nПредположим, что тело вращающется вокруг главной оси с максимальным моментом инерции – $Cx$, с угловой скоростью \\(\\omega_0 = \\text{const}\\). Пусть проекции угловой скорости на все собственные оси получили малые возмущения, которые обозначим как \\(\\delta_x\\), \\(\\delta_y\\) и \\(\\delta_z\\) соответственно:\n\n[\\omega_x = \\omega_0 + \\delta_x, \\; \\ \\omega_y = 0+\\delta_y, \\; \\omega_z = 0 + \\delta_z.]\n\nУравнения движения тела в возмущениях имеют вид:\n\n[\\left{\n\\begin{aligned}\n\t&amp; J_x \\dot \\delta_x - (J_y-J_z) \\delta_y \\delta_z = 0, \n\t&amp; J_y \\dot \\delta_y - (J_z-J_x) \\delta_z (\\omega_0 + \\delta_x) = 0, \n\t&amp; J_z \\dot \\delta_z - (J_x-J_y) \\delta_y (\\omega_0 + \\delta_x) = 0. \n\\end{aligned}\n\\right.]\n\nРаскрывая скобки и пренебрегая произведениями малых отклонений (малыми второго порядка), получим:\n\n[\\left{\n\\begin{aligned}\n\t&amp; J_x \\dot \\delta_x = 0, \n\t&amp; J_y \\dot \\delta_y - (J_z-J_x) \\delta_z \\omega_0 = 0, \n\t&amp; J_z \\dot \\delta_z - (J_x-J_y) \\delta_y \\omega_0 = 0. \n\\end{aligned}\n\\right.]\n\nИз 1-го уравнения следует, что\n\n[\\delta_x = \\text{const}.]\n\nИз 2-го и 3-го уравнений можно получить два независимых линейных дифференциальных уравнения второго порядка:\n\n[J_y \\ddot \\delta_y - \\omega_0^2 \\frac{(J_z-J_x) (J_x-J_y)}{J_z}\\delta_y = 0.]\n\n[J_z \\ddot \\delta_z - \\omega_0^2 \\frac{(J_z-J_x) (J_x-J_y)}{J_y}\\delta_z = 0.]\n\nВид решений последних двух линейных дифференциальных уравнений зависит от знака множителя при \\(\\delta_y\\) и \\(\\delta_z\\). При \\(J_z&lt;J_y&lt;J_x\\):\n\n[\\omega_0^2 \\frac{(J_x-J_z) (J_x-J_y)}{J_y J_z} &gt; 0,]\n\nследовательно решения будут иметь вид:\n\n[\\delta_y = a_y \\sin (\\lambda t + \\varepsilon_y), \\quad \\delta_z = a_z \\sin (\\lambda t + \\varepsilon_z)]\n\nТ.е. отклонения \\(\\delta_y\\) и \\(\\delta_z\\) не будут возрастать и вращение вокруг оси \\(Cx\\) будет устойчивым. Подобным образом показывается устойчивость вращения тела вокруг главной оси с минимальным моментом инерции \\(Cz\\).\n\nВращение вокруг оси с промежуточным значением момента инерции\n\nТеперь предположим, что тело вращается вокруг оси \\(Cy\\) с промежуточным значением момента инерции. Рассмотрим устойчивость такого движения при небольших возмущениях проекций угловой скорости:\n\n[\\omega_x = \\delta_x, \\; \\ \\omega_y = \\omega_0+\\delta_y, \\; \\omega_z = \\delta_z.]\n\nУравнения движения тела имеют вид:\n\n[\\left{\n\\begin{aligned}\n\t&amp; J_x \\dot \\delta_x - (J_y-J_z) (\\omega_0 + \\delta_y) \\delta_z = 0, \n\t&amp; J_y \\dot \\delta_y - (J_z-J_x) \\delta_z \\delta_x = 0, \n\t&amp; J_z \\dot \\delta_z - (J_x-J_y) \\delta_x (\\omega_0 + \\delta_y) = 0. \n\\end{aligned}\n\\right.]\n\nПренебрегая малыми второго порядка, получим:\n\n[\\left{\n\\begin{aligned}\n\t&amp; J_x \\dot \\delta_x - (J_z-J_x) \\delta_z \\omega_0 = 0, \n\t&amp; J_y \\dot \\delta_y = 0, \n\t&amp; J_z \\dot \\delta_z - (J_x-J_y) \\delta_x \\omega_0 = 0. \n\\end{aligned}\n\\right.]\n\nИз 2-го уравнения следует: \\(\\delta_y = \\text{const}\\). Из 1-го и 3-го уравнений:\n\n[\\ddot \\delta_x + \\omega_0^2 \\frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} \\delta_x = 0.]\n\n[\\ddot \\delta_z + \\omega_0^2 \\frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} \\delta_z = 0.]\n\nПри \\(J_z&lt;J_y&lt;J_x\\):\n\n[\\omega_0^2 \\frac{(J_z-J_y) (J_x-J_y)}{J_x J_z} &lt; 0,]\n\nследовательно решения для возмущений будут иметь вид:\n\n[\\delta_x = C_1 e^{\\lambda t} + C_2 e^{- \\lambda t}, \\quad \\delta_y = C_3 e^{\\lambda t} + C_4 e^{- \\lambda t}]\n\nМы видим, что возмущения неограниченно возрастают, поэтому вращение вокруг оси \\(y_2\\) будет неустойчиво.\n\nПолученные уравнения показывают только устойчивость или неустойчивость движения твердого тела при вращении вокруг одной из собcтвенных осей и не описывают само движение при перевороте гайки. Среда моделирования SimInTech позволит нам не только убедиться в неустойчивости движения вокруг оси с промежуточным моментом инерции, построив графики изменения угловой скорости гайки, но и “увидеть” это движение при помощи модуля 3D-визуализации.\n\nМодель\n\nОбщий вид модели в SimInTech показан на рисунке 3.\n\n\n\nРисунок 5 - Модель\n\nГлавным блоком модели вляется новый блок “Гайка (XZ’X’’)”, созданный на основе субмодели. Этот блок может использоваться для моделирования движения твердого тела вокруг центра масс в углах Эйлера. На вход блока подаётся вектор внешнего момента, который в этой задаче равен нулю, и массив значений главных моментов инерции объекта-гайки. Выходными сигналами блока являются вектор проекций угловой скорости гайки на собственные оси [wx, wy, wz] и вектор углов поворота связанной с гайкой системы координат по отношению к неподвижной системе. Угловое положение системы координат, связанной с гайкой, определяется углами Эйлера последовательности поворотов XZ’X’’. Структура блока показа на следующем рисунке:\n\n\n\nРисунок 6 - Модель блока “Гайка (XZ’X’’)”\n\nВ блоке “Гайка (XZ’X’’)” используются блоки-интеграторы, начальные условия которых (начальная угловая скорость и начальные значения углов Эйлера) заданы в свойствах блока “Гайка (XZ’X’’)”:\n\n\n\nРисунок 7 - Свойства блока “Гайка (XZ’X’’)”\n\nДля того, чтобы добавить эти свойства к субмодели необходимо перевести SimInTech в режим разработчика (Меню “Вид” - “Режим разработчика”), в общих свойствах субмодели “Гайка” указать новое наименование типа блока, теперь это не “стандартная” субмодель, а блок типа “ТвердоеТело131”. Таким образом на основе субмодели создается новый блок со своими уникальными свойствами.\n\n\n\nРисунок 8 - Задание типа блока\n\nБлок динамических уравнений\n\nВ блоке “Динамические уравнения” в явном виде на встроенном языке программирования записываются динамические уравнения Эйлера в проекциях на главные центральные оси тела:\n\n[\\left{\n\\begin{aligned}\n\t&amp; J_x \\dot \\omega_x - (J_z-J_x) \\omega_y \\omega_z = M_x, \n\t&amp; J_y \\dot \\omega_y - (J_z-J_x) \\omega_z \\omega_x = M_y, \n\t&amp; J_z \\dot \\omega_z - (J_x-J_y) \\omega_x \\omega_y = M_z. \n\\end{aligned}\n\\right.]\n\nВ рассматриваемом случае движение тела происходит “по-инерции”, поэтому все проекции внешнего момента на собственные оси равны нулю \\(M_x = M_y = M_z = 0\\). Ниже приведен код блока “динамические уравнения” (блок “Язык программирования” из раздела “Динамические”):\n\n// Динамические уравнения Эйлера \n// в главных центральных осях\n// Входы :\n// Torque - Вектор момента в главных центральных осях [Нм]\n// J      - Главные моменты инерции [кгм2]\n// w      - угловые скорости в проекциях на главные оси [1/с]\ninput Torque[3], J[3], w[3];\n// Выходы :\n// dw     - Вектор угловых ускорений [1/с2]\noutput dw[3];\n\ndw[1] = (Torque[1]+(J[2]-J[3])*w[2]*w[3])/J[1];\ndw[2] = (Torque[2]+(J[3]-J[1])*w[3]*w[1])/J[2];\ndw[3] = (Torque[3]+(J[1]-J[2])*w[1]*w[2])/J[3];\n\n\nНа вход блока подаётся вектор проекций угловой скорости тела, на выходе получается вектор проекций угловых ускорений тела (правая часть дифференциальных уранвений).\n\nБлок кинематических уравнений\n\nКинематические уравнения связывают производные параметров, определяющих ориентацию базиса, связанного с твердым телом по отношению к неподвижному базису, с проекциями угловых скоростей. В рассматриваемой задаче используется система углов Эйлера последовательности XZ’X’’, т.е. из исходного положения, когда связанный с телом базис совпадает с неподвижным базисом, угловое положение первого определяется тремя последовательными поворотами:\n\n\n  вокруг оси \\(Cx_2\\) на угол прецессии \\(\\psi\\);\n  вокруг оси \\(Cz_2\\) на угол нутации \\(\\vartheta\\);\n  вокруг оси \\(Cx_2\\) на угол собственного вращения \\(\\varphi\\).\n\n\n\n\nРисунок 9 - Углы XZ’X’’\n\nКинематические уравнения для рассматриваемой последовательности поворотов:\n\n[\\left{\n\\begin{aligned}\n\\dot \\psi &amp; = \\frac{\\omega_z \\sin \\varphi - \\omega_y \\cos \\varphi}{\\sin \\vartheta}, \n\\dot \\vartheta &amp; = \\omega_z cos \\varphi + \\omega_y \\sin \\varphi, \n\\dot \\varphi &amp; = \\omega_x + \\frac{\\omega_y \\cos \\varphi - \\omega_z \\sin \\varphi}{\\tan \\vartheta} \n\\end{aligned}\n\\right.]\n\nБлок кинематических уравнений написан также на встроенном языке программирования (блок “Язык программирования” из раздела “Динамические”):\n\n// Кинематические уравнения для последовательности поворотов 131\ninput  w[3], a[3];\noutput da[3];\n\nda[1] = (w[3]*sin(a[3])-w[2]*cos(a[3]))/sin(a[2]);\nda[2] = w[3]*cos(a[3])+w[2]*sin(a[3]);\nda[3] = w[1]+w[2]*cos(a[3])/tg(a[2])-w[3]*sin(a[3])/tg(a[2]);\n\n\nПереход от углов последовательности 131 к углам последовательности 232\n\nВ модуле 3D-визуализации SimInTech ориентация объекта в пространстве также задается тремя углами Эйлера, определяющими ориентацию связанного с телом базиса по отношению к неподвижному базису, но используется последовательность YZ’Y’‘, т.е. первый поворот выполняется вокруг оси Y на угол прецессии, второй поворот вокруг новой оси Z (поэтому она обозначается как Z’) на угол нутации и третий поворот  на угол собственного вращения вокруг оси Y’’.\n\nК сожалению, в справке описан только этот способ определения ориентации тела в модуле 3D-визуализации, поэтому если в разрабатываемой модели используется другой набор углов, как в рассматриваемом случае, или вместо углов используются катернионы или направляющие косинусы, то для визуализации движения необходимо выполнять пересчет используемых параметров в углы последовательности YZ’Y’’.\n\nДля преобразования одного набора углов Эйлера в другой используется субмодель “Углы 131 в 232”, структура которой показана на следующем рисунке.\n\n\n\nРисунок 10 - Блок преобразования углов последовательности XZ’X’’ в последовательность YZ’Y’’\n\nНа вход субмодели поступает массив (вектор) углов последовательности XZ’X’’ (или 131). Внутри субмодели по значениям углов формируются матрицы поворота вокруг оси X на угол прецессии:\n\n[A_x(\\psi) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; \\cos \\psi &amp; -\\sin \\psi \\ 0 &amp; \\sin \\psi &amp; \\cos \\psi \\end{bmatrix}]\n\nвокруг оси Z на угол прецессии:\n\n[A_z(\\vartheta) = \\begin{bmatrix} \\cos \\vartheta &amp; -\\sin \\vartheta &amp; 0 \\ \\sin \\vartheta &amp; \\cos \\vartheta &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{bmatrix}]\n\nи вокруг оси X на угол собственного вращения\n\n[A_x(\\varphi) = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; \\cos \\varphi &amp; -\\sin \\varphi \\ 0 &amp; \\sin \\varphi &amp; \\cos \\varphi \\end{bmatrix}]\n\nМатрицы перемножаются в прямом порядке:\n\n[A = A_x(\\psi) \\cdot A_z(\\vartheta) \\cdot A_x(\\varphi)]\n\nВ результате перемножения трех матриц элементарных поворотов получается матрица направляющих косинусов базиса связанного с телом по отношению к неподвижному базису.\n\nМатрица направляющих косинусов поступает на вход субмодели DCM-A232, которая написана на встроенном языке программирования. В субмодели определяются углы последовательности 232 по элементам полученной матрицы направляющих косинусов. Ниже приведён код субмодели DCM-A232:\n\n// Вычисление углов последовательности 232\n// по элементам матрицы направляющих косинусов\ninput  u[3,3];\noutput a[3];\n\n// Для каждого угла есть два решения\na21 =  arccos(u[2,2]);\na22 =  2*pi-a21;\n\na31 =  atan2(u[2][3]/sin(a21),u[2][1]/sin(a21));\na32 =  atan2(u[2][3]/sin(a22),u[2][1]/sin(a22));\n\na11 =  atan2(u[3][2]/sin(a21),-u[1][2]/sin(a21));\na12 =  atan2(u[3][2]/sin(a22),-u[1][2]/sin(a22));\n\n// Выбираем первое... \na[1] = a11;\na[2] = a21;\na[3] = a31;\n\n\nНайденные углы передаются на выход субмодели “Углы 131 в 232”. С выхода  значения углов записываются в базу сигналов: переменные A1, A2, A3 соответсенно, которые были предварительно объявленны в редакторе сигналов (меню “Сервис” → “Сигналы”):\n\n\n\nРисунок 11 - Сигналы A1, A2, A3\n\nДля записи сигналов используется блок “Запись в список сигналов”:\n\n\n\nРисунок 12 - Свойства блока “Запись в список сигналов”\n\nСкрипт модели\n\nВ скрипте модели в блоке инициализации задаются значения главных моментов инерции гайки, создается окно 3D-визуализации, загружается объект - гайка из файла screw.stl.\n\n\n\nРисунок 13 - Редактор скрипта модели\n\nВне блока инициализации записаны две строчки кода, которые будут вызываться на каждом шаге интегрирования. Функция Viewer3DSetLCSAngles поворачивает гайку на углы Эйлера, полученные на шаге интегрирования, функция Viewer3DSetLCSPosition перемещает центр масс гайки вдоль оси x имитируя её движение после схода с винта.\n\ninitialization\n     var Jx = 2000;\n     var Jy = 4000;\n     var Jz = 6000;\n\n     Id  = Viewer3DCreate;\n     OId = Viewer3DPlotObject(Id, 0, 4, [0, 0, 0], [0, 0, 0], \"screw.stl\");\n     Viewer3DShowObjectAxes(Id, OId, true);    \nend\n\nViewer3DSetLCSAngles(Id, OId, A1*180/pi, A2*180/pi, A3*180/pi);\nViewer3DSetLCSPosition(ID, oID, -0.2+0.05*time, 0, 0);\n\n\nПеред запуском модели необходимо в настройках “Параметры расчета” на закладке “Синхронизация” поставить галочку “Синхронизировать с реальным временем”.\n\n\n\n\n\nРисунок 14 - Синхронизация скорости расчёта с реальным временем\n\nПосле запуска модели появится окно “Модуль 3D Визуализации SimInTech”, в котором будет показано движение гайки. Графики изменения проекций вектора угловой скорости гайки на собственные оси показаны на рисунке 15.\n\n\n\nРисунок 15 - Угловые скорости гайки\n\nСсылки\n\n\n  Й. Виттенбург, Динамика систем тел, М.: Наука, 1980.\n  Gregory G. Slabaugh. Computing Euler angles from a rotation matrix\n\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2022-12-04-simintech-janibekov/"
    },{
      "image": "/assets/img/blog/simintech-jump/title.png",
      "title": "Модель движения летающего стенда возвращаемой ступени РН в SimInTech",
      "date": "2023-03-17 00:00:00 -0500",
      "description": "Модель иллюстрирует движение летающего стенда для отработки мягкой посадки первой ступени многоразовой ракеты-носителя. При помощи подобного летающего стенда компания SpaceX начиная с 2012 года отрабатывала технологию  посадки возвращаемой ступени РН Falcon-9.\n",
      "content": "\n  Схема системы\n  Уравнения движения\n  Модель SimInTech    \n      Структура модели\n      Субмодель динамической модели ступени\n      Блок управления тягой\n      Блок управления углом поворота сопла\n      Блок, задающий программное изменение высоты\n      Блок, задающий программное изменение бокового смещения\n      Скрипт модели\n      Графики\n      ЗD Визуализация\n      Результаты\n    \n  \n\n\nСхема системы\n\nСхема системы показана на рисунке 1. Движение стенда (далее ступень) рассматривается относительно инерциальной системы координат \\(O X_o Y_o\\), связанной с землей. Положение ступени определяется координатами центра масс \\(x\\) (высота), \\(y\\) и углом наклона ступени \\(\\theta\\) к вертикали.\n\n\n\nРисунок 1 - Схема системы\n\nДвижение ступени происходит под действием силы тяжести \\(G\\), приложенной в центре масс, силы тяги двигателя \\(P\\), приложенной в точке \\(p\\), и аэродинамической силы \\(F_a\\), которая приложена в точке \\(a\\) (центр давления). Аэродинамическая сила представлена в виде суммы продольной \\(X_a\\) и поперечной \\(Y_a\\) составляющих. Направление силы тяги относительно продольной оси ступени определяется углом поворота сопла двигателя \\(\\gamma_p\\).\n\nУравнения движения\n\nУравнения движения ступени построены при следующих допущениях:\n\n  Рассматривается действие на ступень только поперечной аэродинамической силы \\(Y_a\\), которая будет определяться горизонтальной скоростью ступени и скоростью ветра.\n  Положение точки приложения аэродинамической силы не изменяется относительно корпуса ступени при развороте ступени: \\(ba = x_a\\) const. Также не изменяется в процессе движения момент инерции ступени и положение её центра масс относительно корпуса (\\(bC = = x_c\\) const).\n  Полет происходит на небольшой высоте, гравитационное ускорение остается постоянным.\n  Не учитывается действие на ступень газодинамических сил от струй двигателя, отражающихся от поверхности земли, при движении на небольшой высоте.\n  Динамические свойства системы управления тягой двигателя и вектором тяги не учитываются.\n\n\nВертикальное движение ступени определяется тягой двигателя и силой притяжения Земли. Уравнение вертикального движения имеет вид:\n\n[m \\ddot{x} = P \\cos(\\theta + \\gamma_p) - G + Y_a \\sin \\theta]\n\nгде \\(G = m g\\) – вес ступени, \\(g\\) – ускорение свободного падения, \\(m\\) – масса ступени, \\(P\\) – тяга двигателя, \\(Y_a\\) – аэродинамическая сила:\n\n[Y_a = S_m C_y \\frac{\\rho (\\dot y - w)^2}{2} \\text{sgn}(\\dot y - w)]\n\nгде \\(S_m\\) – характерная площадь ступени (площадь Миделя), к которой отнесен аэродинамический коэффициент поперечной силы  \\(C_y\\), \\(w\\) – скорость ветра, \\(\\dot y\\) – горизонтальная скорость ступени, \\(\\rho\\) – плотность воздуха.\n\nГоризонтальное движение ступени описывается уравнением:\n\n[m \\ddot{y} = P \\sin(\\theta + \\gamma_p) - Y_a \\cos \\theta]\n\nУравнение движения ступени вокруг центра масс:\n\n[J_z \\ddot{\\theta} = P (x_c-x_p) \\sin \\gamma_p  - Y_a (x_a-x_c)]\n\nгде \\(x_a\\) – координата x точки приложения аэродинамической силы в базовой системе координат \\(b x_b y_b\\) ступени, \\(x_p\\) – координата x точки приложения силы тяги ступени в базовой системе координат, \\(x_c\\)  – координата x центра масс ступени в базовой системе координат, \\(J_z\\) – поперечный момент инерции ступени.\n\nУравнения движения ступени интегрируются совместно с дифференциальным уравнением изменения массы при расходе топлива:\n\n[\\frac{dm}{dt} = - \\frac{P}{I_s}]\n\nгде \\(I_s\\) – удельный импульс двигателя ступени [м/c].\n\nМодель SimInTech\n\nСтруктура модели\n\nМодель SimInTech состоит из четырех блоков (субмоделей):\n\n  блок динамической модели ступени – “Попрыгунчик”;\n  блок управления тягой двигателя;\n  блок управления углом поворота сопла;\n  блок, задающий программное изменение высоты;\n  блок, задающий программное изменение бокового смещения ступени.\n\n\n\n\nРисунок 2 - Общий вид модели\n\nСубмодель динамической модели ступени\n\nДинамическая модель ступени создана на основе стандартного блока “Субмодель” с дополнительными свойствами (момент инерции, аэродинамический коэффициент, …). В созданной субмодели используется блок “Язык программирования”, в котором записаны дифференциальные уравнения движения ступени, используя встроенный язык программирования SimInTech. Интегрирование уравнений производится при помощи стандартных блоков типа “Интегратор”. На вход субмодели подаются сила тяги двигателя \\(P\\), угол поворота сопла \\(\\gamma_p\\) и скорость горизонтального ветра \\(W\\). Выходы субмодели: кинематические параметры ступени (положение и скорость центра масс, угол поворота ступени, её угловя скорость).\n\n\n\nРисунок 3 - Структура субмодели “Попрыгунчик”\n\nДля построения графиков и упрощения экспорта результатов моделирования в текстовый файл (таблица значений кинематических параметров) в проекте используются сигналы.\n\n\n\nРисунок 4 - Сигналы проекта\n\nЗначения в базу сигналов записываются с линий связи субмодели “Попрыгунчик”. Сигналы связываются со значениями с линий связи субмодели при помощи редактора связей\n\n\n\nРисунок 5 - Редактор связей\n\nКод блока “Язык программирования” – дифференциальные уравнения:\n\n// Плоская модель движения возвращаемой ступени\n// для отработки посадки\n// \"Попрыгунчик\"\n// m       - масса\n// P       - тяга\n// w \t   - горизонтальная скорость ветра\n// gamma_p - угол поворота сопла\n// dx, dy  - вертикальная и горизонтальная скорость\n// theta   - угол наклона ступени\n// dtheta  - угловая скорость ступени\n// rho     - плотность воздуха\n\ninput  m, P, w, gamma_P, dx, dy, theta, dtheta, rho;\noutput d2x, d2y, d2theta, Fa;\n\n// Аэродинамическая сила\nFa  = 0.5*rho*(w-dy)^2*Cy*Sm*sign(w-dy); \n// Плечо аэродинамической силы\nha  = xa-xc; \n// Плечо силы тяги\nhp  = xc-xp; \n// Уравнения\nd2x     = ( p*cos(theta+gamma_p)-m*g + Fa*sin(theta) )/m;\nd2y     = ( p*sin(theta+gamma_p)-Fa*cos(theta) )/m;\nd2theta = (-p*sin(gamma_p)*hp-Fa*ha )/Jz; \n\n\nПараметр \\(g\\) – ускорение свободного падения, объявлена в блоке инициализации модели. Другие параметры,  используемые в скрипте блока (Sm, Cy, xc, xp, xa) определены в свойствах субмодели “Попрыгунчик”:\n\n\n\nРисунок 6 - Параметры субмодели “Попрыгунчик”\n\nДля того, чтобы добавить эти свойства к субмодели необходимо перевести SimInTech в режим разработчика (Меню “Вид” - “Режим разработчика”), в общих свойствах субмодели указать новое наименование типа блока, теперь это не “стандартная” субмодель, а блок типа “TJumpStage”. Процедура создания блоков на основе субмоделей описана в справочной системе SimInTech.\n\nБлок управления тягой\n\nУчитывая, что ступень движется с небольшой вертикальной скоростью, тяга двигателя будет близка к весу ступени \\(G\\). Используемый в блоке управления тяги ПД-регулятор вычисляет “добавку” к этому весу. В блоке управления тягой сравнивается фактическая высота ступени \\(x\\) с программным значением высоты \\(x_p\\) и на основе этой разницы (ошибки) формируется значение тяги:\n\n[P = G + k_1 e_x + k_2 \\dot e_x]\n\nгде \\(e_x = x_p - x\\).\n\n\n\nРисунок 7 - Структура блока управления тягой двигателя\n\nБлок управления углом поворота сопла\n\nГоризонтальное движение ступени производится за счет наклона её корпуса. Для наклона корпуса используется момент относительно центра масс, создаваемый тягой двигателя при ненулевом угле поворота сопла \\(\\gamma_p\\). В блоке управления углом поворота сопла при возникновении разницы между программным значением горизонтальной координаты ступени \\(y_p\\) и фактическим значением \\(y\\) определяется угол наклона ступени при помощи ПД-регулятора:\n\n[\\theta_{PD} = k_3 e_y - k_4 \\dot e_y, \\quad e_y = y_p-y]\n\nПри этом максимальный угол поворота ступени ограничивается некоторым предельным значением \\(\\theta_{max}\\):\n\n[\\theta_p = \n\\begin{cases}\n\\theta_{PD} &amp; |\\theta_{PD}| \\leq \\theta_{max} \n\\theta_{max} &amp; |\\theta_{PD}| &gt; \\theta_{max}\n\\end{cases}]\n\nПолученное значение угла поворота ступени используется как программное значение \\(\\theta_p\\), которое на следующем этапе сравнивается с текущим значением угла \\(\\theta\\). Разница между программным и фактическим значением поступает на вход ПИД-регулятора, который формирует сигнал угла поворота сопла двигателя. Этот угол также ограничен некоторым предельным значением:\n\n[\\gamma_{PID} = k_5 e_{\\theta} + k_6 \\dot e_{\\theta} + k_7 \\int_0^t \\dot e_{\\theta} d \\tau, \\quad e_{\\theta} = \\theta_p-\\theta]\n\n[\\gamma_p = \n\\begin{cases}\n\\gamma_{PID} &amp; |\\gamma_{PID}| \\leq \\gamma_{max} \n\\gamma_{max} &amp; |\\gamma_{PID}| &gt; \\gamma_{max}\n\\end{cases}]\n\nНа вход блока управления углом поворота сопла также поступает горизонтальная скорость блока. При превышении горизонтальной скорости некоторого предельного значения программное значение угла наклона ступени становится равным нулю.\n\n\n\nРисунок 8 - Структура блока управления углом поворота сопла\n\nБлок, задающий программное изменение высоты\n\nПрограмма управления высотой имеет вид:\n\n[x_p = \\frac{h_{max}}{2} \\left[ 1 + \\sin \\left( \\frac{2\\pi}{t_k}t+\\frac{3 \\pi}{2} \\right) \\right]]\n\nгде \\(t_k\\) – конечное время, \\(h_{max}\\) – максимальная высота.\n\n\n\nРисунок 9 - Структура блока, задающего программное значение высоты\n\nБлок, задающий программное изменение бокового смещения\n\nПрограмма управления боковым перемещение ступени определяется выражением:\n\n[y_p = \n\\begin{cases}\n0, &amp; t&lt;t_1 \n\\frac{y_k}{2} \\left[ \\sin( \\frac{t-t_1}{t_2-t_1}\\pi-\\frac{\\pi}{2})+1 \\right], &amp; t_1 \\leq t \\leq t_2 \n0, &amp; t&gt;t_2\n\\end{cases}]\n\nгде \\(t_1 = \\Delta t_v\\) – продолжительность вертикального участка при взлете ступени, \\(t_2\\) - t_{k} - \\Delta t_v \\(начало вертикального участка спуска ступени,\\) t_k \\(-- конечное время (продолжительность полета),\\) y_k $$ – расстояние от точки взлета до точки посадки.\n\nЭто программа управления задается в блоке “Язык программирования”:\n\n// Горизонтальное перемещение\noutput y_p;\n// Начало участка вертикального спуска\nt2 = endtime-t_vert;\n// Горизонтальное перемещение\nyend = y_end;\n                          \n// Вертикальный участок\nif time&lt;=t_vert then y_p = 0;\n// Участок горизонтального перемещения\nif time&gt;t_vert and time&lt;=t2 then y_p = (sin((time-t_vert)*pi/(t2-t_vert)-pi/2)*0.5+0.5)*yend;\nif time&gt;t2 then y_p = yend;\n\n\nСкрипт модели\n\nВ скрипте модели объявляются переменные, используемые в коде и свойствах блоков.\n\ninitialization\n\t// Максимальный угол поворота сопла\n\tvar gamma_max = 4*pi/180;\n\t// Максимальный угол наклона ступени\n\tvar theta_max = 4*pi/180;\n\t// Продолжительность вертикального участка\n\tvar t_vert    = 10;\n\t// Максимальная горизонтальная скорость ступени\n\tvar v_hor_max = 10;\n\t// Горизонтальное перемещение ступени \n\tvar y_end     = 150;\n\t// Максимальная высота подъема ступени\n\tvar h_max     = 50; \nend\n\n\nГрафики\n\nДля того, чтобы не загромождать модель блоками типа “Временной график” для построения графиков используется менеджер данных:\n\n\n\nРисунок 10 - Менеджер данных\n\nЗD Визуализация\n\nДля визуализации движения блока средствами SimInTech используются блоки из раздела Визуализация 3D – блоки типа “Просмотрщик” и “Объект”. Один из блоков “Объект” отображает ступень, второй – поверхность неподвижной земли.\n\n\n\nРисунок 11 - Визуализация 3D - Просмотрщик\n\nСвойства блока “Объект”, используемого для отображения ступени показаны на рисунке 12. Положение объекта задается выражениями, записанными при помощи сигналов x, y и theta.\n\n\n\nРисунок 12 - Свойства блока “Объект” для отображения ступени\n\nРезультаты\n\nДалее приведены результаты моделирования движения ступени. В соответствии с программой полета ступень поднимается на максимальную высоту 50 метров. Посадка ступени производится на расстоянии 150 метров от места взлета. На рисунке 12 показаны графики изменения высоты и горизонтального перемещения ступени.\n\n\n\nРисунок 13 -  Изменение высоты и горизонтального перемещения ступени\n\nНа рисунке 13 показаны графики изменения вертикальной и горизонтальной скорости ступени.\n\n\n\nРисунок 14 -  Изменение вертикальной и горизонтальной скорости ступени\n\nНа рисунке 15 показаны графики изменения угла поворота ступени и угла поворота сопла двигателя. На рисунке можно увидеть реакцию ступени на воздействие горизонтального ветра.\n\n\n\nРисунок 15 -  Угол наклона ступени и угол поворота сопла\n\nВидеоиллюстрация результата моделирования движения ступени (Blender 3D):\n\n\n\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2023-03-17-jump/"
    },{
      "image": "/assets/img/db/student-vkr-er-1.png",
      "title": "Анализ предметной области и создание таблиц на примере базы данных с информацией о выпускных работах",
      "date": "2023-04-15 00:00:00 -0500",
      
      "content": "Пример создания таблиц базы данных с информацией о выпускных квалификационных работах.\n",
      "categories": ["database"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/database/2023-04-15-ddl-sql-example/"
    },{
      
      "title": "Определение момента сопротивления в шарнире физического маятника",
      "date": "2023-04-21 00:00:00 -0500",
      "description": "Determining the friction torque in the pivot point of a physical pendulum through measuring the time it takes to swing from an initial angle until it comes to a halt. Implementing numerical methods to simulate the dynamics of a physical pendulum in Python.\n",
      "content": "Оценка постоянного момента сопротивления в оси вращения физического маятника по продолжительности его колебаний из некоторого начального положения до полной остановки. Численное интегрирование движения физического маятника в среде Python.\n\nПостановка задачи\n\nРассмотрим движение физического маятника с известной массой \\(m\\), моментом инерции относительно оси вращения \\(J\\) и расстоянием от оси вращения до центра масс \\(l\\). Маятник совершает плоские колебания в вертикальной плоскости. В оси вращения маятника «О» действует малый постоянный момент сопротивления \\(M\\).\n\n\n\nПредположим, что нам неизвестен момент сопротивления \\(M\\) и этот момент необходимо определить из эксперимента, оценив продолжительность затухания колебаний маятника при движении и заданного начального положения, определяемого углом \\(\\varphi_0\\).\n\nУравнения движения\n\nЗапишем уравнение малых колебаний маятника:\n\n[J \\ddot{\\varphi} = - m g l \\varphi - M \\text{sgn} (\\varphi)]\n\nРассмотрим движение маятника в течение половины периода из начального положения \\(\\varphi = \\varphi_0 &lt; 0\\) при \\(\\dot \\varphi &gt; 0\\). На этом интервале направление действия момента сопротивления не изменяется, поэтому уравнение движения можно записать в следующем виде:\n\n[\\ddot \\varphi = -k^2  \\varphi - f,]\n\nгде\n\n[k^2 = \\frac{mgl}{J}, \\quad f = \\frac{M}{J}]\n\nРешение этого линейного неоднородного уравнения определяется как:\n\n[\\varphi =  \\left(\\frac{f}{k^2} + \\varphi_0\\right) \\cos ⁡kt - \\frac{f}{k^2}]\n\nЗная период колебаний маятника:\n\n[T = \\frac{2 \\pi}{k} = 2 \\pi \\sqrt{\\frac{J}{mgl}},]\n\nопределим угол поворота маятника через половину периода:\n\n[\\varphi(T/2) = \\varphi(\\pi/k) = - \\varphi_0 - 2 \\frac{f}{k^2}]\n\nУчитывая, что в начальный момент \\(\\varphi_0 &lt; 0\\), амплитуда колебаний маятника за половину периода уменьшится на \\(\\Delta A(T/2)= 2f/k^2\\), а за весь период – на \\(\\Delta A(T) = 4f/k^2\\). Средняя скорость уменьшения амплитуды колебаний равна:\n\n[\\frac{\\Delta A(T)}{T} = \\frac{4f}{k^2 T}]\n\nТеперь можно оценить продолжительность затухания колебаний маятника:\n\n[t_d = \\frac{\\varphi_0}{\\Delta A(T)} T = \\frac{\\varphi_0 k^2}{4f} T = \\frac{\\sqrt{mglJ}}{2M} \\pi \\varphi_0]\n\nПостоянный момент сопротивления \\(M\\) в шарнире при известной продолжительности затухания колебаний:\n\n[M = \\frac{\\sqrt{mglJ}}{2t_d} \\pi \\varphi_0.]\n\nЧисленное интегрирование и “проверка” формулы\n\nЧисленно проинтегрируем в среде Python уравнение движения нелинейного маятника (без допущения о малости его колебаний) для проверки полученной формулы.\n\nПодключаемые библиотеки:\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom dataclasses import dataclass\nimport matplotlib.pyplot as plt\n\n\nОбъявляем гладкую функцию для аппроксимации функции модуля, которая в малой окрестности нуля (“малость” этого интервала зависит от параметра n) плавно изменяется от минус 1 до 1:\n\ndef sigmoid(x):\n    if not hasattr(x, '__iter__'):\n        x = (x,)\n    n = 500\n    return [np.sign(xi) if np.abs(xi) &gt;= 1 else 2.0/(1.0+np.exp(-2*n*xi/(1-xi*xi)))-1 for xi in x]\n\n\nФункция правых частей дифференциальных уравнений\n\ndef dqdt(t, q, p):  \n    phi  = q[0]\n    dphi = q[1]\n    d2phi = - (p.m*p.g*p.l/p.J)*np.sin(phi) - p.M*np.sign(dphi)/p.J\n    return np.hstack([dphi,d2phi])\n\n\nОбъявляем тип на основе dataclass для хранения параметров системы:\n\n@dataclass\nclass Data:\n    # Масса маятника\n    m : float = 100;\n    # Расстояние от точки подвески до центра масс (от оси вращения)\n    l : float = 0.5;\n    # Момент инерции маятника относительно оси вращения\n    J : float =  100*0.5**2/3    \n    # Момент сопротивления\n    M : float = 3\n    # Ускорение свободного падения\n    g : float = 9.807\n\n# Создаем экземпляр класса Data (объект)\np = Data()\n\n\nЧисленно интегрируем уравнение движения маятника методом Рунге-Кутты с начальным углом отклонения маятника 20 градусов:\n\nq0 = [np.deg2rad(20),0]\nsol = solve_ivp(lambda t,q: dqdt(t,q,p), [0,13], q0, method='RK45', rtol = 1e-8)\n\n\nПостроим график изменения угла поворота маятника:\n\nplt.plot(sol.t,np.rad2deg(sol.y[0]))\nplt.grid(ls=':')\nplt.xlabel('t, c')\nplt.ylabel('Угол поворота, градус')\n\n\n\n\nИз графика следует, что колебания затухают приблизительно через 11,5 секунд. Оценим момент трения по выведенной ранее формуле:\n\nnp.sqrt(p.m*p.g*p.l*p.J)*np.pi*q0[0]/(2*11.5)\n\n&gt; 3.047837910536908\n\n\nПолучилось 3.05 Нм. Эта оценка отличается от значения, заданного при интегрировании (3 Нм) менее чем на 2 %.\n\nЛитература\n\n\n  Гладков Сергей Октябринович, Богданова Софья Борисовна К вопросу учета силы сопротивления в шарнирной точке крепления физического маятника и ее влияние на динамику движения // Известия вузов. ПНД. 2019. №1.\n  Mungan C. E., Lipscombe T. C. Simple pendulum with speed-independent bearing friction //European Journal of Physics. – 2022. – Т. 43. – №. 4. – С. 045001. DOI 10.1088/1361-6404/ac646a.\n\n\n",
      "categories": ["mechanics","python"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/python/2023-04-21-friction-torque/"
    },{
      "image": "/assets/img/fairing/fairing-frontpage.png",
      "title": "Модель отделения головного обтекателя ракеты-носителя в SimInTech",
      "date": "2023-09-08 00:00:00 -0500",
      "description": "SimInTech complex model of the separation process of the fairing leaves of the launch vehicle.\n",
      "content": "\n  Математическая модель    \n      Уравнения движения        \n          Принятые допущения\n          Кинематические соотношения\n          Силы и моменты\n          Уравнение движения            \n              Первый этап движения\n              Второй этап движения\n            \n          \n          Изменение давления в полости толкателя\n        \n      \n    \n  \n  Модель SimInTech    \n      База данных сигналов\n      Проект “Пневмосистема”\n      Проект “Створка ГО”\n    \n  \n  Результаты моделирования\n  Список источников\n\n\nГоловной обтекатель (ГО) – это элемент конструкции ракеты-носителя (РН), предназначенный для защиты полезного груза от внешних тепловых и аэродинамических нагрузок при транспортировке полностью собранной ракеты-носителя или космической головной части к стартовому столу и во время полёта ракеты-носителя в плотных слоях атмосферы. После прохождения плотных слоев производится сброс ГО, поскольку он становится бесполезной массой.\n\nГО, как правило, собирается из двух половинок - створок, на которые и он разделяется перед отделением. Для отделения створок используется два способа, отличающиеся характером движения створок: отделение с разворотом створок и отделение без разворота створок. В первом случае каждая створка шарнирно связывается с переходным отсеком РН и после разделения ГО на створки выполняется разворот створок при помощи пружинных или пневматических толкателей. После разворота на некоторый заданный угол створки отделяются от РН. Пример схемы узла вращения, освобождающем створку после разворота на заданный угол приведен в патенте [1]).\n\n\n\nРисунок 1 - Отделение створок ГО с разворотом\n\nВо втором случае створки отделяются в поперечном направлении также под действием толкателей, но уже без разворота и движутся почти поступательно относительно РН после разделения. Такая схема используется для отделения створок ГО РН “Falcon-9” [2].\n\n\n\nРисунок 2 - Отделение створок ГО без разворота\n\nЗдесь рассматривается первый способ отделения ГО с разворотом створок при помощи пневматических толкателей. Модель построена с использованием материалов патента [1] и учебного пособия [5].\n\nНа рисунке 3 показана схема рассматриваемого ГО, разделяемого на две створки. Створки соединяются друг с другом по продольным стыкам при помощи замков. Это могут быть, например, рычажные замки, соединенные тягами, как показано в патенте [1] или линейный удлиненный заряд. К переходному отсеку каждая створка также крепится замками поперечного стыка. После прохождения плотных слоев атмосферы система управления подает команду на раскрытие замков и створки под действием толкателей начинают разворачиваться вокруг узлов вращения. Каждая створка разворачивается при помощи двух пневмотолкателей. Один конец каждого толкателя  шарнирно прикрепляется к створке, а штоки упираются в переходный отсек РН, отталкиваясь от него в процессе разворота створки.\n\n\n\nРисунок 3 - Головной обтекатель\n\nНа рисунке 4 показана схема пневмосистемы разворота створки, которая состоит из баллона с рабочим телом, например, сжатым воздухом, пневмоклапана (ПК) и двух пневмотолкателей. Перед отделением створки срабатывает пневмоклапан для подготовки пневмосистемы к работе – заполнения рабочих полостей толкателей, чтобы сразу после срабатывания замков крепления створки начали разворот.\n\n\n\nРисунок 4 - Схема пневмосистемы\n\nПредположим, что в нашей модели в момент \\(t = 0 + \\Delta t_1\\) срабатывает пневмоклапан ПК, показанный на рисунке 3. С этого момента начинается наполнение рабочих полостей толкателей, при этом створка остается неподвижной –  замки крепления, соединяющие её с другой створкой и с переходным отсеком, не позволяют створке вращаться.\n\nВ момент времени \\(t = 0 + \\Delta t_2\\) производится срабатывание замков крепления и створка под действием пневмотолкателей начинает разворот. Интервал времени \\(t_2 - t_1\\) необходим для заполнения пневмосистемы. Фактическое время готовности  пневмосистемы для работы после срабатывания пневмоклапана будет определяться объёмом той части пневмосистемы, что находится после пневмоклапана и проходным сечением пневмоклапана.\n\nМатематическая модель\n\nДля начала запишем математическую модель движения створок. Важно понять, как будет двигаться створка относительно РН, чтобы убедиться, что это движение будет безударным и створка не столкнется с РН. С этой точки зрения удобней  рассматривать движение створок относительно неинерциальной системы координат, связанной с РН, которая движется с некоторым известным ускорением.\n\nУравнения движения\n\nПринятые допущения\n\nМодель движения створки ГО будет строится с учетом следующих допущений:\n\n\n  Створка – абсолютно-твердое тело постоянного состава.\n  Движение створок не оказывает влияния на движение РН.\n  РН движется поступательно с постоянной продольной перегрузкой.\n  Масса толкателя мала по сравнению с массой створки.\n  Процесс в пневмосистеме толкателя разворота створки адиабатный (без обмена энергией с внешней средой).\n  Моменты сопротивления в точках (шарнирах) крепления толкателя к створке пренебрежимо малы.\n  Трение в узлах вращения створки, соединяющих её с РН, также отсутствует.\n  Отделение створок происходит в разреженных слоях атмосферы, поэтому действие аэродинамических сил на движение створки считается малым и не учитывается.\n  Рассматривается плоское движение створки.\n\n\nС учетом принятых допущений о плоском движении и абсолютной твердости створки можно упростить модель пневмосистемы, заменив действие двух пневмотолкателей одним с удвоенной площадью штока. Эти допущения позволяют рассматривать движение двух створок независимо друг от друга, т.е. достаточно рассмотреть движение одной створки.\n\nНа рисунке 5 показана схема рассматриваемой механической системы. В неинерциальной системе координат движение створки происходит под действием силы толкателей \\(\\mathbf P\\) и переносной силы инерции \\(\\mathbf G\\), определяемой движением РН с некоторой перегрузкой.\n\nКинематические соотношения\n\nСила, создаваемая толкателем, будет зависеть от перемещения его штока. Перемещение штока определяет объём рабочей полости толкателя. С увеличением этого объёма давление в рабочей полости будет падать, приводя к уменьшению силы. Длину толкателя определим из теоремы косинусов, записанной для треугольника osp (рисунок 5):\n\n[l_{sp}^2 = l^2 = y_p^2 + \\rho_p^2 - 2 y_p \\rho_p \\cos (\\varphi + \\psi_p)]\n\nгде \\(\\rho_p = op\\) – расстояние от оси вращения створки до оси вращения шарнира точки крепления толкателя на створке; \\(\\rho_c = oc\\) – расстояние от оси вращения створки до её центра масс. Полученное выражение позволяет найти связь между изменением длины толкателя и изменением угла поворота створки, а также между угловой скоростью створки и скоростью выдвижения штока толкателя. Продифференцировав последнее выражение, получим\n\n[\\dot{l} = y_p \\rho_p \\frac{\\sin(\\varphi + \\psi_p)}{l} \\dot{\\varphi}]\n\n\n\nРисунок 5 - Схема системы\n\nЗапишем уравнение в вариациях:\n\n[\\delta l = y_p \\rho_p \\frac{\\sin(\\varphi + \\gamma_p)}{l} \\delta \\varphi]\n\nСилы и моменты\n\nУравнение в вариациях можно использовать для определения момента, создаваемого силой толкателя относительно оси вращения не проводя дополнительных геометрических построений. В соответствии с принципом виртуальных перемещений\n\n[\\delta A_p = P \\delta l = M_p \\delta \\varphi,]\n\nследовательно момент, создаваемый толкателем относительно оси вращения створки будет определяться следующим образом:\n\n[M_p = \\frac{\\delta l}{\\delta \\varphi} P = y_p \\rho_p \\frac{\\sin(\\varphi + \\gamma_p)}{l} P]\n\nМомент переносной силы инерции относительно оси вращения определяется как:\n\n[M_\\Phi = (x_c \\sin \\varphi - y_c \\cos \\varphi) m g n_x]\n\nгде \\(n_x\\) – продольная перегрузка РН, \\(m\\) - масса створки, \\(g\\) – ускорение свободного падения.\n\nУравнение движения\n\nДвижение створки при отделении можно разделить на два этапа: этап разворота створки и этап свободного движения относительно РН после потери механической связи створки с переходным отсеком.\n\nПервый этап движения\n\nДвижение створки относительно РН на этапе вращения описывается одним дифференциальным уравнением:\n\n[J_o \\ddot{\\varphi} = M_p + M_\\Phi]\n\nгде \\(J_o\\) – момент инерции створки относительно оси вращения. При известном поперечном моменте инерции створки относительно оси, проходящей через центр масс, момент инерции относительно оси, проходящей через ось вращения створки может быть определен по теореме Штейнера\n\n[J_o = J_c + m (x_c+y_c)^2 = J_c + m \\rho_c^2]\n\nПодставляя выражения для моментов сил, получим:\n\n[J_o \\ddot{\\varphi} = y_p \\rho_p \\frac{\\sin(\\varphi + \\gamma_p)}{l} P + (x_c \\sin \\varphi - y_c \\cos \\varphi) m g n_x]\n\nВторой этап движения\n\nПосле того, как створка достигнет угла отделения (угол потери связи) её относительное движение, т.е. движение по отношению к РН, будет равноускоренным вдоль продольной оси РН (x), равномерным вдоль поперечной оси (y) и также равномерным будет вращение створки вокруг центра масс:\n\n[x = x_k + V_{xk} t + \\frac{n_x g t^2}{2}, \\quad y = y_k + V_{yk} t, \\quad \\varphi = \\varphi_{k} + \\omega_k t]\n\nгде \\(x_k\\), \\(y_k\\) – координаты центра масс створки на момент потери механической связи в шарнире, \\(V_{xk}\\), \\(V_{yk}\\) – скорости центра масс на момент потери механической связи, \\(\\varphi_{k}\\), \\(\\omega_k\\) – угол и угловая скорость створки на момент потери механической связи.\n\nИзменение давления в полости толкателя\n\nДля записи дифференциального уравнения изменения давления в рабочей полости толкателя можно воспользоваться готовыми “рецептами”, например, из справочника Герц Е.В., Крейнин Г.В. “Расчет пневмоприводов” (1975).\n\nМы же воспользуемся возможностями системы SimInTech и построим модель пневмосистемы, используя блоки из разделов “Пневмомашины и пневмоавтоматика” и “Механика” для построения модели пневмосистемы.\n\nМодель SimInTech\n\nМодель в SimInTech построим с использованием пакета проектов: построим отдельную модель пневмосистемы и модель движения створки, которые объединим в рамках одного пакета проектов. Обмениваться данными модели будут при помощи общей базы данных сигналов. Структура комплексной модели или пакета показана на рисунке 6.\n\n\n\nРисунок 6 - Схема проекта “Пневмосистема”\n\nМодель пневмосистемы, “зная” положение штока пневмотолкателя и его скорость будет определять силу, которую создает толкатель. Модель створки, получив значение силы, будет определять кинематические параметры створки и вычислять перемещение и скорость штока, которые определяются положением и угловой скоростью створки.\n\nНа рисунке 7 показан пакет проектов “Отделение_ГО.pak”, который включает в свой состав проекты “Пневмосистема.prt” и “Створка_ГО.prt”.\n\n\n\nРисунок 7 - Схема проекта “Пневмосистема”\n\nБаза данных сигналов\n\nНа рисунке 8 показана база сигналов.\n\n\n\nРисунок 8 - Схема проекта “Пневмосистема”\n\nСигналы разделены на три категории:\n\n  Пневмосистема\n  Тела\n  Команды\n\n\nОписываемая структура сигналов не является единственно возможной. Структура была создана в процесса изучения SimInTech и вряд ли лишена недостатков.\n\nВ первой категории собраны сигналы, связанные с работой пневмосистемы. В этой категории три группы сигналов\n\n  FAIRING_VALVE\n  FAIRING_PN\n  FAIRING_PUSHER\n\n\nВ группе FAIRING_VALVE только один сигнал, управляющий состоянием пневмоклапана 1-открыт, 0-закрыт.\n\nВ группе FAIRING_PN собраны сигналы, характеризующие состояние пневмосистемы:\n\n  FAIRING_PN_PRESSURE_PUSHER - давление в рабочей полости пневмотолкателя,\n  FAIRING_PN_PRESSURE_TANK - давление в баллоне пневмосистемы.\n\n\nВ группе FAIRING_PUSHER собраны сигналы, характеризующие работу толкателя:\n\n  FAIRING_PUSHER_P - сила, создаваемая толкателем,\n  FAIRING_PUSHER_STROKE - максимальное перемещение штока толкателя или его “ход” (константа).\n  FAIRING_PUSHER_S - фактическое перемещение штока толкателя.\n  FAIRING_PUSHER_V - скорость штока толкателя.\n\n\nВ категории Тела одна группа сигналов FAIRING c сигналами\n\n  FAIRING_PHI - угол поворота створки;\n  FAIRING_W - угловая скорость створки.\n\n\nВ категории Команды также только одна группа FAIRING_COM c сигналом FAIRING_COM_SEP определяющим начало движения створки – раскрытие замков.\n\nСигналы связываются с параметрами состояния элементов модели при помощи редактора связей.\n\n\n\nРисунок 9 - Редактор связей\n\nПроект “Пневмосистема”\n\nСхема проекта “Пневмосистема” приведена на рисунке 10. Проект состоит из субмодели, которая будет описана далее, на вход которой подаются значения сигналов из общей базы данных проекта: перемещение штока и скорость штока. Также в этом проекте формируется сигнал открытия пневмоклапана, который также подается на вход субмодели. Выходы субмодели (усилие толкателя и состояние пневмоклапана) записываются в базу сигналов проекта.\n\n\n\nРисунок 10 - Схема проекта “Пневмосистема”\n\nСубмодель “Пневмосистема” состоит из двух полостей постоянного объема, которые имитируют объемы пневмосистемы до и после пневмоклапана, самого пнемоклапана (Пневмоклапан 1), разделяющего две части пневмосистемы, пневмотолкателя и дросселя моделирующего вход в пневмотолкатель (штуцер).\n\nПри открытии пневмоклапана ПК1, показанного на рисунке 11, газ из баллона заполняет часть пневмосистемы от ПК1 до рабочей полости пневмотолкателей. Клапан ПК1 открывается при подаче управляющего сигнала с уровнем “1” на вход субмодели “Пневмоклапан (1-открыт, 0-закрыт)”.\n\n\n\nРисунок 11 - Схема пневмосистемы\n\nСила создаваемая толкателем будет определяться давлением в рабочей полости толкателя и положением штока, от которого это давление будет зависеть. Для моделирования толкателя используется блок “ПневмотолкательГПС - Пневмоцилиндр одностороннего действия (базовый)”. Этот блок имеет имеет один двунаправленный порт, по которому передается “скорость” и “сила”. Входом для пневмотолкателя является скорость штока.\n\nВ субмодели пневмосистемы реализована логика прекращения работы толкателя. Когда шток толкателя достигнет своего максимального выдвинутого положения действие на створку силы толкателя прекращается. В блоке SimInTech в модели пневмотолкателя реализовано ограничение перемещение штока при помощи контактной силы, зависящей от перемещения и скорости штока (модель “упора”): в параметрах толкателя можно задать коэффициент жесткости упора штока и их коэффициент демпфирования.\n\n\n\nРисунок 12 - Параметры пневмотолкателя\n\nКогда шток достигает своего крайнего  положения и останавливается под действием контактной силы упора на выходной порт толкателя передается и сила, создаваемая давлением в рабочей полости, и контактная сила от взаимодействия с упором. Для того, чтобы эта сила противодействия упора не действовала на створку при помощи блока “Двунаправленная шина (выход)” двунаправленный сигнал разделяется на два математических сигнала “F” (сила - выход) и “V” (скорость - вход). Выходной сигнал “Сила” в рассматриваемом случае будет вектором, содержащим значение силы пневмотолкателя, создаваемой давлением и силой воздействия упора на шток толкателя. Из массива этих двух величин при помощи блоков Демультиплексор и Мультиплексор извлекается сила, создаваемая давлением в рабочей полости. Далее в соответствии со схемой значение силы умножается на значение признака достижения штоком выдвинутого положения. Результат подается на выходной порт “Усилие толкателя”.\n\nПриведенный здесь способ “извлечения” нужного элемента из двунаправленной шины при помощи пары Демультиплексор/Мультиплексора не выглядит  изящным, однако на момент подготовки этой статьи другого менее громоздкого решения автор не нашел.\n\nКогда шток полностью выдвинется, на выходе “Сила толкателя” будет нулевой сигнал (толкатель не совершает работу). Сигнал со входа “Скорость штока” также будет обнуляться (в модели движения створки). В результате после полного выдвижения штока на створку ГО прекратит действие сила толкателя, а сам шток толкателя будет оставаться неподвижным.\n\nПроект “Створка ГО”\n\nМодель движения створки в проекте “Створка ГО” (рисунок 13) считывает из базы сигналов силу, создаваемую толкателем и перемещение его штока. Перемещение штока пневмотолкателя используется для того, чтобы контролировать момент окончания его работы.\n\nУравнения движения створки интегрируются в блоке типа “Субмодель”. На вход блока подаются значение силы толкателя, перемещение штока толкателя и признак открытия замков крепления створки (1 - замки открыты, 0 - замки закрыты, створка неподвижна). На выходе субмодели формируются скорость штока, угловая скорость створки, угол поворота створки, которые записываются в базу данных сигналов.\n\nВ модели также формируется сигнал на открытие замков, удерживающих створку (изменяется состояние сигнала FAIRING_COM_SEP с 0 на 1), после чего начинается ее разворот. Сигнал формируется при помощи блока “Ступенька”.\n\n\n\nРисунок 13 - Схема проекта “Створка_ГО”\n\nСубмодель “Движение створки ГО” состоит из двух основных блоков “Дифференциальное уравнение движения створки” и “Кинематическое уравнения” (рисунок 14).\n\n\n\nРисунок 14 - Модель разворота створки\n\nБлок “Дифференциальное уравнения движения створки” (блока типа “Язык программирования”) содержит следующий код:\n\n// Вход:  Угол поворота створки и сила толкателей\ninput  phi, pusher_force;\n// Выход: Угловое ускорение створки\noutput d2phi;\n\n// Длина толкателя\npusher_length = sqrt(yp^2+rp^2-2*yp*rp*cos(phi+gamma_p));\n// Момент, создаваемый толкателями относительно оси вращения створки\nMp = yp*rp*sin(phi+gamma_p)*pusher_force/pusher_length;\n// Момент от переносной силы инерции\nMg = (xc*sin(phi)-yc*cos(phi))*m*9.807*nx; \n// Угловое ускорение створки\nd2phi = (Mp+Mg)/Jo;\t\t\n\n\nВ блоке определяется угловое ускорение створки по углу поворота створки и силы, действующей на створку.\n\nВ блоке “Кинематическое уравнение” определяется скорость выдвижения штока. С выхода этого блока сигнал скорости штока перемножается с признаком достижения штоком предельного (выдвинутого) положения. Если шток достиг предельного положения, то на выходной порт “Скорость штока” подается ноль, означающий неподвижность штока (рисунок 14).\n\ninput  phi, dphi;\noutput dl;\n\n// Длина\npusher_length = sqrt(yp^2+rp^2-2*yp*rp*cos(phi+gamma_p));\n// Скорость выдвижения штока\ndl = yp*rp*sin(phi+gamma_p)*dphi/pusher_length;\n\n\nИнтегрирование уравнений движения производится при помощи метода Гира (Gear51).\n\n\n\nРисунок 15 - Настройки проектов\n\nРезультаты моделирования\n\nРезультаты моделирования были экспортированы в текстовый файл при помощи блоков “Выход алгоритма” и “В файл”. Графики построены при помощи библиотеки matplotlib в среде Python.\n\n\n\nРисунок 16 - Экспорт результатов моделирования в текстовый файл\n\nНа рисунке 17 показан график изменения давления в рабочей полости толкателя и в баллоне пневмосистемы. После срабатывания пневмоклапана давление в полостях баллона и пневмотолкателя выравниваются (пневмосистема заполняется). После начала движения створки давление в рабочей полости толкателя падет  вследствие увеличения её объема при развороте створки и выдвижения штока.\n\n\n\nРисунок 17 - Модель разворота створки\n\nНа рисунках 18 и 19 приведены графики изменения угла поворота створки и ее угловой скорости. На графике изменения угловой скорости створки виден этап движения створки под действием момента, создаваемого пневмотолкателем, и этап движения “по инерции”, когда створка по отношению к РН движется только под действием переносной силы инерции. На втором этапе угловая скорость створки уменьшается до тех пор пока её центр масс не достигнет максимальной высоты над поперечным стыком створки с переходным отсеком. После этого переносная сила инерции будет создавать момент, “помогающий” створке разворачиваться и угловая скорость будет увеличиваться.\n\n\n\nРисунок 18 - Угол поворота створки\n\n\n\nРисунок 19 - Угловая скорость створки\n\nНа рисунке 20 показан график перемещения штока пневмотолкателя. График иллюстрирует ограничение перемещения штока толкателя.\n\n\n\nРисунок 20 - Перемещение штока толкателя\n\nНа рисунке 21 приведен график изменения силы толкателя, действующей на створку. После открытия пневмоклапана по мере заполнения полости толкателя рабочим телом сила увеличивается и достигает максимального значения. После начала движения створки сила уменьшается вследствие увеличения объема рабочей полости толкателя и становится равной нулю после того, как шток толкателя выдвинется на максимальное расстояние.\n\n\n\nРисунок 21 - Сила толкателя, действующая на створку\n\nСписок источников\n\n\n  Патент № 2424953 C1 Российская Федерация, МПК B64G 1/00, F42B 15/36. Отделяемый крупногабаритный головной обтекатель ракеты-носителя : № 2010125721/11 : заявл. 24.06.2010 : опубл. 27.07.2011 / Н. Е. Гребнев, Г. Е. Круглов, В. Н. Новиков [и др.] ; заявитель Федеральное государственное унитарное предприятие “Государственный научно-производственный ракетно-космический центр “ЦСКБ-Прогресс” (ФГУП “ГНПРКЦ “ЦСКБ-Прогресс”), Российская Федерация, от имени которой выступает Министерство обороны Российской Федерации.\n  SpaceX Fairing Separation Test\n  Fairing Separation\n  Technology Insights: Fairing Separation Test\n  Круглов, Г. Е. Аналитическое проектирование механических систем [Электронный ресурс] : учеб. пособие / Г. Е. Круглов ; Самар. гос. аэрокосм. ун-т им. С. П. Королева (СГАУ). - Самара, 2000. - on-line\n\n\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2023-09-08-fairing-pneumatic/"
    },{
      "image": "/assets/img/mechanics-in-space/moon-lander.png",
      "title": "Модель посадки КА на Луну",
      "date": "2023-11-03 00:00:00 -0500",
      "description": "Пример моделирования посадки КА на поверхность Луны в среде Python.\n",
      "content": "Посадка на Луну\n",
      "categories": ["mechanics","cae","python"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/python/2023-11-03-moon-lander/"
    },{
      
      "title": "Модель контактного взаимодействиях в MSC.ADAMS",
      "date": "2023-12-01 00:00:00 -0600",
      "description": "Алгоритм вычисления силы реакции и силы трения в MSC.ADAMS при контактном взаимодействии двух тел\n",
      "content": "При контакте двух тел деформация \\(\\delta\\) определяется как длина отрезка \\(ab\\), соединяющего точки двух поверхностей взаимодействующих тел, которые находятся на минимальном расстоянии от центра масс объема пересечения (общего объема) двух поверхностей \\(c\\).\n\n\n\nРисунок 1 - Взаимодействие двух твердых тел\n\nСила реакции\n\nКонтактная сила (сила реакции) направлена вдоль отрезка \\(ab\\). Ее модуль (при \\(\\delta &gt; 0\\)) определяется выражением:\n\n[R = c \\cdot \\delta^k + S(\\delta, 0, 0, \\delta_{max}, d) \\cdot \\dot \\delta]\n\nгде \\(c\\) – коэффициент жесткости контакта, \\(k\\) – степень, определяющая характер роста силы реакции в зависимости от \\(\\delta\\), \\(d\\) – коэффициент демпфирования, \\(\\delta_{max}\\) – деформация, при которой демпфирование достигает максимального значения, \\(S(\\delta, 0, 0, \\delta_{max}, d)\\) – функция \\(\\delta\\) равная нулю если \\(\\delta \\leq 0\\), равная \\(d\\), если \\(\\delta \\geq \\delta_{max}\\), и вычисляемая при помощи полинома \\(P_3(x)\\) третьего порядка на интервале от 0 до \\(\\delta_{max}\\), коэффициенты которого определяются из условий\n\n[P_3(0) = 0, \\quad P’3(0) = 0, \\quad P_3(\\delta{max}) = d, \\quad P’3(\\delta{max}) = 0]\n\nгде \\(P'_3\\) – первая производная полинома по своему аргументу. В общем виде функция \\(S(x,x_{min},y_{min},x_{max},y_{max})\\) равна \\(y_{min}\\), если \\(x&lt;x_{min}\\), равна \\(y_{max}\\), если \\(x&gt;x_{max}\\), и “плавно” переходит (при помощи полинома третьего порядка) от \\(y_{min}\\) к \\(y_{max}\\) при изменении \\(x\\) от \\(x_{min}\\) к \\(x_{max}\\) (рисунок 2).\n\n\n\nРисунок 2 - Функция \\(S(x,x_{min},y_{min},x_{max},y_{max})\\)\n\nСила трения\n\nПри контактном взаимодействии используется упрощенная модель трения. Сила трения зависит от относительной скорости скольжения двух тел \\(V_{12}\\) и величины реакции \\(R\\):\n\n[F = \\mu(V_{12}) R]\n\nгде функция \\(\\mu(V_{12})\\) (рисунок 2) имеет вид\n\n[\\mu(V_{12}) = \n\\begin{cases}\n\\mu_d &amp; V_{12} \\leq -v_d \nS(V_{12},-v_d,\\mu_d,-v_s,\\mu_s) &amp; -v_d &lt; V_{12} &lt; -v_s \nS(V_{12},-v_s,\\mu_s,v_s,-\\mu_s) &amp; -v_s \\leq V_{12} \\leq v_s \nS(V_{12},v_s,-\\mu_s,v_d,-\\mu_d) &amp; v_s &lt; V_{12} &lt; -v_d \n-\\mu_d &amp; V_{12} \\geq v_d \n\\end{cases}]\n\nгде \\(\\mu_s\\) – коэффициент трения покоя, \\(\\mu_d\\) – коэффициент трения скольжения.\n\n\n\nРисунок 3 - Зависимость коэффициента трения от скорости относительного скольжения взаимодействующих тел \\(\\mu(V_{12})\\)\n",
      "categories": ["mechanics","cae"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2023-12-01-adams-friction-model/"
    },{
      "image": "/assets/img/blog/gear-open-image.png",
      "title": "Раскрытие посадочной опоры многоразовой ступени РН Falcon-9",
      "date": "2023-12-07 00:00:00 -0600",
      "description": "Model of the free opening of the landing gear of the  Falcon-9 reusable launch vehicle.\n",
      "content": "\n  Уравнения движения    \n      Кинетическая энергия системы\n      Обобщенная сила\n      Уравнение движения\n    \n  \n  Задание\n\n\nРассмотрим процесс свободного раскрытия посадочной опоры многоразовой первой ступени РН Falcon-9. Возвращаемая ступень имеет четыре одинаковые посадочные опоры. Опоры раскрываются до касания поверхности земли в процессе работы двигателя торможения. Движение посадочной опоры при раскрытии рассматривается по отношению к корпусу возвращаемой ступени, т.е. по отношению к неинерциальной системе координат движущейся с известным ускорением под действием силы тяги двигателя и силы тяжести. Действие других сил на движение опоры не рассматривается.\n\n\n\nРисунок 1 - Посадочная опора возвращаемой ступени РН Falcon-9 в раскрытом положении\n\nПосадочную опору представим в виде двух однородных стержней, которые назовем опорный подкос и демпфирующий подкос. Опорный подкос имеет постоянную длину \\(OB = l\\).  Демпфирующий подкос представляет собой телескопическую конструкцию и его длина \\(AB = s\\) при раскрытии опоры увеличивается. В первом приближении будем считать, что масса подкоса равномерно распределена по длине. Для анализа процесса раскрытия посадочной опоры используется упрощенная модель, схема которой показана на рисунке 2. Подкос OB представлен однородным стержнем с массой \\(m_{OB}=m\\), демпфирующий подкос \\(AB = s\\) представлен однородным стержнем переменной длины AB и массой \\(m_{AB}\\).\n\n\n\nРисунок 2 - Схема посадочной опоры\n\nВ процессе раскрытия опоры возвращаемая ступень движется поступательно с известной вертикальной перегрузкой, определяемой работой двигателя торможения.\n\nУравнения движения\n\nДля записи уравнений движения посадочной опоры используем формализм Лагранжа. Рассматриваемый механизм имеет одну степень свободы и его положение однозначно определяется углом поворота опорного подкоса относительно корпуса возвращаемой ступени \\(\\varphi\\). Уравнение Лагранжа второго рода имеет вид\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot \\varphi} - \\frac{\\partial T}{\\partial \\varphi} = Q_\\varphi]\n\nгде T – кинетическая энергия системы, \\(Q_\\varphi\\) – обобщенная сила.\n\nКинетическая энергия системы\n\nКинетическая энергия системы \\(T\\) представляет собой кинетическую энергию движения посадочной опоры относительно корпуса. Эта кинетическая энергия будет складываться из кинетических энергий двух звеньев АВ и ОВ:\n\n[T = T_{AB} + T_{OB}]\n\nКак было отмечено выше, подкос OB представлен однородным стержнем с массой \\(m_{OB}=m\\), а демпфирующий подкос AB представлен однородным стержнем переменной длины \\(AB=s(t)\\) и массой \\(m_{AB}\\). Кинетическая энергия демпфирующего подкоса определяется с учётом изменения его длины при развороте. Масса демпфирующего подкоса постоянна и равна\n\n[m_{AB}=k m,]\n\nгде коэффициент k представляет собой отношение массы подкоса АВ к массе подкоса ОВ. Длина s демпфирующего подкоса АВ есть функция угла поворота \\(\\varphi\\), который зависит от времени. Для определения кинетической энергии рассмотрим бесконечно-малый элемент этого стержня, который имеет массу \\(dm\\). Эту элементарную массу можно представить как произведение погонной массы стержня \\(\\mu\\) на бесконечно-малый участок длины \\(dm = \\mu ds\\) . Погонную массу стержня \\(\\mu\\) определим как отношению его полной массы \\(m_{AB}\\) к текущей длине, которую обозначим как s:\n\n[dm = \\mu ds=k m/s ds.]\n\nЭлементарная масса \\(dm\\) совершает сложное движение. Во-первых, она поворачивается, вместе со стержнем вокруг оси А. Назовём эту скорость трансверсальной скоростью \\(v_\\tau\\). Во-вторых, масса \\(dm\\) движется вдоль стержня вследствие изменения его длины. Это будет радиальная скорость \\(v_r\\)  (рисунок 3).\n\nСделаем еще одно допущение о том, что радиальные скорости точек стержня увеличиваются от точки А к точке В линейно от нуля (скорость точки А), до \\(V_B= \\dot s\\). Скорость точки, находящейся на расстоянии \\(\\xi\\) от точки А, будет равна\n\n[v_r=  \\frac{\\xi}{s} \\dot s]\n\n\n\nРисунок 3 - К определению кинетической энергии демпфирующего подкоса\n\nКасательная скорость точки также зависит от расстояния до оси вращения А и от угловой скорости вращения стержня АВ:\n\n[v_\\tau = \\xi \\dot \\beta]\n\nгде \t\\(\\beta\\) – угол поворота стержня АВ относительно корпуса. Полная скорость массы \\(dm\\) определяется выражением:\n\n[v_{dm}=\\sqrt{v_\\tau^2+v_r^2}=\\sqrt{\\frac{ξ^2}{s^2}\\dot{s}^2+ξ^2 \\dot{\\beta}^2}]\n\nКинетическую энергию демпфирующего подкоса определим как:\n\n[T_{AB} = \\int_0^s \\frac{v_{dm}^2}{2}\\frac{km}{s} = \\frac{1}{2} \\int_0^s (\\xi^2 \\dot \\beta^2 +\\frac{\\xi^2}{s^2} \\dot s^2) \\frac{km}{s} d \\xi = \\frac{1}{6} (s^2 \\dot \\beta ^2 + \\dot s^2 ) m_{AB}.]\n\nУгол поворота стержня АВ \\(\\beta\\) будет определяться выражением:\n\n[\\cos \\beta = \\frac{h^2 + s^2 - l^2}{2sh}]\n\nа длина \\(s\\) выражением\n\n[s^2 = l^2 + h^2 - 2 l h \\cos \\varphi]\n\nПредставим расстояние между шарнирами \\(h\\) как \\(h= \\zeta l\\), где \\(\\zeta\\) некоторая безразмерная величина \\(0 &lt; \\zeta &lt; 1\\). С учетом этой замены, выражение для угла \\(\\beta\\)  и длины \\(s\\) примут вид:\n\n[\\cos \\beta = \\frac{\\zeta - \\cos \\varphi}{\\eta}, \\quad s = \\eta l]\n\nгде \\(\\eta^2 = 1 + \\zeta^2 - 2 \\zeta \\cos \\varphi\\)\n\nПродифференцировав последние выражения, получим угловую скорость демпфирующего подкоса и скорость его удлинения\n\n[\\dot \\beta = \\frac{\\eta \\cos \\varphi-1}{\\eta^2} \\dot \\varphi, \\quad \\dot s = l \\frac{\\zeta}{\\eta} \\dot \\varphi \\sin \\varphi]\n\nКинетическая энергия посадочной опоры примет вид:\n\n[T = \\frac{1}{6} (s^2 \\dot \\beta ^2 + \\dot s^2 ) m + \\frac{J_{OB} \\dot \\varphi^2}{2}]\n\nПодставим в это выражение полученные выше выражения для \\(\\dot beta\\)  ̇и \\(\\dot s\\), получим:\n\n[T = \\frac{1}{6} m_{AB} l^2 \\dot \\varphi^2 + \\frac{J_{OB} \\dot \\varphi^2}{2}]\n\nС учетом соотношения масс \\(m_{AB}=km\\):\n\n[T = \\frac{1}{6} (1+k) m l^2 \\dot \\varphi^2]\n\nОбобщенная сила\n\nПоскольку движение посадочной опоры рассматривается относительно системы координат, связанной с корпусом возвращаемой ступени, которая движется в поле силы тяжести под действием силы тяги двигателя, на посадочные опоры будут действовать переносные силы инерции \\(G_{OB}\\)  и \\(G_{AB}\\). При постоянной силе тяги обобщенные силы можно определить, используя выражение для потенциальной энергии посадочной опоры:\n\n[\\Pi = \\Pi_{OB}+\\Pi_{AB} = m_{OB} g n_x \\frac{l_{OB}}{2} \\cos \\varphi + m_{AB} g n_x \\left[ h+\\frac{s}{2} \\cos (\\pi - \\beta) \\right]]\n\nгде \\(n_x\\) – перегрузка возвращаемой ступени, вызванная работой двигателя торможения. За нулевой уровень потенциальной энергии принята поперечная плоскость возвращаемой ступени, проходящая через точку О. Для известного выражения потенциальной энергии, обобщенная сила будет определяться выражением:\n\n[Q_\\varphi = - \\frac{\\partial \\Pi}{\\partial \\varphi} = - \\frac{1}{2} g (k+1) l m n_x \\sin \\varphi]\n\nУравнение движения\n\nПри принятых допущениях, если движение системы происходит только под действием переносной силы инерции, уравнение движения посадочной работы имеет вид уравнения нелинейного математического маятника и не зависит от масс элементов, а определяется только длиной опорного подкоса и перегрузкой возвращаемой ступени:\n\n[\\ddot \\varphi = \\frac{3}{2l} g n_x \\sin \\varphi]\n\nЭто уравнение интегрируется с начальными условиями \\(\\varphi(0) = 0\\), \\(\\dot{\\varphi}(0) = \\omega_0\\).\n\nЗадание\n\n\n  Определите угловую скорость опорного подкоса при раскрытии посадочной опоры при следующий параметрах посадочной опоры и начальных условиях:\n    \n      масса опорного подкоса \\(m_{AB} = 250\\) кг;\n      масса телескопического подкоса \\(m_{ОB} = 150\\) кг;\n      длина опорного подкоса \\(l = 6.5\\) м;\n      конечная длина телескопического подкоса \\(s_k = 8\\) м;\n      конечный угол поворота опорного подкоса \\(\\varphi_k = 120^o\\);\n      начальная угловая скорость подкоса \\(\\dot \\varphi(0) = 5^o/c\\) (при \\(\\varphi_0 = 0\\));\n      перегрузка \\(n_x = 1\\).\n    \n  \n  Оцените максимальную силу растяжения телескопического подкоса после раскрытия опоры: считая, что в момент полного раскрытия опоры он имеет жесткость на растяжение \\(c = 10^5\\) Н/м.\n\n\n\n\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2023-12-07-leg-open/"
    },{
      "image": "/assets/img/blog/simintech-ground-test-model/slide.png",
      "title": "Модель системы обезвешивания в SimInTech",
      "date": "2024-03-09 00:00:00 -0600",
      "description": "Модель в среде SimInTech наземной экспериментальной установки для отработки процесса отделения переходного отсека от орбитального блока.\n",
      "content": "Для подтверждения работоспособности механизмов подвижных элементов конструкций космических аппаратов (раскрываемых солнечных батарей, антенн), средств разделения элементов конструкций ракет-носителей (отработавших ускорителей, створок головных обтекателей, хвостовых отсеков) обычно не ограничиваются только математическим и компьютерным моделированием, а используют и экспериментальные методы. Например, для экспериментальной отработки системы раскрытия солнечных батарей КА строят сложные многозвеньевые механические системы для компенсации действия на створки солнечной батареи сил веса, имитируя, конечно с погрешностями, в земных условия условия невесомости.  Ниже на фото показана подобная система обезвешивания панели солнечной батареи, состоящей из 5 створок. На фото видны тросы, на которых подвешены створки, прикрепленные к подвижным поперечным балкам, которые могут двигаться с небольшим сопротивлением по направляющим.\n\n\n\nРисунок 1 - Система обезвешивания створок солнечных батарей КА\n\nПеред разработчиком экспериментальной установки стоит задача выбора параметров системы обезвешивания, например длин и жесткостей тросов, и оценки влияния системы обезвешивания на движение отрабатываемой механической системы, чтобы можно было сопоставить результаты испытаний с ожидаемым (расчётным) движением в условиях полета и сделать вывод об успешности прохождения этапа наземной отработки отрабатываемой системы. Очевидно, что модель движения отрабатываемой системы в условиях наземной отработки является более сложной, чем модель исходной системы.\n\nОтделение переходного отсека\n\nРассмотрим для примера модель отделения переходного неразрезного отсека орбитального блока. Схема отделения отсека описана в патенте “УСТРОЙСТВО ДЛЯ ОТДЕЛЕНИЯ ПЕРЕХОДНОГО ОТСЕКА ОТ КОСМИЧЕСКОГО ОБЪЕКТА (RU 2 200 117 C1)”. Отсек отделяется от орбитального блока без разделения на створки, подобно створкам головного обтекателя ракеты-носителя (поэтому его и “прозвали” неразрезной отсек), а съезжает по роликам, установленным на орбитальном блоке. На самом отсеке установлены направляющие, по которым катятся ролики. Такая схема позволяет снизить массу отсека в сравнении с отсеком разделяемым на створки за счёт исключения из конструкции продольных стыков.\n\nНачальную скорость движения отсека относительно орбитального блока после разделения поперечного стыка отсека с орбитальным блоком обеспечивают пружинные толкатели (рисунок 2).\n\n\n\nРисунок 2 - Отделяемый переходный отсек орбитального блока\n\nПри проведении экспериментальной отработки может быть необходимо подтвердить скорость движения отсека относительно орбитального блока, отсутствие “зацепов” отсека за конструкцию орбитального блока (его макета). Если рассматривать только относительное поступательное движение переходного отсека и орбитального блока, то относительную скорость можно определить из закона об изменении кинетической энергии:\n\n[\\Delta V = V_2 - V_1 = \\sqrt{\\frac{2A}{m^*}}]\n\nгде \\(A\\) - суммарная работа толкателей отделения, \\(m^*\\) - приведенная масса определяемая выражением:\n\n[m^* = \\frac{m_{OB} m_{A}}{m_{OB}+m_A}]\n\nгде \\(m_{OB}\\) – масса орбитального блока, \\(m_A\\) – масса отделяемого отсека.\n\nДля наземной отработки процесса отделения неразрезного переходного отсека в книге “Расчёт и проектирование систем разделения ступеней ракет” рекомендуется использовать вертикальную схему обезвешивания, показанную на рисунке 3.\n\n\n\nРисунок 3 - Схема экспериментальной установки (рисунок из книги “К. С. Колесников, В. В. Кокушкин, С. В. Борзых, Н. В. Панкова Расчёт и проектирование систем разделения ступеней ракет. М.: МГТУ им. Н.Э. Баумана. 2006.”)\n\nОтсек 7 подвешивается в кардановом подвесе при помощи блочно-тросовой системы 2. Вес отсека компенсируется при помощи противовеса 13, масса которого равна массе отсека, массе траверсы 4 и других элементов подвески.\n\nОчевидно, что в этой схеме под действием толкателей отделения 8 после разделения поперечного стыка 9 будет двигаться и отсек и траверса и противовес, т.е. масса минимум в два раза превышающая массу самого отсека, поэтому скорость движения отсека относительно макета орбитального блока 6 (\\(\\Delta V^{исп}\\)) после окончания работы толкателей 8 будет меньше скорости отсека в условиях полета \\(\\Delta V\\):\n\n[\\Delta V^{исп} &lt; \\sqrt{\\frac{2A}{2 m^*}} = \\frac{\\Delta V}{\\sqrt{2}}]\n\nДля того чтобы в условиях наземной отработки добиться той же скоростей движения переходного отсека необходимо компенсировать увеличение массы. Для этого используется  дополнительный комплект толкателей противовеса 12 (рисунок 3). Удвоив работу толкателей в системе, можно компенсировать удвоение подвижной массы экспериментальной установки:\n\n[\\Delta V^{исп} = \\sqrt{\\frac{2\\cdot (2 A)}{2 m^*}} = \\Delta V]\n\nДобавление в систему дополнительных толкателей приводит к большему начальному растяжению троса системы обезвешивания. До начала движения отсека трос будет растягиваться весом противовеса 13 и усилием дополнительных толкателей 12. Необходимо проанализировать влияние троса на движение отсека и сравнить это движение с движением в условиях полета.\n\nДля решения это задачи можно использовать среду SimInTech, которая имеет уже готовые блоки библиотеки “Механика” для описания исследуемой системы.\n\nМодель в SimInTech\n\nПостроим упрощенную модель экспериментальной установки, позволяющую проанализировать поступательное движение отсека. Будем учитывать только упругие свойства троса, пренебрегая влиянием на движение отсека его массы. При построении модели также не будет учитываться сопротивление троса при взаимодействии с блоками подвески и влияние самих блоков на движение системы (сопротивление при вращении блоков, их инерционно-массовые характеристики).\n\nВ условиях наземной отработки скорость отсека относительно неподвижного макета орбитального блока после окончания работы толкателей отделения будет определяться массой отсека (\\(m_A\\)) и работой толкателей (обозначим скорость отсека как \\(V_A\\)):\n\n[V_A = \\sqrt{\\frac{2A}{m_A}}]\n\nРасчётная схема модели приведена на рисунке 4. Справа на рисунке 4 показана эквивалентная схема экспериментальной с учётом принятых допущений. Трос растягивается силами веса отсека (\\(G_A\\)) и балансировочного груза (\\(G_B\\)), на отсек действует сила толкателей \\(P_A\\), на противовес – сила дополнительных толкателей (\\(P_B\\)).\n\n\n\nРисунок 4 - Схема модели\n\nСхема SimInTech модели показана на рисунке 5 (следует отметить, что по структуре модель подобна модели вращающейся тросовой системы). Для сравнения движения отсека в условиях полета и в условиях наземной отработки построены две модели: слева показана модель движения отсека в условиях полета, справа – в условиях наземной отработки. По количеству блоков модель движения отсека в условиях наземной экспериментальной установки в три раза больше.\n\n\n\nРисунок 5 - Схема модели в среде SimInTech\n\nОтсек и противовес представлены в виде материальных точек одинаковой массы. В SimInTech эти тела моделируются при помощи блоков “Масса” библиотеки “Механика”. Силы веса, действующие на отсек и противовес, представлены в виде блоков “Источник силы” подраздела “Механические источники”. Силы веса действуют в противоположные стороны (имеют разные знаки), растягивая трос, соединяющий отсек с противовесом.\n\nТолкатель моделируется при помощи блока Нелинейная пружина”. В блоке в табличном виде задается закон изменения суммарной силы толкателей отсека от деформации пружины. При отрицательной деформации (пружина сжата), равной ходу толкателя, сила пружины равна суммарному  начальному усилию толкателей $P_0$, при нулевой деформации сила равна конечному усилию толкателей \\(P_K\\), при дальнейшем увеличении деформации сила пружины равна нулю (рисунок 6). Работа толкателей для примера подобрана так, чтобы после окончания их работы переходный отсек двигался со скоростью 1 м/с.\n\n\n\nРисунок 6 - Свойства блока “Нелинейная пружина” (модель толкателей отделения переходного отсека)\n\nВ новой версии библиотеки “Механика” начальная деформация нелинейной пружины определяется начальным положением тела (“Масса”), поэтому, в параметрах массы, моделирующей отсек, необходимо указать начальное положение (рисунок 7).\n\n\n\nРисунок 7 - Параметры блока “Масса”, моделирующего переходный отсек\n\nТрос моделируется при помощи блока “Поступательная пружина”. В отличие от Нелинейной пружины, начальная деформация (“Начальное растяжение”) линейной пружины определяется в самом блоке (не вполне понятен различный подход разработчиков к способу определения начальной деформации пружин).\n\n\n\nРисунок 8 - Свойства блока “Поступательная пружина” (модель троса)\n\nДо начала движения трос растянут силой веса переходного отсека и начальным усилием дополнительных толкателей. В этот момент стык переходного отсека с орбитальным блоком еще не раскрылся и удерживается замками, поэтому толкатели отделения отсека не растягивают троса. Предполагается, что в системе обезвешивания используется многожильный трос, эквивалентный по жесткости сплошному стальному тросу диаметром 10 мм и длиной 10 метров – 261.8 кН/м.\n\nДополнительные толкатели также моделируется при помощи блока “Нелинейная пружина”. Все параметры модели определяются в скрипте инициализации модели:\n\ninitialization\n\t// Модуль упругости троса\n\tYM = 200e9;\n\t// Диаметр троса\n\ttether_d  = 0.010;\n\t// Длина троса\n\ttether_l  = 10;\n\t// Площадь поперечного сечения троса\n\ttether_A  = tether_d*tether_d*pi/4;\n\t// Жесткость троса\n\ttether_c  = YM*tether_A/tether_l;\t\n\t// Масса переходного отсека\n\tO_mass = 500;\n\t// Масса противовеса\n\tB_mass = 500;\n\t// Ускорение силы тяжести\n\tg = 9.807;  \n\t// Начальное усилие толкателей (суммарное)\n\tP0 = 1800;\n\t// Конечное  усилие толкателей (суммарное)\n\tPK = 700;\n\t// Ход толкателей\n\tP_stroke = 0.2;  \t\t\t\nend\n\n\nРезультаты моделирования\n\nНа рисунке 9 показаны графики изменения скорости отсека в условиях полета и в условиях наземной экспериментальной установки без задействования дополнительных толкателей противовеса. В этом случае скорость отсека в условиях наземной отработки в $\\sqrt{2}$ меньше скорости отсека в условиях полёта.\n\n\n\nРисунок 9 - Скорость отделяемого отсека в условиях полета и в условиях наземной отработки (без учёта действия толкателей противовеса)\n\nНа рисунке 10 показаны графики изменения скорости отсека в условиях полета и в условиях наземной экспериментальной установки при задействовании дополнительных толкателей. Рисунок иллюстрирует заметное влияние упругих свойств троса на скорость отсека: амплитуда колебаний скорости отсека после окончания работы толкателей составляет около 0,05 м/с (5 % от конечной скорости отсека). Результаты моделирования также показывают, что в течение 0,04 с после разделения стыка переходный отсек в условиях испытаний движется быстрее чем в реальных условиях за счёт начального растяжения троса, вызванного действием дополнительных толкателей противовеса.\n\n\n\nРисунок 10 - Скорость отделяемого отсека в условиях полета и в условиях наземной отработки (с учётом действия толкателей противовеса)\n\nНа рисунке 11 показан график изменения силы толкателей, действующей на переходный отсек. Продолжительность работы толкателей переходного отсека составляет около 0.35 с.\n\n\n\nРисунок 11 - Суммарная сила толкателей, действующая на переходный отсек\n\nПостроенная простейшая модель движения отделяемого переходного отсека в условиях наземной экспериментальной отработки позволяет оценить влияние упругих свойств троса на движение отсека.\n",
      "categories": ["mechanics","cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2024-03-09-simintech-ground-test-model/"
    },{
      "image": "/assets/img/blog/two-dof-mech-python.png",
      "title": "Интегрирование уравнений движения системы с двумя степенями свободы в среде Python",
      "date": "2024-04-01 00:00:00 -0500",
      "description": "Пример интегрирования в среде Python уравнений движения механической системы с двумя степенями свободы на примере курсовой работы “Исследование движения точки и механической системы” курса теоретической механики Самарского университета\n",
      "content": "Круглая пластина может вращаться вокруг оси, проходящей через точку \\(О_1\\) и перпендикулярной плоскости рисунка. В канале пластины движется шарик М, закреплённый на пружине со свободной длиной \\(l_0\\). Канал, в котором движется шарик, находится на расстоянии 2h = R от оси вращения.\n\nРассмотрим два режима движения системы:\n\n  движение системы при известном законе движения пластины;\n  движение системы как системы с двумя степенями свободы.\n\n\nСистема с одной степенью свободы\n\nВ первом случае круглая пластина вращается по известному закону \\(\\varphi(t)\\) и механическая система имеет только одну степень свободы – движение шарика относительно пластины.\n\n\n\nУравнения движения\n\nПри движении пластины с известной угловой скоростью \\(\\dot{\\varphi}(t) = \\omega\\) и ускорением \\(\\varepsilon\\) уравнения относительного движения шарика относительно подвижной системы координат \\(Oxy\\), связанной с пластиной, имеют следующий вид:\n\n[\\left{\n\\begin{aligned}\n&amp; m \\ddot x = G \\sin \\varphi - P - F_{f} + \\Phi_e^n \\sin \\psi + \\Phi_e^\\tau \\cos \\psi \n&amp; m \\ddot y = G \\cos \\varphi + N_y + \\Phi_e^n \\cos \\psi - \\Phi_e^\\tau \\sin \\psi - \\Phi_c \n&amp; m \\ddot z = N_z\n\\end{aligned}\n\\right.]\n\nгде \\(m\\) - масса шарика, \\(P = c \\dot x\\) - сила упругости пружины, \\(F_f = \\text{sign} (V_r) f \\sqrt{N_y^2 + N_z^2}\\) - сила трения скольжения, \\(G  = m g\\) - сила веса, \\(\\Phi_e^n\\) - переносная центробежная сила  инерции:\n\n[\\Phi_e^n = m \\omega^2 (O_1M) = m \\omega^2 \\frac{O_1K}{\\cos \\psi}]\n\nпереносная вращательная сила инерции:\n\n[\\Phi_e^\\tau = m \\varepsilon (O_1M) = m \\varepsilon \\frac{O_1K}{\\cos \\psi}]\n\n[AK = \\sqrt{R^2 - h^2}, \\quad KM = (x + l_0) - AK, \\quad \\psi = \\arctan \\frac{KM}{O_1 K}]\n\nДвижение шарика происходит вдоль оси \\(x\\), поэтому \\(y=0\\). Из второго уравнения системы выразим реакцию \\(N_y\\):\n\n[N_y = \\Phi_e^\\tau \\sin \\psi - G \\cos \\varphi - \\Phi_e^n \\cos \\psi + \\Phi_c]\n\nДифференциальное уравнение второго порядка, описывающее движения шарика вдоль оси \\(Ox\\), будет иметь вид:\n\n[\\ddot x = g \\sin \\varphi - \\frac{c}{m} x - \\text{sign}(V_r) f (\\Phi_e^\\tau \\sin \\psi - G \\cos \\varphi - \\Phi_e^n \\cos \\psi)\\frac{1}{m} + \\frac{\\Phi_e^n}{m} \\sin \\psi + \\frac{\\Phi_e^\\tau}{m} \\cos \\psi = f(x,\\dot x, t)]\n\nПриведём это уравнение к системе дифференциальных уравнений первого порядка:\n\n[\\left{\n\\begin{aligned}\n&amp; \\dot x = V_x \n&amp; \\dot V_x = f(x, V_x, t)\n\\end{aligned}\n\\right.]\n\nВектор состояния системы в момент времени t определяется координатным столбцом\n\n[q(t) = \\begin{bmatrix} x \\ V_x \\end{bmatrix}]\n\nДифференциальные уравнения движения в матричной форме:\n\n[\\frac{dq}{dt} = f(q, t)]\n\nЧисленно проинтегрируем полученные уравнения.\n\nФункция правых частей\n\nДля численного интегрирования уравнений движения системы в среде Python необходимо создать функцию правых частей f(q,t). В начале разрабатываемой программы подключаем модуль для работы с массивами (array):\n\nimport numpy as np\n\n\nи функцию интегрирования дифференциальных уравнений solve_ivp из модуля scipy.integrate:\n\nfrom scipy.integrate import solve_ivp\n\n\nДля \\(\\varphi = \\omega t\\), \\(\\omega = \\text{const}\\) функция правых частей дифференциальных уравнений движения имеет вид:\n\ndef dqdt(t, q):    \n    x   = q[0]\n    vx  = q[1]\n    \n    # Параметры системы\n    g   = 9.807   # ускорение свободного падения\n    m   = 0.5     # масса шарика\n    w   = 2*np.pi # угловая скорость пластины\n    c   = 150     # жёсткость пружины\n    L0  = 0.025   # свободная длина пружины\n    R   = 0.1     # радиус пластины\n    phi = w*t     # Угол поворота пластины    \n    f   = 0.0     # Коэффициент трения\n        \n    # Силы реакции \n    Ny = m*(2*w*vx-g*np.cos(phi)-w*w*R)\n    Nz = 0\n    # Модуль силы реакции (для вычисления силы трения)\n    N  = np.sqrt(Ny**2+Nz**2) \n    \n    # Ускорение шарика\n    ax  = g*np.sin(w*t) - x*c/m - f*np.sign(vx)*N/m + w*w*(L0+x-np.sqrt(3)*0.5*R)\n        \n    # аргумент функции - вектор q содержит координату и скорость,\n    # возвращаем производную от q, т.е. скорость и ускорение    \n    return (vx, ax)\n\n\nАргументы функции: t - время, q - вектор состояния системы для момента времени t. Для системы с одной степенью свободы это координата шарика x и его скорость vx.\n\nИнтегрирование\n\nЧисленное интегрирование выполняется при помощи функции solve_ivp\n\nПорядковые аргументы функции:\n\n  имя функции правой части системы ДУ\n  интервал интегрирования от t0 до tN\n  массив начальных условий\n\n\nИменованные аргументы:\n\n  rtol - относительная погрешность\n  atol - абсолютная погрешность\n\n\nОшибка на шаге интегрирования не превышает: atol + rtol * abs(y)\n\nПо умолчанию используется метод Рунге-Кутты с контролем точности и автоматическим выбором шага.\n\nsol = solve_ivp(dqdt, [0, 5], [0, 0], rtol = 1e-6, atol = 1e-6)\n\n\nРезультат работы функции solve_ivp - структура sol с результатами интегрирования:\n\n    message: The solver successfully reached the end of the integration interval.\n    success: True\n    status: 0\n        t: [ 0.000e+00  1.000e-04 ...  4.992e+00  5.000e+00]\n        y: [[ 0.000e+00 -1.215e-08 ...  8.183e-03  1.020e-02]\n            [ 0.000e+00 -2.429e-04 ...  2.862e-01  2.480e-01]]\n      sol: None\n t_events: None\n y_events: None\n     nfev: 1586\n     njev: 0\n      nlu: 0\n\n\nsol.t – Массив времени 1xN: первый элемент массива - начальное значение времени t0 последний элемент массива - конечное значение времени интегрирования tN.\n\nsol.y – таблица значений перемещения sol.y[0] и скорости шарика sol.y[1].\n\nПостроение графиков\n\nДля построения графиков необходимо подключить библиотеку matplotlib:\n\nimport matplotlib.pyplot as plt\n\n\nЗададим параметры графиков по умолчанию: ширину и высоту графиков в дюймах, размер и тип шрифта\n\nplt.rcParams[\"figure.figsize\"] = (17/2.5,10/2.5)\nplt.rcParams[\"font.size\"] = 14\nplt.rcParams[\"font.family\"] = 'Arial'\n\n\nПостроим график изменения координаты шарика:\n\nplt.plot(sol.t,sol.y[0])\nplt.xlabel('t, c');\nplt.ylabel('x, м');\nplt.grid(True,linestyle='dotted');\n\n\nГрафики изменения координаты и скорости шарика можно показать на одном рисунке.\n\nplt.plot(sol.t,sol.y[0],'k-', sol.t,sol.y[1],'k--');\nplt.xlabel('t, c');\nplt.ylabel('м, м/с');\nplt.grid(True,linestyle='dotted');\n\n\nВ этом случае необходимо добавить “легенду”\n\nplt.legend(('Координата','Скорость'));\n\n​  \nПо умолчанию “легенда” располагается на поле графика автоматически. Положение можно указать при помощи строкового параметра loc. Возможные значения:\n\n  ‘best’\n  ‘upper right’\n  ‘upper left’\n  ‘lower left’\n  ‘lower right’\n  ‘right’\n  ‘center left’\n  ‘center right’\n  ‘lower center’\n  ‘upper center’\n  ‘center’\n\n\nplt.legend(('Координата','Скорость'), loc = 'upper left');\n\n\nВ подписях осей и легенде можно использовать LaTeX-разметку для математических символов\n\nplt.ylabel('x, м, $V_x$, м/c');\nplt.legend(('x','$V_x$'));\n\n\nДля сохранения рисунка в графический файл используется функция savefig\n\nplt.savefig(\"x_Vx.png\",dpi=300)\n\n\nЕще один вариант построения графиков двух функций на одном рисунке, используя две оси y с разным масштабом\n\nfig, ax1 = plt.subplots()\nline1 = ax1.plot(sol.t,sol.y[0],'k-', label='x');\nax1.set_xlabel('t, c');\nax1.set_ylabel('x, м');\n\nax2 = ax1.twinx()\nline2 = ax2.plot(sol.t,sol.y[1],'k--', label='$V_x$')\nax2.set_ylabel('$V_x$, м/с')\n\n\n\n\nПередача параметров в функцию правых частей\n\nВ приведенном выше примере параметры системы были определены в функции правых частей, что не является хорошей практикой программирования. При таком подходе при изменении параметров системы будет необходимо вносить изменения в эту функцию. Для исследования влияния параметров на движение системы удобнее параметры системы задавать вне тела функции правых частей. Для передачи  параметров в функцию правых частей можно использовать объект типа namedtuple из модуля collections.\n\nfrom collections import namedtuple\n\n# Создаем структуру данных \nParameters = namedtuple('Parameters', 'g, m, w, c, L0, R, f')\n\n# Создаем набор параметров\np1 = Parameters(9.81,0.5,2*np.pi,150,0.025,0.1,0.0)\n# или так\np1 = Parameters(g = 9.81, m = 0.5, w = 2*np.pi, c = 100, L0 = 0.025, R = 0.1, f = 0.0)\n\n# Ещё один набор параметров (с другой жёсткостью пружины)\np2 = Parameters(g = 9.81, m = 0.5, w = 2*np.pi, c = 200, L0 = 0.025, R = 0.1, f = 0.0)\n\n\nСледует отметить, что как и классический tuple (кортеж), именованный кортеж не изменяем, т.е. после создания нельзя изменить значение атрибута, это приведет к ошибке.\n\nПерепишем функцию правых частей дифференциальных уравнений, добавив третий аргумент функции – структуру с параметрами системы\n\ndef dqdt(t, q, p):\n    # Функция правых частей\n    # t - текущее время\n    # q - вектор состояния системы\n    # p - параметры системы\n    # для системы с одной степенью свободы это координата шарика и его скорость\n    x  = q[0]\n    vx = q[1]\n    \n    # Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные\n    g, m, w, c, L0, R, f = list(p)\n\n    phi = w*t    # Угол поворота     \n\n    Ny = m*(2*w*vx-g*np.cos(phi)-w*w*R)\n    Nz = 0\n    N  = np.sqrt(Ny**2+Nz**2)     \n    # Вычисляем ускорение шарика\n    ax  = g*np.sin(w*t) - x*c/m - f*np.sign(vx)*N/m + w*w*(L0+x-np.sqrt(3)*0.5*R)\n   \n    # q содержит координату и скорость,\n    # возвращаем производную от q - скорость и ускорение    \n    return (vx, ax)\n\n\nПоскольку функция численного интегрирования solve_ivp первым аргументом ожидает функцию с двумя параметрами, используем лямбда-функцию двух аргументов, которая будет вызывать новую функцию правых частей с тремя аргументами, передавая в неё структуру с параметрами системы:\n\nsol1 = solve_ivp(lambda t, q: dqdt(t, q, p1), [0, 5], [0, 0], rtol = 1e-6)\n\n\nРешение для второго набора параметров\n\nsol2 = solve_ivp(lambda t, q: dqdt(t, q, p2), [0, 5], [0, 0], rtol = 1e-6)\n\n\nСравним два решения:\n\nplt.plot(sol1.t, sol1.y[0], 'k-', sol2.t, sol2.y[0],'k--');\nplt.legend(['c=100 Н/м','c=200 Н/м']);\nplt.ylabel('x, м');\nplt.xlabel('t, c');\nplt.title('Влияние жёсткости пружины');\n\n\nОпределение силы реакции при движении шарика в канале\n\nВариант 1.\n\nСоздадим функцию, которая будет вычислять реакцию заданного вектора состояния q и параметров p:\n\ndef Ny(t, q, p):\n    # t - время\n    # q - массив из двух элементов (x, Vx)\n    g, m, w, c, L0, R, f = list(p)\n    return 2*m*w*q[1] - m*g*np.cos(w*t) - m*w*w*R\n\n\nСклеиваем таблицу времени (строку 1xN) с таблицей решения (матрица 2xN), транспонируем результат. В результате этих действий получим матрицу Nx3, каждая строка которой содержит решение для заданного момента времени:\n\n# t0 x(t0) vx(t0)\n# t1 x(t1) vx(t1)\n# t2 x(t2) vx(t2)\n# ...\n# tN x(tN) vx(tN)\ndata1 = np.vstack((sol1.t,sol1.y)).T\n\n\nВызываем функцию  Ny(t, q, p) для каждой строки полученной матрицы:\n\nsol1_Ny = list(map( lambda row: Ny(row[0],row[1:],p1), data1 ))\n\n\nДля второго набора параметров\n\ndata2 = np.vstack((sol2.t,sol2.y)).T;\nsol2_Ny = list(map( lambda row: Ny(row[0],row[1:],p2), data2 ))\n\n\nПостроим графики сил реакции \\(N_y\\) для двух наборов параметров\n\nplt.plot(sol1.t,sol1_Ny,'r-',sol2.t,sol2_Ny,'b-.');\nplt.xlabel('t, c');\nplt.ylabel('$N_y$, Н');\nplt.legend(['c=100 Н/м','c=200 Н/м']);\n\n\nВариант 2.\n\nФункция, которую можно вызвать сразу для всех значений таблицы решения.\n\ndef Ny(t, q, p):\n    # t - массив t0, t1, t2, ... tN\n    # q - массив [ [ x(t0), x(t1), x(t2), ..., x(tN) ], [ vx(t0), vx(t1), ..., vx(tN) ] ]    \n    g, m, w, c, L0, R, f = list(p)\n    return 2*m*w*q[1,:] - m*g*np.cos(w*t) - m*R*w**2\n\n\nplt.plot(sol1.t,Ny(sol1.t,sol1.y,p1), sol2.t,Ny(sol2.t,sol2.y,p2));\nplt.xlabel('t, c');\nplt.ylabel('$N_y$, Н');\nplt.legend(['c=100 Н/м','c=200 Н/м'],loc='lower right');\n\n\n\n​\nАппроксимация функции sign гладкой функцией\n\nЧисленные методы интегрирования дифференциальных уравнений обычно предполагают гладкость функции правых частей \\(f(t,q)\\) по своим аргументам. Аппроксимируем функцию sign, которая использовалась для определения направления действия силы трения, гладкой функцией на основе сигмоиды\n\n[S(x) = \\frac{1}{1+e^{-x}}]\n\nx = np.linspace(-10,10,100)\n\ndef sigmoid(x):\n    return 1.0 / (1.0 + np.exp(-x))\n\n\nplt.plot(x, sigmoid(x),'r-', x, np.sign(x), 'k--');\nplt.grid()\nplt.xlabel('x')\nplt.legend(['S(x)','sign(x)']);\n\n\n“Крутизной” сигмоиды можно управлять при помощи параметра-множителя k перед аргументом x\n\n[S(x) = 2 \\left( \\frac{1}{1+e^{-k x}} - \\frac{1}{2} \\right)]\n\ndef sigmoid(x , k = 1):\n    return (1.0 / (1.0 + np.exp(-k*x)) - 0.5)*2\n\n\nx = np.linspace(-0.005,0.005,100)\n\nplt.plot(x,sigmoid(x,10000),x,sigmoid(x,2000),x,sigmoid(x,1000), x, np.sign(x),'k--');\nplt.legend(['k=10 000','k=2 000','k=1 000','sign(x)']);\n\n\n\n\nПерепишем функцию правых частей:\n\ndef dqdt(t, q, p):\n    # Функция правых частей\n    # t - текущее время\n    # q - вектор состояния системы\n    # p - параметры системы\n    # для системы с одной степенью свободы это координата шарика и его скорость\n    x  = q[0]\n    vx = q[1]\n    \n    # Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные\n    g, m, w, c, L0, R, f = list(p)\n\n    phi = w*t    # Угол поворота     \n\n    Ny = m*(2*w*vx-g*np.cos(phi)-w*w*R)\n    Nz = 0\n    N  = np.sqrt(Ny**2+Nz**2)     \n    # Вычисляем ускорение шарика\n    ax  = g*np.sin(w*t) - x*c/m - f*sigmoid(vx,10000)*N/m + w*w*(L0+x-np.sqrt(3)*0.5*R)\n   \n    # q содержит координату и скорость,\n    # возвращаем производную от q - скорость и ускорение    \n    return (vx, ax)\n\n\nРешение и графики\n\np1 = Parameters(g = 9.81, m = 0.5, w = 2*np.pi, c = 100, L0 = 0.025, R = 0.1, f = 0.1)\nsol = solve_ivp(lambda t, q: dqdt(t, q, p1), [0, 5], [0, 0], rtol = 1e-7, method = 'BDF')\n\nplt.plot(sol.t,sol.y[0],'k-',sol.t,sol.y[1],'k--');\nplt.xlabel('t, c');\nplt.ylabel('x, м, $V_x$, м/c');\nplt.legend(('x','$V_x$'));\n\n​\nСистема с двумя степенями свободы\n\nВо втором рассматриваемом случае механическая системы имеет две степени свободы, при этом движение происходит под действием только потенциальных сил – силы упругости пружины и силы тяжести. Трение при движении шарика внутри канала и при вращении пластины вокруг оси \\(O_1\\) не учитывается.\n\n\n\nУравнения движения запишем в форме уравнений Лагранжа второго рода для угла поворота пластины и координаты шарика относительно пластины:\n\n[\\begin{aligned}\n    &amp; \\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot \\varphi} - \\frac{\\partial T}{\\partial \\varphi} = - \\frac{\\partial \\Pi}{\\partial \\varphi} \n    &amp; \\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot x} - \\frac{\\partial T}{\\partial x} = - \\frac{\\partial \\Pi}{\\partial x}\n\\end{aligned}]\n\nКинетическая энергия системы имеет вид:\n\n[T = \\frac{1}{2} m_2\\left(\\dot{\\varphi}^2 \\left(l_0-\\frac{\\sqrt{3} R}{2}+x\\right)^2+\\left(\\dot x - R \\dot{\\varphi}\\right)^2\\right)+\\frac{3}{8} m_1 R^2 \\dot{\\varphi}^2]\n\nПотенциальная энергия системы:\n\n[\\Pi = \\frac{1}{2} \\left(c x^2+g m_2 \\sin \\varphi \\left(-2 l_0 + \\sqrt{3} R - 2 x\\right) - g R (m_1+2 m_2) \\cos \\varphi\\right)]\n\nУравнения движения:\n\n[\\left{\n\\begin{align}\n&amp; \\left[ m_2 \\left(l_0-\\frac{\\sqrt{3} R}{2}+x\\right)^2+\\frac{3 m_1 R^2}{4}+m_2 R^2 \\right] \\cdot \\ddot{\\varphi} - m_2 R \\cdot \\ddot x =  \\frac{1}{2} \\left(g m_2 \\cos \\varphi \\left(2 l_0-\\sqrt{3} R+2 x\\right)-g R (m_1+2 m_2) \\sin \\varphi \\right) - 2 m_2 \\dot{\\varphi} \\dot{x} \\left(l_0-\\frac{\\sqrt{3} R}{2}+x\\right) \n&amp; -m_2 R \\cdot \\ddot \\varphi + m_2 \\cdot \\ddot x = - c x + m_2 g \\sin \\varphi + m_2 \\left( l_0 - \\frac{\\sqrt{3}}{2}R + x \\right) \\dot{\\varphi}^2\n\\end{align}\n\\right.]\n\nПолученную систему дифференциальных уравнений можно записать в матричной форме\n\n[\\left{\n\\begin{aligned}\n&amp; a_{11} \\cdot \\ddot \\varphi + a_{12} \\cdot \\ddot x = b_1 \n&amp; a_{21} \\cdot \\ddot \\varphi + a_{22} \\cdot \\ddot x = b_2\n\\end{aligned}\n\\right.]\n\nили\n\n[\\begin{bmatrix} a_{11} &amp; a_{12}  \\ a_{21} &amp; a_{22} \\end{bmatrix} \\cdot \\begin{bmatrix} \\ddot \\varphi \\ \\ddot x \\end{bmatrix} = \\begin{bmatrix} b_{1} \\ b_{2} \\end{bmatrix}]\n\nгде\n\n[\\begin{aligned}\n&amp; a_{11} = \\left[ m_2 \\left(l_0-\\frac{\\sqrt{3} R}{2}+x\\right)^2+\\frac{3 m_1 R^2}{4}+m_2 R^2 \\right], \\quad a_{12} = - m_2 R \n&amp; a_{21} = -m_2 R, \\quad a_{22} = m_2 \n&amp; b_1 = \\frac{1}{2} \\left(g m_2 \\cos \\varphi \\left(2 l_0-\\sqrt{3} R+2 x\\right)-g R (m_1+2 m_2) \\sin \\varphi \\right) - 2 m_2 \\dot{\\varphi} \\dot{x} \\left(l_0-\\frac{\\sqrt{3} R}{2}+x\\right) \n&amp; b_2 = - c x + m_2 g \\sin \\varphi + m_2 \\left( l_0 - \\frac{\\sqrt{3}}{2}R + x \\right) \\dot{\\varphi}^2\n\\end{aligned}]\n\nДифференциальные уравнения движения системы записаны в форме системы линейных уравнений относительно ускорений. Это систему можно решить аналитически и привести систему уравнений к форме Коши. Однако, для системы с большим числом степеней свободы, аналитическое решение и приведение системы к форме Коши будет громоздким, поэтому удобнее решение системы линейных уравнений проводить численно в функции правых частей.\n\nПараметры системы\n\n# Создаем структуру данных \nParameters = namedtuple('Parameters', 'g, m1, m2, c, L0, R')\n\n# Создаем набор параметров\np = Parameters(g=9.81, m1=2, m2=0.5, c=200, L0=0.03, R=0.1)\n\n\nФункция правых частей\n\ndef dqdt(t, q, p):\n    # Функция правых частей\n    # t - текущее время\n    # q - вектор состояния системы\n    # p - параметры системы\n    # для системы с одной степенью свободы это координата шарика и его скорость    \n    phi = q[0]\n    w   = q[1]\n    x   = q[2]\n    vx  = q[3]\n    \n    # Для удобства все параметры извлекаем из именованного кортежа в отдельные переменные\n    g, m1, m2, c, L0, R = list(p)\n    \n    # Коэффициенты при ускорения в системе линейных уравнений\n    # относительно производных\n    a11 = 3*m1*R*R/4 + m2*R*R + m2*(L0 - np.sqrt(3)*R/2 + x)**2\n    a12 = -m2*R\n    \n    a21 = -m2*R\n    a22 =  m2\n    \n    # Элементы матрицы правых частей\n    b1  = 0.5*g*( m2*(2*L0-np.sqrt(3)*R+2*x)*np.cos(phi) - (m1+2*m2)*R*np.sin(phi) ) - 2*m2*(L0 - 0.5*np.sqrt(3)*R + x)*vx*w\n    b2  = -c*x + m2*(L0-0.5*np.sqrt(3)*R+x)*w*w + g*m2*np.sin(phi)\n    \n    # Составляем матрицы системы линейный уравнений относительно вторых производных\n    A   = np.array( [[a11, a12], [a21, a22]] )\n    B   = np.array( [b1,b2])\n\n    # Решаем систему линейных уравнений\n    d2q = np.linalg.solve(A, B)   \n    \n    # Получаем угловое ускорение \n    d2phi = d2q[0]\n        # и линейное относительное ускорение шарика\n    d2x   = d2q[1]\n    \n    # q содержит координату и скорость,\n    # возвращаем производную от q - скорость и ускорение    \n    return (w, d2phi, vx, d2x)\n\n\nНачальные условия\n\n[\\varphi(0) = 0.2, \\quad x(0) = 0, \\quad \\dot{\\varphi}(0) = 0.02, \\quad \\dot{x}(0) = 0.]\n\nq0  = [0.2, 0, 0.02, 0]\n\n\nИнтегрирование\n\nsol = solve_ivp(lambda t, q: dqdt(t, q, p), [0, 5], q0, rtol = 1e-7)\n\n\nГрафик изменения угла поворота пластины\n\nplt.plot(sol.t, sol.y[0], 'k-');\nplt.xlabel('t, c');\nplt.ylabel('$\\\\varphi$, рад');\nplt.grid(True,linestyle='dotted');\n\n\n\n\nГрафик перемещения шарика\n\nplt.plot(sol.t, sol.y[2], 'k-');\nplt.xlabel('t, c');\nplt.ylabel('$x$, м');\nplt.grid(True,linestyle='dotted');\n\n\n\n\nПроверим корректность построенной модели. Рассматриваемая механическая система с двумя степенями свободы является консервативной: при движении этой системы сумма её потенциальной П и кинетической Т энергий не изменяется.\n\nФункция вычисления кинетической энергии системы\n\ndef kinetic_energy(t, q, p):\n    phi = q[0]\n    w   = q[1]\n    x   = q[2]\n    vx  = q[3]    \n    \n    g, m1, m2, c, L0, R = list(p)\n    \n    T = (3.0/8.0)*m1*R*R*w**2 + 0.5*m2*(w*w*(L0-0.5*np.sqrt(3)*R+x)**2+(vx-R*w)**2)\n    \n    return T\n\n\nГрафик изменения кинетической энергии\n\nplt.plot(sol.t, kinetic_energy(sol.t,sol.y,p), 'k-');\nplt.xlabel('t, c')\nplt.ylabel('T, Дж');\nplt.grid(True,linestyle='dotted');\n\n​\nФункция вычисления потенциальной энергии системы\n\ndef potential_energy(t, q, p):\n    phi = q[0]\n    w   = q[1]\n    x   = q[2]\n    vx  = q[3]    \n    \n    g, m1, m2, c, L0, R = list(p)\n\n    P = 0.5*(x*x*c + m2*g*(-2*L0+np.sqrt(3)*R-2*x)*np.sin(phi) - g*(m1+2*m2)*R*np.cos(phi))\n    \n    return P\n\n\nГрафик изменения потенциальной энергии\n\nplt.plot(sol.t, potential_energy(sol.t,sol.y,p), 'k-');\nplt.xlabel('t, c')\nplt.ylabel('П, Дж');\nplt.grid(True,linestyle='dotted');\n\n\nПолная энергия\n\nE = kinetic_energy(sol.t,sol.y,p) + potential_energy(sol.t,sol.y,p)\n\nplt.plot(sol.t, kinetic_energy(sol.t,sol.y,p), sol.t, potential_energy(sol.t,sol.y,p), sol.t, E);\nplt.grid(True,linestyle='dotted');\nplt.xlabel('t, c')\nplt.ylabel('Энергия, Дж')\nplt.legend(['T','П','T+П']);\n\n\n\n\nГрафик иллюстрирует сохранение полной энергии системы, что свидетельствует о корректности построенной модели механической системы с двумя степенями свободны.\n\n",
      "categories": ["mechanics","cae"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2024-04-01-two-dof-python/"
    },{
      
      "title": "Модели SimInTech",
      "date": "2024-04-30 00:00:00 -0500",
      
      "content": "Хранилище (репозиторий) на GitVerse c примерами моделей, разработанных в процессе освоения SimInTech: файлы проектов со ссылками на их описание.\n\n",
      "categories": [],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/2024-04-30-simintech-projects-git/"
    },{
      
      "title": "Пример скрипта для создания анимации в Blender на основе результатов расчётов",
      "date": "2024-05-08 00:00:00 -0500",
      
      "content": "В проекте Blender создана следующая иерархия объектов:\n\n  Empty1 (Empty)\n    \n      Body1 (Mesh)\n      Empty2 (Empty)\n        \n          Body2 (Mesh)\n        \n      \n    \n  \n\n\nimport bpy\nimport math\nimport sys\nimport mathutils\nimport csv\nimport numpy as np\n\n# Удаление существующей анимации: \n# выделяем все объекты типа EMPTY (Add -&gt; Empty -&gt; Arrows)\nbpy.ops.object.select_by_type(type='EMPTY')\n# Удаляем, связанную с выделенными объектами анимацию\nbpy.ops.anim.keyframe_clear_v3d()\nbpy.ops.object.select_all(action='DESELECT')\n\n# Формируем список объектов типа Empty по их именам - систем координат (СК)\nobj = (bpy.data.objects['Empty1'], bpy.data.objects['Empty2'])\n\n# Читаем данные из файла\ndata=np.loadtxt('C:\\\\Users\\\\user\\\\results.csv', delimiter=',')\n\nnframes = data.shape[0]\nfor i in range(nframes):            \n        # Тело 1\n        phi11 = data[i,1]                        \n        phi12 = data[i,2]                        \n        # Матрицы элементарных поворотов СК 1\n        A1 = mathutils.Matrix.Rotation(phi11, 4, 'X')\n        A2 = mathutils.Matrix.Rotation(phi12, 4, 'Y')\n        # Матрица сложного поворота \n        # преобразование координат из СК 0 в СК 1\n        A01 = np.transpose(np.dot(A1,A2))\n        # Сохраняем \"кадр\" анимации \n        # Поворот СК                \n        obj[0].matrix_local =  A01        \n        obj[0].keyframe_insert(data_path='rotation_euler',frame=i)\n        # Положение СК\n        obj[0].location = mathutils.Vector((0.0,0.0,0.0))    \n        obj[0].keyframe_insert(data_path='location', frame=i)\n                \n        # Тело 2\n        phi21 = data[i,3]\n        # Матрицы элементарных поворотов СК 2 относительно СК 1 \n        A1 = mathutils.Matrix.Rotation(phi21, 4, 'X')\n        # Матрица сложного поворота из СК 1 в СК 2\n        A12 = np.transpose(A1)\n        # Поворот СК                \n        obj[1].matrix_local =  A12\n        obj[1].keyframe_insert(data_path='rotation_euler',frame=i)\n        # Положение СК\n        obj[1].location = mathutils.Vector((0.0,0.0,-1.0))    \n        obj[1].keyframe_insert(data_path='location', frame=i)\n\n",
      "categories": ["mechanics"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/2024-05-08-blender-script/"
    },{
      
      "title": "Вывод и интегрирование уравнений движения эллиптического мятника в Python (использование sympy, scipy)",
      "date": "2024-05-12 00:00:00 -0500",
      "description": "The derivation of the equations of motion for an elliptical pendulum using the Python programming language and the sympy library is presented. The obtained equations are numerically integrated and an animation is created.\n",
      "content": "Рассматриваемая механическая система имеет две степени свободы: её конфигурация определяется координатой \\(x\\)  тела 1 (брусок, движущийся поступательно вдоль оси \\($Ox_0\\)) и углом отклонения подвеса тела 2 от вертикали \\(\\phi\\). Движение системы происходит в однородном поле силы тяжести.\n\n\n\nВывод уравнений движения\n\nПодключение необходимых библиотек:\n\n# Массивы и матрицы\nimport numpy as np\n# Графики\nimport matplotlib.pyplot as plt\n# Символьные вычисления\nimport sympy as sp\n# Численное интегрирование дифференциальных уравнений\nfrom scipy.integrate import solve_ivp\n\n\nПараметры системы и обобщенные координаты\n\nУравнения движения системы запишем используя уравнения Лагранжа II-го рода. Для этого необходимо записать выражение для кинетической энергии системы \\(T(q_1,\\dot q_1,q_2,\\dot q_2)\\), аналитически продифференцировать его по обобщенной скорости, времени, обобщенной координате:\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot q_i} -\\frac{\\partial T}{\\partial q_i} = Q_{i}, \\quad i=1,2]\n\nУравнения движения рассматриваемой механической системы будут выводиться с использованием библиотеки sympy. Все переменные и параметры, которые будут входить в уравнения движения, необходимо объявить до их использования при помощи функции var или symbols.  Рассматриваемая система описывается следующими параметрами:\n\n  масса тела 1 (\\(m_1\\));\n  масса тела 2 (\\(m_2\\));\n  длина подвеса тела 2 (\\(l = AB\\));\n  ускорение свободного падения (\\(g\\)).\n\n\nТаким образом, объявление этих параметров-символов будет иметь вид:\n\nsp.var('m1,m2,l,g')\n\n\nТакже необходимо объявить обобщенные координаты, которые являются функциями времени. Это делается при помощи функции Function:\n\nx   = sp.Function('x')\nphi = sp.Function('phi')\n\n\nПосле объявления параметров и обобщенных координат (неизвестных пока функций времени) можно начать формирование выражений, необходимых для построения уравнений движения.\n\nКинематика (скорости тел)\n\nКоординатный столбец положения тела 1 в системе координат \\(Ox_0y_0\\) в sympy определим при помощи объекта типа Матрица:\n\nr1 = sp.Matrix([x(t),0])\n\n\nПри формировании этого выражения указывается, что обобщенная координата – объявленная ранее  функция x является функцией времени.\n\nКоординатный столбец положения тела 2 в системе координат  \\(Ox_0y_0\\):\n\nr2 = r1 + l*sp.Matrix([sp.sin(phi(t)),sp.cos(phi(t))])\n\n\nКоординатный столбец вектора скорости тела 1 определим дифференцированием координатного столбца положения тела 1 по времени, для этого используем функцию diff, передав ей дифференцируемое выражение и имя параметра, по которому выполняется дифференцирование:\n\nv1 = sp.diff(r1,t) \nv1\n\n\n[\\left[\\begin{matrix}\\frac{d}{d t} x{\\left(t \\right)}\\0\\end{matrix}\\right]]\n\nАналогично определим координатный столбец вектора скорости тела 2:\n\nv2 = sp.diff(r2,t)\nv2\n\n\n[\\displaystyle \\left[\\begin{matrix}l \\cos{\\left(\\phi{\\left(t \\right)} \\right)} \\frac{d}{d t} \\phi{\\left(t \\right)} + \\frac{d}{d t} x{\\left(t \\right)}\\- l \\sin{\\left(\\phi{\\left(t \\right)} \\right)} \\frac{d}{d t} \\phi{\\left(t \\right)}\\end{matrix}\\right]]\n\nЛевая часть уравнений Лагранжа\n\nКинетическая энергия рассматриваемой системы определяется суммой кинетических энергий тела 1 и тела 2:\n\nT = m1*v1.dot(v1)/2 + m2*v2.dot(v2)/2\nT\n\n\n[\\frac{m_{1} \\left(\\frac{d}{d t} x{\\left(t \\right)}\\right)^{2}}{2} + \\frac{m_{2} \\left(l^{2} \\sin^{2}{\\left(\\phi{\\left(t \\right)} \\right)} \\left(\\frac{d}{d t} \\phi{\\left(t \\right)}\\right)^{2} + \\left(l \\cos{\\left(\\phi{\\left(t \\right)} \\right)} \\frac{d}{d t} \\phi{\\left(t \\right)} + \\frac{d}{d t} x{\\left(t \\right)}\\right)^{2}\\right)}{2}]\n\nИспользуя функцию diff найдем левую часть уравнений Лагранжа II-го рода для первой обобщенной координаты \\(\\phi\\):\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot \\phi} -\\frac{\\partial T}{\\partial \\phi} = Q_\\phi]\n\neq1 = sp.diff(sp.diff( T, sp.diff(phi(t),t) ),t) - sp.diff(T,phi(t))\n# Упрощаем\neq1 = sp.simplify(eq1)\neq1\n\n\n[l m_{2} \\left(l \\frac{d^{2}}{d t^{2}} \\phi{\\left(t \\right)} + \\cos{\\left(\\phi{\\left(t \\right)} \\right)} \\frac{d^{2}}{d t^{2}} x{\\left(t \\right)}\\right)]\n\nЛевая часть уравнения Лагранжа II-го рода для второй обобщенной координаты \\(x\\):\n\n[\\frac{d}{dt} \\frac{\\partial T}{\\partial \\dot x} -\\frac{\\partial T}{\\partial x} = Q_x]\n\neq2 = sp.simplify( sp.diff(sp.diff( T, sp.diff(x(t),t) ),t) - sp.diff(T,x(t)) )\neq2\n\n\n[l m_{2} \\left(l \\frac{d^{2}}{d t^{2}} \\phi{\\left(t \\right)} + \\cos{\\left(\\phi{\\left(t \\right)} \\right)} \\frac{d^{2}}{d t^{2}} x{\\left(t \\right)}\\right)]\n\nОбобщенные силы\n\nМеханическая система в однородном поле силы тяжести, поэтому для определения обобщенных сил удобней использовать выражение для потенциальной энергии системы, определенной из условия того, что уровень y = 0 является уровнем нулевой потенциальной энергии:\n\n[\\Pi = - m_2 g l \\cos \\phi]\n\nP = -m2*g*r2[1]\n\n\nОбобщенная сила для первой обобщенной координаты:\n\n[Q_\\phi = - \\frac{\\partial \\Pi}{\\partial \\phi}]\n\nQ1 = -sp.diff(P,phi(t))\n\n\nОбобщенная сила для второй обобщенной координаты:\n\n[Q_x = - \\frac{\\partial \\Pi}{\\partial x}]\n\nQ2 = -sp.diff(P,x(t))\n\n\nПриведение уравнений к форме Коши\n\nРазрешим полученную систему дифференциальных уравнений (eq1 = Q1, eq2 = Q2) относительно старших производных, используя функцию solve:\n\nсauchy_form = sp.simplify(sp.solve( (eq1 - Q1, eq2 - Q2), (sp.diff(phi(t),t,2), sp.diff(x(t),t,2) )))\nсauchy_form\n\n\nФункция solve  возвращает решение в виде словаря:\n\n[\\left{ \\frac{d^{2}}{d t^{2}} \\phi{\\left(t \\right)} : - \\frac{g m_{1} \\sin{\\left(\\phi{\\left(t \\right)} \\right)}}{l m_{1} - l m_{2} \\cos^{2}{\\left(\\phi{\\left(t \\right)} \\right)} + l m_{2}} - \\frac{g m_{2} \\sin{\\left(\\phi{\\left(t \\right)} \\right)}}{l m_{1} - l m_{2} \\cos^{2}{\\left(\\phi{\\left(t \\right)} \\right)} + l m_{2}} - \\frac{l m_{2} \\sin{\\left(\\phi{\\left(t \\right)} \\right)} \\cos{\\left(\\phi{\\left(t \\right)} \\right)} \\left(\\frac{d}{d t} \\phi{\\left(t \\right)}\\right)^{2}}{l m_{1} - l m_{2} \\cos^{2}{\\left(\\phi{\\left(t \\right)} \\right)} + l m_{2}}, \\  \\frac{d^{2}}{d t^{2}} x{\\left(t \\right)} : \\frac{g m_{2} \\sin{\\left(\\phi{\\left(t \\right)} \\right)} \\cos{\\left(\\phi{\\left(t \\right)} \\right)}}{m_{1} - m_{2} \\cos^{2}{\\left(\\phi{\\left(t \\right)} \\right)} + m_{2}} + \\frac{l m_{2} \\sin{\\left(\\phi{\\left(t \\right)} \\right)} \\left(\\frac{d}{d t} \\phi{\\left(t \\right)}\\right)^{2}}{m_{1} - m_{2} \\cos^{2}{\\left(\\phi{\\left(t \\right)} \\right)} + m_{2}}\\right}]\n\nДля численного интегрирования уравнений движения преобразуем эту символьную функцию в функцию числовых аргументов (значений параметров системы и значений обобщенных координат и скоростей), которая будет возвращать вторые производные обобщенных координат. Для это используем функцию lambdify.\n\nСформируем список аргументов этой функции: первые 4 элемента этого списка – параметры системы, оставшиеся 4 элемента — обобщенные координаты и скорости (всего 8 параметров):\n\nargs = ( m1,m2,l,g,   phi(t),x(t),sp.diff(phi(t),t),sp.diff(x(t),t) )\n\n\nСоздаем функцию 8 аргументов, которая будет вычислять вторые производные обобщенных координат:\n\naccelerations = sp.lambdify( args, [ сauchy_form[sp.diff(phi(t),t,2)], сauchy_form[sp.diff(x(t),t,2)] ] )\n\n\nПроверяем, как работает эта функция\n\naccelerations(1.0, 3.0, 2, 9.81, 1.0,0, 0,0)\n\n&gt; [-5.284409988846435, 4.282768353189539]\n\n\nЧисленное интегрирование\n\nОбъявим функцию правых частей для численного интегрирования системы двух дифференциальных уравнений второго порядка:\n\ndef dydt(t,q,p):            \n    (d2phi, d2x) = accelerations(*(*p,*q))    \n    return (*q[2:4], d2phi, d2x)  \n\n\nЗададим параметры системы, начальные условия и проинтегрируем дифференциальные уравнения её движения:\n\n# Параметры системы: m1, m2, l, g\np  = [3,1,2,9.81];\n# Начальные условия phi0, x0, dphi/dt, dx/dt\nq0 = [1.0, 0.0, 0, 0];\n\nsolution = solve_ivp(lambda t, q: dydt(t, q, p), [0, 10], q0, \n                     rtol = 1e-6, method=\"LSODA\", t_eval = np.linspace(0,10,100))\n\n\nГрафики\n\nplt.figure(figsize=[11,4])\nplt.subplot(1,2,1)\nplt.plot(solution.t,solution.y[0,:]*180/np.pi); plt.xlabel('t, c'); plt.ylabel('$\\phi$, градус');\nplt.subplot(1,2,2)\nplt.plot(solution.t,solution.y[1,:]); plt.xlabel('t, c'); plt.ylabel('x, м');\n\n\n\n\nАнимация\n\nДополнительные библиотеки для построения графических примитивов и анимации.\n\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.lines as mlines\nfrom matplotlib.patches import Wedge\n\n\nfig, ax = plt.subplots(figsize=[10,6]);\nplt.xlim(-2.5,2.5)\nplt.ylim(-2.5,0.5)\nax.set_aspect(1)\n\n# Основание, по которому скользит первое тело\nbase    = mlines.Line2D([-3,3],[0,0], lw = 1, color = 'k', ls = '--') \n# Подвеска тела 2\nthread  = mlines.Line2D([q0[1],q0[1]+2*np.sin(q0[0])],[0,-2*np.cos(q0[0])], lw = 1, color = 'r') \n# Аннотация (время)\ntext    = plt.annotate('t = 0 c',[1.7,0.2])\n# Тело 1 (брусок)\nbody1   = mlines.Line2D(q0[1]+np.array([0.2,-0.2,-0.2,0.2,0.2]),np.array([0.1,0.1,-0.1,-0.1,0.1]), lw = 2, color = 'b') \n# Тело 2 (шарик)\nbody2   = Wedge([q0[1]+2*np.sin(q0[0]),-2*np.cos(q0[0])], 0.1, 0, 360, fc = 'b')\n\ndef init():\n    ax.add_line(base)        \n    ax.add_line(thread)        \n    ax.add_line(body1)    \n    ax.add_patch(body2)    \n    ax.add_artist(text)\n    return (ax,)\n\ndef get_frame(i):        \n    phi = solution.y[0, i] \n    x   = solution.y[1, i] \n    t   = solution.t[i]\n    \n    x1 =  x + 2*np.sin(phi)\n    y1 =  0 - 2*np.cos(phi)\n    \n    thread.set_xdata([x, x1])\n    thread.set_ydata([0, y1])\n    \n    body1.set_xdata(x+np.array([0.2,-0.2,-0.2,0.2,0.2]))        \n    body1.set_ydata(np.array([0.1,0.1,-0.1,-0.1,0.1]))        \n    \n    body2.set_center([x1, y1])        \n    \n    text.set_text('t = {:3.2f} c'.format(t))    \n    \n    return (base,thread,body1,body2,text)\n    \nanim = FuncAnimation(fig, get_frame, init_func=init, frames = len(solution.t), interval=50, blit=False)\n\nanim.save('animation.gif')\n\n\n\n",
      "categories": ["python","mechanics"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/python/mechanics/2024-05-12-python-elliptic-pendulum/"
    },{
      
      "title": "Уравнения относительного орбитального движения",
      "date": "2024-07-21 00:00:00 -0500",
      
      "content": "Система координат\n\nРассматривается движение космического аппарата (КА) относительно орбитальной станции, движущейся по круговой или эллиптической орбите. Положение КА относительно станции определяется в орбитальной подвижной системе координат \\(Ox_oy_oz_o\\), связанной с центром масс станции. Ось \\(Ox_o\\) направлена по направлению  радиус вектора станции относительно центра Земли (\\(\\vec r\\)), ось \\(Oy_o\\)  лежит в плоскости орбиты станции и направлена в направлении орбитального движения, ось \\(Oz_o\\) дополняет систему координат \\(Ox_oy_oz_o\\) до правой.\n\n\n\nНелинейные уравнения для эллиптической орбиты станции\n\nНелинейные уравнения движения КА относительно станции при движении станции по эллиптической орбите имею следующий вид:\n\n[\\left{\n\\begin{aligned}\n&amp; \\ddot x - 2 \\dot{\\vartheta} \\dot y - \\ddot{\\vartheta} y - \\dot{\\vartheta}^2 x = - \\frac{\\mu(r+x)}{[(r+x)^2+y^2+z^2]^{3/2}} + \\frac{\\mu}{r^2} \n&amp; \\ddot y + \\dot{\\vartheta} \\dot x + \\ddot{\\vartheta} x - \\dot{\\vartheta}^2 y = - \\frac{\\mu y}{[(r+x)^2+y^2+z^2]^{3/2}}\n&amp; \\ddot z = - \\frac{\\mu z}{[(r+x)^2+y^2+z^2]^{3/2}}\n\\end{aligned}\n\\right.]\n\nгде \\(x, y, z\\) – координаты КА относительно станции (проекции вектора \\(\\rho\\) на оси орбитальной подвижной системы координат станции), \\(\\mu\\) – гравитационный параметр Земли. Угол истинной аномалии станции \\(\\dot \\vartheta\\) и расстояние от станции до центра Земли \\(r\\), определяются дифференциальными уравнениями движения станции по эллиптической орбите:\n\n[\\ddot \\vartheta = -\\frac{2 \\dot r \\dot \\vartheta}{r}, \\quad \\ddot{r} = r \\dot{\\vartheta}^2 - \\frac{\\mu}{r^2}.]\n\nФункция правых частей на языке MATLAB\n\nfunction dq = nonlinear_relative_orbital(t,q,p)\n    r       = q(1);     % расстояние до притягивающего центра\n    theta   = q(2);     % угол истинной аномалии станции\n    rho     = q(3:5);   % относительные координаты\n    dr      = q(6);     % dr/dt\n    dtheta  = q(7);     % угловая скорость орбитального движения\n    v       = q(8:10);  % относительная скорость\n    \n    % Уравнения движения станции\n    d2r     = r*dtheta^2-p.mu/(r^2);\n    d2theta = -2*dr*dtheta/r;\n    \n    rm      = sqrt((r+rho(1))^2+rho(2)^2+rho(3)^2);\n    \n    d2x     = -p.mu*(r+rho(1))/rm^3 + p.mu/r^2 + 2*dtheta*v(2) + d2theta*rho(2) + dtheta^2*rho(1);\n    d2y     = -p.mu*rho(2)/rm^3 - 2*dtheta*v(1) - d2theta*rho(1) + dtheta^2*rho(2);\n    d2z     = -p.mu*rho(3)/rm^3;\n    \n    dq = [dr;dtheta;v;d2r;d2theta;d2x;d2y;d2z];\nend\n\n\nНелинейные уравнения относительного движения для круговой орбиты станции\n\nПри движении станции по круговой орбите \\(\\dot{\\vartheta} = n_0 = \\text{const}, \\, \\ddot{\\vartheta}  = 0, \\, r = a_0 = \\text{const}\\) уравнения упрощаются:\n\n[\\left{\n\\begin{aligned}\n&amp; \\ddot x - 2 n_0 \\dot y - n^2_0 x = - \\frac{\\mu(a_0+x)}{[(a_0+x)^2+y^2+z^2]^{3/2}} + \\frac{\\mu}{a_0^2} \n&amp; \\ddot y + n_0 \\dot x - n^2_0 y = - \\frac{\\mu y}{[(a_0+x)^2+y^2+z^2]^{3/2}}\n&amp; \\ddot z = - \\frac{\\mu z}{[(a_0+x)^2+y^2+z^2]^{3/2}}\n\\end{aligned}\n\\right.]\n\nЛинеаризованные уравнения для круговой орбиты\n\nДля малого в сравнении с радиусом орбиты расстояния между станцией и КА (\\(\\rho &lt;&lt; a_0\\)) приведенные выше можно линеаризовать и приводятся к простому виду:\n\n[\\left{\n\\begin{aligned}\n&amp; \\ddot x - 2 n_0 \\dot y - 3 n^2_0 x = 0 \n&amp; \\ddot y + 2 n_0 \\dot x =  0 \n&amp; \\ddot z + n_0^2 z  = 0\n\\end{aligned}\n\\right.]\n\nЭти уравнения  могут быть проинтегрированный аналитически:\n\n[\\begin{aligned}\n&amp; x = x_0 (4 - 3\\cos n_0t) + \\frac{1}{n_0} \\left[ \\dot x_0 \\sin n_0 t + 2 \\dot y_0 (1-\\cos n_0t) \\right],\n&amp; y  =  y_0 + \\left[ 6x_0+\\frac{4\\dot y_0}{n_0}\\right] \\sin n_0 t + \\frac{2 \\dot x_0}{n}(\\cos n_0 t-1) -\\left[ 6n_0 x_0+3 \\dot y_0\\right]t,\n&amp; z  = \\frac{z_0}{n_0} \\sin n_0 t + z_0 \\cos n_0 t.\n\\end{aligned}]\n\nИсточники и ссылки\n\n\n  Alfriend K.T. et al. Spacecraft formation flying: Dynamics, control and navigation // Spacecraft Formation Flying: Dynamics, control and navigation. 2009.\n  Относительное орбитальное движение 1.\n  Относительное орбитальное движение 2\n\n\n",
      "categories": ["mechanics"],
      "tags": ["matlab"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2024-07-21-relative_orbital_motion/"
    },{
      "image": "/assets/img/blog/kane-two-bodies-model_cover.png",
      "title": "Пример вывода уравнений движения системы тел методом Кейна",
      "date": "2024-08-15 00:00:00 -0500",
      "description": "Derivation of the equations of spatial motion for a system of two bodies using the Kane method.\n",
      "content": "Метод Кейна\n\nМетод разработан в 1961 проф. Т. Кейном (Стэндфорский университет) (Kane, T.R., Dynamics of nonholonomic systems, J. App. Mech., 28, 574, 1961). Метод основан на принципе Даламбера-Лагранжа и ориентирован на машинное формирование уравнений движения. При выводе уравнений движения используются вспомогательные векторные величины, которые здесь будут называться частными линейными \\(\\mathbf v_{ik}\\) и угловыми скоростями \\(\\boldsymbol \\omega_{ik}\\). Эти величины являются векторными множителями, стоящими перед обобщенными скоростями в выражениях для линейных и угловых скоростей тел механической системы. Например, скорость материальной точки на плоскости, положение которой определяется двумя координатами x и y, в декартовой системе координат можно представить как:\n\n[\\mathbf v = \\mathbf{e}_x \\dot{x} + \\mathbf{e}_y \\dot{y}]\n\nВ этом выражении частными линейными скоростями будут единичные векторы \\(\\mathbf{e}_x\\) и \\(\\mathbf{e}_x\\).\n\nПри вращении твердого тела вокруг неподвижной точки частными угловыми скоростями будет орты связанной с телом системы координат \\(\\mathbf{e}_x^c, \\mathbf{e}_y^c, \\mathbf{e}_z^c\\), поскольку угловая скорость тела будет определяться выражением\n\n[\\boldsymbol{\\omega} = \\mathbf{e}_x^c \\omega_x + \\mathbf{e}_y^c \\omega_y + \\mathbf{e}_z^c \\omega_z]\n\nРассмотрим движение несвободной системы материальных точек. Движение каждой точки определяется внешней силой и силой реакции:\n\n[m_k \\mathbf a_k = \\mathbf F_k + \\mathbf R_k, \\quad k=1,\\ldots,n.]\n\nПосле умножения каждого уравнения на соответствующее виртуальное перемещение \\(\\delta \\mathbf r_k\\) и сложения всех уравнений, для идеальных связей получим общее уравнение динамики:\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k - m_k \\mathbf a_k \\right)\\cdot \\delta \\mathbf r_k + \\sum_{k=1}^N \\underbrace{\\mathbf R_k \\cdot \\delta \\mathbf r_k}_{0} = 0.]\n\nПодставляя вариации радиус-вектора \\(\\mathbf r_k(q_1,\\ldots,q_n)\\) в обобщённых координатах:\n\n[\\delta \\mathbf r_k =  \\sum_{i=1}^n \\frac{\\partial \\mathbf r_k}{\\partial q_i} \\delta q_i.]\n\nполучим\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k - m_k \\mathbf a_k \\right)\\cdot \\sum_{i=1}^n \\frac{\\partial \\mathbf r_k}{\\partial q_i} \\delta q_i  = 0.]\n\nПосле изменения порядка суммирования:\n\n[\\sum_{i=1}^n \\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} - m_k \\mathbf a_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} \\right) \\delta q_i = 0.]\n\nи с учётом независимости вариаций обобщённых координат:\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} - m_k \\mathbf a_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} \\right)= 0, \\quad i=1,\\ldots,n.]\n\nЧастная производная вектора скорости точки по обобщенной скорости имеет вид:\n\n[\\frac{\\partial \\mathbf v_k}{\\partial \\dot q_i} = \\frac{\\partial {\\mathbf r_k}}{\\partial {q}i} = \\mathbf u{ki}.]\n\nи называется частной скоростью:\n\n[\\mathbf u_{ki} = \\frac{\\partial \\mathbf v_k}{\\partial \\dot q_i}]\n\nПодставляя\n\n[\\frac{\\partial {\\mathbf r_k}}{\\partial {q}_j} = \\frac{\\partial \\mathbf v_k}{\\partial \\dot q_j}]\n\nв уравнения движения\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} - m_k \\mathbf a_k \\cdot \\frac{\\partial \\mathbf r_k}{\\partial q_i} \\right)= 0, \\quad i=1,\\ldots,n.]\n\nполучим\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\frac{\\partial \\mathbf v_k}{\\partial \\dot q_i} - m_k \\mathbf a_k \\cdot \\frac{\\partial \\mathbf v_k}{\\partial \\dot q_i} \\right)= 0, \\quad i=1,\\ldots,n.]\n\nили\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\mathbf u_{ki} - m_k \\mathbf a_k \\cdot \\mathbf u_{ki} \\right)= 0, \\quad i=1,\\ldots,n.]\n\nОбозначив обобщенные активные силы \\(Q_i\\) и силы инерции \\(Q_i^*\\):\n\n[Q_i = \\sum_{k=1}^{N} \\mathbf F_k \\cdot \\mathbf u_{ki}, \\quad\n  Q_i^* = - \\sum_{k=1}^{N} m_k \\mathbf a_k \\cdot \\mathbf u_{ki}]\n\nуравнения\n\n[\\sum_{k=1}^N \\left(\\mathbf F_k \\cdot \\mathbf u_{ki} - m_k \\mathbf a_k \\cdot \\mathbf u_{ki} \\right)= 0, \\quad i=1,\\ldots,n.]\n\nпринимают вид:\n\n[Q_i + Q_i^* = 0.]\n\nАлгоритм\n\n\n  Выбираются обобщенные координаты \\(q_1,q_2\\ldots,q_n\\).\n  Определяются скорости тел, которые  могут быть как производные обобщенных координат, так и их линейными комбинациями (например, угловые скорости для твердого тела).\n  Определяются выражения для векторов скоростей точек приложения сил.\n  Определяются выражения для векторов скоростей центров масс тел.\n  Определяются выражения для векторов угловых скоростей тел.\n  Определяются векторы линейных ускорений тел системы и их угловые ускорения.\n  Определяются частные линейные и угловые скорости для точек приложения сил, центров масс тел.\n  Определяются силы и моменты (активные и инерционные).\n  Вычисляются скалярные произведения сил, моментов и частных скоростей.\n\n\nПример\n\nСхема системы\n\nИспользуя метод Кейна, построим модель движения механической системы с четырьмя степенями свободы, представленной на рисунке 1. Система состоит из двух стержней связанных шарнирами. Первый стержень при помощи сферического шарнира связан с неподвижным основанием, второй стержень соединяется с первым при помощи цилиндрического шарнира.\n\nДвижение механизма происходит под действием силы тяжести, действующей отрицательном направлении оси \\(Oz_0\\).\n\n\n\nРисунок 1 - Схема механизма\n\nПоложение шарниров задано координатными столбцами векторов \\(\\mathbf{c}_{11}^{(1)}\\), \\(\\mathbf{c}_{12}^{(1)}\\), \\(\\mathbf{c}_{22}^{(2)}\\):\n\n\n  вектор \\(\\mathbf{c}_{11}\\) соединяет центр масс тела 1 и шарнирную точку (О) первого шарнира;\n  вектор \\(\\mathbf{c}_{12}\\) соединяет центр масс тела 1 и шарнирную точку (А) второго шарнира;\n  вектор \\(\\mathbf{c}_{22}\\) соединяет центр масс тела 2 и шарнирную точку (А) второго шарнира.\n\n\nКинематические соотношения\n\nПоложение системы определим столбцом обобщенных координат:\n\n[\\mathbf q = [\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4]^T]\n\nПервые три угла определяют ориентацию базиса \\(C_1 x_1 y_1 z_1\\), связанного с телом 1 относительно неподвижного базиса \\(O x_0 y_0 z_0\\). Для определения ориентации используется последовательность XY’Z’’ (углы Брайнта). Матрица преобразования координат из базиса \\(C_1 x_1 y_1 z_1\\) в базис \\(O x_0 y_0 z_0\\) определяется выражением:\n\n[\\mathbf{A}^{01} = \\mathbf{A}{x}(\\alpha_1) \\mathbf{A}{y}(\\alpha_2) \\mathbf{A}_{z}(\\alpha_3)]\n\nУгол \\(\\alpha_4\\) определяет ориентацию тела 2 относительно тела 1. Вращение тела 2 относительно тела 1 происходит вокруг общей оси \\(y\\), поэтому матрица преобразования координат из базиса \\(C_2 x_2 y_2 z_2\\), связанного со вторым телом в базис \\(C_1 x_1 y_1 z_1\\), будет иметь вид:\n\n[\\mathbf{A}^{12} = \\mathbf{A}_{y}(\\alpha_4)]\n\nСформируем столбец скоростей системы, но не из обобщенных скоростей, а из проекций угловых скоростей тела 1 на его связанные оси и производной угла поворота второго тела относительно первого.\n\n[\\mathbf{u}=\\left[\\omega_x^{\\left(1\\right)},\\omega_y^{\\left(1\\right)},\\omega_z^{\\left(1\\right)},{\\dot{\\alpha}}_4\\right]^T]\n\nЭта особенность метода Кейна позволяет упростить вывод уравнений движения системы.\n\nСкорость и ускорение центра масс тела 1\n\nВектор скорости центра масс первого тела определяется выражением:\n\n[\\vec{V}1  = \\vec{\\omega}_1 \\times (-\\vec{c}{11}).]\n\nКоординатная форма этого выражения в неподвижной СК \\(A_1 x_0 y_0 z_0\\) будет иметь вид:\n\n[\\mathbf{V}1^{(0)}=\\mathbf{A}^{01}{\\widetilde{\\mathbf{\\omega}}}_1^{(1)}\\ \\left(-\\mathbf{c}{11}^{\\left(1\\right)}\\right)=\\mathbf{A}^{01}{\\widetilde{\\mathbf{c}}}{11}^{\\left(1\\right)}\\mathbf{\\omega}_1^{(1)}=\\left[\\begin{matrix}\\mathbf{A}^{01}{\\widetilde{\\mathbf{c}}}{11}^{\\left(1\\right)}&amp;\\mathbf{0}3\\\\end{matrix}\\right]\\mathbf{u}=\\mathbf{Q}{V1}^{(0)}\\mathbf{u}]\n\nОператор тильда используется для матричной записи векторного произведения и преобразует координатный столбец вектора в кососимметрическую матрицу:\n\n[\\tilde{\\mathbf a} = \n  \\begin{bmatrix}\n  0 &amp; -a_z &amp; a_y \n  a_z &amp; 0 &amp; -a_x \n -a_y &amp; a_x &amp; 0\n  \\end{bmatrix}, \\quad \\mathbf a \\times \\mathbf b = \\tilde{\\mathbf a} \\mathbf b]\n\nМатрица \\(\\mathbf{Q}_{V1}^{(0)}\\) имеет размерность \\(3\\times n\\), где \\(n\\) – число степеней свободы системы. Каждый столбец этой матрицы представляет собой частную скорость центра масс тела 1, например, первый вектор \\(\\mathbf{u}_{11}\\) можно получить следующим образом:\n\n[\\mathbf{u}{11} = \\mathbf{Q}{V1}^{(0)} \\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \\end{bmatrix}.]\n\nКоординатный столбец ускорения центра масс получим, продифференцировав выражение для скорости:\n\n[\\mathbf{a}1^{(0)} = \\mathbf{Q}{V1}^{(0)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}_{V1}^{(0)} \\dot{\\mathbf{u}}]\n\nПроизводная матрицы частных векторов:\n\n[\\dot{\\mathbf{Q}}{V1}^{(0)} = \\begin{bmatrix} \\mathbf{A}^{01} \\tilde{\\boldsymbol \\omega}_1^((1) ) \\tilde{\\mathbf c}{11}^{(1)} &amp;  \\mathbf{0}_3 \\end{bmatrix}]\n\nгде \\({0}_3\\) – столбец нулей \\(3 \\times 1\\).\n\nУгловая и скорость ускорение тела 1\n\nКоординатный столбец вектора угловой скорости первого тела в проекциях на собственные оси будет определяться выражением\n\n[\\boldsymbol{\\omega}1^{(1)} = \\begin{pmatrix} \\mathbf{E}{3} &amp; \\mathbf{0}3 \\end{pmatrix} \\mathbf{u} = \\mathbf{Q}{w1}^{(1)} \\mathbf{u}]\n\nМатрица \\(\\mathbf{Q}_{w1}^{(1)}\\) как и матрица \\(\\mathbf{Q}_{V1}^{(0)}\\) имеет размерность \\(3\\times n\\), где \\(n\\). Каждый столбец матрицы представляет собой частную угловую скорость тела 1.\n\nУгловое ускорение тела 1\n\n[\\boldsymbol{\\varepsilon}1^{(1)} = \\mathbf{Q}{w1}^{(1)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}_{w1}^{(1)} \\mathbf{u}]\n\nМатрица  \\(\\mathbf{Q}_{w1}^{(1)}\\) не зависит от времени, поэтому \\(\\dot{\\mathbf{Q}}_{V1}^{(0)} = 0\\).\n\nСкорость и ускорение центра масс тела 2\n\nВектор скорости центра масс второго тела представляет собой сумму скорости движения второго тела вместе с первым и скорости второго тела относительно первого:\n\n[\\vec{V}2  = \\vec{V}{2}^e + \\vec{V}{2}^r = \\vec{\\omega}_1 \\times (-\\vec{c}{11}+\\vec{c}{12}-\\vec{c}{22})]\n\nВ координатной матричной форме это выражение имеет вид:\n\n[\\mathbf{V}2^{\\left(0\\right)}=\\mathbf{A}^{01}{\\widetilde{\\mathbf{\\omega}}}_1^{\\left(1\\right)}\\ \\left(-\\mathbf{c}{11}^{\\left(1\\right)}+\\mathbf{c}{12}^{\\left(1\\right)}-\\mathbf{A}^{12}\\mathbf{c}{22}^{\\left(2\\right)}\\right)+\\mathbf{A}^{01}\\mathbf{A}^{12}\\left(-{\\widetilde{\\mathbf{e}}}y\\mathbf{c}{22}^{\\left(2\\right)}\\right){\\dot{\\alpha}}_4]\n\nгде \\(\\mathbf{e}_y  = [0,1,0]\\) – единичный вектор оси y – оси вращения второго тела относительно первого.\n\nИзменим порядок векторного произведения для того, чтобы вынести координатный столбец угловой скорости первого тела в правую часть выражения:\n\n[\\mathbf{V}2^{\\left(0\\right)} = -\\mathbf{A}^{01}\\left(-{\\widetilde{\\mathbf{c}}}{11}^{\\left(1\\right)}+{\\widetilde{\\mathbf{c}}}{12}^{\\left(1\\right)}-\\widetilde{\\mathbf{A}^{12}\\mathbf{c}{22}^{\\left(2\\right)}}\\right)\\mathbf{\\omega}1^{\\left(1\\right)}+\\mathbf{A}^{01}\\mathbf{A}^{12}{\\widetilde{\\mathbf{c}}}{22}^{\\left(2\\right)}\\mathbf{e}_y{\\dot{\\alpha}}_4]\n\nи введем матрицу частных скоростей тела 2 \\(\\mathbf{Q}_{V2}^{(0)}\\):\n\n[\\mathbf{V}2^{\\left(0\\right)} = \\left[-\\begin{matrix}\\mathbf{A}^{01}\\left(-{\\widetilde{\\mathbf{c}}}{11}^{\\left(1\\right)}+{\\widetilde{\\mathbf{c}}}{12}^{\\left(1\\right)}-\\widetilde{\\mathbf{A}^{12}\\mathbf{c}{22}^{\\left(2\\right)}}\\right)&amp;\\mathbf{A}^{01}\\mathbf{A}^{12}{\\widetilde{\\mathbf{c}}}{22}^{\\left(2\\right)}\\mathbf{e}_y\\\\end{matrix}\\right]\\mathbf{u}=\\mathbf{Q}{V2}^{(0)}\\mathbf{u}]\n\nПродифференцируем выражение для \\(\\mathbf{V}_2^{\\left(0\\right)}\\) для определения ускорения центра масс тела 2:\n\n[\\mathbf{a}1^{(0)}=\\mathbf{Q}{V1}^{(0)}\\dot{\\mathbf{u}}+{\\dot{\\mathbf{Q}}}_{V1}^{(0)}\\mathbf{u}]\n\nгде \\({\\dot{\\mathbf{Q}}}_{V1}^{(0)}\\) – производная матрицы \\(\\mathbf{Q}_{V2}^{(0)}\\):\n\n[{\\dot{\\mathbf{Q}}}{V2}^{(0)}=\n\\begin{bmatrix}\n-\\mathbf{A}^{01}{\\widetilde{\\mathbf{\\omega}}}_1^{\\left(1\\right)}\\left(-{\\widetilde{\\mathbf{c}}}{11}^{\\left(1\\right)}+{\\widetilde{\\mathbf{c}}}{12}^{\\left(1\\right)}-\\widetilde{\\mathbf{A}^{12}\\mathbf{c}{22}^{\\left(2\\right)}}\\right)+\\mathbf{A}^{01}\\widetilde{\\left(\\mathbf{A}^{12}{\\widetilde{\\mathbf{\\Omega}}}2^{\\left(2\\right)}\\mathbf{c}{22}^{\\left(2\\right)}\\right)} &amp;\n\\mathbf{A}^{01}{\\widetilde{\\mathbf{\\omega}}}1^{\\left(1\\right)}\\mathbf{A}^{12}{\\widetilde{\\mathbf{c}}}{22}^{\\left(2\\right)}\\mathbf{e}y+\\mathbf{A}^{01}\\mathbf{A}^{12}{\\widetilde{\\mathbf{\\Omega}}}_2^{\\left(2\\right)}{\\widetilde{\\mathbf{c}}}{22}^{\\left(2\\right)}\\mathbf{e}_y\n\\end{bmatrix}]\n\nУгловая скорость и ускорение второго тела\n\nУгловая скорость тела 2 определяется угловой скоростью тела 1 (\\(\\vec{\\omega}_1\\)) и угловой скоростью тела 2 относительно тела 1 (\\(\\vec{\\Omega}_2\\)):\n\n[\\vec{\\omega}_2 = \\vec{\\omega}_1 + \\vec{\\Omega}_2.]\n\nВ матричной координатной форме это выражение имеет вид (в системе координат тела 2):\n\n[\\boldsymbol{\\omega}2^{(2)}=\\left[\\left(\\mathbf{A}^{12}\\right)^T\\mathbf{E}\\mathbf{3}\\ \\ \\ \\mathbf{e}y\\right]\\dot{\\mathbf{u}}=\\mathbf{Q}{w2}^{(2)}\\mathbf{u}]\n\nКоординатный столбец углового ускорения тела 2 определим дифференцированием выражения для \\(\\boldsymbol{\\omega}_2^{(2)}\\):\n\n[\\boldsymbol{\\varepsilon}2^{(2)}=\\mathbf{Q}{w2}^{(2)}\\dot{\\mathbf{u}}+{\\dot{\\mathbf{Q}}}_{w2}^{(2)}\\mathbf{u}]\n\nгде\n\n[{\\dot{\\mathbf{Q}}}{w2}^{(2)}=\\left[\\left(\\mathbf{A}^{12}{\\widetilde{\\mathbf{\\Omega}}}_2^{\\left(2\\right)}\\right)^T\\mathbf{E}\\mathbf{3}\\ \\ \\ \\mathbf{0}_3\\right]]\n\nСилы\n\nДвижение механической системы  происходит под действием силы тяжести, действующей отрицательном направлении оси \\(Oz_0\\). Координатные столбцы сил, действующих на тела 1 и 2 в неподвижном базисе:\n\n[\\mathbf{F}_1^{(0)} = [0,0,-m_1 g]^T, \\quad \\mathbf{F}_2^{(0)} = [0,0,-m_2 g]^T]\n\nУравнения движения\n\nСила инерции первого тела определяется выражением:\n\n[\\boldsymbol{\\Phi}1 = - m_1 \\mathbf{a}_1 = - m_1 [ \\mathbf{Q}{V1}^{(0)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}_{V1}^{(0)} \\mathbf{u} ]]\n\nЭто выражение необходимо умножить скалярно на соответствующие частные скорости центра масс первого тела. Учитывая, что необходимые частные скорости это столбцы матрицы \\(\\mathbf{Q}_{V1}^{(0)}\\), скалярное произведение можно записать в матричном виде следующим образом\n\n[\\mathbf{Q}{v1} = \\begin{bmatrix}\n  \\mathbf{u}{11} \\cdot \\boldsymbol{\\Phi}1  \n  \\mathbf{u}{12} \\cdot \\boldsymbol{\\Phi}1  \n  \\mathbf{u}{13} \\cdot \\boldsymbol{\\Phi}1  \n  \\mathbf{u}{14} \\cdot \\boldsymbol{\\Phi}1  \n  \\end{bmatrix} = \n  (\\mathbf{Q}{V1}^{(0)})^T \\left{- m_1 \\left( \\mathbf{Q}{V1}^{(0)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}{V1}^{(0)} \\mathbf{u} \\right) \\right}]\n\nГлавный момент сил инерции тела 1\n\n[\\mathbf M_{c1}^{\\Phi} = - \\mathbf{J}_1 \\boldsymbol{\\varepsilon}_1^{(1)} - \\boldsymbol{\\omega_1}^{(1)} \\times \\mathbf{J}_1 \\boldsymbol{\\omega}_1^{(1)}]\n\nскалярно умножается на частные угловые скорости тела 1:\n\n[\\mathbf{Q}{w1} = \n  \\begin{bmatrix}\n  \\mathbf{w}{11} \\cdot \\mathbf M_{c1}^{\\Phi}  \n  \\mathbf{w}{12} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\mathbf{w}{13} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\mathbf{w}{14} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\end{bmatrix} = \n  (\\mathbf{Q}{w1}^{(1)})^T \\left[- \\mathbf{J}_1 (\\mathbf{Q}{w1}^{(1)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}_{w1}^{(1)} \\mathbf{u}) - \\boldsymbol{\\omega_1}^{(1)} \\times \\mathbf{J}_1 \\boldsymbol{\\omega}_1^{(1)} \\right]]\n\nАналогичные выражения определяются для тела 2\n\n[\\mathbf{Q}{v2} = \\begin{bmatrix}\n  \\mathbf{u}{21} \\cdot \\boldsymbol{\\Phi}2  \n  \\mathbf{u}{22} \\cdot \\boldsymbol{\\Phi}2  \n  \\mathbf{u}{23} \\cdot \\boldsymbol{\\Phi}2  \n  \\mathbf{u}{24} \\cdot \\boldsymbol{\\Phi}2  \n  \\end{bmatrix} = \n  (\\mathbf{Q}{V2}^{(0)})^T \\left{- m_2 \\left( \\mathbf{Q}{V2}^{(0)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}{V2}^{(0)} \\mathbf{u} \\right) \\right}]\n\n[\\mathbf{Q}{w2} = \n  \\begin{bmatrix}\n  \\mathbf{w}{21} \\cdot \\mathbf M_{c1}^{\\Phi}  \n  \\mathbf{w}{22} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\mathbf{w}{23} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\mathbf{w}{24} \\cdot \\mathbf M{c1}^{\\Phi}  \n  \\end{bmatrix} = \n  (\\mathbf{Q}{w2}^{(2)})^T \\left[- \\mathbf{J}_2 (\\mathbf{Q}{w2}^{(2)} \\dot{\\mathbf{u}} + \\dot{\\mathbf{Q}}_{w2}^{(2)} \\mathbf{u}) - \\boldsymbol{\\omega}_2^{(2)} \\times \\mathbf{J}_2 \\boldsymbol{\\omega}_2^{(2)} \\right]]\n\nДалее определяются обобщенные силы. Поскольку силы приложены в центрах масс тел, векторы этих сил скалярно умножаются на соответствующие частные линейные скорости центров масс:\n\n[\\mathbf{F}{v1} = (\\mathbf{Q}{V1}^{(0)})^T \\mathbf{F}_1]\n\n[\\mathbf{F}{v2} = (\\mathbf{Q}{V2}^{(0)})^T \\mathbf{F}_2]\n\nСложив полученные обобщённые силы\n\n[\\mathbf Q_{v1} + \\mathbf Q_{v2} + \\mathbf Q_{w1} + \\mathbf Q_{w2} +\\mathbf Q_{v1} + \\mathbf{F}{v1} + \\mathbf{F}{v2} = 0,]\n\nи выделив слагаемые с производной координатного столбца скорости, получим систему дифференциальных уравнений в матричной форме относительно \\(\\dot{\\mathbf{u}}\\):\n\n[\\mathbf{Q}{v1} + \\mathbf{Q}{v2} + \\mathbf{Q}{w1} + \\mathbf{Q}{w1} + \\mathbf{F}{v1} + \\mathbf{F}{v2} = 0]\n\n[\\begin{aligned}\n&amp; \\sum_{i=1}^{2}{\\left{-m_i\\left[\\mathbf{Q}{Vi}^{\\left(0\\right)}\\right]^T\\mathbf{Q}{Vi}^{\\left(0\\right)}-\\left[\\mathbf{Q}{wi}^{\\left(i\\right)}\\right]^T\\mathbf{J}_i^{\\left(i\\right)}\\mathbf{Q}{wi}^{\\left(i\\right)}\\right}\\dot{\\mathbf{u}}} = \\ \n&amp; = \\sum_{i=1}^{2}{m_i\\left[\\mathbf{Q}{Vi}^{\\left(0\\right)}\\right]^T{\\dot{\\mathbf{Q}}}{Vi}^{\\left(0\\right)}\\mathbf{u}} + \\sum_{i=1}^{2}{\\left[\\mathbf{Q}{wi}^{\\left(i\\right)}\\right]^T\\left[\\mathbf{J}_i^{\\left(i\\right)}{\\dot{\\mathbf{Q}}}{wi}^{\\left(i\\right)}\\mathbf{u}+{\\widetilde{\\mathbf{\\omega}}}i^{\\left(i\\right)}\\mathbf{J}_i^{\\left(i\\right)}\\mathbf{\\omega}_i^{\\left(i\\right)}\\right]\\ } - \\sum{i=1}^{2}{\\left(\\mathbf{Q}_{Vi}^{\\left(0\\right)}\\right)^T\\mathbf{F}_i} \n\\end{aligned}]\n\nЭти уравнения интегрируются совместно кинематическими уравнениями, связывающими производные углов с угловыми скоростями:\n\n[\\dot{\\alpha}1 = \\sec \\alpha_2 (\\omega{1x}^{(1)} \\cos \\alpha_3 - \\omega_{1y}^{(1)} \\sin \\alpha_3),]\n\n[\\dot{\\alpha}2 = \\omega{1x}^{(1)} \\sin \\alpha_3 + \\omega_{1y}^{(1)} \\cos \\alpha_3,]\n\n[\\dot{\\alpha}3 = \\tan \\alpha_2 (\\omega{1y}^{(1)} \\sin \\alpha_3 - \\omega_{1x}^{(1)} \\cos \\alpha_3) + \\omega_{1z}^{(1)}.]\n\nMATLAB-код\n\nГлавный файл-скрипт\n\nclear all; clc;\n\n% Матрицы тензоров инерции тел в главных центральных осях\np.J1 = eye(3)*10;\np.J2 = eye(3)*10;\n% Шарнирные векторы\np.c11 = [0;0;+1];\np.c12 = [0;0;-1];\np.c22 = [0;0;+1];\n% Массы тел\np.m1 = 1;\np.m2 = 1;\n% Ускорение свободного падения\np.g = 9.807;\n\n% Начальные условия\nq0 = [pi/4;pi/4;pi/4;pi/4;  0;0;0;0];\n\n% Относительная погрешность\nopt = odeset('RelTol',1e-7);\n% Запуск процесса интегрирования\n[t,q] = ode113(@(t,q) dqdt_kane(t,q,p), [0,10], q0,opt);\n\n% Графики\nclose all;\nfigure;\nplot(t,q(:,1:4)*180/pi);\nlegend('\\alpha_1','\\alpha_2','\\alpha_3','\\alpha_4');\nxlabel('t, c'); \nylabel('\\alpha_i, градус');\n\nfigure;\nplot(t,q(:,5:8)*180/pi);\nlegend('\\omega_{1x}','\\omega_{1y}','\\omega_{1z}','d\\alpha_4/dt');\nxlabel('t, c'); \nylabel('Угловые скорости, ...^o/c');\n\n\n\nФункция правых частей\n\nfunction dq = dqdt_kane(t,q,p)\n\ndq = zeros(8,1);\n\n% Матрицы элементарных поворотов\nAx = @(x) [1 0 0; 0 cos(x) -sin(x); 0 sin(x) cos(x)];\nAy = @(x) [cos(x) 0 sin(x); 0 1 0; -sin(x) 0 cos(x)];\nAz = @(x) [cos(x) -sin(x) 0; sin(x) cos(x) 0; 0 0 1];\n% Единичные векторы осей\nex = [1;0;0];\ney = [0;1;0];\nez = [0;0;1];\ne0 = [0;0;0];\n\n% Матрица-столбец скоростей\nu  = q(5:8);\n\n% Матрица преобразования координат из 1 в 0\nA01 = Ax(q(1))*Ay(q(2))*Az(q(3));\n% Матрица преобразования координат из 2 в 1\nA12 = Ay(q(4));\n% Матрица преобразования координат из 2 в 0\nA02 = A01*A12;\n\n% Угловая скорость тела 1\nw1_1  = q(5:7);\n% Относительная угловая скорость тела 2 относительно тела 1 в СК 2\nOw1_2 = ey*q(8);\n% Абсолютная угловая скорость тела 2 в СК 2\nw2_2  = A12'*w1_1+Ow1_2;\n\n% Частные линейные скорости центра масс С1 в 0\nQ1V_0  = [A01*tilde(p.c11) zeros(3,1)];\n% Производная Q1V_0\ndQ1V_0 = [A01*tilde(w1_1)*tilde(p.c11) zeros(3,1)];\n\n% Частные линейные скорости центра масс С2 в 0\nQ2V_0  = [-A01*(-tilde(p.c11)+tilde(p.c12)-tilde(A12*p.c22)) A01*A12*tilde(p.c22)*ey];\ndQ2V_0 = [-A01*tilde(w1_1)*(tilde(-p.c11)+tilde(p.c12)-tilde(A12*p.c22))+A01*tilde(A12*tilde(Ow1_2)*p.c22),...\n          A01*tilde(w1_1)*A12*tilde(p.c22)*ey+A01*A12*tilde(Ow1_2)*tilde(p.c22)*ey];\n\n% Частные угловые скорости 1 в 0 не нужны \nQ1w_1  = [eye(3)   zeros(3,1)];\ndQ1w_1 = [zeros(3) zeros(3,1)];\n\n% Частные угловые скорости 2 в 0 не нужны \nQ2w_2  = [A12'*eye(3) ey];\ndQ2w_2 = [(A12*tilde(Ow1_2))'*eye(3) zeros(3,1)];\n\n% Силы тяжести\nF1 = [0;0;-p.m1*p.g];\nF2 = [0;0;-p.m2*p.g];\n\n% Матрица масс\nM = -p.m1*(Q1V_0')*Q1V_0-p.m2*(Q2V_0')*Q2V_0-(Q1w_1')*(p.J1*Q1w_1)-(Q2w_2')*p.J2*Q2w_2;\n\n% Матрица правых частей\nB = -(-p.m1*(Q1V_0')*dQ1V_0*u-(Q1w_1')*(p.J1*dQ1w_1*u+tilde(w1_1)*p.J1*w1_1)-...\n       p.m2*(Q2V_0')*dQ2V_0*u-(Q2w_2')*(p.J2*dQ2w_2*u+tilde(w2_2)*p.J2*w2_2)+...\n       (Q1V_0')*F1+(Q2V_0')*F2  );\n\n% Решаем СЛУ относительно старших производных (угловых ускорений)\ndu = M\\B;\n\n% Кинематические уравнения\n% Производные углов\ndq(1) = sec(q(2))*(q(5)*cos(q(3))-q(6)*sin(q(3)));\ndq(2) = q(5)*sin(q(3))+q(6)*cos(q(3));\ndq(3) = tan(q(2))*(q(6)*sin(q(3))-q(5)*cos(q(3)))+q(7);\ndq(4) = q(8);\n% Угловые ускорения\ndq(5:8) = du;\n\nend\n\n",
      "categories": ["mechanics","CAE","matlab"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/matlab/2024-08-15-kane-3d/"
    },{
      "image": "/assets/img/blog/simintech-pendulum-wheel/slide.jpg",
      "title": "Модель движения маятника с точкой подвеса на колесе",
      "date": "2024-10-24 00:00:00 -0500",
      "description": "Построение в среде динамического моделирования SimInTech модели движения маятника с подвижной точкой подвеса, закрепленной на колесе.\n",
      "content": "Рассмотрим движение физического маятника с точкой подвеса шарнирно закрепленной в центре колеса (точка С). Колесо может катиться без проскальзывания  по прямой линии на горизонтальной плоскости.\n\nЭта механическая система имеет две степени свободы: её положение определяется углом поворота колеса \\(\\varphi\\) и углом отклонения маятника от вертикали – \\(\\beta\\). Координата центра масс колеса относительно неподвижной системы координат Oxy, расположенной на плоскости, будет определяться произведением радиуса колеса \\(r\\) на угол его поворота \\(\\varphi\\) с противоположным знаком (рисунок 1).\n\n\n\nРисунок 1 - Схема механизма\n\nДвижение механизма описывается следующей системой дифференциальных уравнений второго порядка:\n\n[\\left{\n\\begin{aligned}\n    &amp; \\dot \\omega a_{11} + \\ddot \\beta a_{12} \\cos \\beta  = a_{12} \\dot{\\beta}^2 \\sin \\beta - L \n    &amp; \\dot \\omega a_{12} \\cos \\beta + \\ddot{\\beta} a_{22} = L + m g b \\sin \\beta \n\\end{aligned}\n\\right.]\n\nгде \\(a_{11} = m_1 r^2+J_1\\), \\(a_{12} = m_2 r l\\), \\(a_{22} = J_2\\), \\(m_1\\,J_1\\) – масса и момент инерции колеса относительно его центра C, \\(r\\) – радиус колеса, \\(m_2,\\,J_2\\) – масса и момент инерции маятника относительно точки закрепления С, \\(L\\) – момент привода, который стремится повернуть маятник против часовой стрелки, а колесо в противоположном направлении.\n\nУравнения движения маятника приведены в монографии: Формальский А. М. Управление движением неустойчивых объектов.  М.: Физматлит, 2012.\n\nМодель SimInTech\n\nПараметры модели (глобальные переменные)\n\nСоздадим новый проект “Файл”→”Новый проект”→”Схема модели общего вида”.\n\nПараметры (константы) механической системы зададим в скрипте проекта. Для открытия скрипта проекта необходимо нажать на кнопку “Скрипт” на панели инструментов окна проекта (рисунок 2).\n\n\n\nРисунок 2 - Панель инструментов проекта\n\nВ редакторе кода (скрипта проекта) создадим секцию инициализации и определим значения параметров механической системы. Секция инициализации выполнятся один раз при запуске проекта:\n\ninitialization\n\t// Радиус колеса\n\tr = 0.25;\n\t// Длина стержня\n\tl = 1.0;\n\t// Масса колеса\n\tm1 = 10;\n\t// Масса груза\t\t\n\tm2 = 5;\n\t// Момент инерции колеса\n\tJ1 = 0.5*m1*r^2;\n\t// Момент инерции груза относительно оси вращения\n\tJ2 = m2*l^2;\t\n\t// Ускорение силы тяжести\n\tg = 9.81;\n\t// Начальный угол поворота\n\tbeta0 = 0.7;\t            \t\nend;\n\n\nМодель механизма\n\nМодель механизма построим при помощи блока “Язык программирования” из библиотеки “Динамические”. После помещения блока на схему проекта необходимо дважды начать левую кнопку мыши, чтобы открылся редактор кода блока. В блоке при помощи директивы input объявлены входные переменные: угол поворота маятника от вертикали (beta), угловая скорость вращения маятника (dbeta), угол поворота колеса (phi), угловая скорость колеса (w) и момент привода (Torque). Выходные переменные блока (output) – это угловое ускорением маятника (d2beta) и угловое ускорение колеса (dw):\n\ninput \tbeta, dbeta, phi, w, Torque;\noutput  d2beta,dw;                 \n\n\nВ блоке формируется матрица коэффициентов при старших производных системы дифференциальных уравнений движения механизма (матрица масс), матрица правых частей, производится решение системы линейный уравнений относительной старших производных при помощи функции lsolve:\n\n// Коэффициенты матрицы масс\na11 = m1*(r*r+rho*rho)+m2*r*r;\na12 = m2*r*l;\na21 = a12;\na22 = m2*r*r;                   \n// Коэффициенты столбца правой части\nb1  = -Torque+a12*sin(beta)*dbeta^2;\nb2  = +Torque+m2*g*l*sin(beta);\n// Матрица масс \nA = [[a12*cos(beta),a11],[a22,a12*cos(beta)]];\n// Матрица правой части\nB = [b1,b2];\n// Ускорения\nda = lsolve(A,B);\n// Ускорения записываем в переменные, объявленные в секции output\nd2beta = da[1];\ndw     = da[2];\n\n\nТаким образом, при помощи блока “Язык программирования” построена функция, описывающая правую часть системы дифференциальных уравнений движения механизма в форме Коши: на вход блока подаются углы и угловые скорости, на выходе формируются угловые ускорения колеса и маятника:\n\n\n\nРисунок 3 - Функция правых частей системы дифференциальных уравнений механизма\n\nИнтегрирование\n\nСигналы с выходов блока “Язык программирования” подадим на блоки-интеграторы, на выходах которых в результате интегрирования формируются угловая скорость, угол поворота маятника, угловая скорость и угол поворота колеса.\n\n\n\nРисунок 4 - Интегрирование сигналов с выходов блока “Язык программирования”\n\nСигналы с выходов интеграторов записываются в память (блоки “В память” библиотеки “Субструктуры”) для того чтобы не загромождать схему системы пересекающимися соединительными линиями. Блок “В память” предназначен для соединения одной части схемы с другой, находящейся в произвольном месте проекта. Установка блока на линию связи соответствует установке именованной метки на блок-схеме. После чего, помеченный сигнал может быть использован в произвольном месте проекта с помощью блока “Из памяти”.\n\nВ свойствах второго интегратора на выходе d2beta зададим начальный угол поворота маятника beta0, объявленный в скрипте инициализации проекта (рисунок 5).\n\n\n\nРисунок 5 - Начальные условия интегрирования (свойства блока-интегратора)\n\nВ параметрах остальных блоков-интеграторов в качестве начальных условий указаны нули (это значения “по-умолчанию”), т.е. в начальный момент времени маятник отклонён на угол beta0, при этом угол  поворота колеса, его угловая скорость и угловая скорость самого мятника равны нулю .\n\nСхема модели свободного движения маятника при нулевом внешнем моменте имеет показана на рисунке 6. На вход “torque” модели дифференциальных уравнений подан постоянный нулевой сигнал.\n\n\n\nРисунок 6 - Модель механизма\n\nСигналы проекта\n\nСоздание сигналов\n\nПри помощи редактора сигналов проекта (Главное меню → Сервис → Сигналы) создадим четыре глобальные переменные, в которые будем записывать кинематические параметры маятника: углы поворота и угловые скорости колеса и маятника. Эти сигналы нам понадобятся для построения графиков кинематических параметров механизма и для визуализации его движения.\n\nПод сигналами в SimInTech понимаются глобальные параметры проекта или группы проектов, которые создаются тремя способами: при помощи таблицы сигналов проекта, путем объявления и задания сигналов в скрипте проекта с помощью внутреннего языка программирования или с помощью базы данных проекта, если необходим обмен данными между несколькими проектами в рамках пакета проектов.\n\n\n\nРисунок 7 - Сигналы проекта\n\nСвязь сигналов с динамическими переменными блоков модели\n\nПосле создания списка сигналов откроем редактор связей (Главное меню → Сервис → Связи…), при помощи которого установим связь между кинематическими параметрами и созданными ранее глобальными переменными – сигналами проекта.\n\nПосле открытия редактора связей, не закрывая его, в окне модели выделим второй блок интегратор (рисунок 8), на вход которого поступает производная угла поворота маятника \\(\\dot beta\\), а на выходе формируется угол \\(\\beta\\). В левой нижней области списка сигналов блока “Интегратор” появятся переменная  fdif, обозначающая то, то поступает на вход блока (первая производная угла \\(\\dot \\beta\\)), и xdiff – то, что формируется на выходе блока – результат интегрирования (\\(\\beta\\)). Левой кнопкой мыши схватим строчку xdiff и перетащим её в свободную строчку столбца “Источник”.\n\n\n\nРисунок 8 - Связь сигналов с параметрами блока (выбор блока)\n\nДалее откроем вкладку “Сигнал” редактора связей. Здесь будет показан список ранее созданных сигналов проекта. Левой кнопкой мыши схватим строку beta и перетащим её в столбец “Приёмник”, как показано на рисунке 9. Таким образом мы указали, что результат интегрирования блока “Integrator_2” будет в процессе моделирования автоматически записываться в глобальную переменную (“сигнал проекта”) beta. Подобным образом необходимо связать все оставшиеся сигналы проекта.\n\n\n\nРисунок 9 - Связь сигналов с параметрами блока (выбор сигнала)\n\nГрафики сигналов\n\nДля построения графиков изменения угла поворота маятника \\(\\beta\\) откроем менеджер данных (рисунок 10) и, нажав правую кнопку мыши, добавим в раздел “Графики” новый “Временной график”.\n\n\n\nРисунок 10 - Менеджер данных\n\nВ контекстном меню созданного временного графика, выберем “Добавить” и “Параметр”, указав в качестве имени параметра сигнал проекта  beta.\n\n\n\nРисунок 11 - Добавить параметр\n\nАналогичным образом создадим временные графики для всех определенных ранее сигналов проекта, связанных с параметрами модели.\n\nРезультаты моделирования\n\nНа рисунке 12 показано изменение угла поворота маятника при его свободном движении после запуска процесса моделирования движения механизма. Как следует из рисунка 12, в своём свободном движении при заданных начальных условиях маятник совершает колебаний вокруг устойчивого положения равновесия \\(\\beta = \\pi\\).\n\n\n\nРисунок 12 - Угол поворота маятника\n\nСистема управления\n\nУправление углом \\(\\beta\\)\n\nДобавим в модель системы управления, которая будет удерживать маятник в неустойчивом положении равновесия \\(\\beta = 0\\). Сигнал момента, формируемого системой управления, определим как линейную комбинацию угла \\(\\beta\\) и его производной:\n\n[M_\\beta = - k_1 [(\\beta-\\beta_p) + k_2 (\\dot{\\beta}-\\dot{\\beta}_p)]]\n\nТ.е. управляющий момент \\(M_\\beta\\)  будет тем больше по модулю, чем больше отклонение (ошибка) угла и угловой скорости от требуемого (программного) значения \\(\\beta_p = 0\\), \\(\\dot{\\beta}_p = 0\\). Знак минус в выражении момента означает, что знак момента будет противоположен знаку отклонения угла \\(\\beta\\) от вертикального положения и знаку отклонения угловой скорости от нуля. Коэффициенты \\(k_1\\) и \\(k_2\\) – коэффициенты усиления отклонений. Выбор этих параметров – это отдельная задача теории автоматического управления, которая здесь не рассматривается.\n\nНа рисунке 13 приведен график изменения угла поворота маятника при действии определенного выше момента \\(M_\\beta\\) c \\(k_1 = 60\\) Нм/рад и \\(k_2 = 9\\) Нм*с/рад: при этих коэффициентах в течение 2 секунд мятник возвращается и удерживается системой управления в нулевом положении.\n\n\n\nРисунок 13 - Угол поворота маятника при управлении\n\nУправление углом \\(\\varphi\\)\n\nПри действии управляющего момента \\(M_\\beta\\) движение самого колеса не контролируется, поэтому после стабилизации углового положения маятника колесо продолжит движение с некоторой скоростью. Это иллюстрирует рисунок 14, где показан график изменения угловой скорости колеса.\n\n\n\nРисунок 14 - Угловая скорость вращения колеса\n\nДобавим управление, которое будет возвращать колесо в начало координат. Для этого к управляющему моменту \\(M_\\beta\\) добавим еще один момент, значение которого будет пропорционально отклонению угла поворота колеса \\(\\varphi\\)  и его угловой скорости \\(\\omega = \\dot{\\varphi}\\) от нулевого значения. Поскольку колесо катится без проскальзывания, нулевое значение угла \\(\\varphi\\) будет соответствовать его положению  \\(x = - r \\varphi\\) в начале координат (рисунок 1):\n\n[M_\\varphi = - [k_3 (\\varphi-\\varphi_p) + k_4 (\\dot{\\varphi}-\\dot{\\varphi}_p)]]\n\nгде \\(\\varphi_p = \\dot{\\varphi}_p = 0\\) – программные значения угла поворота и угловой скорости колеса.\n\nСхема модели будет иметь вид:\n\n\n\nРисунок 15 - Схема модели\n\nНа рисунках 16 и 17 показаны графики изменения угла поворота маятника и угловой скорости колеса при действии управляющего момента\n\n[M_u = M_\\beta + M_\\varphi.]\n\n\n\nРисунок 16 - Изменение угла поворота маятника\n\n\n\nРисунок 17 - Изменение угловой скорости колеса\n\nРабота управляющего момента показана на следующем видео:\n\n\n\nПроект на GitVerse.\n",
      "categories": ["mechanics","CAE"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2024-10-24-wheel-pendulum/"
    },{
      "image": "/assets/img/blog/simintech-course-work.png",
      "title": "Моделирования движения механизма с двумя степенями свободы",
      "date": "2024-11-09 00:00:00 -0600",
      "description": "SimInTech-проект моделирования движения механизма с двумя степенями свободы\n",
      "content": "Пример модели механизма с двумя степенями свободы из заданий для курсовой работы кафедры теоретической механики Самарского университета.\n\n",
      "categories": ["mechanics","CAE"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/mechanics/cae/2024-11-09-simintech-course-work/"
    },{
      
      "title": "Модель эффекта Джанибекова в Wolfram Mathematica",
      "date": "2025-04-23 00:00:00 -0500",
      "description": "Численное интегрирование уравнений пространственного движения твёрдого тела вокруг неподвижной точки и его визуализация в Wolfram Mathematica\n",
      "content": "\n  Файл Wolfram Mathematica\n  3D-модель гайки-барашка (stl)\n\n\n\n\nДинамические уравнения Эйлера\n\neq = {\n   Jx wx'[t] == (Jy - Jz) wy[t] wz[t],\n   Jy wy'[t] == (Jz - Jx) wx[t] wz[t],\n   Jz wz'[t] == (Jx - Jy) wy[t] wx[t]\n   };\n\n\nКинематические уравнения для углов последовательности XZ’X’’\n\n\nkinematicEq = {\n   ψ'[t] == (wz[t] Sin[φ[t]] - wy[t] Cos[\\[CurlyPhi][t]])/\n     Sin[\\[CurlyTheta][t]],\n   \\[CurlyTheta]'[t] == \n    wz[t] Cos[\\[CurlyPhi][t]] + wy[t] Sin[\\[CurlyPhi][t]],\n   \\[CurlyPhi]'[t] == \n    wx[t] + (wy[t] Cos[\\[CurlyPhi][t]] - wz[t] Sin[\\[CurlyPhi][t]])/\n      Tan[\\[CurlyTheta][t]]\n   };\n\n\n",
      "categories": ["mechanics"],
      "tags": ["mathematica"],
      
      "collection": "posts",
      "url": "/blog/mechanics/2025-04-23-janibekov-effect-in-wolfram-mathematica/"
    },{
      
      "title": "Модель стандартной атмосферы для среды динамического моделирования SimInTech",
      "date": "2025-08-17 00:00:00 -0500",
      "description": "Модель стандартной атмосферы по ГОСТ 4401-81 для среды динамического моделирования “SimInTech” для диапазона геометрической высоты от -2 до 400 км\n",
      "content": "Модель стандартной атмосферы по ГОСТ 4401-81 для среды динамического моделирования “SimInTech” для диапазона геометрической высоты от -2 до 400 км. В отличие от стандартного блока “Параметры стандартной атмосферы (ГОСТ 4401-81)” библиотеки “Динамика ЛА” представленная здесь модель (блок) может использоваться для определения плотности воздуха, скорости звука, температуры и давления для высоты от -2 до 400 км. Стандартный блок корректно определяет параметры атмосферы до 80 км.\n\nРепозитарий проекта на gitverse.\n",
      "categories": ["cae"],
      "tags": ["simintech"],
      
      "collection": "posts",
      "url": "/blog/cae/2025-08-17-simintec-standard-atmosphere/"
    },{
      
      "title": "CAE",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/cae/"
    },{
      
      "title": "Example",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "This is a featured category, which have their own page. Check out _featured_tags/example.md to learn how to create your own.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/example/"
    },{
      
      "title": "Hyde",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "Hyde is a brazen two-column Jekyll theme that pairs a prominent sidebar with uncomplicated content. It’s based on Poole, the Jekyll butler. Open _featured_tags/hyde.md to edit this text.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/hyde/"
    },{
      
      "title": "Hydejack",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "Hydejack is a pretentious two-column Jekyll theme, stolen by @qwtel from Hyde. You could say it was.. hydejacked. Open _featured_tags/hydejack.md to edit this text.\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/hydejack/"
    },{
      
      "title": "Механика",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/mechanics/"
    },{
      
      "title": "Программирование",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/programming/"
    },{
      
      "title": "Python",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_categories",
      "url": "/python/"
    },{
      
      "title": "CAE",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-cae/"
    },{
      
      "title": "Базы данных",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-database/"
    },{
      
      "title": "Космический мусор",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-debris/"
    },{
      
      "title": "IT-сервис",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "ИТ-сервис\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-it-service/"
    },{
      
      "title": "Linux",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-linux/"
    },{
      
      "title": "Mathematica",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-mathematica/"
    },{
      
      "title": "MATLAB",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-matlab/"
    },{
      
      "title": "Механика",
      "date": "2025-08-18 07:24:38 -0500",
      
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-mechanics/"
    },{
      
      "title": "Python",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "Разработка моделей динамических систем в среде Python\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-python/"
    },{
      
      "title": "SimInTech",
      "date": "2025-08-18 07:24:38 -0500",
      "description": "Разработка цифровых моделей в среде динамического моделирования SimInTech\n",
      "content": "\n",
      "categories": [],
      "tags": [],
      
      "collection": "featured_tags",
      "url": "/tag-simintech/"
    }
  ]
}

